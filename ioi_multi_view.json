[
  {
    "planning_view": {
      "title": "E. Memory",
      "task": "Match 25 letter-pairs (A-Y) on 50 cards using ≤100 faceup() calls",
      "given": [
        "50 face-down cards",
        "Each letter A-Y appears exactly twice",
        "Cards shuffled randomly"
      ],
      "goal": "Collect 25 candies by matching all letter pairs",
      "key_rules": [
        "Cards flip back after every 2 faceup() calls",
        "Cannot call faceup() on currently face-up card",
        "Must collect all 25 candies before terminating"
      ],
      "target": {
        "1": {
          "points": 50,
          "req": "Any valid strategy (e.g., 2450 calls acceptable)"
        },
        "2": {
          "points": 50,
          "req": "At most 100 faceup() calls total"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Memory",
      "contest": "IOI 2010 day 2",
      "one_line": "Match 25 letter-pairs (A-Y) on 50 cards using ≤100 faceup() calls",
      "given": [
        "50 face-down cards",
        "Each letter A-Y appears exactly twice",
        "Cards shuffled randomly"
      ],
      "goal": "Collect 25 candies by matching all letter pairs",
      "mechanism": "Call faceup(C) to reveal card C; after every 2 calls both flip back",
      "success_condition": "First time both copies of a letter are face-up simultaneously → 1 candy",
      "constraints": {
        "critical": [
          "Cards flip back after every 2 faceup() calls",
          "Cannot call faceup() on currently face-up card",
          "Must collect all 25 candies before terminating"
        ],
        "subtasks": {
          "1": {
            "points": 50,
            "req": "Any valid strategy (e.g., 2450 calls acceptable)"
          },
          "2": {
            "points": 50,
            "req": "At most 100 faceup() calls total"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Memory",
        "contest": "IOI 2010 day 2",
        "one_line": "Match 25 letter-pairs (A-Y) on 50 cards using ≤100 faceup() calls"
      },
      "problem": {
        "given": [
          "50 face-down cards",
          "Each letter A-Y appears exactly twice",
          "Cards shuffled randomly"
        ],
        "goal": "Collect 25 candies by matching all letter pairs",
        "mechanism": "Call faceup(C) to reveal card C; after every 2 calls both flip back",
        "success_condition": "First time both copies of a letter are face-up simultaneously → 1 candy"
      },
      "constraints": {
        "critical": [
          "Cards flip back after every 2 faceup() calls",
          "Cannot call faceup() on currently face-up card",
          "Must collect all 25 candies before terminating"
        ],
        "subtasks": {
          "1": {
            "points": 50,
            "req": "Any valid strategy (e.g., 2450 calls acceptable)"
          },
          "2": {
            "points": 50,
            "req": "At most 100 faceup() calls total"
          }
        }
      },
      "implementation": {
        "function_to_write": "void play()",
        "available_api": {
          "faceup": {
            "signature": "char faceup(int C)",
            "params": "C: card number (1-50)",
            "returns": "Letter on card C (A-Y)",
            "side_effect": "After 2nd call, both cards flip back"
          }
        },
        "requirements": [
          "Cards are 1-indexed (1 to 50)",
          "No main() function",
          "Match exact grader signatures"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "A game called Memory is played using $$$50$$$ cards. Each card has one of the letters from A to Y (ASCII $$$65$$$ to $$$89$$$) printed on the face, so that each letter appears on exactly two cards. The cards are shuffled into some random order and dealt face down on the table.\nJack plays the game by turning two cards face up so the letters are visible. For each of the $$$25$$$ letters Jack gets a candy from his mother the first time he sees both copies of the letter on the two face up cards. For example, the first time Jack turns over both cards that contain the letter M, he gets a candy. Regardless of whether the letters were equal or not, Jack then turns both cards face down again. The process is repeated until Jack receives $$$25$$$ candies — one for each letter.\nYou are to implement a procedure play that plays the game. Your implementation should call the procedure\nfaceup(C)\nwhich is implemented by the grader. $$$C$$$ is a number between $$$1$$$ and $$$50$$$ denoting a particular card you wish to be turned face up. The card $$$C$$$ must not currently be face up.\nfaceup(C)\nreturns the character that is printed on the card $$$C$$$.\nAfter every second call to\nfaceup\n, the grader automatically turns both cards face down again.\nYour procedure play may only terminate once Jack has received all $$$25$$$ candies. It is allowed to make calls to\nfaceup(C)\neven after the moment when Jack gets the last candy.\nThe following is one possible sequence of calls your procedure play could make, with explanations.\nCall\nReturned value\nExplanation\nfaceup(1)\n'B'\nCard $$$1$$$ contains B.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X. The letters are not equal. The grader automatically turns cards $$$1$$$ and $$$7$$$ face down.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X.\nfaceup(15)\n'O'\nCard $$$15$$$ contains O. The letters are not equal. The grader automatically turns cards $$$7$$$ and $$$15$$$ face down.\nfaceup(50)\n'X'\nCard $$$50$$$ contains X.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X. Jack gets his first candy. The grader automatically turns cards $$$50$$$ and $$$7$$$ face down.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X.\nfaceup(50)\n'X'\nCard $$$50$$$ contains X. Equal letters, but Jack gets no candy. The grader automatically turns cards $$$7$$$ and $$$50$$$ face down.\nfaceup(2)\n'B'\nCard $$$2$$$ contains B.\n...\n...\nSome function calls were omitted\nfaceup(1)\n'B'\nCard $$$1$$$ contains B.\nfaceup(2)\n'B'\nCard $$$2$$$ contains B. Jack gets his 25th candy.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n50\nImplement any strategy that obeys the rules of the game and finishes it within the time limit. For example, there is a simple strategy that always makes exactly $$$2 \\cdot (49+48+...+2+1) = 2450$$$ calls to\nfaceup(C)\n.\n2\n50\nImplement a strategy that finishes any possible game with at most $$$100$$$ calls to\nfaceup(C)\n."
    },
    "original": "A game called Memory is played using $$$50$$$ cards. Each card has one of the letters from A to Y (ASCII $$$65$$$ to $$$89$$$) printed on the face, so that each letter appears on exactly two cards. The cards are shuffled into some random order and dealt face down on the table.\nJack plays the game by turning two cards face up so the letters are visible. For each of the $$$25$$$ letters Jack gets a candy from his mother the first time he sees both copies of the letter on the two face up cards. For example, the first time Jack turns over both cards that contain the letter M, he gets a candy. Regardless of whether the letters were equal or not, Jack then turns both cards face down again. The process is repeated until Jack receives $$$25$$$ candies — one for each letter.\nYou are to implement a procedure play that plays the game. Your implementation should call the procedure\nfaceup(C)\nwhich is implemented by the grader. $$$C$$$ is a number between $$$1$$$ and $$$50$$$ denoting a particular card you wish to be turned face up. The card $$$C$$$ must not currently be face up.\nfaceup(C)\nreturns the character that is printed on the card $$$C$$$.\nAfter every second call to\nfaceup\n, the grader automatically turns both cards face down again.\nYour procedure play may only terminate once Jack has received all $$$25$$$ candies. It is allowed to make calls to\nfaceup(C)\neven after the moment when Jack gets the last candy.\nThe following is one possible sequence of calls your procedure play could make, with explanations.\nCall\nReturned value\nExplanation\nfaceup(1)\n'B'\nCard $$$1$$$ contains B.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X. The letters are not equal. The grader automatically turns cards $$$1$$$ and $$$7$$$ face down.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X.\nfaceup(15)\n'O'\nCard $$$15$$$ contains O. The letters are not equal. The grader automatically turns cards $$$7$$$ and $$$15$$$ face down.\nfaceup(50)\n'X'\nCard $$$50$$$ contains X.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X. Jack gets his first candy. The grader automatically turns cards $$$50$$$ and $$$7$$$ face down.\nfaceup(7)\n'X'\nCard $$$7$$$ contains X.\nfaceup(50)\n'X'\nCard $$$50$$$ contains X. Equal letters, but Jack gets no candy. The grader automatically turns cards $$$7$$$ and $$$50$$$ face down.\nfaceup(2)\n'B'\nCard $$$2$$$ contains B.\n...\n...\nSome function calls were omitted\nfaceup(1)\n'B'\nCard $$$1$$$ contains B.\nfaceup(2)\n'B'\nCard $$$2$$$ contains B. Jack gets his 25th candy.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n50\nImplement any strategy that obeys the rules of the game and finishes it within the time limit. For example, there is a simple strategy that always makes exactly $$$2 \\cdot (49+48+...+2+1) = 2450$$$ calls to\nfaceup(C)\n.\n2\n50\nImplement a strategy that finishes any possible game with at most $$$100$$$ calls to\nfaceup(C)\n.",
    "_meta": {
      "index": 0,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/E",
      "uuid": "ps_34ed2ceeb12ceab464ae8af48cca5bbf8f3ae887"
    }
  },
  {
    "planning_view": {
      "title": "C. Quality of Living",
      "task": "Find smallest median in all H×W subgrids (H,W odd) of R×C grid",
      "given": [
        "R×C grid with distinct quality ranks 1 to R·C",
        "H and W are odd (H≤R, W≤C)",
        "Quality ranks: 1=best, R·C=worst"
      ],
      "goal": "Find the best possible median quality rank in any H×W subrectangle",
      "key_rules": [
        "H and W must be odd numbers",
        "All quality ranks are distinct integers 1 to R·C",
        "Must consider all possible H×W subrectangles"
      ],
      "target": {
        "1": {
          "points": 20,
          "req": "R ≤ 30, C ≤ 30"
        },
        "2": {
          "points": 20,
          "req": "R ≤ 100, C ≤ 100"
        },
        "3": {
          "points": 20,
          "req": "R ≤ 300, C ≤ 300"
        },
        "4": {
          "points": 20,
          "req": "R ≤ 1,000, C ≤ 1,000"
        },
        "5": {
          "points": 20,
          "req": "R ≤ 3,000, C ≤ 3,000"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Quality of Living",
      "contest": "IOI 2010 day 1",
      "one_line": "Find smallest median in all H×W subgrids (H,W odd) of R×C grid",
      "given": [
        "R×C grid with distinct quality ranks 1 to R·C",
        "H and W are odd (H≤R, W≤C)",
        "Quality ranks: 1=best, R·C=worst"
      ],
      "goal": "Find the best possible median quality rank in any H×W subrectangle",
      "mechanism": "Median is the middle value when sorted: equal numbers better/worse than it",
      "success_condition": "Return the numerically smallest median found in any H×W subgrid",
      "constraints": {
        "critical": [
          "H and W must be odd numbers",
          "All quality ranks are distinct integers 1 to R·C",
          "Must consider all possible H×W subrectangles"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "R ≤ 30, C ≤ 30"
          },
          "2": {
            "points": 20,
            "req": "R ≤ 100, C ≤ 100"
          },
          "3": {
            "points": 20,
            "req": "R ≤ 300, C ≤ 300"
          },
          "4": {
            "points": 20,
            "req": "R ≤ 1,000, C ≤ 1,000"
          },
          "5": {
            "points": 20,
            "req": "R ≤ 3,000, C ≤ 3,000"
          }
        }
      },
      "limits": {
        "time": "5 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Quality of Living",
        "contest": "IOI 2010 day 1",
        "one_line": "Find smallest median in all H×W subgrids (H,W odd) of R×C grid"
      },
      "problem": {
        "given": [
          "R×C grid with distinct quality ranks 1 to R·C",
          "H and W are odd (H≤R, W≤C)",
          "Quality ranks: 1=best, R·C=worst"
        ],
        "goal": "Find the best possible median quality rank in any H×W subrectangle",
        "mechanism": "Median is the middle value when sorted: equal numbers better/worse than it",
        "success_condition": "Return the numerically smallest median found in any H×W subgrid"
      },
      "constraints": {
        "critical": [
          "H and W must be odd numbers",
          "All quality ranks are distinct integers 1 to R·C",
          "Must consider all possible H×W subrectangles"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "R ≤ 30, C ≤ 30"
          },
          "2": {
            "points": 20,
            "req": "R ≤ 100, C ≤ 100"
          },
          "3": {
            "points": 20,
            "req": "R ≤ 300, C ≤ 300"
          },
          "4": {
            "points": 20,
            "req": "R ≤ 1,000, C ≤ 1,000"
          },
          "5": {
            "points": 20,
            "req": "R ≤ 3,000, C ≤ 3,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int rectangle(int R, int C, int H, int W, int Q[][])",
        "available_api": {},
        "requirements": [
          "Q is 2D array with Q[a][b] = quality rank at row a, column b",
          "Rows indexed 0 to R-1, columns 0 to C-1",
          "Return single integer: best median value",
          "Called only once per test run"
        ]
      },
      "limits": {
        "time": "5 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "5 5 3 3\n5 11 12 16 25\n17 18 2 7 10\n4 23 20 3 1\n24 21 19 14 9\n6 22 8 13 15",
          "output": "9"
        }
      ],
      "original_statement": "Cities in Alberta tend to be laid out as rectangular grids of blocks. Blocks are labeled with coordinates 0 to $$$R-1$$$ from north to south and 0 to $$$C-1$$$ from west to east.\nThe quality of living in each particular block has been ranked by a distinct number, called quality rank, between $$$1$$$ and $$$R\\cdot C$$$, where $$$1$$$ is the best and $$$R\\cdot C$$$ is the worst.\nThe city planning department wishes to identify a rectangular set of blocks with dimensions $$$H$$$ from north to south and $$$W$$$ from west to east, such that the median quality rank among all blocks in the rectangle is the best. $$$H$$$ and $$$W$$$ are odd numbers not exceeding $$$R$$$ and $$$C$$$ respectively. The median quality rank among an odd number of quality ranks is defined to be the quality rank $$$m$$$ in the set such that the number of quality ranks better than $$$m$$$ equals the number of quality ranks worse than $$$m$$$.\nYou are to implement a procedure\nrectangle(R,C,H,W,Q)\nwhere $$$R$$$ and $$$C$$$ represent the total size of the city, $$$H$$$ and $$$W$$$ represent the dimensions of the set of blocks, and $$$Q$$$ is an array such that $$$Q[a][b]$$$ is the quality rank for the block labeled a from north to south and b from west to east.\nYour implementation of rectangle must return a number: the best (numerically smallest) possible median quality rank of an $$$H$$$ by $$$W$$$ rectangle of blocks.\nEach test run will only call rectangle once.\nScoring\nSubtask\nPoints\nConditions\n$$$1$$$\n$$$20$$$\n$$$ R \\le 30, C \\le 30 $$$\n$$$2$$$\n$$$20$$$\n$$$ R \\le 100, C \\le 100 $$$\n$$$3$$$\n$$$20$$$\n$$$ R \\le 300, C \\le 300 $$$\n$$$4$$$\n$$$20$$$\n$$$ R \\le 1\\,000, C \\le 1\\,000 $$$\n$$$5$$$\n$$$20$$$\n$$$ R \\le 3\\,000, C \\le 3\\,000 $$$\nExamples\nNote\nIn the first example, the best (numerically smallest) median quality rank of 9 is achieved by the middle-right rectangle of $$$Q$$$ with 2 in upper left angle. That is,\nrectangle(R,C,H,W,Q)=9"
    },
    "original": "Cities in Alberta tend to be laid out as rectangular grids of blocks. Blocks are labeled with coordinates 0 to $$$R-1$$$ from north to south and 0 to $$$C-1$$$ from west to east.\nThe quality of living in each particular block has been ranked by a distinct number, called quality rank, between $$$1$$$ and $$$R\\cdot C$$$, where $$$1$$$ is the best and $$$R\\cdot C$$$ is the worst.\nThe city planning department wishes to identify a rectangular set of blocks with dimensions $$$H$$$ from north to south and $$$W$$$ from west to east, such that the median quality rank among all blocks in the rectangle is the best. $$$H$$$ and $$$W$$$ are odd numbers not exceeding $$$R$$$ and $$$C$$$ respectively. The median quality rank among an odd number of quality ranks is defined to be the quality rank $$$m$$$ in the set such that the number of quality ranks better than $$$m$$$ equals the number of quality ranks worse than $$$m$$$.\nYou are to implement a procedure\nrectangle(R,C,H,W,Q)\nwhere $$$R$$$ and $$$C$$$ represent the total size of the city, $$$H$$$ and $$$W$$$ represent the dimensions of the set of blocks, and $$$Q$$$ is an array such that $$$Q[a][b]$$$ is the quality rank for the block labeled a from north to south and b from west to east.\nYour implementation of rectangle must return a number: the best (numerically smallest) possible median quality rank of an $$$H$$$ by $$$W$$$ rectangle of blocks.\nEach test run will only call rectangle once.\nScoring\nSubtask\nPoints\nConditions\n$$$1$$$\n$$$20$$$\n$$$ R \\le 30, C \\le 30 $$$\n$$$2$$$\n$$$20$$$\n$$$ R \\le 100, C \\le 100 $$$\n$$$3$$$\n$$$20$$$\n$$$ R \\le 300, C \\le 300 $$$\n$$$4$$$\n$$$20$$$\n$$$ R \\le 1\\,000, C \\le 1\\,000 $$$\n$$$5$$$\n$$$20$$$\n$$$ R \\le 3\\,000, C \\le 3\\,000 $$$\nExamples\nNote\nIn the first example, the best (numerically smallest) median quality rank of 9 is achieved by the middle-right rectangle of $$$Q$$$ with 2 in upper left angle. That is,\nrectangle(R,C,H,W,Q)=9",
    "_meta": {
      "index": 1,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/C",
      "uuid": "ps_87a3a133e68621915d1276d8980fac0ace7d09d2"
    }
  },
  {
    "planning_view": {
      "title": "E. Friend",
      "task": "Find maximum independent set in social network built with 3 connection protocols",
      "given": [
        "n people with confidence values",
        "Social network built in n stages with 3 connection protocols",
        "People added one by one with host selection"
      ],
      "goal": "Select sample of non-adjacent people with maximum total confidence",
      "key_rules": [
        "IAmYourFriend: new person connects only to host",
        "MyFriendsAreYourFriends: new person connects to all of host's friends (not host)",
        "WeAreYourFriends: new person connects to host and all host's friends"
      ],
      "target": {
        "1": {
          "points": 11,
          "req": "n ≤ 10, all three protocols"
        },
        "2": {
          "points": 8,
          "req": "n ≤ 1000, only MyFriendsAreYourFriends"
        },
        "3": {
          "points": 8,
          "req": "n ≤ 1000, only WeAreYourFriends"
        },
        "4": {
          "points": 19,
          "req": "n ≤ 1000, only IAmYourFriend"
        },
        "5": {
          "points": 23,
          "req": "n ≤ 1000, confidence=1, MyFriendsAreYourFriends and IAmYourFriend"
        },
        "6": {
          "points": 31,
          "req": "n ≤ 100000, all three protocols"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Friend",
      "contest": "IOI 2014 day 2",
      "one_line": "Find maximum independent set in social network built with 3 connection protocols",
      "given": [
        "n people with confidence values",
        "Social network built in n stages with 3 connection protocols",
        "People added one by one with host selection"
      ],
      "goal": "Select sample of non-adjacent people with maximum total confidence",
      "mechanism": "Network grows using protocols that determine how new person connects to host and host's friends",
      "success_condition": "Return maximum possible total confidence of an independent set",
      "constraints": {
        "critical": [
          "IAmYourFriend: new person connects only to host",
          "MyFriendsAreYourFriends: new person connects to all of host's friends (not host)",
          "WeAreYourFriends: new person connects to host and all host's friends"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "n ≤ 10, all three protocols"
          },
          "2": {
            "points": 8,
            "req": "n ≤ 1000, only MyFriendsAreYourFriends"
          },
          "3": {
            "points": 8,
            "req": "n ≤ 1000, only WeAreYourFriends"
          },
          "4": {
            "points": 19,
            "req": "n ≤ 1000, only IAmYourFriend"
          },
          "5": {
            "points": 23,
            "req": "n ≤ 1000, confidence=1, MyFriendsAreYourFriends and IAmYourFriend"
          },
          "6": {
            "points": 31,
            "req": "n ≤ 100000, all three protocols"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "16 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Friend",
        "contest": "IOI 2014 day 2",
        "one_line": "Find maximum independent set in social network built with 3 connection protocols"
      },
      "problem": {
        "given": [
          "n people with confidence values",
          "Social network built in n stages with 3 connection protocols",
          "People added one by one with host selection"
        ],
        "goal": "Select sample of non-adjacent people with maximum total confidence",
        "mechanism": "Network grows using protocols that determine how new person connects to host and host's friends",
        "success_condition": "Return maximum possible total confidence of an independent set"
      },
      "constraints": {
        "critical": [
          "IAmYourFriend: new person connects only to host",
          "MyFriendsAreYourFriends: new person connects to all of host's friends (not host)",
          "WeAreYourFriends: new person connects to host and all host's friends"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "n ≤ 10, all three protocols"
          },
          "2": {
            "points": 8,
            "req": "n ≤ 1000, only MyFriendsAreYourFriends"
          },
          "3": {
            "points": 8,
            "req": "n ≤ 1000, only WeAreYourFriends"
          },
          "4": {
            "points": 19,
            "req": "n ≤ 1000, only IAmYourFriend"
          },
          "5": {
            "points": 23,
            "req": "n ≤ 1000, confidence=1, MyFriendsAreYourFriends and IAmYourFriend"
          },
          "6": {
            "points": 31,
            "req": "n ≤ 100000, all three protocols"
          }
        }
      },
      "implementation": {
        "function_to_write": "int findSample(int n, int confidence[], int host[], int protocol[])",
        "available_api": {
          "findSample": {
            "signature": "int findSample(int n, int confidence[], int host[], int protocol[])",
            "params": "n: number of people, confidence: array of confidence values, host: array of hosts for each stage, protocol: array of protocol codes used",
            "returns": "Maximum total confidence of an independent set",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Do not access host[0] and protocol[0] (undefined)",
          "People are 0-indexed",
          "Stage 0: person 0 added (no host)",
          "Stage i (1 to n-1): person i added using host[i] and protocol[i]"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "16 megabytes"
      },
      "samples": [
        {
          "input": "6\n13 3 6 20 10 15\n0 0 0 1 1 2 2 1 0 0",
          "output": "35"
        }
      ],
      "original_statement": "We build a social network from $$$n$$$ people numbered $$$0, \\ldots, n - 1$$$. Some pairs of people in the network will be friends. If person $$$x$$$ becomes a friend of person $$$y$$$, then person $$$y$$$ also becomes a friend of person $$$x$$$.\nThe people are added to the network in $$$n$$$ stages, which are also numbered from $$$0$$$ to $$$n - 1$$$. Person $$$i$$$ is added in stage $$$i$$$. In stage $$$0$$$, person $$$0$$$ is added as the only person of the network. In each of the next $$$n - 1$$$ stages, a person is added to the network by a\nhost\n, who may be any person already in the network. At stage $$$i (0 < i < n)$$$, the host for that stage can add the incoming person $$$i$$$ into the network by one of the following three protocols:\nIAmYourFriend\nmakes person $$$i$$$ a friend of the host only.\nMyFriendsAreYourFriends\nmakes person $$$i$$$ a friend of\neach\nperson, who is a friend of the host at this moment. Note that this protocol does\nnot\nmake person $$$i$$$ a friend of the host.\nWeAreYourFriends\nmakes person $$$i$$$ a friend of the host, and also a friend of\neach\nperson, who is a friend of the host at this moment.\nAfter we build the network we would like to pick a\nsample\nfor a survey, that is, choose a group of people from the network. Since friends usually have similar interests, the sample should not include any pair of people who are friends with each other. Each person has a survey\nconfidence\n, expressed as a positive integer, and we would like to find a sample with the maximum total confidence.\nTask\nGiven the description of each stage and the confidence value of each person, find a sample with the maximum total confidence. You only need to implement the function\nfindSample\n.\nint findSample(int n, int confidence[], int host[], int protocol[])\n$$$n$$$: the number of people.\n$$$confidence$$$: array of length $$$n$$$; $$$confidence[i]$$$ gives the confidence value of person $$$i$$$.\n$$$host$$$: array of length $$$n$$$; $$$host[i]$$$ gives the host of stage $$$i$$$.\n$$$protocol$$$: array of length $$$n$$$; $$$protocol[i]$$$ gives the protocol code used in stage $$$i$$$ $$$(0 < i < n)$$$: $$$0$$$ for\nIAmYourFriend\n, $$$1$$$ for\nMyFriendsAreYourFriends\n, $$$2$$$ for\nWeAreYourFriends\n.\nSince there is no host in stage $$$0$$$, $$$host[0]$$$ and $$$protocol[0]$$$ are undefined and should not be accessed by your program.\nThe function should return the maximum possible total confidence of a sample.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$.\nline 2: $$$confidence[0], \\ldots, confidence[n - 1]$$$.\nline 3: $$$host[1], protocol[1], host[2], protocol[2], \\ldots, host[n - 1], protocol[n - 1]$$$.\nOutput\nThe sample grader will print the return value of\nfindSample\n.\nScoring\nSubtask\nPoints\n$$$n$$$\nconfidence\nProtocols used\n1\n11\n$$$2 \\le n \\le 10$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nAll three protocols\n2\n8\n$$$2 \\le n \\le 1\\,000$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nOnly\nMyFriendsAreYourFriends\n3\n8\n$$$2 \\le n \\le 1\\,000$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nOnly\nWeAreYourFriends\n4\n19\n$$$2 \\le n \\le 1\\,000$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nOnly\nIAmYourFriend\n5\n23\n$$$2 \\le n \\le 1\\,000$$$\nAll confidence values are 1\nBoth\nMyFriendsAreYourFriends\nand\nIAmYourFriend\n6\n31\n$$$2 \\le n \\le 100\\,000$$$\n$$$1 \\le confidence \\le 10\\,000$$$\nAll three protocols\nExamples\nNote\nYou have to submit exactly one file, called\nfriend.cpp\n. This file should implement the subprogram described above, using the following signatures. You also need to include a header file\nfriend.h\nfor C/C++ implementation.\nstage\nhost\nprotocol\nfriend relations added\n1\n0\nIAmYourFriend\n(1, 0)\n2\n0\nMyFriendsAreYourFriends\n(2, 1)\n3\n1\nWeAreYourFriends\n(3, 1), (3, 0), (3, 2)\n4\n2\nMyFriendsAreYourFriends\n(4, 1), (4, 3)\n5\n0\nIAmYourFriend\n(5, 0)\nInitially the network contains only person 0. The host of stage 1 (person 0) invites the new person 1 through the\nIAmYourFriend\nprotocol, hence they become friends. The host of stage 2 (person 0 again) invites person 2 by\nMyFriendsAreYourFriends\n, which makes person 1 (the only friend of the host) the only friend of person 2. The host of stage 3 (person 1) adds person 3 through\nWeAreYourFriends\n, which makes person 3 a friend of person 1 (the host) and people 0 and 2 (the friends of the host). Stages 4 and 5 are also shown in the table above. The final network is shown in the following figure, in which the numbers inside the circles show the labels of people, and the numbers next to the circles show the survey confidence. The sample consisting of people 3 and 5 has totalsurvey confidence equal to $$$20 + 15 = 35$$$, which is the maximum possible total confidence."
    },
    "original": "We build a social network from $$$n$$$ people numbered $$$0, \\ldots, n - 1$$$. Some pairs of people in the network will be friends. If person $$$x$$$ becomes a friend of person $$$y$$$, then person $$$y$$$ also becomes a friend of person $$$x$$$.\nThe people are added to the network in $$$n$$$ stages, which are also numbered from $$$0$$$ to $$$n - 1$$$. Person $$$i$$$ is added in stage $$$i$$$. In stage $$$0$$$, person $$$0$$$ is added as the only person of the network. In each of the next $$$n - 1$$$ stages, a person is added to the network by a\nhost\n, who may be any person already in the network. At stage $$$i (0 < i < n)$$$, the host for that stage can add the incoming person $$$i$$$ into the network by one of the following three protocols:\nIAmYourFriend\nmakes person $$$i$$$ a friend of the host only.\nMyFriendsAreYourFriends\nmakes person $$$i$$$ a friend of\neach\nperson, who is a friend of the host at this moment. Note that this protocol does\nnot\nmake person $$$i$$$ a friend of the host.\nWeAreYourFriends\nmakes person $$$i$$$ a friend of the host, and also a friend of\neach\nperson, who is a friend of the host at this moment.\nAfter we build the network we would like to pick a\nsample\nfor a survey, that is, choose a group of people from the network. Since friends usually have similar interests, the sample should not include any pair of people who are friends with each other. Each person has a survey\nconfidence\n, expressed as a positive integer, and we would like to find a sample with the maximum total confidence.\nTask\nGiven the description of each stage and the confidence value of each person, find a sample with the maximum total confidence. You only need to implement the function\nfindSample\n.\nint findSample(int n, int confidence[], int host[], int protocol[])\n$$$n$$$: the number of people.\n$$$confidence$$$: array of length $$$n$$$; $$$confidence[i]$$$ gives the confidence value of person $$$i$$$.\n$$$host$$$: array of length $$$n$$$; $$$host[i]$$$ gives the host of stage $$$i$$$.\n$$$protocol$$$: array of length $$$n$$$; $$$protocol[i]$$$ gives the protocol code used in stage $$$i$$$ $$$(0 < i < n)$$$: $$$0$$$ for\nIAmYourFriend\n, $$$1$$$ for\nMyFriendsAreYourFriends\n, $$$2$$$ for\nWeAreYourFriends\n.\nSince there is no host in stage $$$0$$$, $$$host[0]$$$ and $$$protocol[0]$$$ are undefined and should not be accessed by your program.\nThe function should return the maximum possible total confidence of a sample.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$.\nline 2: $$$confidence[0], \\ldots, confidence[n - 1]$$$.\nline 3: $$$host[1], protocol[1], host[2], protocol[2], \\ldots, host[n - 1], protocol[n - 1]$$$.\nOutput\nThe sample grader will print the return value of\nfindSample\n.\nScoring\nSubtask\nPoints\n$$$n$$$\nconfidence\nProtocols used\n1\n11\n$$$2 \\le n \\le 10$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nAll three protocols\n2\n8\n$$$2 \\le n \\le 1\\,000$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nOnly\nMyFriendsAreYourFriends\n3\n8\n$$$2 \\le n \\le 1\\,000$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nOnly\nWeAreYourFriends\n4\n19\n$$$2 \\le n \\le 1\\,000$$$\n$$$1 \\le confidence \\le 1\\,000\\,000$$$\nOnly\nIAmYourFriend\n5\n23\n$$$2 \\le n \\le 1\\,000$$$\nAll confidence values are 1\nBoth\nMyFriendsAreYourFriends\nand\nIAmYourFriend\n6\n31\n$$$2 \\le n \\le 100\\,000$$$\n$$$1 \\le confidence \\le 10\\,000$$$\nAll three protocols\nExamples\nNote\nYou have to submit exactly one file, called\nfriend.cpp\n. This file should implement the subprogram described above, using the following signatures. You also need to include a header file\nfriend.h\nfor C/C++ implementation.\nstage\nhost\nprotocol\nfriend relations added\n1\n0\nIAmYourFriend\n(1, 0)\n2\n0\nMyFriendsAreYourFriends\n(2, 1)\n3\n1\nWeAreYourFriends\n(3, 1), (3, 0), (3, 2)\n4\n2\nMyFriendsAreYourFriends\n(4, 1), (4, 3)\n5\n0\nIAmYourFriend\n(5, 0)\nInitially the network contains only person 0. The host of stage 1 (person 0) invites the new person 1 through the\nIAmYourFriend\nprotocol, hence they become friends. The host of stage 2 (person 0 again) invites person 2 by\nMyFriendsAreYourFriends\n, which makes person 1 (the only friend of the host) the only friend of person 2. The host of stage 3 (person 1) adds person 3 through\nWeAreYourFriends\n, which makes person 3 a friend of person 1 (the host) and people 0 and 2 (the friends of the host). Stages 4 and 5 are also shown in the table above. The final network is shown in the following figure, in which the numbers inside the circles show the labels of people, and the numbers next to the circles show the survey confidence. The sample consisting of people 3 and 5 has totalsurvey confidence equal to $$$20 + 15 = 35$$$, which is the maximum possible total confidence.",
    "_meta": {
      "index": 2,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/E",
      "uuid": "ps_0003bd5cea4f3cb318943bdc2815aa339784a8b3"
    }
  },
  {
    "planning_view": {
      "title": "A. Arranging Shoes",
      "task": "Arrange 2n shoes into valid pairs with minimum adjacent swaps",
      "given": [
        "2n shoes in positions 0 to 2n-1",
        "Each shoe has size (positive integer) and type (negative=left, positive=right)",
        "Each size appears exactly twice (one left, one right)"
      ],
      "goal": "Find minimum adjacent swaps to achieve valid arrangement",
      "key_rules": [
        "Only adjacent swaps allowed",
        "Valid arrangement: positions 2i=left shoe, 2i+1=right shoe of same size",
        "Must use all 2n shoes"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "n = 1"
        },
        "2": {
          "points": 20,
          "req": "n ≤ 8"
        },
        "3": {
          "points": 20,
          "req": "All shoes same size"
        },
        "4": {
          "points": 15,
          "req": "First n positions left shoes, last n right shoes, matching pairs aligned"
        },
        "5": {
          "points": 20,
          "req": "n ≤ 1000"
        },
        "6": {
          "points": 15,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Arranging Shoes",
      "contest": "IOI 2019 day 1",
      "one_line": "Arrange 2n shoes into valid pairs with minimum adjacent swaps",
      "given": [
        "2n shoes in positions 0 to 2n-1",
        "Each shoe has size (positive integer) and type (negative=left, positive=right)",
        "Each size appears exactly twice (one left, one right)"
      ],
      "goal": "Find minimum adjacent swaps to achieve valid arrangement",
      "mechanism": "Swap adjacent shoes to rearrange into pairs where positions 2i=left shoe, 2i+1=right shoe of same size",
      "success_condition": "All shoes in correct pairing pattern with minimum swap count",
      "constraints": {
        "critical": [
          "Only adjacent swaps allowed",
          "Valid arrangement: positions 2i=left shoe, 2i+1=right shoe of same size",
          "Must use all 2n shoes"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "n = 1"
          },
          "2": {
            "points": 20,
            "req": "n ≤ 8"
          },
          "3": {
            "points": 20,
            "req": "All shoes same size"
          },
          "4": {
            "points": 15,
            "req": "First n positions left shoes, last n right shoes, matching pairs aligned"
          },
          "5": {
            "points": 20,
            "req": "n ≤ 1000"
          },
          "6": {
            "points": 15,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Arranging Shoes",
        "contest": "IOI 2019 day 1",
        "one_line": "Arrange 2n shoes into valid pairs with minimum adjacent swaps"
      },
      "problem": {
        "given": [
          "2n shoes in positions 0 to 2n-1",
          "Each shoe has size (positive integer) and type (negative=left, positive=right)",
          "Each size appears exactly twice (one left, one right)"
        ],
        "goal": "Find minimum adjacent swaps to achieve valid arrangement",
        "mechanism": "Swap adjacent shoes to rearrange into pairs where positions 2i=left shoe, 2i+1=right shoe of same size",
        "success_condition": "All shoes in correct pairing pattern with minimum swap count"
      },
      "constraints": {
        "critical": [
          "Only adjacent swaps allowed",
          "Valid arrangement: positions 2i=left shoe, 2i+1=right shoe of same size",
          "Must use all 2n shoes"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "n = 1"
          },
          "2": {
            "points": 20,
            "req": "n ≤ 8"
          },
          "3": {
            "points": 20,
            "req": "All shoes same size"
          },
          "4": {
            "points": 15,
            "req": "First n positions left shoes, last n right shoes, matching pairs aligned"
          },
          "5": {
            "points": 20,
            "req": "n ≤ 1000"
          },
          "6": {
            "points": 15,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 count_swaps(int[] S)",
        "available_api": {},
        "requirements": [
          "Input array S has exactly 2n elements",
          "S[i] negative = left shoe, positive = right shoe",
          "Return minimum number of adjacent swaps as int64"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "2\n2 1 -1 -2",
          "output": "4"
        }
      ],
      "original_statement": "Adnan owns the biggest shoe store in Baku. A box containing $$$n$$$ pairs of shoes has just arrived at the store. Each pair consists of two shoes of the same size: a left and a right one. Adnan has put all of the $$$2n$$$ shoes in a row consisting of $$$2n$$$ positions numbered $$$0$$$ through $$$2n - 1$$$ from left to right.\nAdnan wants to rearrange the shoes into a valid arrangement. An arrangement is valid if and only if for every $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), the following conditions hold:\nThe shoes at positions $$$2i$$$ and $$$2i+1$$$ are of the same size.\nThe shoe at position $$$2i$$$ is a left shoe.\nThe shoe at position $$$2i+1$$$ is a right shoe.\nFor this purpose, Adnan can make a series of swaps. In each swap, he selects two shoes that are adjacent at that moment and exchanges them (i.e., picks them up and puts each one on the former position of the other shoe). Two shoes are adjacent if their positions differ by one.\nDetermine the minimum number of swaps that Adnan needs to perform in order to obtain a valid arrangement of the shoes.\nImplementation details\nYou should implement the following procedure:\nint64 count_swaps(int[] S)\n$$$S$$$: an array of $$$2n$$$ integers. For each $$$i$$$ ($$$0 \\leq i \\leq 2n-1$$$), $$$|S[i]|$$$ is a non-zero value equal to the size of the shoe initially placed at position $$$i$$$. Here, $$$|x|$$$ denotes the absolute value of $$$x$$$, which equals $$$x$$$ if $$$x>0$$$ and equals $$$-x$$$ if $$$x<0$$$. If $$$S[i] < 0$$$, the shoe at position $$$i$$$ is a left shoe; otherwise, it is a right shoe.\nThis procedure should return the minimum number of swaps (of adjacent shoes) that need to be performed in order to obtain a valid arrangement.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ ($$$1 \\leq n \\leq 100\\,000$$$)\nline 2: $$$S[0], S[1], S[2], \\ldots, S[2n-1]$$$ ($$$1 \\leq |S[i]| \\leq n$$$)\nA valid arrangement of the shoes can be obtained by performing some sequence of swaps.\nOutput\nThe sample grader outputs a single line containing the return value of count_swaps.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$n = 1$$$\n2\n20\n$$$n \\leq 8$$$\n3\n20\nAll the shoes are of the same size.\n4\n15\nAll shoes at positions $$$0, \\ldots, n-1$$$ are left shoes, and all shoes at positions $$$n, \\ldots, 2n-1$$$ are right shoes. Also, for each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), the shoes at positions $$$i$$$ and $$$i+n$$$ are of the same size.\n5\n20\n$$$n \\leq 1000$$$\n6\n15\nno additional constraints\nExamples\nNote\nExample 1\nConsider the following call:\ncount_swaps([2, 1, -1, -2])\nAdnan can obtain a valid arrangement in $$$4$$$ swaps.\nFor instance, he can first swap shoes $$$1$$$ and $$$-1$$$, then $$$1$$$ and $$$-2$$$, then $$$-1$$$ and $$$-2$$$, and finally $$$2$$$ and $$$-2$$$. He would then obtain the following valid arrangement: $$$[-2, 2, -1, 1]$$$. It is not possible to obtain any valid arrangement with less than $$$4$$$ swaps. Therefore, the procedure should return $$$4$$$.\nExample 2\nIn the following example, all the shoes have the same size:\ncount_swaps([-2, 2, 2, -2, -2, 2])\nAdnan can swap the shoes at positions $$$2$$$ and $$$3$$$ to obtain the valid arrangement $$$[-2, 2, -2, 2, -2, 2]$$$, so the procedure should return $$$1$$$."
    },
    "original": "Adnan owns the biggest shoe store in Baku. A box containing $$$n$$$ pairs of shoes has just arrived at the store. Each pair consists of two shoes of the same size: a left and a right one. Adnan has put all of the $$$2n$$$ shoes in a row consisting of $$$2n$$$ positions numbered $$$0$$$ through $$$2n - 1$$$ from left to right.\nAdnan wants to rearrange the shoes into a valid arrangement. An arrangement is valid if and only if for every $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), the following conditions hold:\nThe shoes at positions $$$2i$$$ and $$$2i+1$$$ are of the same size.\nThe shoe at position $$$2i$$$ is a left shoe.\nThe shoe at position $$$2i+1$$$ is a right shoe.\nFor this purpose, Adnan can make a series of swaps. In each swap, he selects two shoes that are adjacent at that moment and exchanges them (i.e., picks them up and puts each one on the former position of the other shoe). Two shoes are adjacent if their positions differ by one.\nDetermine the minimum number of swaps that Adnan needs to perform in order to obtain a valid arrangement of the shoes.\nImplementation details\nYou should implement the following procedure:\nint64 count_swaps(int[] S)\n$$$S$$$: an array of $$$2n$$$ integers. For each $$$i$$$ ($$$0 \\leq i \\leq 2n-1$$$), $$$|S[i]|$$$ is a non-zero value equal to the size of the shoe initially placed at position $$$i$$$. Here, $$$|x|$$$ denotes the absolute value of $$$x$$$, which equals $$$x$$$ if $$$x>0$$$ and equals $$$-x$$$ if $$$x<0$$$. If $$$S[i] < 0$$$, the shoe at position $$$i$$$ is a left shoe; otherwise, it is a right shoe.\nThis procedure should return the minimum number of swaps (of adjacent shoes) that need to be performed in order to obtain a valid arrangement.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ ($$$1 \\leq n \\leq 100\\,000$$$)\nline 2: $$$S[0], S[1], S[2], \\ldots, S[2n-1]$$$ ($$$1 \\leq |S[i]| \\leq n$$$)\nA valid arrangement of the shoes can be obtained by performing some sequence of swaps.\nOutput\nThe sample grader outputs a single line containing the return value of count_swaps.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$n = 1$$$\n2\n20\n$$$n \\leq 8$$$\n3\n20\nAll the shoes are of the same size.\n4\n15\nAll shoes at positions $$$0, \\ldots, n-1$$$ are left shoes, and all shoes at positions $$$n, \\ldots, 2n-1$$$ are right shoes. Also, for each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), the shoes at positions $$$i$$$ and $$$i+n$$$ are of the same size.\n5\n20\n$$$n \\leq 1000$$$\n6\n15\nno additional constraints\nExamples\nNote\nExample 1\nConsider the following call:\ncount_swaps([2, 1, -1, -2])\nAdnan can obtain a valid arrangement in $$$4$$$ swaps.\nFor instance, he can first swap shoes $$$1$$$ and $$$-1$$$, then $$$1$$$ and $$$-2$$$, then $$$-1$$$ and $$$-2$$$, and finally $$$2$$$ and $$$-2$$$. He would then obtain the following valid arrangement: $$$[-2, 2, -1, 1]$$$. It is not possible to obtain any valid arrangement with less than $$$4$$$ swaps. Therefore, the procedure should return $$$4$$$.\nExample 2\nIn the following example, all the shoes have the same size:\ncount_swaps([-2, 2, 2, -2, -2, 2])\nAdnan can swap the shoes at positions $$$2$$$ and $$$3$$$ to obtain the valid arrangement $$$[-2, 2, -2, 2, -2, 2]$$$, so the procedure should return $$$1$$$.",
    "_meta": {
      "index": 3,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/A",
      "uuid": "ps_ff9715751d51f006e17870ce3d9742747df2c674"
    }
  },
  {
    "planning_view": {
      "title": "D. Mutating DNA",
      "task": "Answer Q range queries about mutation distance between substrings using ≤1M operations",
      "given": [
        "Two DNA strings a and b of length n (A,T,C only)",
        "Q queries with ranges [x,y]",
        "Mutation = swap two characters in a string"
      ],
      "goal": "Compute mutation distance between a[x..y] and b[x..y] for each query",
      "key_rules": [
        "Substrings must have same character frequency to be transformable",
        "Distance only defined when transform is possible (return -1 otherwise)",
        "Must handle up to 100,000 queries efficiently"
      ],
      "target": {
        "1": {
          "points": 21,
          "req": "y-x ≤ 2"
        },
        "2": {
          "points": 22,
          "req": "q ≤ 500, y-x ≤ 1000, only A/T characters"
        },
        "3": {
          "points": 13,
          "req": "Only A/T characters"
        },
        "4": {
          "points": 28,
          "req": "q ≤ 500, y-x ≤ 1000"
        },
        "5": {
          "points": 16,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Mutating DNA",
      "contest": "IOI 2021 day 2",
      "one_line": "Answer Q range queries about mutation distance between substrings using ≤1M operations",
      "given": [
        "Two DNA strings a and b of length n (A,T,C only)",
        "Q queries with ranges [x,y]",
        "Mutation = swap two characters in a string"
      ],
      "goal": "Compute mutation distance between a[x..y] and b[x..y] for each query",
      "mechanism": "Mutation distance is minimum swaps to transform one string into another, or -1 if impossible",
      "success_condition": "Return correct mutation distance for each query range",
      "constraints": {
        "critical": [
          "Substrings must have same character frequency to be transformable",
          "Distance only defined when transform is possible (return -1 otherwise)",
          "Must handle up to 100,000 queries efficiently"
        ],
        "subtasks": {
          "1": {
            "points": 21,
            "req": "y-x ≤ 2"
          },
          "2": {
            "points": 22,
            "req": "q ≤ 500, y-x ≤ 1000, only A/T characters"
          },
          "3": {
            "points": 13,
            "req": "Only A/T characters"
          },
          "4": {
            "points": 28,
            "req": "q ≤ 500, y-x ≤ 1000"
          },
          "5": {
            "points": 16,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Mutating DNA",
        "contest": "IOI 2021 day 2",
        "one_line": "Answer Q range queries about mutation distance between substrings using ≤1M operations"
      },
      "problem": {
        "given": [
          "Two DNA strings a and b of length n (A,T,C only)",
          "Q queries with ranges [x,y]",
          "Mutation = swap two characters in a string"
        ],
        "goal": "Compute mutation distance between a[x..y] and b[x..y] for each query",
        "mechanism": "Mutation distance is minimum swaps to transform one string into another, or -1 if impossible",
        "success_condition": "Return correct mutation distance for each query range"
      },
      "constraints": {
        "critical": [
          "Substrings must have same character frequency to be transformable",
          "Distance only defined when transform is possible (return -1 otherwise)",
          "Must handle up to 100,000 queries efficiently"
        ],
        "subtasks": {
          "1": {
            "points": 21,
            "req": "y-x ≤ 2"
          },
          "2": {
            "points": 22,
            "req": "q ≤ 500, y-x ≤ 1000, only A/T characters"
          },
          "3": {
            "points": 13,
            "req": "Only A/T characters"
          },
          "4": {
            "points": 28,
            "req": "q ≤ 500, y-x ≤ 1000"
          },
          "5": {
            "points": 16,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "void init(string a, string b) and int get_distance(int x, int y)",
        "available_api": {
          "init": {
            "signature": "void init(string a, string b)",
            "params": "a, b: DNA strings of length n",
            "returns": "void",
            "side_effect": "Called once before any get_distance calls"
          },
          "get_distance": {
            "signature": "int get_distance(int x, int y)",
            "params": "x, y: substring indices [x,y] inclusive",
            "returns": "Mutation distance between a[x..y] and b[x..y], or -1 if impossible",
            "side_effect": "Called exactly q times after init"
          }
        },
        "requirements": [
          "Strings are 0-indexed",
          "Must process q queries efficiently for n,q up to 100,000",
          "Use exact function signatures as provided"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "6 3\nATACAT\nACTATA\n1 3\n4 5\n3 5",
          "output": "2\n1\n-1"
        }
      ],
      "original_statement": "Grace is a biologist working in a bioinformatics firm in Singapore. As part of her job, she analyses the DNA sequences of various organisms. A DNA sequence is defined as a string consisting of characters \"A\", \"T\", and \"C\". Note that in this task DNA sequences\ndo not contain character \"G\"\n.\nWe define a mutation to be an operation on a DNA sequence where two elements of the sequence are swapped. For example a single mutation can transform \"A\nC\nT\nA\n\" into \"A\nA\nT\nC\n\" by swapping the highlighted characters \"A\" and \"C\".\nThe mutation distance between two sequences is the minimum number of mutations required to transform one sequence into the other, or $$$-1$$$ if it is not possible to transform one sequence into the other by using mutations.\nGrace is analysing two DNA sequences $$$a$$$ and $$$b$$$, both consisting of $$$n$$$ elements with indices from $$$0$$$ to $$$n - 1$$$. Your task is to help Grace answer $$$q$$$ questions of the form: what is the mutation distance between the substring $$$a[x\\ldots y]$$$ and the substring $$$b[x\\ldots y]$$$? Here, a substring $$$s[x\\ldots y]$$$ of a DNA sequence $$$s$$$ is defined to be a sequence of consecutive characters of $$$s$$$, whose indices are $$$x$$$ to $$$y$$$ inclusive. In other words, $$$s[x\\ldots y]$$$ is the sequence $$$s[x]s[x+1]\\ldots s[y]$$$.\nImplementation details\nYou should implement the following procedures:\nvoid init(string a, string b)\n$$$a$$$, $$$b$$$: strings of length $$$n$$$, describing the two DNA sequences to be analysed.\nThis procedure is called exactly once, before any calls to\nget_distance\n.\nint get_distance(int x, int y)\n$$$x$$$, $$$y$$$: starting and ending indices of the substrings to be analysed.\nThe procedure should return the mutation distance between substrings $$$a[x..y]$$$ and $$$b[x..y]$$$.\nThis procedure is called exactly $$$q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ q$$$ ($$$1 \\leq n, q \\leq 100\\,000$$$)\nline $$$2$$$: $$$a$$$\nline $$$3$$$: $$$b$$$\nline $$$4 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): $$$x\\ y$$$ ($$$0 \\leq x \\leq y \\leq n-1$$$) for the $$$i$$$-th call to\nget_distance\n.\nEach character of $$$a$$$ and $$$b$$$ is one of \"A\", \"T\", and \"C\".\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): the return value of the $$$i$$$-th call to\nget_distance\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n21\n$$$y - x \\leq 2$$$\n2\n22\n$$$q \\leq 500$$$, $$$y-x \\leq 1000$$$, each character of $$$a$$$ and $$$b$$$ is either \"A\" or \"T\".\n3\n13\neach character of $$$a$$$ and $$$b$$$ is either \"A\" or \"T\".\n4\n28\n$$$q \\leq 500$$$, $$$y-x \\leq 1000$$$\n5\n16\nNo additional constraints.\nExample\nNote\nExample\nConsider the following call:\ninit(\"ATACAT\", \"ACTATA\")\nLet's say the grader call\nget_distance(1, 3)\n. This call should return the mutation distance between $$$a[1\\ldots 3]$$$ and $$$b[1\\ldots 3]$$$, that is, the sequences \"TAC\" and \"CTA\". \"TAC\" can be transformed into \"CTA\" via $$$2$$$ mutations: \"\nT\nA\nC\n\" $$$\\rightarrow$$$ \"\nC\nA\nT\n\", followed by C\nAT\n» $$$\\rightarrow$$$ «C\nTA\n», and the transformation is impossible with fewer than $$$2$$$ mutations.\nTherefore, this call should return $$$2$$$.\nLet's say the grader calls\nget_distance(4, 5)\n. This call should return the mutation distance between sequences \"AT\" and \"TA\". \"AT\" can be transformed into \"TA\" through a single mutation, and clearly at least one mutation is required.\nTherefore, this call should return $$$1$$$.\nFinally, let's say the grader calls\nget_distance(3, 5)\n. Since there is\nno way\nfor the sequence \"CAT\" to be transformed into \"ATA\" via any sequence of mutations, this call should return $$$-1$$$."
    },
    "original": "Grace is a biologist working in a bioinformatics firm in Singapore. As part of her job, she analyses the DNA sequences of various organisms. A DNA sequence is defined as a string consisting of characters \"A\", \"T\", and \"C\". Note that in this task DNA sequences\ndo not contain character \"G\"\n.\nWe define a mutation to be an operation on a DNA sequence where two elements of the sequence are swapped. For example a single mutation can transform \"A\nC\nT\nA\n\" into \"A\nA\nT\nC\n\" by swapping the highlighted characters \"A\" and \"C\".\nThe mutation distance between two sequences is the minimum number of mutations required to transform one sequence into the other, or $$$-1$$$ if it is not possible to transform one sequence into the other by using mutations.\nGrace is analysing two DNA sequences $$$a$$$ and $$$b$$$, both consisting of $$$n$$$ elements with indices from $$$0$$$ to $$$n - 1$$$. Your task is to help Grace answer $$$q$$$ questions of the form: what is the mutation distance between the substring $$$a[x\\ldots y]$$$ and the substring $$$b[x\\ldots y]$$$? Here, a substring $$$s[x\\ldots y]$$$ of a DNA sequence $$$s$$$ is defined to be a sequence of consecutive characters of $$$s$$$, whose indices are $$$x$$$ to $$$y$$$ inclusive. In other words, $$$s[x\\ldots y]$$$ is the sequence $$$s[x]s[x+1]\\ldots s[y]$$$.\nImplementation details\nYou should implement the following procedures:\nvoid init(string a, string b)\n$$$a$$$, $$$b$$$: strings of length $$$n$$$, describing the two DNA sequences to be analysed.\nThis procedure is called exactly once, before any calls to\nget_distance\n.\nint get_distance(int x, int y)\n$$$x$$$, $$$y$$$: starting and ending indices of the substrings to be analysed.\nThe procedure should return the mutation distance between substrings $$$a[x..y]$$$ and $$$b[x..y]$$$.\nThis procedure is called exactly $$$q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ q$$$ ($$$1 \\leq n, q \\leq 100\\,000$$$)\nline $$$2$$$: $$$a$$$\nline $$$3$$$: $$$b$$$\nline $$$4 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): $$$x\\ y$$$ ($$$0 \\leq x \\leq y \\leq n-1$$$) for the $$$i$$$-th call to\nget_distance\n.\nEach character of $$$a$$$ and $$$b$$$ is one of \"A\", \"T\", and \"C\".\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): the return value of the $$$i$$$-th call to\nget_distance\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n21\n$$$y - x \\leq 2$$$\n2\n22\n$$$q \\leq 500$$$, $$$y-x \\leq 1000$$$, each character of $$$a$$$ and $$$b$$$ is either \"A\" or \"T\".\n3\n13\neach character of $$$a$$$ and $$$b$$$ is either \"A\" or \"T\".\n4\n28\n$$$q \\leq 500$$$, $$$y-x \\leq 1000$$$\n5\n16\nNo additional constraints.\nExample\nNote\nExample\nConsider the following call:\ninit(\"ATACAT\", \"ACTATA\")\nLet's say the grader call\nget_distance(1, 3)\n. This call should return the mutation distance between $$$a[1\\ldots 3]$$$ and $$$b[1\\ldots 3]$$$, that is, the sequences \"TAC\" and \"CTA\". \"TAC\" can be transformed into \"CTA\" via $$$2$$$ mutations: \"\nT\nA\nC\n\" $$$\\rightarrow$$$ \"\nC\nA\nT\n\", followed by C\nAT\n» $$$\\rightarrow$$$ «C\nTA\n», and the transformation is impossible with fewer than $$$2$$$ mutations.\nTherefore, this call should return $$$2$$$.\nLet's say the grader calls\nget_distance(4, 5)\n. This call should return the mutation distance between sequences \"AT\" and \"TA\". \"AT\" can be transformed into \"TA\" through a single mutation, and clearly at least one mutation is required.\nTherefore, this call should return $$$1$$$.\nFinally, let's say the grader calls\nget_distance(3, 5)\n. Since there is\nno way\nfor the sequence \"CAT\" to be transformed into \"ATA\" via any sequence of mutations, this call should return $$$-1$$$.",
    "_meta": {
      "index": 4,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/D",
      "uuid": "ps_da82a2509f87e00f52aa20e837f5ae964734fc02"
    }
  },
  {
    "planning_view": {
      "title": "F. Game",
      "task": "Support 2D GCD queries and updates on 10⁹×10⁹ grid with ≤472K operations",
      "given": [
        "R×C grid (R,C up to 10⁹)",
        "All cells initially contain 0",
        "Bazza performs update(P,Q,K) and calculate(P,Q,U,V) operations"
      ],
      "goal": "Answer GCD queries on rectangular regions after series of updates",
      "key_rules": [
        "GCD of all numbers in rectangle; 0 if all zeros",
        "Grid dimensions up to 10⁹ × 10⁹",
        "K values up to 10¹⁸",
        "Total operations ≤ 472,000"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "R,C ≤ 100, operations ≤ 200"
        },
        "2": {
          "points": 27,
          "req": "R ≤ 10, C ≤ 100k, NU ≤ 10k, NQ ≤ 250k"
        },
        "3": {
          "points": 26,
          "req": "R,C ≤ 2000, NU ≤ 10k, NQ ≤ 250k"
        },
        "4": {
          "points": 17,
          "req": "R,C ≤ 10⁹, NU ≤ 10k, NQ ≤ 250k"
        },
        "5": {
          "points": 20,
          "req": "R,C ≤ 10⁹, NU ≤ 22k, NQ ≤ 250k"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Game",
      "contest": "IOI 2013 day 2",
      "one_line": "Support 2D GCD queries and updates on 10⁹×10⁹ grid with ≤472K operations",
      "given": [
        "R×C grid (R,C up to 10⁹)",
        "All cells initially contain 0",
        "Bazza performs update(P,Q,K) and calculate(P,Q,U,V) operations"
      ],
      "goal": "Answer GCD queries on rectangular regions after series of updates",
      "mechanism": "Grid supports point updates (overwrite cell value) and rectangle GCD queries",
      "success_condition": "Return correct GCD for each calculate() call, or 0 if all cells in rectangle are 0",
      "constraints": {
        "critical": [
          "GCD of all numbers in rectangle; 0 if all zeros",
          "Grid dimensions up to 10⁹ × 10⁹",
          "K values up to 10¹⁸",
          "Total operations ≤ 472,000"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "R,C ≤ 100, operations ≤ 200"
          },
          "2": {
            "points": 27,
            "req": "R ≤ 10, C ≤ 100k, NU ≤ 10k, NQ ≤ 250k"
          },
          "3": {
            "points": 26,
            "req": "R,C ≤ 2000, NU ≤ 10k, NQ ≤ 250k"
          },
          "4": {
            "points": 17,
            "req": "R,C ≤ 10⁹, NU ≤ 10k, NQ ≤ 250k"
          },
          "5": {
            "points": 20,
            "req": "R,C ≤ 10⁹, NU ≤ 22k, NQ ≤ 250k"
          }
        }
      },
      "limits": {
        "time": "10 seconds",
        "memory": "230 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Game",
        "contest": "IOI 2013 day 2",
        "one_line": "Support 2D GCD queries and updates on 10⁹×10⁹ grid with ≤472K operations"
      },
      "problem": {
        "given": [
          "R×C grid (R,C up to 10⁹)",
          "All cells initially contain 0",
          "Bazza performs update(P,Q,K) and calculate(P,Q,U,V) operations"
        ],
        "goal": "Answer GCD queries on rectangular regions after series of updates",
        "mechanism": "Grid supports point updates (overwrite cell value) and rectangle GCD queries",
        "success_condition": "Return correct GCD for each calculate() call, or 0 if all cells in rectangle are 0"
      },
      "constraints": {
        "critical": [
          "GCD of all numbers in rectangle; 0 if all zeros",
          "Grid dimensions up to 10⁹ × 10⁹",
          "K values up to 10¹⁸",
          "Total operations ≤ 472,000"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "R,C ≤ 100, operations ≤ 200"
          },
          "2": {
            "points": 27,
            "req": "R ≤ 10, C ≤ 100k, NU ≤ 10k, NQ ≤ 250k"
          },
          "3": {
            "points": 26,
            "req": "R,C ≤ 2000, NU ≤ 10k, NQ ≤ 250k"
          },
          "4": {
            "points": 17,
            "req": "R,C ≤ 10⁹, NU ≤ 10k, NQ ≤ 250k"
          },
          "5": {
            "points": 20,
            "req": "R,C ≤ 10⁹, NU ≤ 22k, NQ ≤ 250k"
          }
        }
      },
      "implementation": {
        "function_to_write": "Three functions: init(), update(), calculate()",
        "available_api": {
          "init": {
            "signature": "void init(int R, int C)",
            "params": "R: rows (0..R-1), C: columns (0..C-1)",
            "returns": "void",
            "side_effect": "Called once before any operations"
          },
          "update": {
            "signature": "void update(int P, int Q, long long K)",
            "params": "P: row, Q: column, K: new value (0 ≤ K ≤ 10¹⁸)",
            "returns": "void",
            "side_effect": "Overwrites cell (P,Q) with K"
          },
          "calculate": {
            "signature": "long long calculate(int P, int Q, int U, int V)",
            "params": "P,Q: top-left corner, U,V: bottom-right corner (P ≤ U, Q ≤ V)",
            "returns": "GCD of rectangle or 0 if all zeros",
            "side_effect": "None"
          }
        },
        "requirements": [
          "0-indexed grid coordinates",
          "Must handle large coordinates and values",
          "No main() function",
          "Exact function signatures required"
        ]
      },
      "limits": {
        "time": "10 seconds",
        "memory": "230 megabytes"
      },
      "samples": [
        {
          "input": "2 3 9\n1 0 0 20\n1 0 2 15\n1 1 1 12\n2 0 0 0 2\n2 0 0 1 1\n1 0 1 6\n1 1 1 14\n2 0 0 0 2\n2 0 0 1 1",
          "output": "5\n4\n1\n2"
        }
      ],
      "original_statement": "Bazza and Shazza are playing a game. The board is a grid of cells, with $$$R$$$ rows numbered $$$0, \\dots, R - 1$$$, and $$$C$$$ columns numbered $$$0, \\dots, C - 1$$$. We let $$$(P, Q)$$$ denote the cell in row $$$P$$$ and column $$$Q$$$ Each cell contains a non-negative integer, and at the beginning of the game all of these integers are zero.\\nThe game proceeds as follows. At any time, Bazza may either:\\nupdate a cell $$$(P, Q)$$$, by assigning the integer that it contains;\\nask Shazza to calculate the greatest common divisor (GCD) of all integers within a rectangular block of cells, with opposite corners $$$(P, Q)$$$ and $$$(U, V)$$$ inclusive.\\nBazza will take no more than $$$(N_U + N_Q)$$$ actions (updating cells $$$N_U$$$ times and asking questions $$$N_Q$$$ times) before he gets bored and goes outside to play cricket.\\nYour task is to work out the correct answers.\\nYou should submit a file implementing the procedures\\ninit()\\nand\\nupdate()\\nand the function\\ncalculate()\\n, as described below.\\nYour Procedure\\ninit()\\n:\\nvoid init(int R, int C);\\nYour submission must implement this procedure.\\nThis procedure gives you the initial size of the grid, and allows you to initialise any global variables and data structures. It will be called only once, before any calls to\\nupdate()\\nor\\ncalculate()\\n.\\nParameters:\\n$$$R$$$: The number of rows.\\n$$$C$$$: The number of columns.\\nYour Procedure\\nupdate()\\n:\\nvoid update(int P, int Q, long long K);\\nYour submission must implement this procedure.\\nThis procedure will be called when Bazza assigns the number in some grid cell.\\nParameters:\\n$$$P$$$: The row of the grid cell $$$( 0 \\leq P \\leq R - 1 )$$$.\\n$$$Q$$$: The column of the grid cell $$$( 0 \\leq Q \\leq C - 1 )$$$.\\n$$$K$$$: The new integer in this grid cell $$$( 0 \\leq K \\leq 10^{18} )$$$. May be the same as the current value.\\nYour Function\\ncalculate()\\n:\\nlong long calculate(int P, int Q, int U, int V);\\nYour submission must implement this function.\\nThis function should calculate the greatest common divisor of all integers in the rectangle with opposite corners $$$(P, Q)$$$ and $$$(U, V)$$$. This range is inclusive, i.e., the cells $$$(P, Q)$$$ and $$$(U, V)$$$ are included in the rectangle.\\nIf all integers in this rectangle are zero, then this function should return zero also.\\nParameters:\\n$$$P$$$: The row of the top-left cell in the rectangle $$$( 0 \\leq P \\leq R - 1)$$$.\\n$$$Q$$$: The column of the top-left cell in the rectangle $$$( 0 \\leq Q \\leq C - 1)$$$.\\n$$$U$$$: The row of the bottom-right cell in the rectangle $$$( P \\leq U \\leq C - 1)$$$.\\n$$$V$$$: The column of the bottom-right cell in the rectangle $$$( Q \\leq V \\leq C - 1)$$$.\\nReturns\\n: The GCD of all integers in the rectangle, or $$$0$$$ if all of those integers are zero.\\nInput\\nGrader reads input in following format:\\nline $$$1$$$: $$$R\\ C\\ N$$$\\nnext $$$N$$$ lines: one action per line, in the order in which actions occur\\nThe line for each action muist be in one of the following formats:\\nto indicate\\nupdate(P, Q, K)\\n: $$$1\\ P\\ Q\\ K$$$\\nto indicate\\ncalculate(P, Q, U, V)\\n: $$$2\\ P\\ Q\\ U\\ V$$$\\nScoring\\nThe full constraints are:\\n$$$1 \\leq R, C \\leq 10^9$$$\\n$$$0 \\leq K \\leq 10^{18}$$$\\nSubtask\\nPoints\\n$$$R$$$\\n$$$C$$$\\n$$$N_U$$$\\n$$$N_Q$$$\\n1\\n10\\n$$$\\leq 100$$$\\n$$$\\leq 100$$$\\n$$$\\leq 100$$$\\n$$$\\leq 100$$$\\n2\\n27\\n$$$\\leq 10$$$\\n$$$\\leq 100,000$$$\\n$$$\\leq 10,000$$$\\n$$$\\leq 250,000$$$\\n3\\n26\\n$$$\\leq 2,000$$$\\n$$$\\leq 2,000$$$\\n$$$\\leq 10,000$$$\\n$$$\\leq 250,000$$$\\n4\\n17\\n$$$\\leq 10^9$$$\\n$$$\\leq 10^9$$$\\n$$$\\leq 10,000$$$\\n$$$\\leq 250,000$$$\\n5\\n20\\n$$$\\leq 10^9$$$\\n$$$\\leq 10^9$$$\\n$$$\\leq 22,000$$$\\n$$$\\leq 250,000$$$\\nExample\\nNote\\nConsider the first example.\\nThis is the resulting grid after performing the first $$$3$$$ updates:\\nThe red rectangle is the rectangle from the first\\ncalculate\\noperation.\\nThe blue rectangle is the rectangle from the second\\ncalculate\\noperation.\\nAfter processing $$$2$$$ more updates, the grid becomes like in the picture below:\\nAnd now the GCD in the red rectangle is $$$1$$$, and in the blue rectangle it is equal to $$$2$$$."
    },
    "original": "Bazza and Shazza are playing a game. The board is a grid of cells, with $$$R$$$ rows numbered $$$0, \\dots, R - 1$$$, and $$$C$$$ columns numbered $$$0, \\dots, C - 1$$$. We let $$$(P, Q)$$$ denote the cell in row $$$P$$$ and column $$$Q$$$ Each cell contains a non-negative integer, and at the beginning of the game all of these integers are zero.\\nThe game proceeds as follows. At any time, Bazza may either:\\nupdate a cell $$$(P, Q)$$$, by assigning the integer that it contains;\\nask Shazza to calculate the greatest common divisor (GCD) of all integers within a rectangular block of cells, with opposite corners $$$(P, Q)$$$ and $$$(U, V)$$$ inclusive.\\nBazza will take no more than $$$(N_U + N_Q)$$$ actions (updating cells $$$N_U$$$ times and asking questions $$$N_Q$$$ times) before he gets bored and goes outside to play cricket.\\nYour task is to work out the correct answers.\\nYou should submit a file implementing the procedures\\ninit()\\nand\\nupdate()\\nand the function\\ncalculate()\\n, as described below.\\nYour Procedure\\ninit()\\n:\\nvoid init(int R, int C);\\nYour submission must implement this procedure.\\nThis procedure gives you the initial size of the grid, and allows you to initialise any global variables and data structures. It will be called only once, before any calls to\\nupdate()\\nor\\ncalculate()\\n.\\nParameters:\\n$$$R$$$: The number of rows.\\n$$$C$$$: The number of columns.\\nYour Procedure\\nupdate()\\n:\\nvoid update(int P, int Q, long long K);\\nYour submission must implement this procedure.\\nThis procedure will be called when Bazza assigns the number in some grid cell.\\nParameters:\\n$$$P$$$: The row of the grid cell $$$( 0 \\leq P \\leq R - 1 )$$$.\\n$$$Q$$$: The column of the grid cell $$$( 0 \\leq Q \\leq C - 1 )$$$.\\n$$$K$$$: The new integer in this grid cell $$$( 0 \\leq K \\leq 10^{18} )$$$. May be the same as the current value.\\nYour Function\\ncalculate()\\n:\\nlong long calculate(int P, int Q, int U, int V);\\nYour submission must implement this function.\\nThis function should calculate the greatest common divisor of all integers in the rectangle with opposite corners $$$(P, Q)$$$ and $$$(U, V)$$$. This range is inclusive, i.e., the cells $$$(P, Q)$$$ and $$$(U, V)$$$ are included in the rectangle.\\nIf all integers in this rectangle are zero, then this function should return zero also.\\nParameters:\\n$$$P$$$: The row of the top-left cell in the rectangle $$$( 0 \\leq P \\leq R - 1)$$$.\\n$$$Q$$$: The column of the top-left cell in the rectangle $$$( 0 \\leq Q \\leq C - 1)$$$.\\n$$$U$$$: The row of the bottom-right cell in the rectangle $$$( P \\leq U \\leq C - 1)$$$.\\n$$$V$$$: The column of the bottom-right cell in the rectangle $$$( Q \\leq V \\leq C - 1)$$$.\\nReturns\\n: The GCD of all integers in the rectangle, or $$$0$$$ if all of those integers are zero.\\nInput\\nGrader reads input in following format:\\nline $$$1$$$: $$$R\\ C\\ N$$$\\nnext $$$N$$$ lines: one action per line, in the order in which actions occur\\nThe line for each action muist be in one of the following formats:\\nto indicate\\nupdate(P, Q, K)\\n: $$$1\\ P\\ Q\\ K$$$\\nto indicate\\ncalculate(P, Q, U, V)\\n: $$$2\\ P\\ Q\\ U\\ V$$$\\nScoring\\nThe full constraints are:\\n$$$1 \\leq R, C \\leq 10^9$$$\\n$$$0 \\leq K \\leq 10^{18}$$$\\nSubtask\\nPoints\\n$$$R$$$\\n$$$C$$$\\n$$$N_U$$$\\n$$$N_Q$$$\\n1\\n10\\n$$$\\leq 100$$$\\n$$$\\leq 100$$$\\n$$$\\leq 100$$$\\n$$$\\leq 100$$$\\n2\\n27\\n$$$\\leq 10$$$\\n$$$\\leq 100,000$$$\\n$$$\\leq 10,000$$$\\n$$$\\leq 250,000$$$\\n3\\n26\\n$$$\\leq 2,000$$$\\n$$$\\leq 2,000$$$\\n$$$\\leq 10,000$$$\\n$$$\\leq 250,000$$$\\n4\\n17\\n$$$\\leq 10^9$$$\\n$$$\\leq 10^9$$$\\n$$$\\leq 10,000$$$\\n$$$\\leq 250,000$$$\\n5\\n20\\n$$$\\leq 10^9$$$\\n$$$\\leq 10^9$$$\\n$$$\\leq 22,000$$$\\n$$$\\leq 250,000$$$\\nExample\\nNote\\nConsider the first example.\\nThis is the resulting grid after performing the first $$$3$$$ updates:\\nThe red rectangle is the rectangle from the first\\ncalculate\\noperation.\\nThe blue rectangle is the rectangle from the second\\ncalculate\\noperation.\\nAfter processing $$$2$$$ more updates, the grid becomes like in the picture below:\\nAnd now the GCD in the red rectangle is $$$1$$$, and in the blue rectangle it is equal to $$$2$$$.",
    "_meta": {
      "index": 5,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/F",
      "uuid": "ps_9fbdbccd3abaf888f9185ba35c8654a3761dd026"
    }
  },
  {
    "planning_view": {
      "title": "C. Shortcut",
      "task": "Minimize railway diameter by adding one express line ≤1000000 stations",
      "given": [
        "n stations in line (0 to n-1)",
        "Distances l[i] between stations i and i+1",
        "Secondary lines d[i] from station i (d[i]=0 if none)",
        "Express line has fixed length c"
      ],
      "goal": "Place one express line between main stations to minimize network diameter",
      "key_rules": [
        "Express line connects exactly two main stations",
        "Express line length is fixed c regardless of endpoints",
        "Secondary lines are one-way from main stations only",
        "All railway segments are bidirectional"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "2 ≤ n ≤ 10"
        },
        "2": {
          "points": 14,
          "req": "2 ≤ n ≤ 100"
        },
        "3": {
          "points": 8,
          "req": "2 ≤ n ≤ 250"
        },
        "4": {
          "points": 7,
          "req": "2 ≤ n ≤ 500"
        },
        "5": {
          "points": 33,
          "req": "2 ≤ n ≤ 3000"
        },
        "6": {
          "points": 22,
          "req": "2 ≤ n ≤ 100000"
        },
        "7": {
          "points": 4,
          "req": "2 ≤ n ≤ 300000"
        },
        "8": {
          "points": 3,
          "req": "2 ≤ n ≤ 1000000"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Shortcut",
      "contest": "IOI 2016 day 1",
      "one_line": "Minimize railway diameter by adding one express line ≤1000000 stations",
      "given": [
        "n stations in line (0 to n-1)",
        "Distances l[i] between stations i and i+1",
        "Secondary lines d[i] from station i (d[i]=0 if none)",
        "Express line has fixed length c"
      ],
      "goal": "Place one express line between main stations to minimize network diameter",
      "mechanism": "Distance is shortest path length; diameter is maximum pairwise distance",
      "success_condition": "Return the smallest possible diameter after adding the express line",
      "constraints": {
        "critical": [
          "Express line connects exactly two main stations",
          "Express line length is fixed c regardless of endpoints",
          "Secondary lines are one-way from main stations only",
          "All railway segments are bidirectional"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "2 ≤ n ≤ 10"
          },
          "2": {
            "points": 14,
            "req": "2 ≤ n ≤ 100"
          },
          "3": {
            "points": 8,
            "req": "2 ≤ n ≤ 250"
          },
          "4": {
            "points": 7,
            "req": "2 ≤ n ≤ 500"
          },
          "5": {
            "points": 33,
            "req": "2 ≤ n ≤ 3000"
          },
          "6": {
            "points": 22,
            "req": "2 ≤ n ≤ 100000"
          },
          "7": {
            "points": 4,
            "req": "2 ≤ n ≤ 300000"
          },
          "8": {
            "points": 3,
            "req": "2 ≤ n ≤ 1000000"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Shortcut",
        "contest": "IOI 2016 day 1",
        "one_line": "Minimize railway diameter by adding one express line ≤1000000 stations"
      },
      "problem": {
        "given": [
          "n stations in line (0 to n-1)",
          "Distances l[i] between stations i and i+1",
          "Secondary lines d[i] from station i (d[i]=0 if none)",
          "Express line has fixed length c"
        ],
        "goal": "Place one express line between main stations to minimize network diameter",
        "mechanism": "Distance is shortest path length; diameter is maximum pairwise distance",
        "success_condition": "Return the smallest possible diameter after adding the express line"
      },
      "constraints": {
        "critical": [
          "Express line connects exactly two main stations",
          "Express line length is fixed c regardless of endpoints",
          "Secondary lines are one-way from main stations only",
          "All railway segments are bidirectional"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "2 ≤ n ≤ 10"
          },
          "2": {
            "points": 14,
            "req": "2 ≤ n ≤ 100"
          },
          "3": {
            "points": 8,
            "req": "2 ≤ n ≤ 250"
          },
          "4": {
            "points": 7,
            "req": "2 ≤ n ≤ 500"
          },
          "5": {
            "points": 33,
            "req": "2 ≤ n ≤ 3000"
          },
          "6": {
            "points": 22,
            "req": "2 ≤ n ≤ 100000"
          },
          "7": {
            "points": 4,
            "req": "2 ≤ n ≤ 300000"
          },
          "8": {
            "points": 3,
            "req": "2 ≤ n ≤ 1000000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 find_shortcut(int n, int[] l, int[] d, int c)",
        "available_api": {},
        "requirements": [
          "Return type is int64",
          "l has length n-1, d has length n",
          "All parameters can be up to 10^9"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "4 10\n10 20 20\n0 40 0 30",
          "output": "80"
        }
      ],
      "original_statement": "Pavel has a toy railway. It is very simple. There is a single main line consisting of $$$n$$$ stations. These stations are numbered from $$$0$$$ to $$$n - 1$$$ in order along the line. The distance between the stations $$$i$$$ and $$$i + 1$$$ is $$$l_i$$$ centimeters ($$$0 \\leq i < n - 1$$$).\nApart from the main line there may be some secondary lines. Each secondary line is a railway line between a station on the main line and a new station that does not lie on the main line. (These new stations are not numbered.) At most one secondary line can start in each station of the main line. The length of the secondary line starting at station $$$i$$$ is $$$d_i$$$ centimeters. We use $$$d_i = 0$$$ to denote that there is no secondary line starting at station $$$i$$$.\nPavel is now planning to build one shortcut: an express line between two different (possibly neighbouring) stations of\nthe main line\n. Express line will have length of exactly $$$c$$$ centimeters, regardless of what two stations it will connect.\nEach segment of the railway, including the new express line, can be used in both directions. The\ndistance\nbetween two stations is the smallest length of a route that goes from one station to the other along the railways. The\ndiameter\nof the whole railway network is the maximum distance among all pairs of stations. In other words, this is the smallest number $$$t$$$, such that the distance between every pair of stations is at most $$$t$$$.\nPavel wants to build the express line in such a way that the diameter of the resulting network is minimized.\nImplementation details\nYou should implement the function\nint64 find_shortcut(int n, int[] l, int[] d, int c)\nn\n: number of stations on the main line,\nl\n: distances between stations on the main line (array of length $$$n - 1$$$),\nd\n: lengths of secondary lines (array of length $$$n$$$),\nc\n: length of the new express line.\nthe function should return the smallest possible diameter of the railway network after adding the express line.\nInput\nThe sample grader reads the input in the following format:\nline 1: integers $$$n$$$ and $$$c$$$,\nline 2: integers $$$l_0, l_1, \\ldots, l_{n - 2}$$$,\nline 3: integers $$$d_0, d_1, \\ldots, d_{n - 1}$$$.\nOutput\nOne number— the return value of function.\nScoring\nIn all Subtasks $$$2 \\le n \\le 1\\,000\\,000$$$, $$$1 \\le l_i \\le 10^9$$$, $$$0 \\le d_i \\le 10^9$$$, $$$1 \\le c \\le 10^9$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$2 \\le n \\le 10$$$\n2\n14\n$$$2 \\le n \\le 100$$$\n3\n8\n$$$2 \\le n \\le 250$$$\n4\n7\n$$$2 \\le n \\le 500$$$\n5\n33\n$$$2 \\le n \\le 3000$$$\n6\n22\n$$$2 \\le n \\le 100\\,000$$$\n7\n4\n$$$2 \\le n \\le 300\\,000$$$\n8\n3\n$$$2 \\le n \\le 1\\,000\\,000$$$\nExamples\nNote\nExample 1\nFor the railway network shown above, the grader would make the following function call:\nfind_shortcut(4, [10, 20, 20], [0, 40, 0, 30], 10)\nThe optimal solution is to build the express line between stations $$$1$$$ and $$$3$$$, as shown below.\nThe diameter of the new railway network is $$$80$$$ centimeters, so the function should return $$$80$$$.\nExample 2\nThe grader makes the following function call:\nfind_shortcut(9, [10, 10, 10, 10, 10, 10, 10, 10], [20, 0, 30, 0, 0, 40, 0, 40, 0], 30)\nThe optimal solution is to connect stations $$$2$$$ and $$$7$$$, in which case the diameter is $$$110$$$.\nExample 3\nThe grader makes the following function call:\nfind_shortcut(4, [2, 2, 2], [1, 10, 10, 1], 1)\nThe optimal solution is to connect stations $$$1$$$ and $$$2$$$, reducing the diameter to $$$21$$$.\nExample 4\nThe grader makes the following function call:\nfind_shortcut(3, [1, 1], [1, 1, 1], 3)\nConnecting any two stations with the express line of length $$$3$$$ does not improve the initial diameter of the railway network which is $$$4$$$."
    },
    "original": "Pavel has a toy railway. It is very simple. There is a single main line consisting of $$$n$$$ stations. These stations are numbered from $$$0$$$ to $$$n - 1$$$ in order along the line. The distance between the stations $$$i$$$ and $$$i + 1$$$ is $$$l_i$$$ centimeters ($$$0 \\leq i < n - 1$$$).\nApart from the main line there may be some secondary lines. Each secondary line is a railway line between a station on the main line and a new station that does not lie on the main line. (These new stations are not numbered.) At most one secondary line can start in each station of the main line. The length of the secondary line starting at station $$$i$$$ is $$$d_i$$$ centimeters. We use $$$d_i = 0$$$ to denote that there is no secondary line starting at station $$$i$$$.\nPavel is now planning to build one shortcut: an express line between two different (possibly neighbouring) stations of\nthe main line\n. Express line will have length of exactly $$$c$$$ centimeters, regardless of what two stations it will connect.\nEach segment of the railway, including the new express line, can be used in both directions. The\ndistance\nbetween two stations is the smallest length of a route that goes from one station to the other along the railways. The\ndiameter\nof the whole railway network is the maximum distance among all pairs of stations. In other words, this is the smallest number $$$t$$$, such that the distance between every pair of stations is at most $$$t$$$.\nPavel wants to build the express line in such a way that the diameter of the resulting network is minimized.\nImplementation details\nYou should implement the function\nint64 find_shortcut(int n, int[] l, int[] d, int c)\nn\n: number of stations on the main line,\nl\n: distances between stations on the main line (array of length $$$n - 1$$$),\nd\n: lengths of secondary lines (array of length $$$n$$$),\nc\n: length of the new express line.\nthe function should return the smallest possible diameter of the railway network after adding the express line.\nInput\nThe sample grader reads the input in the following format:\nline 1: integers $$$n$$$ and $$$c$$$,\nline 2: integers $$$l_0, l_1, \\ldots, l_{n - 2}$$$,\nline 3: integers $$$d_0, d_1, \\ldots, d_{n - 1}$$$.\nOutput\nOne number— the return value of function.\nScoring\nIn all Subtasks $$$2 \\le n \\le 1\\,000\\,000$$$, $$$1 \\le l_i \\le 10^9$$$, $$$0 \\le d_i \\le 10^9$$$, $$$1 \\le c \\le 10^9$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$2 \\le n \\le 10$$$\n2\n14\n$$$2 \\le n \\le 100$$$\n3\n8\n$$$2 \\le n \\le 250$$$\n4\n7\n$$$2 \\le n \\le 500$$$\n5\n33\n$$$2 \\le n \\le 3000$$$\n6\n22\n$$$2 \\le n \\le 100\\,000$$$\n7\n4\n$$$2 \\le n \\le 300\\,000$$$\n8\n3\n$$$2 \\le n \\le 1\\,000\\,000$$$\nExamples\nNote\nExample 1\nFor the railway network shown above, the grader would make the following function call:\nfind_shortcut(4, [10, 20, 20], [0, 40, 0, 30], 10)\nThe optimal solution is to build the express line between stations $$$1$$$ and $$$3$$$, as shown below.\nThe diameter of the new railway network is $$$80$$$ centimeters, so the function should return $$$80$$$.\nExample 2\nThe grader makes the following function call:\nfind_shortcut(9, [10, 10, 10, 10, 10, 10, 10, 10], [20, 0, 30, 0, 0, 40, 0, 40, 0], 30)\nThe optimal solution is to connect stations $$$2$$$ and $$$7$$$, in which case the diameter is $$$110$$$.\nExample 3\nThe grader makes the following function call:\nfind_shortcut(4, [2, 2, 2], [1, 10, 10, 1], 1)\nThe optimal solution is to connect stations $$$1$$$ and $$$2$$$, reducing the diameter to $$$21$$$.\nExample 4\nThe grader makes the following function call:\nfind_shortcut(3, [1, 1], [1, 1, 1], 3)\nConnecting any two stations with the express line of length $$$3$$$ does not improve the initial diameter of the railway network which is $$$4$$$.",
    "_meta": {
      "index": 6,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/C",
      "uuid": "ps_46a2c1eb2dc1508d364d0928841d83ecefb0a177"
    }
  },
  {
    "planning_view": {
      "title": "C. Soccer Stadium",
      "task": "Find largest regular stadium size in N×N grid with trees",
      "given": [
        "N×N grid with empty cells (0) and trees (1)",
        "At least one empty cell exists",
        "Stadium: set of distinct empty cells"
      ],
      "goal": "Find maximum size of a regular stadium",
      "key_rules": [
        "Straight kicks require all cells between start/end in same row/column to be in stadium",
        "Regular stadium: any cell pair reachable with ≤2 straight kicks",
        "Stadium must consist of distinct empty cells only"
      ],
      "target": {
        "1": {
          "points": 6,
          "req": "At most one tree"
        },
        "2": {
          "points": 8,
          "req": "N ≤ 3"
        },
        "3": {
          "points": 22,
          "req": "N ≤ 7"
        },
        "4": {
          "points": 18,
          "req": "N ≤ 30"
        },
        "5": {
          "points": 16,
          "req": "N ≤ 500"
        },
        "6": {
          "points": 30,
          "req": "N ≤ 2000 (no additional constraints)"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Soccer Stadium",
      "contest": "IOI 2023 day 1",
      "one_line": "Find largest regular stadium size in N×N grid with trees",
      "given": [
        "N×N grid with empty cells (0) and trees (1)",
        "At least one empty cell exists",
        "Stadium: set of distinct empty cells"
      ],
      "goal": "Find maximum size of a regular stadium",
      "mechanism": "Regular stadium: ball can move between any two cells with ≤2 straight kicks (horizontal/vertical moves requiring all intermediate cells in stadium)",
      "success_condition": "Return largest s where regular stadium of size s exists",
      "constraints": {
        "critical": [
          "Straight kicks require all cells between start/end in same row/column to be in stadium",
          "Regular stadium: any cell pair reachable with ≤2 straight kicks",
          "Stadium must consist of distinct empty cells only"
        ],
        "subtasks": {
          "1": {
            "points": 6,
            "req": "At most one tree"
          },
          "2": {
            "points": 8,
            "req": "N ≤ 3"
          },
          "3": {
            "points": 22,
            "req": "N ≤ 7"
          },
          "4": {
            "points": 18,
            "req": "N ≤ 30"
          },
          "5": {
            "points": 16,
            "req": "N ≤ 500"
          },
          "6": {
            "points": 30,
            "req": "N ≤ 2000 (no additional constraints)"
          }
        }
      },
      "limits": {
        "time": "5 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Soccer Stadium",
        "contest": "IOI 2023 day 1",
        "one_line": "Find largest regular stadium size in N×N grid with trees"
      },
      "problem": {
        "given": [
          "N×N grid with empty cells (0) and trees (1)",
          "At least one empty cell exists",
          "Stadium: set of distinct empty cells"
        ],
        "goal": "Find maximum size of a regular stadium",
        "mechanism": "Regular stadium: ball can move between any two cells with ≤2 straight kicks (horizontal/vertical moves requiring all intermediate cells in stadium)",
        "success_condition": "Return largest s where regular stadium of size s exists"
      },
      "constraints": {
        "critical": [
          "Straight kicks require all cells between start/end in same row/column to be in stadium",
          "Regular stadium: any cell pair reachable with ≤2 straight kicks",
          "Stadium must consist of distinct empty cells only"
        ],
        "subtasks": {
          "1": {
            "points": 6,
            "req": "At most one tree"
          },
          "2": {
            "points": 8,
            "req": "N ≤ 3"
          },
          "3": {
            "points": 22,
            "req": "N ≤ 7"
          },
          "4": {
            "points": 18,
            "req": "N ≤ 30"
          },
          "5": {
            "points": 16,
            "req": "N ≤ 500"
          },
          "6": {
            "points": 30,
            "req": "N ≤ 2000 (no additional constraints)"
          }
        }
      },
      "implementation": {
        "function_to_write": "int biggest_stadium(int N, int[][] F)",
        "available_api": {
          "biggest_stadium": {
            "signature": "int biggest_stadium(int N, int[][] F)",
            "params": "N: grid size, F: N×N array where 0=empty, 1=tree",
            "returns": "Maximum size of regular stadium",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Grid indexing: 0-based (0 to N-1)",
          "Procedure called exactly once per test case",
          "Return integer representing maximum stadium size"
        ]
      },
      "limits": {
        "time": "5 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "5\n0 0 0 0 0\n1 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "output": "20"
        }
      ],
      "original_statement": "Nagyerdő is a square-shaped forest located in the city of Debrecen, which can be modeled as an $$$N \\times N$$$ grid of cells. The rows of the grid are numbered from $$$0$$$ to $$$N - 1$$$ from north to south, and the columns are numbered from $$$0$$$ to $$$N - 1$$$ from west to east. We refer to the cell located at row $$$r$$$ and column $$$c$$$ of the grid as cell $$$(r, c)$$$.\nIn the forest, each cell is either\nempty\nor contains a\ntree\n. At least one cell in the forest is empty.\nDVSC, the famous sports club of the city, is planning to build a new soccer stadium in the forest. A stadium of size $$$s$$$ (where $$$s \\ge 1$$$) is a set of $$$s$$$\ndistinct empty\ncells $$$(r_0, c_0), \\ldots, (r_{s - 1}, c_{s - 1})$$$. Formally this means:\nfor each $$$i$$$ from $$$0$$$ to $$$s - 1$$$, inclusive, cell $$$(r_i, c_i)$$$ is empty,\nfor each $$$i, j$$$ such that $$$0 \\le i < j < s$$$, at least one of $$$r_i \\neq r_j$$$ and $$$c_i \\neq c_j$$$ holds.\nSoccer is played using a ball that is moved around the cells of the stadium. A\nstraight kick\nis defined to be either of the following two actions:\nMove the ball from cell $$$(r,a)$$$ to cell $$$(r,b)$$$ ($$$0 \\le r,a,b < N, a \\ne b$$$), where the stadium contains\nall\ncells between cell $$$(r,a)$$$ and $$$(r,b)$$$ in row $$$r$$$. Formally,\nif $$$a < b$$$ then the stadium should contain cell $$$(r,k)$$$ for each $$$k$$$ such that $$$a \\le k \\le b$$$,\nif $$$a > b$$$ then the stadium should contain cell $$$(r,k)$$$ for each $$$k$$$ such that $$$b \\le k \\le a$$$.\nMove the ball from cell $$$(a,c)$$$ to cell $$$(b,c)$$$ ($$$0 \\le c,a,b < N, a \\ne b$$$), where the stadium contains\nall\ncells between cell $$$(a,c)$$$ and $$$(b,c)$$$ in column $$$c$$$. Formally,\nif $$$a < b$$$ then the stadium should contain cell $$$(k,c)$$$ for each $$$k$$$ such that $$$a \\le k \\le b$$$,\nif $$$a > b$$$ then the stadium should contain cell $$$(k,c)$$$ for each $$$k$$$ such that $$$b \\le k \\le a$$$.\nA stadium is\nregular\nif it is possible to move the ball from any cell contained by the stadium to any other cell contained by the stadium with at most $$$2$$$ straight kicks. Note that any stadium of size $$$1$$$ is regular.\nFor example, consider a forest of size $$$N = 5$$$, with cells $$$(1,0)$$$ and $$$(4,2)$$$ containing trees and every other cell being empty. The figure below shows three possible stadiums. Cells with trees are darkened, and cells contained by the stadium are striped.\nThe stadium on the left is regular. However, the stadium in the middle is not regular, because at least $$$3$$$ straight kicks are needed to move the ball from cell $$$(4,1)$$$ to $$$(4,3)$$$. The stadium on the right is also not regular, because it is impossible to move the ball from cell $$$(3,0)$$$ to $$$(1,3)$$$ using straight kicks.\nThe sports club wants to build a regular stadium that is as big as possible. Your task is to find the maximum value of $$$s$$$ such that there exists a regular stadium of size $$$s$$$ in the forest.\nImplementation Details\nYou should implement the following procedure.\nint biggest_stadium(int N, int[][] F)\n$$$N$$$: the size of the forest.\n$$$F$$$: an array of length $$$N$$$ containing arrays of length $$$N$$$, describing cells in the forest. For each $$$r$$$ and $$$c$$$ such that $$$0 \\le r < N$$$ and $$$0 \\le c < N$$$, $$$F[r][c] = 0$$$ means that cell $$$(r, c)$$$ is empty, and $$$F[r][c] = 1$$$ means that it contains a tree.\nThis procedure should return the maximum size of a regular stadium that can be built in the forest.\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\le N \\le 2\\,000$$$)\nline $$$2 + i$$$ ($$$0 \\le i < N$$$): $$$F[i][0] \\; F[i][1] \\; \\ldots \\; F[i][N - 1]$$$ ($$$0 \\le F[i][j] \\le 1$$$)\nThere is at least one empty cell in the forest. In other words, $$$F[i][j] = 0$$$ for some $$$0 \\le i < N$$$ and $$$0 \\le j < N$$$.\nOutput\nThe sample grader prints your answer in the following format:\nline $$$1$$$: the return value of\nbiggest_stadium\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n6\nThere is at most one cell containing a tree.\n2\n8\n$$$N \\le 3$$$\n3\n22\n$$$N \\le 7$$$\n4\n18\n$$$N \\le 30$$$\n5\n16\n$$$N \\le 500$$$\n6\n30\nNo additional constraints.\nIn each subtask, you can obtain 25% of the subtask score if your program judges correctly whether the set consisting of\nall\nthe empty cells is a regular stadium.\nMore precisely, for each test case in which the set consisting of all the empty cells is a regular stadium, your solution:\ngets full points if it returns the correct answer (which is the size of the set consisting of all the empty cells).\ngets 0 points otherwise.\nFor each test case in which the set consisting of all the empty cells is\nnot\na regular stadium, your solution:\ngets full points if it returns the correct answer.\ngets 0 points if it returns the size of the set consisting of all the empty cells.\ngets 25% of the points if it returns any other value.\nThe score for each subtask is the minimum of the points for the test cases in the subtask.\nExample\nNote\nConsider the following call:\nbiggest_stadium(5, [[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]])\nIn this example, the forest is displayed on the left and a regular stadium of size $$$20$$$ is displayed on the right of the following figure:\nSince there is no regular stadium of size $$$21$$$ or greater, the procedure should return $$$20$$$."
    },
    "original": "Nagyerdő is a square-shaped forest located in the city of Debrecen, which can be modeled as an $$$N \\times N$$$ grid of cells. The rows of the grid are numbered from $$$0$$$ to $$$N - 1$$$ from north to south, and the columns are numbered from $$$0$$$ to $$$N - 1$$$ from west to east. We refer to the cell located at row $$$r$$$ and column $$$c$$$ of the grid as cell $$$(r, c)$$$.\nIn the forest, each cell is either\nempty\nor contains a\ntree\n. At least one cell in the forest is empty.\nDVSC, the famous sports club of the city, is planning to build a new soccer stadium in the forest. A stadium of size $$$s$$$ (where $$$s \\ge 1$$$) is a set of $$$s$$$\ndistinct empty\ncells $$$(r_0, c_0), \\ldots, (r_{s - 1}, c_{s - 1})$$$. Formally this means:\nfor each $$$i$$$ from $$$0$$$ to $$$s - 1$$$, inclusive, cell $$$(r_i, c_i)$$$ is empty,\nfor each $$$i, j$$$ such that $$$0 \\le i < j < s$$$, at least one of $$$r_i \\neq r_j$$$ and $$$c_i \\neq c_j$$$ holds.\nSoccer is played using a ball that is moved around the cells of the stadium. A\nstraight kick\nis defined to be either of the following two actions:\nMove the ball from cell $$$(r,a)$$$ to cell $$$(r,b)$$$ ($$$0 \\le r,a,b < N, a \\ne b$$$), where the stadium contains\nall\ncells between cell $$$(r,a)$$$ and $$$(r,b)$$$ in row $$$r$$$. Formally,\nif $$$a < b$$$ then the stadium should contain cell $$$(r,k)$$$ for each $$$k$$$ such that $$$a \\le k \\le b$$$,\nif $$$a > b$$$ then the stadium should contain cell $$$(r,k)$$$ for each $$$k$$$ such that $$$b \\le k \\le a$$$.\nMove the ball from cell $$$(a,c)$$$ to cell $$$(b,c)$$$ ($$$0 \\le c,a,b < N, a \\ne b$$$), where the stadium contains\nall\ncells between cell $$$(a,c)$$$ and $$$(b,c)$$$ in column $$$c$$$. Formally,\nif $$$a < b$$$ then the stadium should contain cell $$$(k,c)$$$ for each $$$k$$$ such that $$$a \\le k \\le b$$$,\nif $$$a > b$$$ then the stadium should contain cell $$$(k,c)$$$ for each $$$k$$$ such that $$$b \\le k \\le a$$$.\nA stadium is\nregular\nif it is possible to move the ball from any cell contained by the stadium to any other cell contained by the stadium with at most $$$2$$$ straight kicks. Note that any stadium of size $$$1$$$ is regular.\nFor example, consider a forest of size $$$N = 5$$$, with cells $$$(1,0)$$$ and $$$(4,2)$$$ containing trees and every other cell being empty. The figure below shows three possible stadiums. Cells with trees are darkened, and cells contained by the stadium are striped.\nThe stadium on the left is regular. However, the stadium in the middle is not regular, because at least $$$3$$$ straight kicks are needed to move the ball from cell $$$(4,1)$$$ to $$$(4,3)$$$. The stadium on the right is also not regular, because it is impossible to move the ball from cell $$$(3,0)$$$ to $$$(1,3)$$$ using straight kicks.\nThe sports club wants to build a regular stadium that is as big as possible. Your task is to find the maximum value of $$$s$$$ such that there exists a regular stadium of size $$$s$$$ in the forest.\nImplementation Details\nYou should implement the following procedure.\nint biggest_stadium(int N, int[][] F)\n$$$N$$$: the size of the forest.\n$$$F$$$: an array of length $$$N$$$ containing arrays of length $$$N$$$, describing cells in the forest. For each $$$r$$$ and $$$c$$$ such that $$$0 \\le r < N$$$ and $$$0 \\le c < N$$$, $$$F[r][c] = 0$$$ means that cell $$$(r, c)$$$ is empty, and $$$F[r][c] = 1$$$ means that it contains a tree.\nThis procedure should return the maximum size of a regular stadium that can be built in the forest.\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\le N \\le 2\\,000$$$)\nline $$$2 + i$$$ ($$$0 \\le i < N$$$): $$$F[i][0] \\; F[i][1] \\; \\ldots \\; F[i][N - 1]$$$ ($$$0 \\le F[i][j] \\le 1$$$)\nThere is at least one empty cell in the forest. In other words, $$$F[i][j] = 0$$$ for some $$$0 \\le i < N$$$ and $$$0 \\le j < N$$$.\nOutput\nThe sample grader prints your answer in the following format:\nline $$$1$$$: the return value of\nbiggest_stadium\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n6\nThere is at most one cell containing a tree.\n2\n8\n$$$N \\le 3$$$\n3\n22\n$$$N \\le 7$$$\n4\n18\n$$$N \\le 30$$$\n5\n16\n$$$N \\le 500$$$\n6\n30\nNo additional constraints.\nIn each subtask, you can obtain 25% of the subtask score if your program judges correctly whether the set consisting of\nall\nthe empty cells is a regular stadium.\nMore precisely, for each test case in which the set consisting of all the empty cells is a regular stadium, your solution:\ngets full points if it returns the correct answer (which is the size of the set consisting of all the empty cells).\ngets 0 points otherwise.\nFor each test case in which the set consisting of all the empty cells is\nnot\na regular stadium, your solution:\ngets full points if it returns the correct answer.\ngets 0 points if it returns the size of the set consisting of all the empty cells.\ngets 25% of the points if it returns any other value.\nThe score for each subtask is the minimum of the points for the test cases in the subtask.\nExample\nNote\nConsider the following call:\nbiggest_stadium(5, [[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]])\nIn this example, the forest is displayed on the left and a regular stadium of size $$$20$$$ is displayed on the right of the following figure:\nSince there is no regular stadium of size $$$21$$$ or greater, the procedure should return $$$20$$$.",
    "_meta": {
      "index": 7,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/C",
      "uuid": "ps_05f6539e2bcdad67c593673cdd6eda614675d834"
    }
  },
  {
    "planning_view": {
      "title": "F. Jousting tournament",
      "task": "Insert knight with rank R into line to maximize rounds won in ≤100,000 knights",
      "given": [
        "N knights with distinct ranks 0 to N-1",
        "N-1 knights already arranged in line",
        "Late knight has rank R",
        "C rounds with known S[i], E[i] ranges"
      ],
      "goal": "Choose insertion position P (0 ≤ P ≤ N-1) to maximize rounds won by late knight",
      "key_rules": [
        "Late knight can only win rounds where he participates AND has highest rank",
        "Knights pack left after each round, positions change",
        "If multiple optimal P, return smallest"
      ],
      "target": {
        "1": {
          "points": 17,
          "req": "N ≤ 500"
        },
        "2": {
          "points": 32,
          "req": "N ≤ 5,000"
        },
        "3": {
          "points": 51,
          "req": "N ≤ 100,000"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Jousting tournament",
      "contest": "IOI 2012 day 2",
      "one_line": "Insert knight with rank R into line to maximize rounds won in ≤100,000 knights",
      "given": [
        "N knights with distinct ranks 0 to N-1",
        "N-1 knights already arranged in line",
        "Late knight has rank R",
        "C rounds with known S[i], E[i] ranges"
      ],
      "goal": "Choose insertion position P (0 ≤ P ≤ N-1) to maximize rounds won by late knight",
      "mechanism": "Each round: knights between S and E compete, highest rank wins, losers leave, survivors pack left maintaining order",
      "success_condition": "Late knight wins when he has highest rank in current round's range",
      "constraints": {
        "critical": [
          "Late knight can only win rounds where he participates AND has highest rank",
          "Knights pack left after each round, positions change",
          "If multiple optimal P, return smallest"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "N ≤ 500"
          },
          "2": {
            "points": 32,
            "req": "N ≤ 5,000"
          },
          "3": {
            "points": 51,
            "req": "N ≤ 100,000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Jousting tournament",
        "contest": "IOI 2012 day 2",
        "one_line": "Insert knight with rank R into line to maximize rounds won in ≤100,000 knights"
      },
      "problem": {
        "given": [
          "N knights with distinct ranks 0 to N-1",
          "N-1 knights already arranged in line",
          "Late knight has rank R",
          "C rounds with known S[i], E[i] ranges"
        ],
        "goal": "Choose insertion position P (0 ≤ P ≤ N-1) to maximize rounds won by late knight",
        "mechanism": "Each round: knights between S and E compete, highest rank wins, losers leave, survivors pack left maintaining order",
        "success_condition": "Late knight wins when he has highest rank in current round's range"
      },
      "constraints": {
        "critical": [
          "Late knight can only win rounds where he participates AND has highest rank",
          "Knights pack left after each round, positions change",
          "If multiple optimal P, return smallest"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "N ≤ 500"
          },
          "2": {
            "points": 32,
            "req": "N ≤ 5,000"
          },
          "3": {
            "points": 51,
            "req": "N ≤ 100,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int GetBestPosition(int N, int C, int R, int *K, int *S, int *E)",
        "available_api": {
          "GetBestPosition": {
            "signature": "int GetBestPosition(int N, int C, int R, int *K, int *S, int *E)",
            "params": "N: total knights, C: rounds count, R: late knight rank, K: array of N-1 existing knight ranks, S/E: arrays of round ranges",
            "returns": "Best insertion position P (0 ≤ P ≤ N-1)",
            "side_effect": "None"
          }
        },
        "requirements": [
          "0-based indexing throughout",
          "K has size N-1, S/E have size C",
          "Return smallest P if multiple optimal"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "5 3 3\n1\n0\n2\n4\n1 3\n0 1\n0 1",
          "output": "1"
        }
      ],
      "original_statement": "For his wedding with Beatrice d'Este in 1491, the Duke of Milan Lodovico Sforza asked Leonardo to orchestrate the wedding celebrations, including a great jousting tournament that lasted for three whole days. But the most popular knight is late...\nTournament\nIn a jousting tournament, the $$$N$$$ knights are first arranged in a line and then their positions are numbered from 0 to $$$N - 1$$$ following the line order. The joust master sets up a round by calling out two positions $$$S$$$ and $$$E$$$ (where $$$0 \\le S < E \\le N - 1).$$$ All the knights whose positions are between $$$S$$$ and $$$E$$$ (inclusive) compete: the winner continues in the tournament and goes back to his place in the line, whereas the losers are out of the game and leave the field. After that, the remaining knights pack together towards the beginning of the line, preserving their relative order in the line, so that their resulting positions are from $$$0$$$ to $$$N - (E - S) - 1.$$$ The joust master calls out another round, repeating this process until just one knight remains.\nLeonardo knows that all the knights have different strengths, represented as distinct ranks from $$$0$$$ (weakest) to $$$N - 1$$$ (strongest). He also knows the exact commands that the joust master will call out for the $$$C$$$ rounds: he's Leonardo, after all... and he is certain that in each of these rounds the knight with the highest rank will win.\nLate knight\n$$$N - 1$$$ of the $$$N$$$ knights are already arranged in the line, just the most popular knight is missing. This knight has rank $$$R$$$ and is arriving a bit late. For the benefit of the entertainment, Leonardo wants to exploit his popularity and choose for him a position in the line that will maximize the number of rounds that the late knight will win. Note that we are not interested in the rounds that don't involve the late knight, just in the rounds he takes part in and wins.\nExample\nFor $$$N = 5$$$ knights, the $$$N - 1$$$ knights that are already arranged in the line have ranks $$$[1, 0, 2, 4],$$$ respectively. Consequently, the late knight has rank $$$R = 3.$$$ For the $$$C = 3$$$ rounds, the joust master intends to call out the $$$(S, E)$$$ positions per round, in this order: $$$(1, 3),$$$ $$$(0, 1),$$$ $$$(0, 1).$$$\nIf Leonardo inserts the late knight at the first position, the ranks of the knights on the line will be $$$[3, 1, 0, 2, 4].$$$ The first round involves knights (at positions $$$1, 2, 3)$$$ with ranks $$$1, 0, 2,$$$ leaving the knight with rank $$$2$$$ as the winner. The new line is $$$[3, 2, 4].$$$ The next round is $$$3$$$ against $$$2$$$ (at positions $$$0, 1)$$$, and knight with rank $$$R = 3$$$ wins, leaving the line $$$[3, 4].$$$ The final round (at positions $$$0, 1)$$$ has $$$4$$$ as winner. Thus, the late knight only wins one round (the second one).\nInstead, if Leonardo inserts the late knight between those two of ranks $$$1$$$ and $$$0,$$$ the line looks like this: $$$[1, 3, 0, 2, 4].$$$ This time, the first round involves $$$3, 0, 2,$$$ and the knight with rank $$$R = 3$$$ wins. The next starting line is $$$[1, 3, 4],$$$ and in the next round ($$$1$$$ against $$$3)$$$ the knight with rank $$$R = 3$$$ wins again. The final line is $$$[3, 4],$$$ where $$$4$$$ wins. Thus, the late knight wins two rounds: this is actually the best possible placement as there is no way for the late knight to win more than twice.\nStatement\nYour task is to write a program that chooses the best position for the late knight so that the number of rounds won by him is maximized, as Leonardo wants. Specifically, you have to implement a routine called\nGetBestPosition(N, C, R, K, S, E)\n, where:\nN\nis the number of knights;\nC\nis the number of rounds called out by the joust master $$$(1 \\le C \\le N - 1);$$$\nR\nis the rank of the late knight; the ranks of all the knights (both those already lined up and the late one) are distinct and chosen from $$$0, \\dots, N - 1,$$$ and the rank\nR\nof the late knight is given explicitly even though it can be deduced;\nK\nis an array of $$$N - 1$$$ integers, representing the ranks of the $$$N - 1$$$ knights that are already on the starting line;\nS\nand\nE\nare two arrays of size $$$C:$$$ for each $$$i$$$ between $$$0$$$ and $$$C - 1,$$$ inclusive, the $$$(i + 1)$$$th round called by the joust master will involve all knights from position $$$S[i]$$$ to position $$$E[i],$$$ inclusive. You may assume that for each $$$i,$$$ $$$S[i] < E[i].$$$\nThe calls passed to this routine are valid: we have that $$$E[i]$$$ is less than the current number of knights remaining for the $$$(i + 1)$$$th round, and after all the $$$C$$$ commands there will be exactly one knight left.\nGetBestPosition(N, C, R, K, S, E)\nmust return the best position $$$P$$$ where Leonardo should put the late knight $$$(0 \\le P \\le N - 1).$$$ If there are multiple equivalent positions, output the smallest one. (The position $$$P$$$ is the 0-based position of the late knight in the resulting line. In other words, $$$P$$$ is the number of other knights standing before the late knight in the optimal solution. Specifically, $$$P$$$ = 0 means that the late knight is at the beginning of the line, and $$$P = N - 1$$$ means that he is at the end of it.)\nImplementation details\nYou have to submit exactly one file, called\ntournament.c\nor\ntournament.cpp\n. This file must implement the subprogram described above using the following signatures.\nint GetBestPosition(int N, int C, int R, int *K, int *S, int *E);\nThese subprograms must behave as described above. Of course you are free to implement other subprograms for their internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nSample grader\nThe sample grader provided with the task environment will expect input in the following format:\nline 1 :\n$$$M, C, R$$$\nlines 2, ..., $$$N$$$ :\n$$$K[i]$$$\nlines $$$N + 1,$$$ ..., $$$N + C$$$ :\n$$$S[i], E[i]$$$\nScoring\nSubtask\nPoints\nConditions\n1\n17\n$$$N \\le 500$$$\n2\n32\n$$$N \\le 5\\,000$$$\n3\n51\n$$$N \\le 100\\,000$$$\nExample"
    },
    "original": "For his wedding with Beatrice d'Este in 1491, the Duke of Milan Lodovico Sforza asked Leonardo to orchestrate the wedding celebrations, including a great jousting tournament that lasted for three whole days. But the most popular knight is late...\nTournament\nIn a jousting tournament, the $$$N$$$ knights are first arranged in a line and then their positions are numbered from 0 to $$$N - 1$$$ following the line order. The joust master sets up a round by calling out two positions $$$S$$$ and $$$E$$$ (where $$$0 \\le S < E \\le N - 1).$$$ All the knights whose positions are between $$$S$$$ and $$$E$$$ (inclusive) compete: the winner continues in the tournament and goes back to his place in the line, whereas the losers are out of the game and leave the field. After that, the remaining knights pack together towards the beginning of the line, preserving their relative order in the line, so that their resulting positions are from $$$0$$$ to $$$N - (E - S) - 1.$$$ The joust master calls out another round, repeating this process until just one knight remains.\nLeonardo knows that all the knights have different strengths, represented as distinct ranks from $$$0$$$ (weakest) to $$$N - 1$$$ (strongest). He also knows the exact commands that the joust master will call out for the $$$C$$$ rounds: he's Leonardo, after all... and he is certain that in each of these rounds the knight with the highest rank will win.\nLate knight\n$$$N - 1$$$ of the $$$N$$$ knights are already arranged in the line, just the most popular knight is missing. This knight has rank $$$R$$$ and is arriving a bit late. For the benefit of the entertainment, Leonardo wants to exploit his popularity and choose for him a position in the line that will maximize the number of rounds that the late knight will win. Note that we are not interested in the rounds that don't involve the late knight, just in the rounds he takes part in and wins.\nExample\nFor $$$N = 5$$$ knights, the $$$N - 1$$$ knights that are already arranged in the line have ranks $$$[1, 0, 2, 4],$$$ respectively. Consequently, the late knight has rank $$$R = 3.$$$ For the $$$C = 3$$$ rounds, the joust master intends to call out the $$$(S, E)$$$ positions per round, in this order: $$$(1, 3),$$$ $$$(0, 1),$$$ $$$(0, 1).$$$\nIf Leonardo inserts the late knight at the first position, the ranks of the knights on the line will be $$$[3, 1, 0, 2, 4].$$$ The first round involves knights (at positions $$$1, 2, 3)$$$ with ranks $$$1, 0, 2,$$$ leaving the knight with rank $$$2$$$ as the winner. The new line is $$$[3, 2, 4].$$$ The next round is $$$3$$$ against $$$2$$$ (at positions $$$0, 1)$$$, and knight with rank $$$R = 3$$$ wins, leaving the line $$$[3, 4].$$$ The final round (at positions $$$0, 1)$$$ has $$$4$$$ as winner. Thus, the late knight only wins one round (the second one).\nInstead, if Leonardo inserts the late knight between those two of ranks $$$1$$$ and $$$0,$$$ the line looks like this: $$$[1, 3, 0, 2, 4].$$$ This time, the first round involves $$$3, 0, 2,$$$ and the knight with rank $$$R = 3$$$ wins. The next starting line is $$$[1, 3, 4],$$$ and in the next round ($$$1$$$ against $$$3)$$$ the knight with rank $$$R = 3$$$ wins again. The final line is $$$[3, 4],$$$ where $$$4$$$ wins. Thus, the late knight wins two rounds: this is actually the best possible placement as there is no way for the late knight to win more than twice.\nStatement\nYour task is to write a program that chooses the best position for the late knight so that the number of rounds won by him is maximized, as Leonardo wants. Specifically, you have to implement a routine called\nGetBestPosition(N, C, R, K, S, E)\n, where:\nN\nis the number of knights;\nC\nis the number of rounds called out by the joust master $$$(1 \\le C \\le N - 1);$$$\nR\nis the rank of the late knight; the ranks of all the knights (both those already lined up and the late one) are distinct and chosen from $$$0, \\dots, N - 1,$$$ and the rank\nR\nof the late knight is given explicitly even though it can be deduced;\nK\nis an array of $$$N - 1$$$ integers, representing the ranks of the $$$N - 1$$$ knights that are already on the starting line;\nS\nand\nE\nare two arrays of size $$$C:$$$ for each $$$i$$$ between $$$0$$$ and $$$C - 1,$$$ inclusive, the $$$(i + 1)$$$th round called by the joust master will involve all knights from position $$$S[i]$$$ to position $$$E[i],$$$ inclusive. You may assume that for each $$$i,$$$ $$$S[i] < E[i].$$$\nThe calls passed to this routine are valid: we have that $$$E[i]$$$ is less than the current number of knights remaining for the $$$(i + 1)$$$th round, and after all the $$$C$$$ commands there will be exactly one knight left.\nGetBestPosition(N, C, R, K, S, E)\nmust return the best position $$$P$$$ where Leonardo should put the late knight $$$(0 \\le P \\le N - 1).$$$ If there are multiple equivalent positions, output the smallest one. (The position $$$P$$$ is the 0-based position of the late knight in the resulting line. In other words, $$$P$$$ is the number of other knights standing before the late knight in the optimal solution. Specifically, $$$P$$$ = 0 means that the late knight is at the beginning of the line, and $$$P = N - 1$$$ means that he is at the end of it.)\nImplementation details\nYou have to submit exactly one file, called\ntournament.c\nor\ntournament.cpp\n. This file must implement the subprogram described above using the following signatures.\nint GetBestPosition(int N, int C, int R, int *K, int *S, int *E);\nThese subprograms must behave as described above. Of course you are free to implement other subprograms for their internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nSample grader\nThe sample grader provided with the task environment will expect input in the following format:\nline 1 :\n$$$M, C, R$$$\nlines 2, ..., $$$N$$$ :\n$$$K[i]$$$\nlines $$$N + 1,$$$ ..., $$$N + C$$$ :\n$$$S[i], E[i]$$$\nScoring\nSubtask\nPoints\nConditions\n1\n17\n$$$N \\le 500$$$\n2\n32\n$$$N \\le 5\\,000$$$\n3\n51\n$$$N \\le 100\\,000$$$\nExample",
    "_meta": {
      "index": 8,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/F",
      "uuid": "ps_b406b62e1af5a4c0a13e203567a47d88043b930a"
    }
  },
  {
    "planning_view": {
      "title": "C. Radio Towers",
      "task": "Find largest set where all towers communicate via intermediaries given δ",
      "given": [
        "N radio towers numbered 0 to N-1 along a line",
        "Each tower has distinct height H[i]",
        "Towers i and j communicate if ∃k where i < k < j and H[i], H[j] ≤ H[k] - δ"
      ],
      "goal": "For each query (L, R, D), find maximum number of leased towers in [L,R] where all pairs communicate",
      "key_rules": [
        "Communication requires intermediary tower between the pair",
        "Intermediary tower height must be at least δ more than both communicating towers",
        "Intermediary tower can be outside the leased set"
      ],
      "target": {
        "1": {
          "points": 4,
          "req": "Heights form unimodal sequence (increasing then decreasing)"
        },
        "2": {
          "points": 11,
          "req": "Q = 1, N ≤ 2000"
        },
        "3": {
          "points": 12,
          "req": "Q = 1"
        },
        "4": {
          "points": 14,
          "req": "D = 1"
        },
        "5": {
          "points": 17,
          "req": "L = 0, R = N-1 (full range)"
        },
        "6": {
          "points": 19,
          "req": "D constant across all queries"
        },
        "7": {
          "points": 23,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Radio Towers",
      "contest": "IOI 2022 day 1",
      "one_line": "Find largest set where all towers communicate via intermediaries given δ",
      "given": [
        "N radio towers numbered 0 to N-1 along a line",
        "Each tower has distinct height H[i]",
        "Towers i and j communicate if ∃k where i < k < j and H[i], H[j] ≤ H[k] - δ"
      ],
      "goal": "For each query (L, R, D), find maximum number of leased towers in [L,R] where all pairs communicate",
      "mechanism": "Two towers communicate if there exists an intermediary tower between them with sufficient height difference",
      "success_condition": "Return size of largest subset of towers in [L,R] where every pair can communicate (directly or via intermediaries)",
      "constraints": {
        "critical": [
          "Communication requires intermediary tower between the pair",
          "Intermediary tower height must be at least δ more than both communicating towers",
          "Intermediary tower can be outside the leased set"
        ],
        "subtasks": {
          "1": {
            "points": 4,
            "req": "Heights form unimodal sequence (increasing then decreasing)"
          },
          "2": {
            "points": 11,
            "req": "Q = 1, N ≤ 2000"
          },
          "3": {
            "points": 12,
            "req": "Q = 1"
          },
          "4": {
            "points": 14,
            "req": "D = 1"
          },
          "5": {
            "points": 17,
            "req": "L = 0, R = N-1 (full range)"
          },
          "6": {
            "points": 19,
            "req": "D constant across all queries"
          },
          "7": {
            "points": 23,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Radio Towers",
        "contest": "IOI 2022 day 1",
        "one_line": "Find largest set where all towers communicate via intermediaries given δ"
      },
      "problem": {
        "given": [
          "N radio towers numbered 0 to N-1 along a line",
          "Each tower has distinct height H[i]",
          "Towers i and j communicate if ∃k where i < k < j and H[i], H[j] ≤ H[k] - δ"
        ],
        "goal": "For each query (L, R, D), find maximum number of leased towers in [L,R] where all pairs communicate",
        "mechanism": "Two towers communicate if there exists an intermediary tower between them with sufficient height difference",
        "success_condition": "Return size of largest subset of towers in [L,R] where every pair can communicate (directly or via intermediaries)"
      },
      "constraints": {
        "critical": [
          "Communication requires intermediary tower between the pair",
          "Intermediary tower height must be at least δ more than both communicating towers",
          "Intermediary tower can be outside the leased set"
        ],
        "subtasks": {
          "1": {
            "points": 4,
            "req": "Heights form unimodal sequence (increasing then decreasing)"
          },
          "2": {
            "points": 11,
            "req": "Q = 1, N ≤ 2000"
          },
          "3": {
            "points": 12,
            "req": "Q = 1"
          },
          "4": {
            "points": 14,
            "req": "D = 1"
          },
          "5": {
            "points": 17,
            "req": "L = 0, R = N-1 (full range)"
          },
          "6": {
            "points": 19,
            "req": "D constant across all queries"
          },
          "7": {
            "points": 23,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int max_towers(int L, int R, int D)",
        "available_api": {
          "init": {
            "signature": "void init(int N, int[] H)",
            "params": "N: number of towers, H: array of distinct heights",
            "returns": "void",
            "side_effect": "Initializes data structures for subsequent queries"
          },
          "max_towers": {
            "signature": "int max_towers(int L, int R, int D)",
            "params": "L,R: range boundaries, D: interference value δ",
            "returns": "Maximum number of towers that can be leased",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Towers are 0-indexed",
          "init called once before any max_towers calls",
          "max_towers called exactly Q times"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "7 3\n10 20 60 40 50 30 70\n1 5 10\n2 2 100\n0 6 17",
          "output": "3\n1\n2"
        }
      ],
      "original_statement": "There are $$$N$$$ radio towers in Jakarta. The towers are located along a straight line and numbered from $$$0$$$ to $$$N - 1$$$ from left to right. For each $$$i$$$ such that $$$0 \\le i \\le N - 1$$$, the height of tower $$$i$$$ is $$$H[i]$$$ metres. The heights of the towers are\ndistinct\n.\nFor some positive interference value $$$\\delta$$$, a pair of towers $$$i$$$ and $$$j$$$ (where $$$0 \\le i \\textless j \\le N - 1$$$) can communicate with each other if and only if there is an intermediary tower $$$k$$$, such that\ntower $$$i$$$ is to the left of tower $$$k$$$ and tower $$$j$$$ is to the right of tower $$$k$$$, that is, $$$i \\textless k \\textless j$$$, and\nthe heights of tower $$$i$$$ and tower $$$j$$$ are both at most $$$H[k] - \\delta$$$ metres.\nPak Dengklek wants to lease some radio towers for his new radio network. Your task is to answer $$$Q$$$ questions of Pak Dengklek which are of the following form: given parameters $$$L\\ R$$$ and $$$D$$$ ($$$0 \\le L \\le R \\le N - 1$$$ and $$$D > 0$$$), what is the maximum number of towers Pak Dengklek can lease, assuming that\nPak Dengklek can only lease towers with indices between $$$L$$$ and $$$R$$$ (inclusive), and\nthe interference value $$$\\delta$$$ is $$$D$$$, and\nany pair of radio towers that Pak Dengklek leases must be able to communicate with each other.\nNote that two leased towers may communicate using an intermediary tower $$$k$$$, regardless of whether tower $$$k$$$ is leased or not.\nImplementation Details\nYou should implement the following procedures:\nvoid init(int N, int[] H)\n$$$N$$$: the number of radio towers.\n$$$H$$$: an array of length $$$N$$$ describing the tower heights.\nThis procedure is called exactly once, before any calls to\nmax_towers\n.\nint max_towers(int L, int R, int D)\n$$$L$$$, $$$R$$$: the boundaries of a range of towers.\n$$$D$$$: the value of $$$\\delta$$$.\nThis procedure should return the maximum number of radio towers Pak Dengklek can lease for his new radio network if he is only allowed to lease towers between tower $$$L$$$ and tower $$$R$$$ (inclusive) and the value of $$$\\delta$$$ is $$$D$$$.\nThis procedure is called exactly $$$Q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\ Q$$$ ($$$1 \\le N \\le 100\\,000$$$, $$$1 \\le Q \\le 100\\,000$$$)\nline $$$2$$$: $$$H[0] \\ H[1] \\ \\ldots \\ H[N - 1]$$$ ($$$1 \\le H[i] \\le 10^9$$$, $$$H[i] \\ne H[j]$$$ (for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i \\textless j \\le N - 1$$$))\nline $$$3 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$L \\ R \\ D$$$ for question $$$j$$$ ($$$0 \\le L \\le R \\le N - 1$$$, $$$1 \\le D \\le 10^9$$$)\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + j$$$ ($$$0 \\le j \\le Q - 1$$$): the return value of\nmax_towers\nfor question $$$j$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n4\nThere exists a tower $$$k$$$ ($$$0 \\le k \\le N - 1$$$) such that\nfor each $$$i$$$ such that $$$0\\le i\\le k-1$$$: $$$H[i] \\textless H[i + 1]$$$, and\nfor each $$$i$$$ such that $$$k \\le i \\le N - 2$$$: $$$H[i] \\textgreater H[i + 1]$$$.\n2\n11\n$$$Q = 1$$$, $$$N \\le 2000$$$\n3\n12\n$$$Q = 1$$$\n4\n14\n$$$D = 1$$$\n5\n17\n$$$L = 0$$$, $$$R = N - 1$$$\n6\n19\nThe value of $$$D$$$ is the same across all\nmax_towers\ncalls.\n7\n23\nNo additional constraints\nExample\nNote\nConsider the following sequence of calls:\ninit(7, [10, 20, 60, 40, 50, 30, 70])\nmax_towers(1, 5, 10)\nPak Dengklek can lease towers $$$1$$$, $$$3$$$, and $$$5$$$. The example is illustrated in the following picture, where shaded trapezoids represent leased towers.\nTowers $$$3$$$ and $$$5$$$ can communicate using tower $$$4$$$ as an intermediary, since $$$40 \\le 50 - 10$$$ and $$$30 \\le 50 - 10$$$. Towers $$$1$$$ and $$$3$$$ can communicate using tower $$$2$$$ as an intermediary. Towers $$$1$$$ and $$$5$$$ can communicate using tower $$$3$$$ as an intermediary. There is no way to lease more than $$$3$$$ towers, therefore the procedure should return $$$3$$$.\nmax_towers(2, 2, 100)\nThere is only $$$1$$$ tower in the range, thus Pak Dengklek can only lease $$$1$$$ tower. Therefore the procedure should return $$$1$$$.\nmax_towers(0, 6, 17)\nPak Dengklek can lease towers $$$1$$$ and $$$3$$$. Towers $$$1$$$ and $$$3$$$ can communicate using tower $$$2$$$ as an intermediary, since $$$20 \\le 60 - 17$$$ and $$$40 \\le 60 - 17$$$. There is no way to lease more than $$$2$$$ towers, therefore the procedure should return $$$2$$$."
    },
    "original": "There are $$$N$$$ radio towers in Jakarta. The towers are located along a straight line and numbered from $$$0$$$ to $$$N - 1$$$ from left to right. For each $$$i$$$ such that $$$0 \\le i \\le N - 1$$$, the height of tower $$$i$$$ is $$$H[i]$$$ metres. The heights of the towers are\ndistinct\n.\nFor some positive interference value $$$\\delta$$$, a pair of towers $$$i$$$ and $$$j$$$ (where $$$0 \\le i \\textless j \\le N - 1$$$) can communicate with each other if and only if there is an intermediary tower $$$k$$$, such that\ntower $$$i$$$ is to the left of tower $$$k$$$ and tower $$$j$$$ is to the right of tower $$$k$$$, that is, $$$i \\textless k \\textless j$$$, and\nthe heights of tower $$$i$$$ and tower $$$j$$$ are both at most $$$H[k] - \\delta$$$ metres.\nPak Dengklek wants to lease some radio towers for his new radio network. Your task is to answer $$$Q$$$ questions of Pak Dengklek which are of the following form: given parameters $$$L\\ R$$$ and $$$D$$$ ($$$0 \\le L \\le R \\le N - 1$$$ and $$$D > 0$$$), what is the maximum number of towers Pak Dengklek can lease, assuming that\nPak Dengklek can only lease towers with indices between $$$L$$$ and $$$R$$$ (inclusive), and\nthe interference value $$$\\delta$$$ is $$$D$$$, and\nany pair of radio towers that Pak Dengklek leases must be able to communicate with each other.\nNote that two leased towers may communicate using an intermediary tower $$$k$$$, regardless of whether tower $$$k$$$ is leased or not.\nImplementation Details\nYou should implement the following procedures:\nvoid init(int N, int[] H)\n$$$N$$$: the number of radio towers.\n$$$H$$$: an array of length $$$N$$$ describing the tower heights.\nThis procedure is called exactly once, before any calls to\nmax_towers\n.\nint max_towers(int L, int R, int D)\n$$$L$$$, $$$R$$$: the boundaries of a range of towers.\n$$$D$$$: the value of $$$\\delta$$$.\nThis procedure should return the maximum number of radio towers Pak Dengklek can lease for his new radio network if he is only allowed to lease towers between tower $$$L$$$ and tower $$$R$$$ (inclusive) and the value of $$$\\delta$$$ is $$$D$$$.\nThis procedure is called exactly $$$Q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\ Q$$$ ($$$1 \\le N \\le 100\\,000$$$, $$$1 \\le Q \\le 100\\,000$$$)\nline $$$2$$$: $$$H[0] \\ H[1] \\ \\ldots \\ H[N - 1]$$$ ($$$1 \\le H[i] \\le 10^9$$$, $$$H[i] \\ne H[j]$$$ (for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i \\textless j \\le N - 1$$$))\nline $$$3 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$L \\ R \\ D$$$ for question $$$j$$$ ($$$0 \\le L \\le R \\le N - 1$$$, $$$1 \\le D \\le 10^9$$$)\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + j$$$ ($$$0 \\le j \\le Q - 1$$$): the return value of\nmax_towers\nfor question $$$j$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n4\nThere exists a tower $$$k$$$ ($$$0 \\le k \\le N - 1$$$) such that\nfor each $$$i$$$ such that $$$0\\le i\\le k-1$$$: $$$H[i] \\textless H[i + 1]$$$, and\nfor each $$$i$$$ such that $$$k \\le i \\le N - 2$$$: $$$H[i] \\textgreater H[i + 1]$$$.\n2\n11\n$$$Q = 1$$$, $$$N \\le 2000$$$\n3\n12\n$$$Q = 1$$$\n4\n14\n$$$D = 1$$$\n5\n17\n$$$L = 0$$$, $$$R = N - 1$$$\n6\n19\nThe value of $$$D$$$ is the same across all\nmax_towers\ncalls.\n7\n23\nNo additional constraints\nExample\nNote\nConsider the following sequence of calls:\ninit(7, [10, 20, 60, 40, 50, 30, 70])\nmax_towers(1, 5, 10)\nPak Dengklek can lease towers $$$1$$$, $$$3$$$, and $$$5$$$. The example is illustrated in the following picture, where shaded trapezoids represent leased towers.\nTowers $$$3$$$ and $$$5$$$ can communicate using tower $$$4$$$ as an intermediary, since $$$40 \\le 50 - 10$$$ and $$$30 \\le 50 - 10$$$. Towers $$$1$$$ and $$$3$$$ can communicate using tower $$$2$$$ as an intermediary. Towers $$$1$$$ and $$$5$$$ can communicate using tower $$$3$$$ as an intermediary. There is no way to lease more than $$$3$$$ towers, therefore the procedure should return $$$3$$$.\nmax_towers(2, 2, 100)\nThere is only $$$1$$$ tower in the range, thus Pak Dengklek can only lease $$$1$$$ tower. Therefore the procedure should return $$$1$$$.\nmax_towers(0, 6, 17)\nPak Dengklek can lease towers $$$1$$$ and $$$3$$$. Towers $$$1$$$ and $$$3$$$ can communicate using tower $$$2$$$ as an intermediary, since $$$20 \\le 60 - 17$$$ and $$$40 \\le 60 - 17$$$. There is no way to lease more than $$$2$$$ towers, therefore the procedure should return $$$2$$$.",
    "_meta": {
      "index": 9,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/C",
      "uuid": "ps_cf0125bb656310f35d3094491f9f51b826c6876d"
    }
  },
  {
    "planning_view": {
      "title": "E. Sorting",
      "task": "Sort array against adversary's swaps in ≤M rounds, minimizing moves",
      "given": [
        "Array S of N integers",
        "Adversary's M swap pairs (X[i], Y[i])",
        "Sequence must be sorted in ascending order"
      ],
      "goal": "Find Aizhan's swap sequence to sort S despite Ermek's interference",
      "key_rules": [
        "Aizhan swaps after Ermek each round",
        "Can swap equal indices (no-op)",
        "Terminate immediately when sorted",
        "Must use exactly the adversary's swap sequence order"
      ],
      "target": {
        "1": {
          "points": 8,
          "req": "N ≤ 5, M = N², adversary always swaps (0,0)"
        },
        "2": {
          "points": 12,
          "req": "N ≤ 100, M = 30N, adversary always swaps (0,0)"
        },
        "3": {
          "points": 16,
          "req": "N ≤ 100, M = 30N, adversary always swaps (0,1)"
        },
        "4": {
          "points": 18,
          "req": "N ≤ 500, M = 30N, any adversary swaps"
        },
        "5": {
          "points": 20,
          "req": "N ≤ 2000, M = 3N, find minimum R"
        },
        "6": {
          "points": 26,
          "req": "N ≤ 200000, M = 3N, find minimum R"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Sorting",
      "contest": "IOI 2015 day 2",
      "one_line": "Sort array against adversary's swaps in ≤M rounds, minimizing moves",
      "given": [
        "Array S of N integers",
        "Adversary's M swap pairs (X[i], Y[i])",
        "Sequence must be sorted in ascending order"
      ],
      "goal": "Find Aizhan's swap sequence to sort S despite Ermek's interference",
      "mechanism": "Each round: Ermek swaps X[i] and Y[i], then Aizhan swaps P[i] and Q[i]",
      "success_condition": "Array becomes sorted after any round (can terminate early)",
      "constraints": {
        "critical": [
          "Aizhan swaps after Ermek each round",
          "Can swap equal indices (no-op)",
          "Terminate immediately when sorted",
          "Must use exactly the adversary's swap sequence order"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "N ≤ 5, M = N², adversary always swaps (0,0)"
          },
          "2": {
            "points": 12,
            "req": "N ≤ 100, M = 30N, adversary always swaps (0,0)"
          },
          "3": {
            "points": 16,
            "req": "N ≤ 100, M = 30N, adversary always swaps (0,1)"
          },
          "4": {
            "points": 18,
            "req": "N ≤ 500, M = 30N, any adversary swaps"
          },
          "5": {
            "points": 20,
            "req": "N ≤ 2000, M = 3N, find minimum R"
          },
          "6": {
            "points": 26,
            "req": "N ≤ 200000, M = 3N, find minimum R"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Sorting",
        "contest": "IOI 2015 day 2",
        "one_line": "Sort array against adversary's swaps in ≤M rounds, minimizing moves"
      },
      "problem": {
        "given": [
          "Array S of N integers",
          "Adversary's M swap pairs (X[i], Y[i])",
          "Sequence must be sorted in ascending order"
        ],
        "goal": "Find Aizhan's swap sequence to sort S despite Ermek's interference",
        "mechanism": "Each round: Ermek swaps X[i] and Y[i], then Aizhan swaps P[i] and Q[i]",
        "success_condition": "Array becomes sorted after any round (can terminate early)"
      },
      "constraints": {
        "critical": [
          "Aizhan swaps after Ermek each round",
          "Can swap equal indices (no-op)",
          "Terminate immediately when sorted",
          "Must use exactly the adversary's swap sequence order"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "N ≤ 5, M = N², adversary always swaps (0,0)"
          },
          "2": {
            "points": 12,
            "req": "N ≤ 100, M = 30N, adversary always swaps (0,0)"
          },
          "3": {
            "points": 16,
            "req": "N ≤ 100, M = 30N, adversary always swaps (0,1)"
          },
          "4": {
            "points": 18,
            "req": "N ≤ 500, M = 30N, any adversary swaps"
          },
          "5": {
            "points": 20,
            "req": "N ≤ 2000, M = 3N, find minimum R"
          },
          "6": {
            "points": 26,
            "req": "N ≤ 200000, M = 3N, find minimum R"
          }
        }
      },
      "implementation": {
        "function_to_write": "int findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[])",
        "available_api": {
          "findSwapPairs": {
            "signature": "int findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[])",
            "params": "N: array length, S: initial array, M: number of rounds, X/Y: adversary's swaps",
            "returns": "R: number of Aizhan's swaps actually used",
            "side_effect": "Fills P and Q arrays with Aizhan's swap indices"
          }
        },
        "requirements": [
          "Arrays P and Q pre-allocated to size M",
          "Return R ≤ M",
          "Indices are 0-based",
          "Function called exactly once by grader"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "Aizhan has a sequence of $$$N$$$ integers $$$S[0], S[1], \\ldots, S[N - 1]$$$. She is trying to sort this sequence in ascending order by swapping some pairs of elements. Her friend Ermek is also going to swap some pairs of elements— not necessarily in a helpful way.\nErmek and Aizhan are going to modify the sequence in a series of rounds. In each round, first Ermek makes a swap and then Aizhan makes another swap. More precisely, the person making a swap chooses two valid indices and swaps the elements at those indices. Note that the two indices do not have to be distinct. If they are equal, the current person swaps an element with itself, which does not change the sequence.\nAizhan knows that Ermek does not actually care about sorting the sequence $$$S$$$. She also knows the exact indices Ermek is going to choose. Ermek plans to take part in $$$M$$$ rounds of swapping. We number these rounds from $$$0$$$ to $$$M - 1$$$. For each $$$i$$$ between $$$0$$$ and $$$M - 1$$$ inclusive, Ermek will choose the indices $$$X[i]$$$ and $$$Y[i]$$$ in round $$$i$$$.\nAizhan wants to sort the sequence $$$S$$$. Before each round, if Aizhan sees that the sequence is already sorted in ascending order, she will terminate the entire process. Given the original sequence $$$S$$$ and the indices Ermek is going to choose, your task is to find a sequence of swaps, which Aizhan can use to sort the sequence $$$S$$$. In addition, in some subtasks you are required to find a sequence of swaps that is as short as possible. You may assume that it is possible to sort the sequence $$$S$$$ in $$$M$$$ or fewer rounds.\nNote that if Aizhan sees that the sequence $$$S$$$ is sorted after Ermek's swap, she can choose to swap two equal indices (e.g., 0 and 0). As a result the sequence $$$S$$$ Aizhan reaches her goal. Also note that if the initial sequence $$$S$$$ is also sorted after the entire round, so is already sorted, the minimal number of rounds needed to sort it is 0.\nYou are given the sequence $$$S$$$, the number $$$M$$$, and the sequences of indices $$$X$$$ and $$$Y$$$. Compute a sequence of swaps, which Aizhan can use to sort the sequence $$$S$$$. In subtasks and 5 and 6 the sequence of swaps you find has to be the shortest possible.\nYou need to implement the function\nfindSwapPairs\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[])\n— This function will be called by the grader exactly once.\n$$$N$$$: the length of the sequence $$$S$$$.\n$$$S$$$: an array of integers containing the initial sequence $$$S$$$.\n$$$M$$$: the number of swaps Ermek plans to make.\n$$$X, Y$$$: arrays of integers of length $$$M$$$. For $$$0 \\le i \\le M - 1$$$, in round $$$i$$$ Ermek plans to swap numbers at indices $$$X[i]$$$ and $$$Y[i]$$$.\n$$$P, Q$$$: arrays of integers. Use these arrays to report one possible sequence of swaps Aizhan can make to sort the sequence $$$S$$$. Denote by $$$R$$$ the length of the sequence of swaps that your program has found. For each $$$i$$$ between $$$0$$$ and $$$R - 1$$$ inclusive, the indices Aizhan should choose in round $$$i$$$ should be stored into $$$P[i]$$$ and $$$Q[i]$$$. You may assume that the arrays $$$P$$$ and $$$Q$$$ have already been allocated to $$$M$$$ elements each.\nThis function should return the value of $$$R$$$(defined above).\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$N$$$\nline 2: $$$S[0]\\ \\ldots\\ S[N - 1]$$$\nline 3: $$$M$$$\nlines $$$4, \\ldots, M + 3$$$: $$$X[i]\\ Y[i]$$$\nOutput\nThe sample grader prints the following output:\nline 1: The return value $$$R$$$ of\nfindSwapPairs\nlines $$$2 + i (0 \\le i < R)$$$: $$$P[i]\\ Q[i]$$$\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\nExtra constraints on $$$X$$$ and $$$Y$$$\nRequirement on R\n1\n8\n$$$1 \\le N \\le 5$$$\n$$$M = N^2$$$\n$$$X[i] = Y[i] = 0$$$ for all $$$i$$$\n$$$R \\le M$$$\n2\n12\n$$$1 \\le N \\le 100$$$\n$$$M = 30N$$$\n$$$X[i] = Y[i] = 0$$$ for all $$$i$$$\n$$$R \\le M$$$\n3\n16\n$$$1 \\le N \\le 100$$$\n$$$M = 30N$$$\n$$$X[i] = 0, Y[i] = 1$$$ for all $$$i$$$\n$$$R \\le M$$$\n4\n18\n$$$1 \\le N \\le 500$$$\n$$$M = 30N$$$\n—\n$$$R \\le M$$$\n5\n20\n$$$6 \\le N \\le 2000$$$\n$$$M = 3N$$$\n—\nminimum possible\n6\n26\n$$$6 \\le N \\le 200\\,000$$$\n$$$M = 3N$$$\n—\nminimum possible\nYou may assume that there exists a solution that requires $$$M$$$ or fewer rounds.\nNote\nExample 1\nSuppose that:\nThe initial sequence is $$$S=4,3,2,1,0$$$.\nErmek is willing to make $$$M=6$$$ swaps.\nThe sequences $$$X$$$ and $$$Y$$$ that describe the indices Ermek is going to choose are $$$X=0,1,2,3,0,1$$$ and $$$Y=1,2,3,4,1,2$$$. In other words, the pairs of indices that Ermek plans to choose are (0, 1), (1, 2), (2, 3), (3, 4), (0, 1), and (1, 2).\nIn this setting Aizhan can sort the sequence $$$S$$$ into the order $$$0,1,2,3,4$$$ in three rounds. She can do so by choosing the indices (0, 4), (1, 3), and then (3, 4).\nThe following table shows how Ermek and Aizhan modify the sequence.\nRound\nPlayer\nPair of swapped indices\nSequence\nbeginning\n4,3,2,1,0\n0\nErmek\n(0,1)\n3,4,2,1,0\n0\nAizhan\n(0,4)\n0,4,2,1,3\n1\nErmek\n(1,2)\n0,2,4,1,3\n1\nAizhan\n(1,3)\n0,1,4,2,3\n2\nErmek\n(2,3)\n0,1,2,4,3\n2\nAizhan\n(3,4)\n0,1,2,3,4\nExample 2\nSuppose that:\nThe initial sequence is $$$S=3,0,4,2,1$$$.\nErmek is willing to make $$$M=5$$$ swaps.\nThe pairs of indices that Ermek plans to choose are (1, 1), (4, 0), (2, 3), (1, 4), and (0, 4).\nIn this setting Aizhan can sort the sequence $$$S$$$ in three rounds, for example by choosing the pairs of indices (1, 4), (4, 2), and then (2, 2). The following table shows how Ermek and Aizhan modify the sequence.\nRound\nPlayer\nPair of swapped indices\nSequence\nbeginning\n3,0,4,2,1\n0\nErmek\n(1,1)\n3,0,4,2,1\n0\nAizhan\n(1,4)\n3,1,4,2,0\n1\nErmek\n(4,0)\n0,1,4,2,3\n1\nAizhan\n(4,2)\n0,1,3,2,4\n2\nErmek\n(2,3)\n0,1,2,3,4\n2\nAizhan\n(2,2)\n0,1,2,3,4"
    },
    "original": "Aizhan has a sequence of $$$N$$$ integers $$$S[0], S[1], \\ldots, S[N - 1]$$$. She is trying to sort this sequence in ascending order by swapping some pairs of elements. Her friend Ermek is also going to swap some pairs of elements— not necessarily in a helpful way.\nErmek and Aizhan are going to modify the sequence in a series of rounds. In each round, first Ermek makes a swap and then Aizhan makes another swap. More precisely, the person making a swap chooses two valid indices and swaps the elements at those indices. Note that the two indices do not have to be distinct. If they are equal, the current person swaps an element with itself, which does not change the sequence.\nAizhan knows that Ermek does not actually care about sorting the sequence $$$S$$$. She also knows the exact indices Ermek is going to choose. Ermek plans to take part in $$$M$$$ rounds of swapping. We number these rounds from $$$0$$$ to $$$M - 1$$$. For each $$$i$$$ between $$$0$$$ and $$$M - 1$$$ inclusive, Ermek will choose the indices $$$X[i]$$$ and $$$Y[i]$$$ in round $$$i$$$.\nAizhan wants to sort the sequence $$$S$$$. Before each round, if Aizhan sees that the sequence is already sorted in ascending order, she will terminate the entire process. Given the original sequence $$$S$$$ and the indices Ermek is going to choose, your task is to find a sequence of swaps, which Aizhan can use to sort the sequence $$$S$$$. In addition, in some subtasks you are required to find a sequence of swaps that is as short as possible. You may assume that it is possible to sort the sequence $$$S$$$ in $$$M$$$ or fewer rounds.\nNote that if Aizhan sees that the sequence $$$S$$$ is sorted after Ermek's swap, she can choose to swap two equal indices (e.g., 0 and 0). As a result the sequence $$$S$$$ Aizhan reaches her goal. Also note that if the initial sequence $$$S$$$ is also sorted after the entire round, so is already sorted, the minimal number of rounds needed to sort it is 0.\nYou are given the sequence $$$S$$$, the number $$$M$$$, and the sequences of indices $$$X$$$ and $$$Y$$$. Compute a sequence of swaps, which Aizhan can use to sort the sequence $$$S$$$. In subtasks and 5 and 6 the sequence of swaps you find has to be the shortest possible.\nYou need to implement the function\nfindSwapPairs\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[])\n— This function will be called by the grader exactly once.\n$$$N$$$: the length of the sequence $$$S$$$.\n$$$S$$$: an array of integers containing the initial sequence $$$S$$$.\n$$$M$$$: the number of swaps Ermek plans to make.\n$$$X, Y$$$: arrays of integers of length $$$M$$$. For $$$0 \\le i \\le M - 1$$$, in round $$$i$$$ Ermek plans to swap numbers at indices $$$X[i]$$$ and $$$Y[i]$$$.\n$$$P, Q$$$: arrays of integers. Use these arrays to report one possible sequence of swaps Aizhan can make to sort the sequence $$$S$$$. Denote by $$$R$$$ the length of the sequence of swaps that your program has found. For each $$$i$$$ between $$$0$$$ and $$$R - 1$$$ inclusive, the indices Aizhan should choose in round $$$i$$$ should be stored into $$$P[i]$$$ and $$$Q[i]$$$. You may assume that the arrays $$$P$$$ and $$$Q$$$ have already been allocated to $$$M$$$ elements each.\nThis function should return the value of $$$R$$$(defined above).\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$N$$$\nline 2: $$$S[0]\\ \\ldots\\ S[N - 1]$$$\nline 3: $$$M$$$\nlines $$$4, \\ldots, M + 3$$$: $$$X[i]\\ Y[i]$$$\nOutput\nThe sample grader prints the following output:\nline 1: The return value $$$R$$$ of\nfindSwapPairs\nlines $$$2 + i (0 \\le i < R)$$$: $$$P[i]\\ Q[i]$$$\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\nExtra constraints on $$$X$$$ and $$$Y$$$\nRequirement on R\n1\n8\n$$$1 \\le N \\le 5$$$\n$$$M = N^2$$$\n$$$X[i] = Y[i] = 0$$$ for all $$$i$$$\n$$$R \\le M$$$\n2\n12\n$$$1 \\le N \\le 100$$$\n$$$M = 30N$$$\n$$$X[i] = Y[i] = 0$$$ for all $$$i$$$\n$$$R \\le M$$$\n3\n16\n$$$1 \\le N \\le 100$$$\n$$$M = 30N$$$\n$$$X[i] = 0, Y[i] = 1$$$ for all $$$i$$$\n$$$R \\le M$$$\n4\n18\n$$$1 \\le N \\le 500$$$\n$$$M = 30N$$$\n—\n$$$R \\le M$$$\n5\n20\n$$$6 \\le N \\le 2000$$$\n$$$M = 3N$$$\n—\nminimum possible\n6\n26\n$$$6 \\le N \\le 200\\,000$$$\n$$$M = 3N$$$\n—\nminimum possible\nYou may assume that there exists a solution that requires $$$M$$$ or fewer rounds.\nNote\nExample 1\nSuppose that:\nThe initial sequence is $$$S=4,3,2,1,0$$$.\nErmek is willing to make $$$M=6$$$ swaps.\nThe sequences $$$X$$$ and $$$Y$$$ that describe the indices Ermek is going to choose are $$$X=0,1,2,3,0,1$$$ and $$$Y=1,2,3,4,1,2$$$. In other words, the pairs of indices that Ermek plans to choose are (0, 1), (1, 2), (2, 3), (3, 4), (0, 1), and (1, 2).\nIn this setting Aizhan can sort the sequence $$$S$$$ into the order $$$0,1,2,3,4$$$ in three rounds. She can do so by choosing the indices (0, 4), (1, 3), and then (3, 4).\nThe following table shows how Ermek and Aizhan modify the sequence.\nRound\nPlayer\nPair of swapped indices\nSequence\nbeginning\n4,3,2,1,0\n0\nErmek\n(0,1)\n3,4,2,1,0\n0\nAizhan\n(0,4)\n0,4,2,1,3\n1\nErmek\n(1,2)\n0,2,4,1,3\n1\nAizhan\n(1,3)\n0,1,4,2,3\n2\nErmek\n(2,3)\n0,1,2,4,3\n2\nAizhan\n(3,4)\n0,1,2,3,4\nExample 2\nSuppose that:\nThe initial sequence is $$$S=3,0,4,2,1$$$.\nErmek is willing to make $$$M=5$$$ swaps.\nThe pairs of indices that Ermek plans to choose are (1, 1), (4, 0), (2, 3), (1, 4), and (0, 4).\nIn this setting Aizhan can sort the sequence $$$S$$$ in three rounds, for example by choosing the pairs of indices (1, 4), (4, 2), and then (2, 2). The following table shows how Ermek and Aizhan modify the sequence.\nRound\nPlayer\nPair of swapped indices\nSequence\nbeginning\n3,0,4,2,1\n0\nErmek\n(1,1)\n3,0,4,2,1\n0\nAizhan\n(1,4)\n3,1,4,2,0\n1\nErmek\n(4,0)\n0,1,4,2,3\n1\nAizhan\n(4,2)\n0,1,3,2,4\n2\nErmek\n(2,3)\n0,1,2,3,4\n2\nAizhan\n(2,2)\n0,1,2,3,4",
    "_meta": {
      "index": 10,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/E",
      "uuid": "ps_76b2348fc7a54f704cd3253504c270fa090cea68"
    }
  },
  {
    "planning_view": {
      "title": "D. Hieroglyphs",
      "task": "Find universal common subsequence of A and B or return [-1] if none exists",
      "given": [
        "Sequence A of N non-negative integers",
        "Sequence B of M non-negative integers",
        "Universal common subsequence must contain all common subsequences"
      ],
      "goal": "Return the universal common subsequence of A and B, or [-1] if none exists",
      "key_rules": [
        "Universal common subsequence must contain all common subsequences as subsequences",
        "Any two sequences have at most one universal common subsequence",
        "Empty sequence [] is valid common subsequence"
      ],
      "target": {
        "1": {
          "points": 3,
          "req": "N=M; A and B contain distinct integers 0 to N-1"
        },
        "2": {
          "points": 15,
          "req": "For any k, count(k in A) + count(k in B) ≤ 3"
        },
        "3": {
          "points": 10,
          "req": "All elements of A and B are ≤ 1"
        },
        "4": {
          "points": 16,
          "req": "Universal common subsequence exists"
        },
        "5": {
          "points": 14,
          "req": "N ≤ 3000; M ≤ 3000"
        },
        "6": {
          "points": 42,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Hieroglyphs",
      "contest": "IOI 2024 day 2",
      "one_line": "Find universal common subsequence of A and B or return [-1] if none exists",
      "given": [
        "Sequence A of N non-negative integers",
        "Sequence B of M non-negative integers",
        "Universal common subsequence must contain all common subsequences"
      ],
      "goal": "Return the universal common subsequence of A and B, or [-1] if none exists",
      "mechanism": "A sequence U is universal if it's a common subsequence of A and B, and every common subsequence of A and B is also a subsequence of U",
      "success_condition": "Return the correct universal common subsequence or [-1] if no such sequence exists",
      "constraints": {
        "critical": [
          "Universal common subsequence must contain all common subsequences as subsequences",
          "Any two sequences have at most one universal common subsequence",
          "Empty sequence [] is valid common subsequence"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "N=M; A and B contain distinct integers 0 to N-1"
          },
          "2": {
            "points": 15,
            "req": "For any k, count(k in A) + count(k in B) ≤ 3"
          },
          "3": {
            "points": 10,
            "req": "All elements of A and B are ≤ 1"
          },
          "4": {
            "points": 16,
            "req": "Universal common subsequence exists"
          },
          "5": {
            "points": 14,
            "req": "N ≤ 3000; M ≤ 3000"
          },
          "6": {
            "points": 42,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Hieroglyphs",
        "contest": "IOI 2024 day 2",
        "one_line": "Find universal common subsequence of A and B or return [-1] if none exists"
      },
      "problem": {
        "given": [
          "Sequence A of N non-negative integers",
          "Sequence B of M non-negative integers",
          "Universal common subsequence must contain all common subsequences"
        ],
        "goal": "Return the universal common subsequence of A and B, or [-1] if none exists",
        "mechanism": "A sequence U is universal if it's a common subsequence of A and B, and every common subsequence of A and B is also a subsequence of U",
        "success_condition": "Return the correct universal common subsequence or [-1] if no such sequence exists"
      },
      "constraints": {
        "critical": [
          "Universal common subsequence must contain all common subsequences as subsequences",
          "Any two sequences have at most one universal common subsequence",
          "Empty sequence [] is valid common subsequence"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "N=M; A and B contain distinct integers 0 to N-1"
          },
          "2": {
            "points": 15,
            "req": "For any k, count(k in A) + count(k in B) ≤ 3"
          },
          "3": {
            "points": 10,
            "req": "All elements of A and B are ≤ 1"
          },
          "4": {
            "points": 16,
            "req": "Universal common subsequence exists"
          },
          "5": {
            "points": 14,
            "req": "N ≤ 3000; M ≤ 3000"
          },
          "6": {
            "points": 42,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "std::vector<int> ucs(std::vector<int> A, std::vector<int> B)",
        "available_api": {
          "ucs": {
            "signature": "std::vector<int> ucs(std::vector<int> A, std::vector<int> B)",
            "params": "A: sequence of length N (0 ≤ A[i] ≤ 200,000), B: sequence of length M (0 ≤ B[j] ≤ 200,000)",
            "returns": "Universal common subsequence as vector, or [-1] if none exists",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Procedure called exactly once per test case",
          "Return [-1] as vector with single element -1",
          "Use std::vector<int> for input and output"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "6 5\n0 0 1 0 1 2\n2 0 1 0 2",
          "output": "4\n0 1 0 2"
        }
      ],
      "original_statement": "A team of researchers is studying the similarities between sequences of hieroglyphs. They represent each hieroglyph with a non-negative integer. To perform their study, they use the following concepts about sequences.\nFor a fixed sequence $$$A$$$, a sequence $$$S$$$ is called a\nsubsequence\nof $$$A$$$ if and only if $$$S$$$ can be obtained by removing some elements (possibly none) from $$$A$$$.\nThe table below shows some examples of subsequences of a sequence $$$A = [3, 2, 1, 2]$$$.\nSubsequence\nHow it can be obtained from $$$A$$$\n$$$[3, 2, 1, 2]$$$\nNo elements are removed.\n$$$[2, 1, 2]$$$\n[\n3\n, 2, 1, 2]\n$$$[3, 2, 2]$$$\n[3, 2,\n1\n, 2]\n$$$[3, 2]$$$\n[3,\n2\n,\n1\n, 2] or [3, 2,\n1\n,\n2\n]\n$$$[3]$$$\n[3,\n2\n,\n1\n,\n2\n]\n$$$[ ] $$$\n[\n3\n,\n2\n,\n1\n,\n2\n]\nOn the other hand, $$$[3, 3]$$$ or $$$[1, 3]$$$ are not subsequences of $$$A$$$.\nConsider two sequences of hieroglyphs, $$$A$$$ and $$$B$$$. A sequence $$$S$$$ is called a\ncommon subsequence\nof $$$A$$$ and $$$B$$$ if and only if $$$S$$$ is a subsequence of both $$$A$$$ and $$$B$$$. Moreover, we say that a sequence $$$U$$$ is a\nuniversal common subsequence\nof $$$A$$$ and $$$B$$$ if and only if the following two conditions are met:\n$$$U$$$ is a common subsequence of $$$A$$$ and $$$B$$$.\nEvery common subsequence of $$$A$$$ and $$$B$$$ is also a subsequence of $$$U$$$.\nIt can be shown that any two sequences $$$A$$$ and $$$B$$$ have at most one universal common subsequence.\nThe researchers have found two sequences of hieroglyphs $$$A$$$ and $$$B$$$. Sequence $$$A$$$ consists of $$$N$$$ hieroglyphs and sequence $$$B$$$ consists of $$$M$$$ hieroglyphs. Help the researchers compute a universal common subsequence of sequences $$$A$$$ and $$$B$$$, or determine that such a sequence does not exist.\nImplementation details\nYou should implement the following procedure.\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B)\n$$$A$$$: array of length $$$N$$$ describing the first sequence.\n$$$B$$$: array of length $$$M$$$ describing the second sequence.\nIf there exists a universal common subsequence of $$$A$$$ and $$$B$$$, the procedure should return an array containing this sequence. Otherwise, the procedure should return $$$[-1]$$$ (an array of length $$$1$$$, whose only element is $$$-1$$$).\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ $$$M$$$ ($$$1 \\leq N \\leq 100\\,000$$$, $$$1 \\leq M \\leq 100\\,000$$$)\nline $$$2$$$: $$$A[0]\\; A[1]\\ldots A[N-1]$$$ ($$$0 \\leq A[i] \\leq 200\\,000$$$)\nline $$$3$$$: $$$B[0]\\; B[1]\\ldots B[M-1]$$$ ($$$0 \\leq B[j] \\leq 200\\,000$$$)\nOutput\nThe sample grader prints in the following format:\nline $$$1$$$: $$$T$$$\nline $$$2$$$: $$$R[0]\\; R[1]\\ldots R[T-1]$$$\nHere, $$$R$$$ is the array returned by\nucs\nand $$$T$$$ is its length.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$N = M$$$; each of $$$A$$$ and $$$B$$$ consists of $$$N$$$\ndistinct\nintegers between $$$0$$$ and $$$N-1$$$ (inclusive)\n2\n15\nFor any integer $$$k$$$, (the number of elements of $$$A$$$ equal to $$$k$$$) plus (the number of elements of $$$B$$$ equal to $$$k$$$) is at most $$$3$$$.\n3\n10\n$$$A[i] \\leq 1$$$ for each $$$i$$$ such that $$$0 \\leq i < N$$$; $$$B[j] \\leq 1$$$ for each $$$j$$$ such that $$$0 \\leq j < M$$$\n4\n16\nThere exists a universal common subsequence of $$$A$$$ and $$$B$$$.\n5\n14\n$$$N \\leq 3000$$$; $$$M \\leq 3000$$$\n6\n42\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call.\nucs([0, 0, 1, 0, 1, 2], [2, 0, 1, 0, 2])\nHere, the common subsequences of $$$A$$$ and $$$B$$$ are the following: $$$[\\ ]$$$, $$$[0]$$$, $$$[1]$$$, $$$[2]$$$, $$$[0, 0]$$$, $$$[0, 1]$$$, $$$[0, 2]$$$, $$$[1, 0]$$$, $$$[1, 2]$$$, $$$[0, 0, 2]$$$, $$$[0, 1, 0]$$$, $$$[0, 1, 2]$$$, $$$[1, 0, 2]$$$ and $$$[0, 1, 0, 2]$$$.\nSince $$$[0, 1, 0, 2]$$$ is a common subsequence of $$$A$$$ and $$$B$$$, and all common subsequences of $$$A$$$ and $$$B$$$ are subsequences of $$$[0, 1, 0, 2]$$$, the procedure should return $$$[0, 1, 0, 2]$$$.\nExample 2\nConsider the following call.\nucs([0, 0, 2], [1, 1])\nHere, the only common subsequence of $$$A$$$ and $$$B$$$ is the empty sequence $$$[\\ ]$$$. It follows that the procedure should return an empty array $$$[\\ ]$$$.\nExample 3\nConsider the following call.\nucs([0, 1, 0], [1, 0, 1])\nHere, the common subsequences of $$$A$$$ and $$$B$$$ are $$$[\\ ], [0], [1], [0, 1]$$$ and $$$[1, 0]$$$. It can be shown that a universal common subsequence does not exist. Therefore, the procedure should return $$$[-1]$$$."
    },
    "original": "A team of researchers is studying the similarities between sequences of hieroglyphs. They represent each hieroglyph with a non-negative integer. To perform their study, they use the following concepts about sequences.\nFor a fixed sequence $$$A$$$, a sequence $$$S$$$ is called a\nsubsequence\nof $$$A$$$ if and only if $$$S$$$ can be obtained by removing some elements (possibly none) from $$$A$$$.\nThe table below shows some examples of subsequences of a sequence $$$A = [3, 2, 1, 2]$$$.\nSubsequence\nHow it can be obtained from $$$A$$$\n$$$[3, 2, 1, 2]$$$\nNo elements are removed.\n$$$[2, 1, 2]$$$\n[\n3\n, 2, 1, 2]\n$$$[3, 2, 2]$$$\n[3, 2,\n1\n, 2]\n$$$[3, 2]$$$\n[3,\n2\n,\n1\n, 2] or [3, 2,\n1\n,\n2\n]\n$$$[3]$$$\n[3,\n2\n,\n1\n,\n2\n]\n$$$[ ] $$$\n[\n3\n,\n2\n,\n1\n,\n2\n]\nOn the other hand, $$$[3, 3]$$$ or $$$[1, 3]$$$ are not subsequences of $$$A$$$.\nConsider two sequences of hieroglyphs, $$$A$$$ and $$$B$$$. A sequence $$$S$$$ is called a\ncommon subsequence\nof $$$A$$$ and $$$B$$$ if and only if $$$S$$$ is a subsequence of both $$$A$$$ and $$$B$$$. Moreover, we say that a sequence $$$U$$$ is a\nuniversal common subsequence\nof $$$A$$$ and $$$B$$$ if and only if the following two conditions are met:\n$$$U$$$ is a common subsequence of $$$A$$$ and $$$B$$$.\nEvery common subsequence of $$$A$$$ and $$$B$$$ is also a subsequence of $$$U$$$.\nIt can be shown that any two sequences $$$A$$$ and $$$B$$$ have at most one universal common subsequence.\nThe researchers have found two sequences of hieroglyphs $$$A$$$ and $$$B$$$. Sequence $$$A$$$ consists of $$$N$$$ hieroglyphs and sequence $$$B$$$ consists of $$$M$$$ hieroglyphs. Help the researchers compute a universal common subsequence of sequences $$$A$$$ and $$$B$$$, or determine that such a sequence does not exist.\nImplementation details\nYou should implement the following procedure.\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B)\n$$$A$$$: array of length $$$N$$$ describing the first sequence.\n$$$B$$$: array of length $$$M$$$ describing the second sequence.\nIf there exists a universal common subsequence of $$$A$$$ and $$$B$$$, the procedure should return an array containing this sequence. Otherwise, the procedure should return $$$[-1]$$$ (an array of length $$$1$$$, whose only element is $$$-1$$$).\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ $$$M$$$ ($$$1 \\leq N \\leq 100\\,000$$$, $$$1 \\leq M \\leq 100\\,000$$$)\nline $$$2$$$: $$$A[0]\\; A[1]\\ldots A[N-1]$$$ ($$$0 \\leq A[i] \\leq 200\\,000$$$)\nline $$$3$$$: $$$B[0]\\; B[1]\\ldots B[M-1]$$$ ($$$0 \\leq B[j] \\leq 200\\,000$$$)\nOutput\nThe sample grader prints in the following format:\nline $$$1$$$: $$$T$$$\nline $$$2$$$: $$$R[0]\\; R[1]\\ldots R[T-1]$$$\nHere, $$$R$$$ is the array returned by\nucs\nand $$$T$$$ is its length.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$N = M$$$; each of $$$A$$$ and $$$B$$$ consists of $$$N$$$\ndistinct\nintegers between $$$0$$$ and $$$N-1$$$ (inclusive)\n2\n15\nFor any integer $$$k$$$, (the number of elements of $$$A$$$ equal to $$$k$$$) plus (the number of elements of $$$B$$$ equal to $$$k$$$) is at most $$$3$$$.\n3\n10\n$$$A[i] \\leq 1$$$ for each $$$i$$$ such that $$$0 \\leq i < N$$$; $$$B[j] \\leq 1$$$ for each $$$j$$$ such that $$$0 \\leq j < M$$$\n4\n16\nThere exists a universal common subsequence of $$$A$$$ and $$$B$$$.\n5\n14\n$$$N \\leq 3000$$$; $$$M \\leq 3000$$$\n6\n42\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call.\nucs([0, 0, 1, 0, 1, 2], [2, 0, 1, 0, 2])\nHere, the common subsequences of $$$A$$$ and $$$B$$$ are the following: $$$[\\ ]$$$, $$$[0]$$$, $$$[1]$$$, $$$[2]$$$, $$$[0, 0]$$$, $$$[0, 1]$$$, $$$[0, 2]$$$, $$$[1, 0]$$$, $$$[1, 2]$$$, $$$[0, 0, 2]$$$, $$$[0, 1, 0]$$$, $$$[0, 1, 2]$$$, $$$[1, 0, 2]$$$ and $$$[0, 1, 0, 2]$$$.\nSince $$$[0, 1, 0, 2]$$$ is a common subsequence of $$$A$$$ and $$$B$$$, and all common subsequences of $$$A$$$ and $$$B$$$ are subsequences of $$$[0, 1, 0, 2]$$$, the procedure should return $$$[0, 1, 0, 2]$$$.\nExample 2\nConsider the following call.\nucs([0, 0, 2], [1, 1])\nHere, the only common subsequence of $$$A$$$ and $$$B$$$ is the empty sequence $$$[\\ ]$$$. It follows that the procedure should return an empty array $$$[\\ ]$$$.\nExample 3\nConsider the following call.\nucs([0, 1, 0], [1, 0, 1])\nHere, the common subsequences of $$$A$$$ and $$$B$$$ are $$$[\\ ], [0], [1], [0, 1]$$$ and $$$[1, 0]$$$. It can be shown that a universal common subsequence does not exist. Therefore, the procedure should return $$$[-1]$$$.",
    "_meta": {
      "index": 11,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/D",
      "uuid": "ps_e64ca123ac7cdb64558cf8f4e487cc2542b66abd"
    }
  },
  {
    "planning_view": {
      "title": "C. Fountain Parks",
      "task": "Connect n fountains via roads with benches at odd coordinates",
      "given": [
        "n fountains at distinct even-coordinate points",
        "Each road is horizontal/vertical segment of length 2",
        "Roads must connect all fountains",
        "Each road needs exactly one bench at odd coordinates"
      ],
      "goal": "Determine if roads+benches construction is possible and provide solution",
      "key_rules": [
        "Roads must be horizontal/vertical segments of length exactly 2",
        "Bench coordinates (a,b) must be odd integers",
        "Bench must be adjacent to both endpoints of its road",
        "All benches must have distinct locations",
        "Road network must be connected"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "All fountains have x=2"
        },
        "2": {
          "points": 10,
          "req": "All fountains have 2≤x≤4"
        },
        "3": {
          "points": 15,
          "req": "All fountains have 2≤x≤6"
        },
        "4": {
          "points": 20,
          "req": "At most one possible road construction"
        },
        "5": {
          "points": 20,
          "req": "No 2×2 square of fountains"
        },
        "6": {
          "points": 30,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Fountain Parks",
      "contest": "IOI 2021 day 1",
      "one_line": "Connect n fountains via roads with benches at odd coordinates",
      "given": [
        "n fountains at distinct even-coordinate points",
        "Each road is horizontal/vertical segment of length 2",
        "Roads must connect all fountains",
        "Each road needs exactly one bench at odd coordinates"
      ],
      "goal": "Determine if roads+benches construction is possible and provide solution",
      "mechanism": "Connect fountains with roads; assign benches to roads where bench coordinates are odd and adjacent to road endpoints",
      "success_condition": "All fountains connected via roads; each road has unique bench at valid odd coordinate",
      "constraints": {
        "critical": [
          "Roads must be horizontal/vertical segments of length exactly 2",
          "Bench coordinates (a,b) must be odd integers",
          "Bench must be adjacent to both endpoints of its road",
          "All benches must have distinct locations",
          "Road network must be connected"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "All fountains have x=2"
          },
          "2": {
            "points": 10,
            "req": "All fountains have 2≤x≤4"
          },
          "3": {
            "points": 15,
            "req": "All fountains have 2≤x≤6"
          },
          "4": {
            "points": 20,
            "req": "At most one possible road construction"
          },
          "5": {
            "points": 20,
            "req": "No 2×2 square of fountains"
          },
          "6": {
            "points": 30,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Fountain Parks",
        "contest": "IOI 2021 day 1",
        "one_line": "Connect n fountains via roads with benches at odd coordinates"
      },
      "problem": {
        "given": [
          "n fountains at distinct even-coordinate points",
          "Each road is horizontal/vertical segment of length 2",
          "Roads must connect all fountains",
          "Each road needs exactly one bench at odd coordinates"
        ],
        "goal": "Determine if roads+benches construction is possible and provide solution",
        "mechanism": "Connect fountains with roads; assign benches to roads where bench coordinates are odd and adjacent to road endpoints",
        "success_condition": "All fountains connected via roads; each road has unique bench at valid odd coordinate"
      },
      "constraints": {
        "critical": [
          "Roads must be horizontal/vertical segments of length exactly 2",
          "Bench coordinates (a,b) must be odd integers",
          "Bench must be adjacent to both endpoints of its road",
          "All benches must have distinct locations",
          "Road network must be connected"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "All fountains have x=2"
          },
          "2": {
            "points": 10,
            "req": "All fountains have 2≤x≤4"
          },
          "3": {
            "points": 15,
            "req": "All fountains have 2≤x≤6"
          },
          "4": {
            "points": 20,
            "req": "At most one possible road construction"
          },
          "5": {
            "points": 20,
            "req": "No 2×2 square of fountains"
          },
          "6": {
            "points": 30,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int construct_roads(int[] x, int[] y)",
        "available_api": {
          "build": {
            "signature": "void build(int[] u, int[] v, int[] a, int[] b)",
            "params": "u,v: fountain indices for each road; a,b: bench coordinates for each road",
            "returns": "void",
            "side_effect": "Submits solution to grader"
          }
        },
        "requirements": [
          "Return 1 and call build() if solution exists",
          "Return 0 without calling build() if no solution",
          "Fountain indices are 0-indexed",
          "Called exactly once"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "5\n4 4\n4 6\n6 4\n4 2\n2 4",
          "output": "OK\n1\n4\n0 2 5 5\n0 1 3 5\n3 0 5 3\n4 0 3 3"
        }
      ],
      "original_statement": "In a nearby park, there are $$$n$$$\nfountains\n, labeled from $$$0$$$ to $$$n-1$$$. We model the fountains as points on a two-dimensional plane. Namely, fountain $$$i$$$ ($$$0\\leq i\\leq n-1$$$) is a point $$$(x[i],y[i])$$$ where $$$x[i]$$$ and $$$y[i]$$$ are\neven integers\n. The locations of the fountains are all distinct.\nTimothy the architect has been hired to plan the construction of some\nroads\nand the placement of one\nbench\nper road. A road is a\nhorizontal\nor\nvertical\nline segment of length $$$2$$$, whose endpoints are two distinct fountains. The roads should be constructed such that one can travel between any two fountains by moving along roads. Initially, there are no roads in the park.\nFor each road,\nexactly\none bench needs to be placed in the park and\nassigned to\n(i.e., face) that road. Each bench must be placed at some point $$$(a, b)$$$ such that $$$a$$$ and $$$b$$$ are\nodd integers\n. The locations of the benches must be all\ndistinct\n. A bench at $$$(a,b)$$$ can only be assigned to a road if\nboth\nof the road's endpoints are among $$$(a-1,b-1)$$$, $$$(a-1,b+1)$$$, $$$(a+1,b-1)$$$ and $$$(a+1,b+1)$$$. For example, the bench at $$$(3,3)$$$ can only be assigned to a road, which is one of the four line segments $$$(2,2)$$$— $$$(2,4)$$$, $$$(2,4)$$$— $$$(4,4)$$$, $$$(4,4)$$$— $$$(4,2)$$$, $$$(4,2)$$$— $$$(2,2)$$$.\nHelp Timothy determine if it is possible to construct roads, and place and assign benches satisfying all conditions given above, and if so, provide him with a feasible solution. If there are multiple feasible solutions that satisfy all conditions, you can report any of them.\nImplementation Details\nYou should implement the following procedure:\nint construct_roads(int[] x, int[] y)\n$$$x,y$$$: two arrays of length $$$n$$$. For each $$$i$$$ ($$$0\\leq i\\leq n-1$$$), fountain $$$i$$$ is a point $$$(x[i],y[i])$$$, where $$$x[i]$$$ and $$$y[i]$$$ are even integers.\nIf a construction is possible, this procedure should make exactly one call to\nbuild\n(see below) to report a solution, following which it should return $$$1$$$.\nOtherwise, the procedure should return $$$0$$$ without making any calls to\nbuild\n.\nThis procedure is called exactly once\nYour implementation can call the following procedure to provide a feasible construction of roads and a placement of benches:\nvoid build(int[] u, int[] v, int[] a, int[] b)\nLet $$$m$$$ be the total number of roads in the construction.\n$$$u,v$$$: two arrays of length $$$m$$$, representing the roads to be constructed. These roads are labeled from $$$0$$$ to $$$m-1$$$. For each $$$j$$$ ($$$0 \\leq j \\leq m-1$$$) road $$$j$$$ connects fountains $$$u[j]$$$ and $$$v[j]$$$. Each road must be a horizontal or vertical line segment of length $$$2$$$. Any two distinct roads can have at most one point in common (a fountain). Once the roads are constructed, it should be possible to travel between any two fountains by moving along roads.\n$$$a,b$$$: two arrays of length $$$m$$$, representing the benches. For each $$$j$$$ ($$$0 \\leq j \\leq m-1$$$), a bench is placed at $$$(a[j],b[j])$$$, and is assigned to road $$$j$$$. No two distinct benches can have the same location.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$ : $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$)\nline $$$2+i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$x[i]\\ y[i]$$$ ($$$2 \\leq x[i], y[i] \\leq 200\\,000$$$, $$$x[i]$$$ and $$$y[i]$$$— are even integers)\nNo two fountains have the same location.\nOutput\nThe output of the sample grader is in the following format:\nline $$$1$$$: the return value of\nconstruct_roads\nIf the return value of\nconstruct_roads\nis $$$1$$$ and\nbuild(u, v, a, b)\nis called, the grader then additionally prints:\nline $$$2$$$: $$$m$$$\nline $$$3+j$$$ ($$$0 \\leq i \\leq m - 1$$$): $$$u[j]\\ v[j]\\ a[j]\\ b[j]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$x[i] = 2$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n2\n10\n$$$2 \\leq x[i] \\leq 4$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n3\n15\n$$$2 \\leq x[i] \\leq 6$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n4\n20\nThere is at most one way of constructing the roads, such that one can travel between any two fountains by moving along roads.\n5\n20\nThere do not exist four fountains that form the corners of a $$$2 \\times 2$$$ square.\n6\n30\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nconstruct_roads([4, 4, 6, 4, 2], [4, 6, 4, 2, 4])\nThis means that there are $$$5$$$ fountains:\nfountain $$$0$$$ is located at $$$(4,4)$$$,\nfountain $$$1$$$ is located at $$$(4,6)$$$,\nfountain $$$2$$$ is located at $$$(6,4)$$$,\nfountain $$$3$$$ is located at $$$(4,2)$$$,\nfountain $$$4$$$ is located at $$$(2,4)$$$.\nIt is possible to construct the following $$$4$$$ roads, where each road connects two fountains, and place the corresponding benches:\nRoad label\nLabels of the fountains the road connects\nLocation of the assigned bench\n$$$0$$$\n$$$0,2$$$\n$$$(5,5)$$$\n$$$1$$$\n$$$0,1$$$\n$$$(3,5)$$$\n$$$2$$$\n$$$3,0$$$\n$$$(5,3)$$$\n$$$3$$$\n$$$4,0$$$\n$$$(3,3)$$$\nThis solution corresponds to the following diagram:\nTo report this solution,\nconstruct_roads\nshould make the following call:\nbuild([0, 0, 3, 4], [2, 1, 0, 0], [5, 3, 5, 3], [5, 5, 3, 3])\nIt should then return $$$1$$$.\nNote that in this case, there are multiple solutions that satisfy the requirements, all of which would be considered correct. For example, it is also correct to call\nbuild([1, 2, 3, 4], [0, 0, 0, 0], [5, 5, 3, 3], [5, 3, 3, 5])\nand then return $$$1$$$.\nExample 2\nConsider the following call:\nconstruct_roads([2, 4], [2, 6])\nFountain $$$0$$$ is located at $$$(2,2)$$$ and fountain $$$1$$$ is located at $$$(4,6)$$$. Since there is no way to construct roads that satisfy the requirements,\nconstruct_roads\nshould return $$$0$$$ without making any call to\nbuild\n."
    },
    "original": "In a nearby park, there are $$$n$$$\nfountains\n, labeled from $$$0$$$ to $$$n-1$$$. We model the fountains as points on a two-dimensional plane. Namely, fountain $$$i$$$ ($$$0\\leq i\\leq n-1$$$) is a point $$$(x[i],y[i])$$$ where $$$x[i]$$$ and $$$y[i]$$$ are\neven integers\n. The locations of the fountains are all distinct.\nTimothy the architect has been hired to plan the construction of some\nroads\nand the placement of one\nbench\nper road. A road is a\nhorizontal\nor\nvertical\nline segment of length $$$2$$$, whose endpoints are two distinct fountains. The roads should be constructed such that one can travel between any two fountains by moving along roads. Initially, there are no roads in the park.\nFor each road,\nexactly\none bench needs to be placed in the park and\nassigned to\n(i.e., face) that road. Each bench must be placed at some point $$$(a, b)$$$ such that $$$a$$$ and $$$b$$$ are\nodd integers\n. The locations of the benches must be all\ndistinct\n. A bench at $$$(a,b)$$$ can only be assigned to a road if\nboth\nof the road's endpoints are among $$$(a-1,b-1)$$$, $$$(a-1,b+1)$$$, $$$(a+1,b-1)$$$ and $$$(a+1,b+1)$$$. For example, the bench at $$$(3,3)$$$ can only be assigned to a road, which is one of the four line segments $$$(2,2)$$$— $$$(2,4)$$$, $$$(2,4)$$$— $$$(4,4)$$$, $$$(4,4)$$$— $$$(4,2)$$$, $$$(4,2)$$$— $$$(2,2)$$$.\nHelp Timothy determine if it is possible to construct roads, and place and assign benches satisfying all conditions given above, and if so, provide him with a feasible solution. If there are multiple feasible solutions that satisfy all conditions, you can report any of them.\nImplementation Details\nYou should implement the following procedure:\nint construct_roads(int[] x, int[] y)\n$$$x,y$$$: two arrays of length $$$n$$$. For each $$$i$$$ ($$$0\\leq i\\leq n-1$$$), fountain $$$i$$$ is a point $$$(x[i],y[i])$$$, where $$$x[i]$$$ and $$$y[i]$$$ are even integers.\nIf a construction is possible, this procedure should make exactly one call to\nbuild\n(see below) to report a solution, following which it should return $$$1$$$.\nOtherwise, the procedure should return $$$0$$$ without making any calls to\nbuild\n.\nThis procedure is called exactly once\nYour implementation can call the following procedure to provide a feasible construction of roads and a placement of benches:\nvoid build(int[] u, int[] v, int[] a, int[] b)\nLet $$$m$$$ be the total number of roads in the construction.\n$$$u,v$$$: two arrays of length $$$m$$$, representing the roads to be constructed. These roads are labeled from $$$0$$$ to $$$m-1$$$. For each $$$j$$$ ($$$0 \\leq j \\leq m-1$$$) road $$$j$$$ connects fountains $$$u[j]$$$ and $$$v[j]$$$. Each road must be a horizontal or vertical line segment of length $$$2$$$. Any two distinct roads can have at most one point in common (a fountain). Once the roads are constructed, it should be possible to travel between any two fountains by moving along roads.\n$$$a,b$$$: two arrays of length $$$m$$$, representing the benches. For each $$$j$$$ ($$$0 \\leq j \\leq m-1$$$), a bench is placed at $$$(a[j],b[j])$$$, and is assigned to road $$$j$$$. No two distinct benches can have the same location.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$ : $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$)\nline $$$2+i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$x[i]\\ y[i]$$$ ($$$2 \\leq x[i], y[i] \\leq 200\\,000$$$, $$$x[i]$$$ and $$$y[i]$$$— are even integers)\nNo two fountains have the same location.\nOutput\nThe output of the sample grader is in the following format:\nline $$$1$$$: the return value of\nconstruct_roads\nIf the return value of\nconstruct_roads\nis $$$1$$$ and\nbuild(u, v, a, b)\nis called, the grader then additionally prints:\nline $$$2$$$: $$$m$$$\nline $$$3+j$$$ ($$$0 \\leq i \\leq m - 1$$$): $$$u[j]\\ v[j]\\ a[j]\\ b[j]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$x[i] = 2$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n2\n10\n$$$2 \\leq x[i] \\leq 4$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n3\n15\n$$$2 \\leq x[i] \\leq 6$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n4\n20\nThere is at most one way of constructing the roads, such that one can travel between any two fountains by moving along roads.\n5\n20\nThere do not exist four fountains that form the corners of a $$$2 \\times 2$$$ square.\n6\n30\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nconstruct_roads([4, 4, 6, 4, 2], [4, 6, 4, 2, 4])\nThis means that there are $$$5$$$ fountains:\nfountain $$$0$$$ is located at $$$(4,4)$$$,\nfountain $$$1$$$ is located at $$$(4,6)$$$,\nfountain $$$2$$$ is located at $$$(6,4)$$$,\nfountain $$$3$$$ is located at $$$(4,2)$$$,\nfountain $$$4$$$ is located at $$$(2,4)$$$.\nIt is possible to construct the following $$$4$$$ roads, where each road connects two fountains, and place the corresponding benches:\nRoad label\nLabels of the fountains the road connects\nLocation of the assigned bench\n$$$0$$$\n$$$0,2$$$\n$$$(5,5)$$$\n$$$1$$$\n$$$0,1$$$\n$$$(3,5)$$$\n$$$2$$$\n$$$3,0$$$\n$$$(5,3)$$$\n$$$3$$$\n$$$4,0$$$\n$$$(3,3)$$$\nThis solution corresponds to the following diagram:\nTo report this solution,\nconstruct_roads\nshould make the following call:\nbuild([0, 0, 3, 4], [2, 1, 0, 0], [5, 3, 5, 3], [5, 5, 3, 3])\nIt should then return $$$1$$$.\nNote that in this case, there are multiple solutions that satisfy the requirements, all of which would be considered correct. For example, it is also correct to call\nbuild([1, 2, 3, 4], [0, 0, 0, 0], [5, 5, 3, 3], [5, 3, 3, 5])\nand then return $$$1$$$.\nExample 2\nConsider the following call:\nconstruct_roads([2, 4], [2, 6])\nFountain $$$0$$$ is located at $$$(2,2)$$$ and fountain $$$1$$$ is located at $$$(4,6)$$$. Since there is no way to construct roads that satisfy the requirements,\nconstruct_roads\nshould return $$$0$$$ without making any call to\nbuild\n.",
    "_meta": {
      "index": 12,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/C",
      "uuid": "ps_981d342b49301b49dec04947a2a706b198310002"
    }
  },
  {
    "planning_view": {
      "title": "D. The Big Prize",
      "task": "Find 1 diamond among n boxes using ≤5000 ask() queries",
      "given": [
        "n boxes (0 to n-1) with hidden prizes",
        "Exactly 1 diamond (type 1)",
        "v prize types in decreasing value order",
        "Cheaper prizes vastly outnumber expensive ones: k_t > k_{t-1}^2"
      ],
      "goal": "Identify the box containing the diamond",
      "key_rules": [
        "Grader may be adaptive but maintains consistency",
        "Prize distribution follows strict exponential growth pattern",
        "Cannot open boxes directly - only query comparisons"
      ],
      "target": {
        "1": {
          "points": 20,
          "req": "v=2 (only diamond and lollipops), ≤10000 queries"
        },
        "2": {
          "points": 80,
          "req": "Full problem, score depends on max queries used: 5000→80, 6000→70, >10000→0"
        }
      }
    },
    "algorithm_view": {
      "title": "D. The Big Prize",
      "contest": "IOI 2017 day 2",
      "one_line": "Find 1 diamond among n boxes using ≤5000 ask() queries",
      "given": [
        "n boxes (0 to n-1) with hidden prizes",
        "Exactly 1 diamond (type 1)",
        "v prize types in decreasing value order",
        "Cheaper prizes vastly outnumber expensive ones: k_t > k_{t-1}^2"
      ],
      "goal": "Identify the box containing the diamond",
      "mechanism": "Call ask(i) to get [left_count, right_count] of boxes with better prizes than box i",
      "success_condition": "Return the correct box index containing type 1 prize",
      "constraints": {
        "critical": [
          "Grader may be adaptive but maintains consistency",
          "Prize distribution follows strict exponential growth pattern",
          "Cannot open boxes directly - only query comparisons"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "v=2 (only diamond and lollipops), ≤10000 queries"
          },
          "2": {
            "points": 80,
            "req": "Full problem, score depends on max queries used: 5000→80, 6000→70, >10000→0"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. The Big Prize",
        "contest": "IOI 2017 day 2",
        "one_line": "Find 1 diamond among n boxes using ≤5000 ask() queries"
      },
      "problem": {
        "given": [
          "n boxes (0 to n-1) with hidden prizes",
          "Exactly 1 diamond (type 1)",
          "v prize types in decreasing value order",
          "Cheaper prizes vastly outnumber expensive ones: k_t > k_{t-1}^2"
        ],
        "goal": "Identify the box containing the diamond",
        "mechanism": "Call ask(i) to get [left_count, right_count] of boxes with better prizes than box i",
        "success_condition": "Return the correct box index containing type 1 prize"
      },
      "constraints": {
        "critical": [
          "Grader may be adaptive but maintains consistency",
          "Prize distribution follows strict exponential growth pattern",
          "Cannot open boxes directly - only query comparisons"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "v=2 (only diamond and lollipops), ≤10000 queries"
          },
          "2": {
            "points": 80,
            "req": "Full problem, score depends on max queries used: 5000→80, 6000→70, >10000→0"
          }
        }
      },
      "implementation": {
        "function_to_write": "int find_best(int n)",
        "available_api": {
          "ask": {
            "signature": "int[] ask(int i)",
            "params": "i: box index (0 to n-1)",
            "returns": "Array [a,b] where a=count of better prizes left of i, b=count of better prizes right of i",
            "side_effect": "None (grader may be adaptive)"
          }
        },
        "requirements": [
          "Return single integer: index of diamond box",
          "Box indices are 0-indexed",
          "Procedure called exactly once by grader"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "The Big Prize is a famous TV game show. You are the lucky contestant who has advanced to the final round. You are standing in front of a row of $$$n$$$ boxes, labeled $$$0$$$ through $$$n - 1$$$ from left to right. Each box contains a prize that cannot be seen until the box is opened. There are $$$v \\geq 2$$$ different\ntypes\nof prizes. The types are numbered from $$$1$$$ to $$$v$$$ in\ndecreasing\norder of value.\nThe prize of type $$$1$$$ is the most expensive one: a diamond. There is exactly one diamond in the boxes. The prize of type $$$v$$$ is the cheapest one: a lollipop. To make the game more exciting, the number of cheaper prizes is much larger than the number of more expensive ones. More specifically, for all $$$t$$$ such that $$$2 \\leq t \\leq v$$$ we know the following: if there are $$$k$$$ prizes of type $$$t - 1$$$, there are\nstrictly more\nthan $$$k^2$$$ prizes of type $$$t$$$.\nYour goal is to win the diamond. At the end of the game you will have to open a box and you will receive the prize it contains. Before having to choose the box to open you get to ask Rambod, the host of the game show, some questions. For each question, you choose some box $$$i$$$. As his answer, Rambod will give you an array $$$a$$$ containing two integers. Their meaning is as follows:\nAmong the boxes to the left of box $$$i$$$ there are exactly $$$a[0]$$$ boxes that contain a more expensive prize than the one in box $$$i$$$.\nAmong the boxes to the right of box $$$i$$$ there are exactly $$$a[1]$$$ boxes that contain a more expensive prize than the one in box $$$i$$$.\nFor instance, suppose that $$$n = 8$$$. For your question, you choose the box $$$i = 2$$$. As his response, Rambod tells you that $$$a = [1, 2]$$$. The meaning of this response is:\nExactly one of the boxes $$$0$$$ and $$$1$$$ contains a prize more expensive than the one in box $$$2$$$.\nExactly two of the boxes $$$3, 4, \\ldots, 7$$$ contain a prize more expensive than the one in box $$$2$$$.\nYour task is to find the box containing the diamond by asking a small number of questions.\nImplementation details\nYou should implement the following procedure:\nint find_best(int n)\nThis procedure is called exactly once by the grader.\n$$$n$$$: the number of boxes.\nThe procedure should return the label of the box which contains the diamond, i.e., the unique integer $$$d$$$ ($$$0 \\leq d \\leq n - 1$$$) such that box $$$d$$$ contains a prize of type $$$1$$$.\nThe above procedure can make calls to the following procedure:\nint[] ask(int i)\n$$$i$$$: label of the box that you choose to ask about. The value of $$$i$$$ must be between $$$0$$$ and $$$n - 1$$$, inclusive.\nThis procedure returns the array $$$a$$$ with 2 elements. Here, $$$a[0]$$$ is the number of more expensive prizes in the boxes to the left of box $$$i$$$ and $$$a[1]$$$ is the number of more expensive prizes in the boxes to the right of box $$$i$$$.\nInput\nThe sample grader is not adaptive. Instead, it just reads and uses a fixed array $$$p$$$ of prize types. For all $$$0 \\leq b \\leq n - 1$$$, the type of the prize in box $$$b$$$ is given as $$$p[b]$$$. The sample grader expects input in the following format:\nline 1: $$$n$$$ ($$$3 \\leq n \\leq 200\\,000$$$)\nline 2: $$$p[0], p[1], \\ldots, p[n - 1]$$$\nThe type of the prize in each box is between $$$1$$$ and $$$v$$$, inclusive.\nThere is exactly one prize of type $$$1$$$.\nFor all $$$2 \\le t \\le v$$$, if there are $$$k$$$ prizes of type $$$t - 1$$$, there are\nstrictly\nmore than $$$k ^ 2$$$ prizes of type $$$t$$$.\nOutput\nThe sample grader prints a single line containing the return value of\nfind_best\nand the number of calls to the procedure\nask\n.\nScoring\nIn some test cases the behavior of the grader is adaptive. This means that in these test cases the grader does not have a fixed sequence of prizes. Instead, the answers given by the grader may depend on the questions asked by your solution. It is guaranteed that the grader answers in such a way that after each answer there is at least one sequence of prizes consistent with all the answers given so far.\nSubtask\nPoints\nAdditional Input Constraints\n1\n20\nThere is exactly 1 diamond and $$$n - 1$$$ lollipops (hence, $$$v = 2$$$). You can call the procedure\nask\nat most $$$10\\,000$$$ times\n2\n80\nNo additional constraints\nIn subtask 2 you can obtain a partial score. Let $$$q$$$ be the maximum number of calls to the procedure\nask\namong all test cases in this subtask. Then, your score for this subtask is calculated according to the following table:\nQuestions\nScore\n$$$10\\,000 \\textless q$$$\n$$$0$$$ (reported in CMS as 'Wrong Answer')\n$$$6000 \\textless q \\leq 10\\,000$$$\n$$$70$$$\n$$$5000 \\textless q \\leq 6000$$$\n$$$80 - (q-5000)/100$$$\n$$$q \\leq 5000$$$\n$$$80$$$\nNote\nThe grader makes the following procedure call:\nfind_best(8)\nThere are $$$n = 8$$$ boxes. Suppose the prize types are $$$[3,2,3,1,3,3,2,3]$$$. All possible calls to the procedure 'ask' and the corresponding return values are listed below.\n'ask(0)' returns $$$[0, 3]$$$\n'ask(1)' returns $$$[0, 1]$$$\n'ask(2)' returns $$$[1, 2]$$$\n'ask(3)' returns $$$[0, 0]$$$\n'ask(4)' returns $$$[2, 1]$$$\n'ask(5)' returns $$$[2, 1]$$$\n'ask(6)' returns $$$[1, 0]$$$\n'ask(7)' returns $$$[3, 0]$$$\nIn this example, the diamond is in box $$$3$$$. So the procedure\nfind_best\nshould return $$$3$$$.\nThe above figure illustrates this example. The upper part shows the types of the prizes in each box. The lower part illustrates the query\nask(2)\n. The marked boxes contain more expensive prizes than the one in box $$$2$$$."
    },
    "original": "The Big Prize is a famous TV game show. You are the lucky contestant who has advanced to the final round. You are standing in front of a row of $$$n$$$ boxes, labeled $$$0$$$ through $$$n - 1$$$ from left to right. Each box contains a prize that cannot be seen until the box is opened. There are $$$v \\geq 2$$$ different\ntypes\nof prizes. The types are numbered from $$$1$$$ to $$$v$$$ in\ndecreasing\norder of value.\nThe prize of type $$$1$$$ is the most expensive one: a diamond. There is exactly one diamond in the boxes. The prize of type $$$v$$$ is the cheapest one: a lollipop. To make the game more exciting, the number of cheaper prizes is much larger than the number of more expensive ones. More specifically, for all $$$t$$$ such that $$$2 \\leq t \\leq v$$$ we know the following: if there are $$$k$$$ prizes of type $$$t - 1$$$, there are\nstrictly more\nthan $$$k^2$$$ prizes of type $$$t$$$.\nYour goal is to win the diamond. At the end of the game you will have to open a box and you will receive the prize it contains. Before having to choose the box to open you get to ask Rambod, the host of the game show, some questions. For each question, you choose some box $$$i$$$. As his answer, Rambod will give you an array $$$a$$$ containing two integers. Their meaning is as follows:\nAmong the boxes to the left of box $$$i$$$ there are exactly $$$a[0]$$$ boxes that contain a more expensive prize than the one in box $$$i$$$.\nAmong the boxes to the right of box $$$i$$$ there are exactly $$$a[1]$$$ boxes that contain a more expensive prize than the one in box $$$i$$$.\nFor instance, suppose that $$$n = 8$$$. For your question, you choose the box $$$i = 2$$$. As his response, Rambod tells you that $$$a = [1, 2]$$$. The meaning of this response is:\nExactly one of the boxes $$$0$$$ and $$$1$$$ contains a prize more expensive than the one in box $$$2$$$.\nExactly two of the boxes $$$3, 4, \\ldots, 7$$$ contain a prize more expensive than the one in box $$$2$$$.\nYour task is to find the box containing the diamond by asking a small number of questions.\nImplementation details\nYou should implement the following procedure:\nint find_best(int n)\nThis procedure is called exactly once by the grader.\n$$$n$$$: the number of boxes.\nThe procedure should return the label of the box which contains the diamond, i.e., the unique integer $$$d$$$ ($$$0 \\leq d \\leq n - 1$$$) such that box $$$d$$$ contains a prize of type $$$1$$$.\nThe above procedure can make calls to the following procedure:\nint[] ask(int i)\n$$$i$$$: label of the box that you choose to ask about. The value of $$$i$$$ must be between $$$0$$$ and $$$n - 1$$$, inclusive.\nThis procedure returns the array $$$a$$$ with 2 elements. Here, $$$a[0]$$$ is the number of more expensive prizes in the boxes to the left of box $$$i$$$ and $$$a[1]$$$ is the number of more expensive prizes in the boxes to the right of box $$$i$$$.\nInput\nThe sample grader is not adaptive. Instead, it just reads and uses a fixed array $$$p$$$ of prize types. For all $$$0 \\leq b \\leq n - 1$$$, the type of the prize in box $$$b$$$ is given as $$$p[b]$$$. The sample grader expects input in the following format:\nline 1: $$$n$$$ ($$$3 \\leq n \\leq 200\\,000$$$)\nline 2: $$$p[0], p[1], \\ldots, p[n - 1]$$$\nThe type of the prize in each box is between $$$1$$$ and $$$v$$$, inclusive.\nThere is exactly one prize of type $$$1$$$.\nFor all $$$2 \\le t \\le v$$$, if there are $$$k$$$ prizes of type $$$t - 1$$$, there are\nstrictly\nmore than $$$k ^ 2$$$ prizes of type $$$t$$$.\nOutput\nThe sample grader prints a single line containing the return value of\nfind_best\nand the number of calls to the procedure\nask\n.\nScoring\nIn some test cases the behavior of the grader is adaptive. This means that in these test cases the grader does not have a fixed sequence of prizes. Instead, the answers given by the grader may depend on the questions asked by your solution. It is guaranteed that the grader answers in such a way that after each answer there is at least one sequence of prizes consistent with all the answers given so far.\nSubtask\nPoints\nAdditional Input Constraints\n1\n20\nThere is exactly 1 diamond and $$$n - 1$$$ lollipops (hence, $$$v = 2$$$). You can call the procedure\nask\nat most $$$10\\,000$$$ times\n2\n80\nNo additional constraints\nIn subtask 2 you can obtain a partial score. Let $$$q$$$ be the maximum number of calls to the procedure\nask\namong all test cases in this subtask. Then, your score for this subtask is calculated according to the following table:\nQuestions\nScore\n$$$10\\,000 \\textless q$$$\n$$$0$$$ (reported in CMS as 'Wrong Answer')\n$$$6000 \\textless q \\leq 10\\,000$$$\n$$$70$$$\n$$$5000 \\textless q \\leq 6000$$$\n$$$80 - (q-5000)/100$$$\n$$$q \\leq 5000$$$\n$$$80$$$\nNote\nThe grader makes the following procedure call:\nfind_best(8)\nThere are $$$n = 8$$$ boxes. Suppose the prize types are $$$[3,2,3,1,3,3,2,3]$$$. All possible calls to the procedure 'ask' and the corresponding return values are listed below.\n'ask(0)' returns $$$[0, 3]$$$\n'ask(1)' returns $$$[0, 1]$$$\n'ask(2)' returns $$$[1, 2]$$$\n'ask(3)' returns $$$[0, 0]$$$\n'ask(4)' returns $$$[2, 1]$$$\n'ask(5)' returns $$$[2, 1]$$$\n'ask(6)' returns $$$[1, 0]$$$\n'ask(7)' returns $$$[3, 0]$$$\nIn this example, the diamond is in box $$$3$$$. So the procedure\nfind_best\nshould return $$$3$$$.\nThe above figure illustrates this example. The upper part shows the types of the prizes in each box. The lower part illustrates the query\nask(2)\n. The marked boxes contain more expensive prizes than the one in box $$$2$$$.",
    "_meta": {
      "index": 13,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/D",
      "uuid": "ps_0ae025733494f857a0e38df44118344a6f988e45"
    }
  },
  {
    "planning_view": {
      "title": "F. Stations",
      "task": "Label n stations (0-k) so routing finds paths using only neighbour labels",
      "given": [
        "Tree with n stations (0 to n-1), n-1 links",
        "Each station has degree limited only by tree structure",
        "Maximum label value k ≥ n-1",
        "Routing uses only current, target, and neighbour labels"
      ],
      "goal": "Assign unique labels 0-k to stations for correct packet routing",
      "key_rules": [
        "find_next_station() receives only (s, t, c) - no global state from label()",
        "Labels must be unique integers 0-k",
        "Routing must be correct for all valid s≠t pairs",
        "Maximum label value affects score in subtask 5"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "k=1000, maximum degree ≤ 2 (path graph)"
        },
        "2": {
          "points": 8,
          "req": "k=1000, specific binary tree structure"
        },
        "3": {
          "points": 16,
          "req": "k=1,000,000, at most one high-degree station"
        },
        "4": {
          "points": 10,
          "req": "k=10^9, n ≤ 8"
        },
        "5": {
          "points": 61,
          "req": "k=10^9, score based on maximum label used (0-61 points)"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Stations",
      "contest": "IOI 2020 day 2",
      "one_line": "Label n stations (0-k) so routing finds paths using only neighbour labels",
      "given": [
        "Tree with n stations (0 to n-1), n-1 links",
        "Each station has degree limited only by tree structure",
        "Maximum label value k ≥ n-1",
        "Routing uses only current, target, and neighbour labels"
      ],
      "goal": "Assign unique labels 0-k to stations for correct packet routing",
      "mechanism": "label() assigns station labels; find_next_station() routes packets using only current station label, target label, and neighbour labels",
      "success_condition": "Packets follow unique tree paths using only the provided local information",
      "constraints": {
        "critical": [
          "find_next_station() receives only (s, t, c) - no global state from label()",
          "Labels must be unique integers 0-k",
          "Routing must be correct for all valid s≠t pairs",
          "Maximum label value affects score in subtask 5"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "k=1000, maximum degree ≤ 2 (path graph)"
          },
          "2": {
            "points": 8,
            "req": "k=1000, specific binary tree structure"
          },
          "3": {
            "points": 16,
            "req": "k=1,000,000, at most one high-degree station"
          },
          "4": {
            "points": 10,
            "req": "k=10^9, n ≤ 8"
          },
          "5": {
            "points": 61,
            "req": "k=10^9, score based on maximum label used (0-61 points)"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Stations",
        "contest": "IOI 2020 day 2",
        "one_line": "Label n stations (0-k) so routing finds paths using only neighbour labels"
      },
      "problem": {
        "given": [
          "Tree with n stations (0 to n-1), n-1 links",
          "Each station has degree limited only by tree structure",
          "Maximum label value k ≥ n-1",
          "Routing uses only current, target, and neighbour labels"
        ],
        "goal": "Assign unique labels 0-k to stations for correct packet routing",
        "mechanism": "label() assigns station labels; find_next_station() routes packets using only current station label, target label, and neighbour labels",
        "success_condition": "Packets follow unique tree paths using only the provided local information"
      },
      "constraints": {
        "critical": [
          "find_next_station() receives only (s, t, c) - no global state from label()",
          "Labels must be unique integers 0-k",
          "Routing must be correct for all valid s≠t pairs",
          "Maximum label value affects score in subtask 5"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "k=1000, maximum degree ≤ 2 (path graph)"
          },
          "2": {
            "points": 8,
            "req": "k=1000, specific binary tree structure"
          },
          "3": {
            "points": 16,
            "req": "k=1,000,000, at most one high-degree station"
          },
          "4": {
            "points": 10,
            "req": "k=10^9, n ≤ 8"
          },
          "5": {
            "points": 61,
            "req": "k=10^9, score based on maximum label used (0-61 points)"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] label(int n, int k, int[] u, int[] v)",
        "available_api": {
          "label": {
            "signature": "int[] label(int n, int k, int[] u, int[] v)",
            "params": "n: stations count, k: max label, u/v: edge endpoints",
            "returns": "Array of n unique labels 0-k for stations 0 to n-1",
            "side_effect": "Labels stored for later routing calls"
          },
          "find_next_station": {
            "signature": "int find_next_station(int s, int t, int[] c)",
            "params": "s: current station label, t: target label, c: sorted neighbour labels",
            "returns": "Label of neighbour to forward packet to",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Two separate runs: label() calls first, then find_next_station() calls",
          "No shared state between runs",
          "Total c array length ≤ 100,000 across all find_next_station calls",
          "Stations are 0-indexed"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "Singapore's Internet Backbone (SIB) consists of $$$n$$$ stations, which are assigned\nindices\nfrom $$$0$$$ to $$$n-1$$$. There are also $$$n-1$$$ bidirectional links, numbered from $$$0$$$ to $$$n-2$$$. Each link connects two distinct stations. Two stations connected with a single link are called neighbours.\nA path from $$$x$$$ station to $$$y$$$ station is a sequence of distinct stations $$$a_0,a_1,\\cdots,a_p$$$, such that $$$a_0=x$$$, $$$a_p=y$$$, and every two consecutive stations in the path are neighbours. There is\nexactly one\npath from any station $$$x$$$ to any other station $$$y$$$.\nAny station $$$x$$$ can create a packet (a piece of data) and send it to any other station $$$y$$$, which is called the packet's\ntarget\n. This packet must be routed along the unique path from $$$x$$$ to $$$y$$$ as follows. Consider a station $$$z$$$ that currently holds a packet, whose target station is $$$y$$$ ($$$z \\neq y$$$). In this situation station $$$z$$$:\nexecutes a\nrouting procedure\nthat determines the neighbour of $$$z$$$ which is on the unique path from $$$z$$$ to $$$y$$$, and\nforwards the packet to this neighbour.\nHowever, stations have limited memory and do not store the entire list of the links in SIB to use it in the routing procedure.\nYour task is to implement a routing scheme for SIB, which consists of two procedures.\nThe first procedure is given $$$n$$$, the list of the links in the SIB and an integer $$$k \\geq n-1$$$ as the inputs. It assigns each station a\nunique\ninteger\nlabel\nbetween $$$0$$$ and $$$k$$$, inclusive.\nThe second procedure is the routing procedure, which is deployed to all stations after labels are assigned. It is given\nonly\nthe following inputs:\n$$$s$$$, the\nlabel\nof the station that currently holds a packet,\n$$$t$$$, the\nlabel\nof the packet's target station ($$$t \\neq s$$$),\n$$$c$$$, the list of the\nlabels\nof all neighbours of $$$s$$$.\nIt should return the\nlabel\nof the neighbour of $$$s$$$ that the packet should be forwarded to.\nIn one subtask, the score of your solution depends on the value of the maximum label assigned to any station (in general, smaller is better).\nImplementation details\nYou should implement the following procedures:\nint[] label(int n, int k, int[] u, int[] v)\n$$$n$$$: number of stations in the SIB.\n$$$k$$$: maximum label that can be used.\n$$$u$$$ and $$$v$$$: arrays of size $$$n-1$$$, describing the links. For each $$$i$$$ ($$$0 \\leq i \\leq n-2$$$), link $$$i$$$ connects stations with indices $$$u[i]$$$ and $$$v[i]$$$.\nThis procedure should return a single array $$$L$$$ of size $$$n$$$. For each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) $$$L[i]$$$ is the label assigned to station with index $$$i$$$. All elements of array $$$L$$$ must be unique and between $$$0$$$ and $$$k$$$, inclusive.\nint find_next_station(int s, int t, int[] c)\n$$$s$$$: label of the station holding a packet.\n$$$t$$$: label of the packet's target station.\n$$$c$$$: an array giving the list of the labels of all neighbours of $$$s$$$. The array $$$c$$$ is sorted in ascending order.\nThis procedure should return the label of a neighbour of $$$s$$$ that the packet should be forwarded to.\nEach test case involves one or more independent scenarios (i.e., different SIB descriptions). For a test case involving $$$r$$$ scenarios, a\nprogram\nthat calls the above procedures is run exactly two times, as follows.\nDuring the first run of the program:\nlabel\nprocedure is called $$$r$$$ times,\nthe returned labels are stored by the grading system, and\nfind_next_station\nis not called.\nDuring the second run of the program:\nfind_next_station\nmay be called multiple times. In each call, an\narbitrary\nscenario is chosen, and the labels returned by the call to\nlabel\nprocedure in that scenario are used as the inputs to\nfind_next_station\n.\nlabel\nis not called.\nIn particular, any information saved to static or global variables in the first run of the program is not available within\nfind_next_station\nprocedure.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$r$$$ ($$$1 \\leq r \\leq 10$$$)\n$$$r$$$ blocks follow, each describing a single scenario. The format of each block is as follows:\nline $$$1$$$: $$$n\\ k$$$ ($$$2 \\leq n \\leq 1000$$$, $$$k \\geq n-1$$$)\nline $$$2+i$$$ ($$$0 \\leq i \\leq n - 2$$$): $$$u[i]\\ v[i]$$$ ($$$0 \\leq u[i], v[i] \\leq n - 1$$$)\nline $$$1 + n$$$: $$$q$$$: the number of calls to\nfind_next_station\n.\nline $$$2 + n + j$$$ ($$$0 \\leq j \\leq q - 1$$$): $$$z[j]\\ y[j]\\ w[j]$$$:\nindices\nof stations involved in the $$$j$$$-th call to\nfind_next_station\n. The station $$$z[j]$$$ holds the packet, the station $$$y[j]$$$ is the packet's target, and the station $$$w[j]$$$ is the station that the packet should be forwarded to.\nFor each call to\nfind_next_station\n, the input comes from an arbitrarily chosen previous call to\nlabel\n. Consider the labels it produced. Then:\n$$$s$$$ and $$$t$$$ are labels of two different stations.\n$$$c$$$ is the sequence of all labels of neighbours of the station with label $$$s$$$, in ascending order.\nFor each test case, the total length of all arrays $$$c$$$ passed to the procedure\nfind_next_station\ndoes not exceed $$$100\\,000$$$ for all scenarios combined.\nOutput\nThe sample grader prints the result in the following format:\nline $$$1$$$: $$$m$$$\n$$$r$$$ blocks corresponding to the consecutive scenarios in the input follow. The format of each block is as follows:\nline $$$1 + j$$$ ($$$0 \\leq j \\leq q - 1$$$):\nindex\nof the station, whose\nlabel\nwas returned by the $$$j$$$-th call to\nfind_next_station\nin this scenario.\nNote that each run of the sample grader calls both\nlabel\nand\nfind_next_station\n.\nScoring\nSubtask\nPoints\n$$$K$$$\nAdditional Input Constraints\n1\n5\n$$$k = 1000$$$\nNo station has more than $$$2$$$ neighbours.\n2\n8\n$$$k = 1000$$$\nLink $$$i$$$ connects stations $$$i+1$$$ and $$$\\left\\lfloor \\frac{i}{2} \\right\\rfloor$$$.\n3\n16\n$$$k = 1\\,000\\,000$$$\nAt most one station has more than $$$2$$$ neighbours.\n4\n10\n$$$k = 10^9$$$\n$$$n \\leq 8$$$\n5\n61\n$$$k = 10^9$$$\n—\nIn subtask 5 you can obtain a partial score. Let $$$m$$$ be the maximum label value returned by\nlabel\nacross all scenarios. Your score for this subtask is calculated according to the following table:\nMaximum label\nScore\n$$$m\\geq10^9$$$\n$$$0$$$\n$$$2000 \\leq m \\textless 10^9$$$\n$$$50 \\cdot \\log_{5\\cdot10^5}(\\frac{10^9}{m})$$$\n$$$1000 \\textless m \\textless 2000$$$\n$$$50$$$\n$$$m\\leq 1000$$$\n$$$61$$$\nNote\nConsider the following call:\nlabel(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])\nThere are a total of $$$5$$$ stations, and $$$4$$$ links connecting pairs of stations with indices $$$(0, 1)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$ and $$$(2, 4)$$$. Each label can be an integer from $$$0$$$ to $$$k=10$$$.\nIn order to report the following labelling:\nIndex\nLable\n0\n6\n1\n2\n2\n9\n3\n3\n4\n7\nthe\nlabel\nprocedure should return [$$$6$$$, $$$2$$$, $$$9$$$, $$$3$$$, $$$7$$$]. The numbers in the following figure show the indices (left panel) and assigned labels (right panel).\nAssume the labels have been assigned as described above and consider the following call:\nfind_next_station(9, 6, [2, 7])\nThis means that the station holding the packet has label $$$9$$$, and the target station has label $$$6$$$. The labels of stations on the path to the target station are $$$[9, 2, 6]$$$. Hence, the call should return $$$2$$$, which is the label of the station that the packet should be forwarded to (which has index $$$1$$$).\nConsider another possible call:\nfind_next_station(2, 3, [3, 6, 9])\nThe procedure should return $$$3$$$, since the target station with label $$$3$$$ is a neighbour of the station with label $$$2$$$, and hence should receive the packet directly."
    },
    "original": "Singapore's Internet Backbone (SIB) consists of $$$n$$$ stations, which are assigned\nindices\nfrom $$$0$$$ to $$$n-1$$$. There are also $$$n-1$$$ bidirectional links, numbered from $$$0$$$ to $$$n-2$$$. Each link connects two distinct stations. Two stations connected with a single link are called neighbours.\nA path from $$$x$$$ station to $$$y$$$ station is a sequence of distinct stations $$$a_0,a_1,\\cdots,a_p$$$, such that $$$a_0=x$$$, $$$a_p=y$$$, and every two consecutive stations in the path are neighbours. There is\nexactly one\npath from any station $$$x$$$ to any other station $$$y$$$.\nAny station $$$x$$$ can create a packet (a piece of data) and send it to any other station $$$y$$$, which is called the packet's\ntarget\n. This packet must be routed along the unique path from $$$x$$$ to $$$y$$$ as follows. Consider a station $$$z$$$ that currently holds a packet, whose target station is $$$y$$$ ($$$z \\neq y$$$). In this situation station $$$z$$$:\nexecutes a\nrouting procedure\nthat determines the neighbour of $$$z$$$ which is on the unique path from $$$z$$$ to $$$y$$$, and\nforwards the packet to this neighbour.\nHowever, stations have limited memory and do not store the entire list of the links in SIB to use it in the routing procedure.\nYour task is to implement a routing scheme for SIB, which consists of two procedures.\nThe first procedure is given $$$n$$$, the list of the links in the SIB and an integer $$$k \\geq n-1$$$ as the inputs. It assigns each station a\nunique\ninteger\nlabel\nbetween $$$0$$$ and $$$k$$$, inclusive.\nThe second procedure is the routing procedure, which is deployed to all stations after labels are assigned. It is given\nonly\nthe following inputs:\n$$$s$$$, the\nlabel\nof the station that currently holds a packet,\n$$$t$$$, the\nlabel\nof the packet's target station ($$$t \\neq s$$$),\n$$$c$$$, the list of the\nlabels\nof all neighbours of $$$s$$$.\nIt should return the\nlabel\nof the neighbour of $$$s$$$ that the packet should be forwarded to.\nIn one subtask, the score of your solution depends on the value of the maximum label assigned to any station (in general, smaller is better).\nImplementation details\nYou should implement the following procedures:\nint[] label(int n, int k, int[] u, int[] v)\n$$$n$$$: number of stations in the SIB.\n$$$k$$$: maximum label that can be used.\n$$$u$$$ and $$$v$$$: arrays of size $$$n-1$$$, describing the links. For each $$$i$$$ ($$$0 \\leq i \\leq n-2$$$), link $$$i$$$ connects stations with indices $$$u[i]$$$ and $$$v[i]$$$.\nThis procedure should return a single array $$$L$$$ of size $$$n$$$. For each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) $$$L[i]$$$ is the label assigned to station with index $$$i$$$. All elements of array $$$L$$$ must be unique and between $$$0$$$ and $$$k$$$, inclusive.\nint find_next_station(int s, int t, int[] c)\n$$$s$$$: label of the station holding a packet.\n$$$t$$$: label of the packet's target station.\n$$$c$$$: an array giving the list of the labels of all neighbours of $$$s$$$. The array $$$c$$$ is sorted in ascending order.\nThis procedure should return the label of a neighbour of $$$s$$$ that the packet should be forwarded to.\nEach test case involves one or more independent scenarios (i.e., different SIB descriptions). For a test case involving $$$r$$$ scenarios, a\nprogram\nthat calls the above procedures is run exactly two times, as follows.\nDuring the first run of the program:\nlabel\nprocedure is called $$$r$$$ times,\nthe returned labels are stored by the grading system, and\nfind_next_station\nis not called.\nDuring the second run of the program:\nfind_next_station\nmay be called multiple times. In each call, an\narbitrary\nscenario is chosen, and the labels returned by the call to\nlabel\nprocedure in that scenario are used as the inputs to\nfind_next_station\n.\nlabel\nis not called.\nIn particular, any information saved to static or global variables in the first run of the program is not available within\nfind_next_station\nprocedure.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$r$$$ ($$$1 \\leq r \\leq 10$$$)\n$$$r$$$ blocks follow, each describing a single scenario. The format of each block is as follows:\nline $$$1$$$: $$$n\\ k$$$ ($$$2 \\leq n \\leq 1000$$$, $$$k \\geq n-1$$$)\nline $$$2+i$$$ ($$$0 \\leq i \\leq n - 2$$$): $$$u[i]\\ v[i]$$$ ($$$0 \\leq u[i], v[i] \\leq n - 1$$$)\nline $$$1 + n$$$: $$$q$$$: the number of calls to\nfind_next_station\n.\nline $$$2 + n + j$$$ ($$$0 \\leq j \\leq q - 1$$$): $$$z[j]\\ y[j]\\ w[j]$$$:\nindices\nof stations involved in the $$$j$$$-th call to\nfind_next_station\n. The station $$$z[j]$$$ holds the packet, the station $$$y[j]$$$ is the packet's target, and the station $$$w[j]$$$ is the station that the packet should be forwarded to.\nFor each call to\nfind_next_station\n, the input comes from an arbitrarily chosen previous call to\nlabel\n. Consider the labels it produced. Then:\n$$$s$$$ and $$$t$$$ are labels of two different stations.\n$$$c$$$ is the sequence of all labels of neighbours of the station with label $$$s$$$, in ascending order.\nFor each test case, the total length of all arrays $$$c$$$ passed to the procedure\nfind_next_station\ndoes not exceed $$$100\\,000$$$ for all scenarios combined.\nOutput\nThe sample grader prints the result in the following format:\nline $$$1$$$: $$$m$$$\n$$$r$$$ blocks corresponding to the consecutive scenarios in the input follow. The format of each block is as follows:\nline $$$1 + j$$$ ($$$0 \\leq j \\leq q - 1$$$):\nindex\nof the station, whose\nlabel\nwas returned by the $$$j$$$-th call to\nfind_next_station\nin this scenario.\nNote that each run of the sample grader calls both\nlabel\nand\nfind_next_station\n.\nScoring\nSubtask\nPoints\n$$$K$$$\nAdditional Input Constraints\n1\n5\n$$$k = 1000$$$\nNo station has more than $$$2$$$ neighbours.\n2\n8\n$$$k = 1000$$$\nLink $$$i$$$ connects stations $$$i+1$$$ and $$$\\left\\lfloor \\frac{i}{2} \\right\\rfloor$$$.\n3\n16\n$$$k = 1\\,000\\,000$$$\nAt most one station has more than $$$2$$$ neighbours.\n4\n10\n$$$k = 10^9$$$\n$$$n \\leq 8$$$\n5\n61\n$$$k = 10^9$$$\n—\nIn subtask 5 you can obtain a partial score. Let $$$m$$$ be the maximum label value returned by\nlabel\nacross all scenarios. Your score for this subtask is calculated according to the following table:\nMaximum label\nScore\n$$$m\\geq10^9$$$\n$$$0$$$\n$$$2000 \\leq m \\textless 10^9$$$\n$$$50 \\cdot \\log_{5\\cdot10^5}(\\frac{10^9}{m})$$$\n$$$1000 \\textless m \\textless 2000$$$\n$$$50$$$\n$$$m\\leq 1000$$$\n$$$61$$$\nNote\nConsider the following call:\nlabel(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])\nThere are a total of $$$5$$$ stations, and $$$4$$$ links connecting pairs of stations with indices $$$(0, 1)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$ and $$$(2, 4)$$$. Each label can be an integer from $$$0$$$ to $$$k=10$$$.\nIn order to report the following labelling:\nIndex\nLable\n0\n6\n1\n2\n2\n9\n3\n3\n4\n7\nthe\nlabel\nprocedure should return [$$$6$$$, $$$2$$$, $$$9$$$, $$$3$$$, $$$7$$$]. The numbers in the following figure show the indices (left panel) and assigned labels (right panel).\nAssume the labels have been assigned as described above and consider the following call:\nfind_next_station(9, 6, [2, 7])\nThis means that the station holding the packet has label $$$9$$$, and the target station has label $$$6$$$. The labels of stations on the path to the target station are $$$[9, 2, 6]$$$. Hence, the call should return $$$2$$$, which is the label of the station that the packet should be forwarded to (which has index $$$1$$$).\nConsider another possible call:\nfind_next_station(2, 3, [3, 6, 9])\nThe procedure should return $$$3$$$, since the target station with label $$$3$$$ is a neighbour of the station with label $$$2$$$, and hence should receive the packet directly.",
    "_meta": {
      "index": 14,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/F",
      "uuid": "ps_c69ee9cc92cdfab29d72f5f8165e9a2283d60f78"
    }
  },
  {
    "planning_view": {
      "title": "C. Wombats",
      "task": "Find safest path on grid with dynamic updates in ≤15 seconds",
      "given": [
        "R×C grid of roads (R horizontal roads, C vertical roads)",
        "Wombat counts on horizontal and vertical segments",
        "People can move E/W on horizontal roads, only S on vertical roads"
      ],
      "goal": "Find path with minimum wombats from north (row 0) to south (row R-1)",
      "key_rules": [
        "R ≤ 5,000, C ≤ 200",
        "At most 500 updates (changeH/changeV)",
        "At most 200,000 escape() queries",
        "Wombat counts 0-1,000 per segment"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "C=1 (single column)"
        },
        "2": {
          "points": 12,
          "req": "R,C ≤ 20, no updates"
        },
        "3": {
          "points": 16,
          "req": "R,C ≤ 100, ≤100 escape calls"
        },
        "4": {
          "points": 18,
          "req": "C=2"
        },
        "5": {
          "points": 21,
          "req": "C ≤ 100"
        },
        "6": {
          "points": 24,
          "req": "No restrictions"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Wombats",
      "contest": "IOI 2013 day 1",
      "one_line": "Find safest path on grid with dynamic updates in ≤15 seconds",
      "given": [
        "R×C grid of roads (R horizontal roads, C vertical roads)",
        "Wombat counts on horizontal and vertical segments",
        "People can move E/W on horizontal roads, only S on vertical roads"
      ],
      "goal": "Find path with minimum wombats from north (row 0) to south (row R-1)",
      "mechanism": "Grid segments have dynamic wombat counts updated via API calls",
      "success_condition": "Return minimal wombat count on path from (0,V1) to (R-1,V2)",
      "constraints": {
        "critical": [
          "R ≤ 5,000, C ≤ 200",
          "At most 500 updates (changeH/changeV)",
          "At most 200,000 escape() queries",
          "Wombat counts 0-1,000 per segment"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "C=1 (single column)"
          },
          "2": {
            "points": 12,
            "req": "R,C ≤ 20, no updates"
          },
          "3": {
            "points": 16,
            "req": "R,C ≤ 100, ≤100 escape calls"
          },
          "4": {
            "points": 18,
            "req": "C=2"
          },
          "5": {
            "points": 21,
            "req": "C ≤ 100"
          },
          "6": {
            "points": 24,
            "req": "No restrictions"
          }
        }
      },
      "limits": {
        "time": "15 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Wombats",
        "contest": "IOI 2013 day 1",
        "one_line": "Find safest path on grid with dynamic updates in ≤15 seconds"
      },
      "problem": {
        "given": [
          "R×C grid of roads (R horizontal roads, C vertical roads)",
          "Wombat counts on horizontal and vertical segments",
          "People can move E/W on horizontal roads, only S on vertical roads"
        ],
        "goal": "Find path with minimum wombats from north (row 0) to south (row R-1)",
        "mechanism": "Grid segments have dynamic wombat counts updated via API calls",
        "success_condition": "Return minimal wombat count on path from (0,V1) to (R-1,V2)"
      },
      "constraints": {
        "critical": [
          "R ≤ 5,000, C ≤ 200",
          "At most 500 updates (changeH/changeV)",
          "At most 200,000 escape() queries",
          "Wombat counts 0-1,000 per segment"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "C=1 (single column)"
          },
          "2": {
            "points": 12,
            "req": "R,C ≤ 20, no updates"
          },
          "3": {
            "points": 16,
            "req": "R,C ≤ 100, ≤100 escape calls"
          },
          "4": {
            "points": 18,
            "req": "C=2"
          },
          "5": {
            "points": 21,
            "req": "C ≤ 100"
          },
          "6": {
            "points": 24,
            "req": "No restrictions"
          }
        }
      },
      "implementation": {
        "function_to_write": "Multiple: init(), changeH(), changeV(), escape()",
        "available_api": {
          "init": {
            "signature": "void init(int R, int C, int H[5000][200], int V[5000][200])",
            "params": "R: rows, C: columns, H: horizontal wombat counts, V: vertical wombat counts",
            "returns": "void",
            "side_effect": "Initializes data structures"
          },
          "changeH": {
            "signature": "void changeH(int P, int Q, int W)",
            "params": "P: row, Q: start column, W: new wombat count",
            "returns": "void",
            "side_effect": "Updates horizontal segment between (P,Q) and (P,Q+1)"
          },
          "changeV": {
            "signature": "void changeV(int P, int Q, int W)",
            "params": "P: start row, Q: column, W: new wombat count",
            "returns": "void",
            "side_effect": "Updates vertical segment between (P,Q) and (P+1,Q)"
          },
          "escape": {
            "signature": "int escape(int V1, int V2)",
            "params": "V1: start column, V2: target column",
            "returns": "Minimum wombat count from (0,V1) to (R-1,V2)",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Include \"wombats.h\"",
          "Must handle dynamic updates efficiently",
          "Grid coordinates are 0-indexed"
        ]
      },
      "limits": {
        "time": "15 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "3 4\n0 2 5\n7 1 1\n0 4 0\n0 0 0 2\n0 3 4 7\n5\n3 2 1\n3 3 3\n2 0 0 5\n1 1 1 6\n3 2 1",
          "output": "2\n7\n5"
        }
      ],
      "original_statement": "The city of Brisbane has been taken over by large mutated wombats, and you must lead the people to safety.\nThe roads in Brisbane are laid out in a large grid. There are $$$R$$$ horizontal roads that run easttowest, numbered $$$0, \\dots, (R - 1)$$$ in order from north to south, and $$$C$$$ vertical roads that run northtosouth, numbered $$$0, \\dots, (C - 1)$$$ in order from west to east, as shown in the picture below.\nThe wombats have invaded from the north, and the people are escaping to the south. People can run along horizontal roads in either direction, but on vertical roads they will\nonly run towards the south\n, towards safety.\nThe intersection of horizontal road $$$P$$$ with vertical road $$$Q$$$ is denoted $$$(P, Q)$$$. Each segment of road between two intersections contains some number of wombats, and these numbers may change over time. Your task is to guide each person from some given intersection in the north (on horizontal road $$$0$$$) to some given intersection in the south (on horizontal road $$$(R - 1)$$$), taking them on a route that passes as few wombats as possible.\nTo begin, you will be given the size of the grid and the number of wombats on each road segment. Following this you will be given a series of $$$E$$$ events, each of which is either:\na\nchange\n, which alters the number of wombats on some road segment; or\nan\nescape\n, where some person arrives at a given intersection on horizontal road $$$0$$$, and you must find a route to a given intersection on horizontal road $$$(R - 1)$$$ that passes the fewest possible wombats.\nYou must handle these events by implementing the routines\ninit()\n,\nchangeH()\n,\nchangeV()\nand\nescape()\n, as described below.\nYou should submit a file implementing the procedures\ninit()\n,\nchangeH()\nand\nchangeV()\nand the function\nescape()\n.\nYour Procedure\ninit()\n:\nvoid init(int R, int C, int H[5000][200], int V[5000][200]);\nThis procedure gives you the initial layout of the map, and allows you to initialise any global variables and data structures. It will be called only once, before any calls to\nchangeH()\n,\nchangeV()\nor\nescape()\n.\nParameters:\n$$$R$$$: The number of horizontal roads.\n$$$C$$$: The number of vertical roads.\n$$$H$$$: A twodimensional array of size $$$R \\cdot (C - 1)$$$, where $$$H[P][Q]$$$ gives the number of wombats on the segment of horizontal road between intersections $$$(P, Q)$$$ and $$$(P, Q + 1)$$$.\n$$$V$$$: A twodimensional array of size $$$(R - 1) \\cdot C$$$, where $$$V[P][Q]$$$ gives the number of wombats on the segment of vertical road between intersections $$$(P, Q)$$$ and $$$(P + 1, Q)$$$.\nYour Procedure\nchangeH()\n:\nvoid changeH(int P, int Q, int W);\nThis procedure will be called when the number of wombats changes on the horizontal road segment between intersections $$$(P, Q)$$$ and $$$(P, Q + 1)$$$.\nParameters:\n$$$P$$$: Indicates which horizontal road is affected $$$(0 \\leq P \\leq R - 1)$$$.\n$$$Q$$$: Indicates between which two vertical roads the segment lies $$$(0 \\leq Q \\leq C - 2)$$$.\n$$$W$$$: The new number of wombats on this road segment $$$(0 \\leq W \\leq 1,000)$$$.\nYour Procedure:\nchangeV()\n:\nvoid changeV(int P, int Q, int W);\nThis procedure will be called when the number of wombats changes on the vertical road segment between intersections $$$(P, Q)$$$ and $$$(P + 1, Q)$$$.\nParameters:\n$$$P$$$: Indicates between which two horizontal roads the segment lies $$$(0 \\leq P \\leq R - 2)$$$\n$$$Q$$$: Indicates which vertical road is affected $$$(0 \\leq Q \\leq C - 1)$$$.\n$$$W$$$: The new number of wombats on this road segment $$$( 0 \\leq W \\leq 1\\,000)$$$.\nYour Function\nescape()\n:\nint escape(int V1, int V2);\nThis function should calculate the fewest possible wombats a person must pass when travelling from intersection $$$(0, V1)$$$ to $$$(R1, V2)$$$.\nParameters:\n$$$V1$$$: Indicates where the person begins on horizontal row $$$0$$$ $$$( 0 \\leq V1 \\leq C-1 )$$$.\n$$$V2$$$: Indicates where the person ends on horizontal row $$$R-1$$$ $$$( 0 \\leq V2 \\leq C-1 )$$$.\nReturns\n: The smallest number of wombats the person must pass.\nInput\nThe grader reads input in the following format:\nline $$$1$$$: $$$R\\ C$$$\nline $$$2$$$: $$$H[0][0]\\dots H[0][C-2]$$$\n...\nline $$$(R + 1)$$$: $$$H[R-1][0] \\dots H[R-1][C-2]$$$\nline $$$(R + 2)$$$: $$$V[0][0] \\dots V[0][C-1]$$$\n...\nline $$$2R$$$: $$$V[R-2][0] \\dots V[R-2][C-1]$$$\nnext line: $$$E$$$\nnext $$$E$$$ lines: one event per line, in the order in which events occur\nIf $$$C = 1$$$, the empty lines containing the number of wombats on horizontal roads (lines $$$2$$$ through $$$R + 1$$$) are not necessary.\nThe line for each event must be in one of the following formats:\nto indicate\nchangeH(P, Q, W)\n: $$$1\\ P\\ Q\\ W$$$\nto indicate\nchangeV(P, Q, W)\n: $$$2\\ P\\ Q\\ W$$$\nto indicate\nescape(V1, V2)\n: $$$3\\ V1\\ V2$$$\nScoring\nFull constraints:\n$$$2 \\leq R \\leq 5,000$$$\n$$$1 \\leq C \\leq 200$$$\nAt most $$$500$$$ changes (calls to either\nchangeH()\nor\nchangeV()\n)\nAt most $$$200,000$$$ calls to\nescape()\nAt most $$$1,000$$$ wombats on any segment at any time\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$C=1$$$\n2\n12\n$$$R,C \\leq 20$$$, and there will be no calls to\nchangeH()\nor\nchangeV()\n3\n16\n$$$R,C \\leq 100$$$, and there will be at most $$$100$$$ calls to\nescape()\n4\n18\n$$$C=2$$$\n5\n21\n$$$C \\leq 100$$$\n6\n24\n(\nNone\n)\nExample\nNote\nConsider the first example.\nThe picture above shows an initial map with $$$R = 3$$$ horizontal roads and $$$C = 4$$$ vertical roads, with the number of wombats marked on each segment. Consider the following series of events:\nA person arrives at intersection $$$A = (0, 2)$$$ and wishes to escape to intersection $$$(2, 1)$$$. The smallest number of wombats she can pass is $$$2$$$, as indicated by a dashed line.\nAnother person arrives at intersection $$$X = (0, 3)$$$ and wishes to escape to intersection $$$Y = (2, 3)$$$. The smallest number of wombats he can pass is $$$7$$$, again indicated by a dashed line.\nTwo change events occur: the number of wombats on the top segment of vertical road $$$0$$$ changes to $$$5$$$, and the number of wombats on the middle segment of horizontal road $$$1$$$ changes to $$$6$$$. See the circled numbers in the picture below.\nA third person arrives at intersection $$$A = (0, 2)$$$ and wishes to escape to intersection $$$B = (2, 1)$$$. Now the smallest number of wombats she can pass is $$$5$$$, as indicated by the new dashed line.\nIn the file you are submitting you must\n#include\"wombats.h\"\n."
    },
    "original": "The city of Brisbane has been taken over by large mutated wombats, and you must lead the people to safety.\nThe roads in Brisbane are laid out in a large grid. There are $$$R$$$ horizontal roads that run easttowest, numbered $$$0, \\dots, (R - 1)$$$ in order from north to south, and $$$C$$$ vertical roads that run northtosouth, numbered $$$0, \\dots, (C - 1)$$$ in order from west to east, as shown in the picture below.\nThe wombats have invaded from the north, and the people are escaping to the south. People can run along horizontal roads in either direction, but on vertical roads they will\nonly run towards the south\n, towards safety.\nThe intersection of horizontal road $$$P$$$ with vertical road $$$Q$$$ is denoted $$$(P, Q)$$$. Each segment of road between two intersections contains some number of wombats, and these numbers may change over time. Your task is to guide each person from some given intersection in the north (on horizontal road $$$0$$$) to some given intersection in the south (on horizontal road $$$(R - 1)$$$), taking them on a route that passes as few wombats as possible.\nTo begin, you will be given the size of the grid and the number of wombats on each road segment. Following this you will be given a series of $$$E$$$ events, each of which is either:\na\nchange\n, which alters the number of wombats on some road segment; or\nan\nescape\n, where some person arrives at a given intersection on horizontal road $$$0$$$, and you must find a route to a given intersection on horizontal road $$$(R - 1)$$$ that passes the fewest possible wombats.\nYou must handle these events by implementing the routines\ninit()\n,\nchangeH()\n,\nchangeV()\nand\nescape()\n, as described below.\nYou should submit a file implementing the procedures\ninit()\n,\nchangeH()\nand\nchangeV()\nand the function\nescape()\n.\nYour Procedure\ninit()\n:\nvoid init(int R, int C, int H[5000][200], int V[5000][200]);\nThis procedure gives you the initial layout of the map, and allows you to initialise any global variables and data structures. It will be called only once, before any calls to\nchangeH()\n,\nchangeV()\nor\nescape()\n.\nParameters:\n$$$R$$$: The number of horizontal roads.\n$$$C$$$: The number of vertical roads.\n$$$H$$$: A twodimensional array of size $$$R \\cdot (C - 1)$$$, where $$$H[P][Q]$$$ gives the number of wombats on the segment of horizontal road between intersections $$$(P, Q)$$$ and $$$(P, Q + 1)$$$.\n$$$V$$$: A twodimensional array of size $$$(R - 1) \\cdot C$$$, where $$$V[P][Q]$$$ gives the number of wombats on the segment of vertical road between intersections $$$(P, Q)$$$ and $$$(P + 1, Q)$$$.\nYour Procedure\nchangeH()\n:\nvoid changeH(int P, int Q, int W);\nThis procedure will be called when the number of wombats changes on the horizontal road segment between intersections $$$(P, Q)$$$ and $$$(P, Q + 1)$$$.\nParameters:\n$$$P$$$: Indicates which horizontal road is affected $$$(0 \\leq P \\leq R - 1)$$$.\n$$$Q$$$: Indicates between which two vertical roads the segment lies $$$(0 \\leq Q \\leq C - 2)$$$.\n$$$W$$$: The new number of wombats on this road segment $$$(0 \\leq W \\leq 1,000)$$$.\nYour Procedure:\nchangeV()\n:\nvoid changeV(int P, int Q, int W);\nThis procedure will be called when the number of wombats changes on the vertical road segment between intersections $$$(P, Q)$$$ and $$$(P + 1, Q)$$$.\nParameters:\n$$$P$$$: Indicates between which two horizontal roads the segment lies $$$(0 \\leq P \\leq R - 2)$$$\n$$$Q$$$: Indicates which vertical road is affected $$$(0 \\leq Q \\leq C - 1)$$$.\n$$$W$$$: The new number of wombats on this road segment $$$( 0 \\leq W \\leq 1\\,000)$$$.\nYour Function\nescape()\n:\nint escape(int V1, int V2);\nThis function should calculate the fewest possible wombats a person must pass when travelling from intersection $$$(0, V1)$$$ to $$$(R1, V2)$$$.\nParameters:\n$$$V1$$$: Indicates where the person begins on horizontal row $$$0$$$ $$$( 0 \\leq V1 \\leq C-1 )$$$.\n$$$V2$$$: Indicates where the person ends on horizontal row $$$R-1$$$ $$$( 0 \\leq V2 \\leq C-1 )$$$.\nReturns\n: The smallest number of wombats the person must pass.\nInput\nThe grader reads input in the following format:\nline $$$1$$$: $$$R\\ C$$$\nline $$$2$$$: $$$H[0][0]\\dots H[0][C-2]$$$\n...\nline $$$(R + 1)$$$: $$$H[R-1][0] \\dots H[R-1][C-2]$$$\nline $$$(R + 2)$$$: $$$V[0][0] \\dots V[0][C-1]$$$\n...\nline $$$2R$$$: $$$V[R-2][0] \\dots V[R-2][C-1]$$$\nnext line: $$$E$$$\nnext $$$E$$$ lines: one event per line, in the order in which events occur\nIf $$$C = 1$$$, the empty lines containing the number of wombats on horizontal roads (lines $$$2$$$ through $$$R + 1$$$) are not necessary.\nThe line for each event must be in one of the following formats:\nto indicate\nchangeH(P, Q, W)\n: $$$1\\ P\\ Q\\ W$$$\nto indicate\nchangeV(P, Q, W)\n: $$$2\\ P\\ Q\\ W$$$\nto indicate\nescape(V1, V2)\n: $$$3\\ V1\\ V2$$$\nScoring\nFull constraints:\n$$$2 \\leq R \\leq 5,000$$$\n$$$1 \\leq C \\leq 200$$$\nAt most $$$500$$$ changes (calls to either\nchangeH()\nor\nchangeV()\n)\nAt most $$$200,000$$$ calls to\nescape()\nAt most $$$1,000$$$ wombats on any segment at any time\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$C=1$$$\n2\n12\n$$$R,C \\leq 20$$$, and there will be no calls to\nchangeH()\nor\nchangeV()\n3\n16\n$$$R,C \\leq 100$$$, and there will be at most $$$100$$$ calls to\nescape()\n4\n18\n$$$C=2$$$\n5\n21\n$$$C \\leq 100$$$\n6\n24\n(\nNone\n)\nExample\nNote\nConsider the first example.\nThe picture above shows an initial map with $$$R = 3$$$ horizontal roads and $$$C = 4$$$ vertical roads, with the number of wombats marked on each segment. Consider the following series of events:\nA person arrives at intersection $$$A = (0, 2)$$$ and wishes to escape to intersection $$$(2, 1)$$$. The smallest number of wombats she can pass is $$$2$$$, as indicated by a dashed line.\nAnother person arrives at intersection $$$X = (0, 3)$$$ and wishes to escape to intersection $$$Y = (2, 3)$$$. The smallest number of wombats he can pass is $$$7$$$, again indicated by a dashed line.\nTwo change events occur: the number of wombats on the top segment of vertical road $$$0$$$ changes to $$$5$$$, and the number of wombats on the middle segment of horizontal road $$$1$$$ changes to $$$6$$$. See the circled numbers in the picture below.\nA third person arrives at intersection $$$A = (0, 2)$$$ and wishes to escape to intersection $$$B = (2, 1)$$$. Now the smallest number of wombats she can pass is $$$5$$$, as indicated by the new dashed line.\nIn the file you are submitting you must\n#include\"wombats.h\"\n.",
    "_meta": {
      "index": 15,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/C",
      "uuid": "ps_83064905d99eca59d55f7764f3707ffd966b3e5f"
    }
  },
  {
    "planning_view": {
      "title": "B. Message",
      "task": "Send S-bit message using ≤100 packets with 15/31 bits editable by adversary",
      "given": [
        "Message M of S bits (1 ≤ S ≤ 1024)",
        "31-bit packets with 15 bits controlled by adversary (known to sender)",
        "Adversary changes controlled bits arbitrarily per packet"
      ],
      "goal": "Design sender/receiver protocols to reliably transmit M despite bit-flipping attacks",
      "key_rules": [
        "Adversary controls exactly 15 fixed indices per test case (known to sender)",
        "Receiver doesn't know which indices are controlled",
        "send_packet() can be called ≤100 times per send_message()",
        "send_message() called ≤2100 times total",
        "Adversary is adaptive but deterministic"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "S ≤ 64 bits"
        },
        "2": {
          "points": 90,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Message",
      "contest": "IOI 2024 day 1",
      "one_line": "Send S-bit message using ≤100 packets with 15/31 bits editable by adversary",
      "given": [
        "Message M of S bits (1 ≤ S ≤ 1024)",
        "31-bit packets with 15 bits controlled by adversary (known to sender)",
        "Adversary changes controlled bits arbitrarily per packet"
      ],
      "goal": "Design sender/receiver protocols to reliably transmit M despite bit-flipping attacks",
      "mechanism": "Sender sends packets; adversary modifies controlled bits; receiver reconstructs M from tainted packets",
      "success_condition": "Receiver must recover original M exactly from tainted packets",
      "constraints": {
        "critical": [
          "Adversary controls exactly 15 fixed indices per test case (known to sender)",
          "Receiver doesn't know which indices are controlled",
          "send_packet() can be called ≤100 times per send_message()",
          "send_message() called ≤2100 times total",
          "Adversary is adaptive but deterministic"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "S ≤ 64 bits"
          },
          "2": {
            "points": 90,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "5 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Message",
        "contest": "IOI 2024 day 1",
        "one_line": "Send S-bit message using ≤100 packets with 15/31 bits editable by adversary"
      },
      "problem": {
        "given": [
          "Message M of S bits (1 ≤ S ≤ 1024)",
          "31-bit packets with 15 bits controlled by adversary (known to sender)",
          "Adversary changes controlled bits arbitrarily per packet"
        ],
        "goal": "Design sender/receiver protocols to reliably transmit M despite bit-flipping attacks",
        "mechanism": "Sender sends packets; adversary modifies controlled bits; receiver reconstructs M from tainted packets",
        "success_condition": "Receiver must recover original M exactly from tainted packets"
      },
      "constraints": {
        "critical": [
          "Adversary controls exactly 15 fixed indices per test case (known to sender)",
          "Receiver doesn't know which indices are controlled",
          "send_packet() can be called ≤100 times per send_message()",
          "send_message() called ≤2100 times total",
          "Adversary is adaptive but deterministic"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "S ≤ 64 bits"
          },
          "2": {
            "points": 90,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "void send_message(vector<bool> M, vector<bool> C)",
        "available_api": {
          "send_packet": {
            "signature": "vector<bool> send_packet(vector<bool> A)",
            "params": "A: 31-bit packet to send",
            "returns": "31-bit tainted packet received by Basma",
            "side_effect": "Counts against 100-call limit per send_message"
          }
        },
        "requirements": [
          "Must implement send_message() and receive_message() in separate programs",
          "receive_message() returns vector<bool> of length S",
          "Packets delivered in sent order to receiver",
          "Use vector<bool> for all bit arrays"
        ]
      },
      "limits": {
        "time": "5 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "Aisha and Basma are two friends who correspond with each other. Aisha has a message $$$M$$$, which is a sequence of $$$S$$$ bits (i.e., zeroes or ones), that she would like to send to Basma. Aisha communicates with Basma by sending her\npackets\n. A packet is a sequence of $$$31$$$ bits indexed from $$$0$$$ to $$$30$$$. Aisha would like to send the message $$$M$$$ to Basma by sending her some number of packets.\nUnfortunately, Cleopatra compromised the communication between Aisha and Basma and is able to\ntaint\nthe packets. That is, in each packet Cleopatra can modify bits on exactly $$$15$$$ indices. Specifically, there is an array $$$C$$$ of length $$$31$$$, in which every element is either $$$0$$$ or $$$1$$$, with the following meaning:\n$$$C[i] = 1$$$ indicates that the bit with index $$$i$$$ can be changed by Cleopatra. We call these indices\ncontrolled\nby Cleopatra.\n$$$C[i] = 0$$$ indicates that bit with index $$$i$$$ cannot be changed by Cleopatra.\nThe array $$$C$$$ contains precisely $$$15$$$ ones and $$$16$$$ zeroes. While sending the message $$$M$$$ , the set of indices controlled by Cleopatra stays the same for all packets. Aisha knows precisely which $$$15$$$ indices are controlled by Cleopatra. Basma only knows that $$$15$$$ indices are controlled by Cleopatra, but she does not know which indices.\nLet $$$A$$$ be a packet that Aisha decides to send (which we call the\noriginal packet\n). Let $$$B$$$ be the packet that is received by Basma (which we call the\ntainted packet\n). For each $$$i$$$, such that $$$0 \\le i < 31$$$:\nif Cleopatra does not control the bit with index $$$i$$$ ($$$C[i] = 0$$$), Basma receives bit $$$i$$$ as sent by Aisha ($$$B[i] = A[i]$$$),\notherwise, if Cleopatra controls the bit with index $$$i$$$ ($$$C[i] = 1$$$), the value of $$$B[i]$$$ is decided by Cleopatra.\nImmediately after sending each packet, Aisha learns what the corresponding tainted packet is.\nAfter Aisha sends all the packets, Basma receives all the tainted packets\nin the order they were sent\nand has to reconstruct the original message $$$M$$$.\nYour task is to devise and implement a strategy that would allow Aisha to send the message $$$M$$$ to Basma, so that Basma can recover $$$M$$$ from the tainted packets. Specifically, you should implement two procedures. The first procedure performs the actions of Aisha. It is given a message $$$M$$$ and the array $$$C$$$, and should send some packets to transfer the message to Basma. The second procedure performs the actions of Basma. It is given the tainted packets and should recover the original message $$$M$$$.\nImplementation Details\nThe first procedure you should implement is:\nvoid send_message(std::vector<bool> M, std::vector<bool> C)\n$$$M$$$: an array of length $$$S$$$ describing the message that Aisha wants to send to Basma.\n$$$C$$$: an array of length $$$31$$$ indicating the indices of bits controlled by Cleopatra.\nThis procedure may be called\nat most 2100 times\nin each test case.\nThis procedure should call the following procedure to send a packet:\nstd::vector<bool> send_packet(std::vector<bool> A)\n$$$A$$$: an original packet (an array of length $$$31$$$) representing the bits sent by Aisha.\nThis procedure returns a tainted packet $$$B$$$ representing the bits that will be received by Basma.\nThis procedure can be called at most $$$100$$$ times in each invocation of\nsend_message\n.\nThe second procedure you should implement is:\nstd::vector<bool> receive_message(std::vector<std::vector<bool» R)\n$$$R$$$: an array describing the tainted packets. The packets originate from packets sent by Aisha in one\nsend_message\ncall and are given\nin the order they were sent\nby Aisha. Each element of $$$R$$$ is an array of length $$$31$$$, representing a tainted packet.\nThis procedure should return an array of $$$S$$$ bits that is equal to the original message $$$M$$$.\nThis procedure may be called\nmultiple times\nin each test case,\nexactly once\nfor each corresponding\nsend_message\ncall. The\norder of\nreceive_message\nprocedure calls\nis not necessarily the same as the order of the corresponding\nsend_message\ncalls.\nNote that in the grading system the\nsend_message\nand\nreceive_message\nprocedures are called in\ntwo separate programs\n.\nInput\nThe sample grader is not adaptive. Instead, Cleopatra fills consecutive bits she controls with alternating $$$0$$$ and $$$1$$$ bits, as described in the example above.\nThe first line of the input contains an integer $$$T$$$, specifying the number of scenarios.\n$$$T$$$ scenarios follow. Each of them is provided in the following format:\nline $$$1$$$: $$$S$$$ ($$$1\\le S \\le 1024$$$)\nline $$$2$$$: $$$M[0]\\; M[1]\\ldots M[S-1]$$$\nline $$$3$$$: $$$C[0]\\; C[1]\\ldots C[30]$$$\n$$$C$$$ has exactly $$$31$$$ elements, out of which $$$16$$$ are equal to $$$0$$$ and $$$15$$$ are equal to $$$1$$$.\nOutput\nThe sample grader writes the result of each of the $$$T$$$ scenarios in the same order as they are provided in the input in the following format:\nline $$$1$$$: $$$K$$$ $$$L$$$\nline $$$2$$$: $$$D[0]\\; D[1]\\; \\ldots D[L-1]$$$\nHere, $$$K$$$ is the number of calls to\nsend_packet\n, $$$D$$$ is the message returned by\nreceive_message\nand $$$L$$$ is its length.\nScoring\nIf in any of the test cases, the calls to the procedure\nsend_packet\ndo not conform to the rules mentioned above, or the return value of any of the calls to procedure\nreceive_message\nis incorrect, the score of your solution for that test case will be $$$0$$$.\nOtherwise, let $$$Q$$$ be the maximum number of calls to the procedure\nsend_packet\namong all invocations of\nsend_message\nover all test cases. Also let $$$X$$$ be equal to:\n1, if $$$Q \\le 66$$$\n$$$0.95^{Q-66}$$$, if $$$66 < Q \\le 100$$$\nThen, the score is calculated as follows:\nSubtask\nScore\nAdditional Constraints\n1\n$$$10 \\cdot X$$$\n$$$S \\le 64$$$\n2\n$$$90 \\cdot X$$$\nNo additional constraints.\nNote that in some cases the behaviour of the grader can be\nadaptive\n. This means that the values returned by\nsend_packet\nmay depend not just on its input arguments but also on many other things, including the inputs and return values of the prior calls to this procedure and pseudo- random numbers generated by the grader. The grader is\ndeterministic\nin the sense that if you run it twice and in both runs you send the same packets, it will make the same changes to them.\nNote\nConsider the following call.\nsend_message([0, 1, 1, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\nThe message that Aisha tries to send to Basma is $$$[0,\\; 1,\\; 1,\\; 0]$$$. The bits with indices from $$$0$$$ to $$$15$$$ cannot be changed by Cleopatra, while the bits with indices from $$$16$$$ to $$$30$$$ can be changed by Cleopatra.\nFor the sake of this example, let us assume that Cleopatra fills consecutive bits she controls with alternating $$$0$$$ and $$$1$$$, i.e. she assigns $$$0$$$ to the first index she controls (index $$$16$$$ in our case), $$$1$$$ to the second index she controls (index $$$17$$$), $$$0$$$ to the third index she controls (index $$$18$$$), and so on.\nAisha can decide to send two bits from the original message in one packet as follows: she will send the first bit at the first $$$8$$$ indices she controls and the second bit at the following $$$8$$$ indices she controls.\nAisha then chooses to send the following packet:\nsend_packet([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\nNote that Cleopatra can change bits with the last $$$15$$$ indices, so Aisha can set them arbitrarily, as they might be overwritten. With the assumed strategy of Cleopatra, the procedure returns: $$$[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]$$$. Aisha decides to send the last two bits of $$$M$$$ in the second packet in a similar way as before:\nsend_packet([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\nWith the assumed strategy of Cleopatra, the procedure returns: [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0].\nAisha can send more packets, but she chooses not to.\nThe grader then makes the following procedure call:\nreceive_message([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]])\nBasma recovers message $$$M$$$ as follows. From each packet she takes the first bit that occurs twice in a row, and the last bit that occurs twice in a row. That is, from the first packet, she takes bits $$$[0,\\; 1]$$$, and from the second packet she takes bits $$$[1,\\; 0]$$$. By putting them together, she recovers the message $$$[0,\\; 1,\\; 1,\\; 0]$$$, which is the correct return value for this call to\nreceive_message\n.\nIt can be shown that with the assumed strategy of Cleopatra and for messages of length $$$4$$$, this approach of Basma correctly recovers $$$M$$$, regardless of the value of $$$C$$$. However, it is not correct in the general case."
    },
    "original": "Aisha and Basma are two friends who correspond with each other. Aisha has a message $$$M$$$, which is a sequence of $$$S$$$ bits (i.e., zeroes or ones), that she would like to send to Basma. Aisha communicates with Basma by sending her\npackets\n. A packet is a sequence of $$$31$$$ bits indexed from $$$0$$$ to $$$30$$$. Aisha would like to send the message $$$M$$$ to Basma by sending her some number of packets.\nUnfortunately, Cleopatra compromised the communication between Aisha and Basma and is able to\ntaint\nthe packets. That is, in each packet Cleopatra can modify bits on exactly $$$15$$$ indices. Specifically, there is an array $$$C$$$ of length $$$31$$$, in which every element is either $$$0$$$ or $$$1$$$, with the following meaning:\n$$$C[i] = 1$$$ indicates that the bit with index $$$i$$$ can be changed by Cleopatra. We call these indices\ncontrolled\nby Cleopatra.\n$$$C[i] = 0$$$ indicates that bit with index $$$i$$$ cannot be changed by Cleopatra.\nThe array $$$C$$$ contains precisely $$$15$$$ ones and $$$16$$$ zeroes. While sending the message $$$M$$$ , the set of indices controlled by Cleopatra stays the same for all packets. Aisha knows precisely which $$$15$$$ indices are controlled by Cleopatra. Basma only knows that $$$15$$$ indices are controlled by Cleopatra, but she does not know which indices.\nLet $$$A$$$ be a packet that Aisha decides to send (which we call the\noriginal packet\n). Let $$$B$$$ be the packet that is received by Basma (which we call the\ntainted packet\n). For each $$$i$$$, such that $$$0 \\le i < 31$$$:\nif Cleopatra does not control the bit with index $$$i$$$ ($$$C[i] = 0$$$), Basma receives bit $$$i$$$ as sent by Aisha ($$$B[i] = A[i]$$$),\notherwise, if Cleopatra controls the bit with index $$$i$$$ ($$$C[i] = 1$$$), the value of $$$B[i]$$$ is decided by Cleopatra.\nImmediately after sending each packet, Aisha learns what the corresponding tainted packet is.\nAfter Aisha sends all the packets, Basma receives all the tainted packets\nin the order they were sent\nand has to reconstruct the original message $$$M$$$.\nYour task is to devise and implement a strategy that would allow Aisha to send the message $$$M$$$ to Basma, so that Basma can recover $$$M$$$ from the tainted packets. Specifically, you should implement two procedures. The first procedure performs the actions of Aisha. It is given a message $$$M$$$ and the array $$$C$$$, and should send some packets to transfer the message to Basma. The second procedure performs the actions of Basma. It is given the tainted packets and should recover the original message $$$M$$$.\nImplementation Details\nThe first procedure you should implement is:\nvoid send_message(std::vector<bool> M, std::vector<bool> C)\n$$$M$$$: an array of length $$$S$$$ describing the message that Aisha wants to send to Basma.\n$$$C$$$: an array of length $$$31$$$ indicating the indices of bits controlled by Cleopatra.\nThis procedure may be called\nat most 2100 times\nin each test case.\nThis procedure should call the following procedure to send a packet:\nstd::vector<bool> send_packet(std::vector<bool> A)\n$$$A$$$: an original packet (an array of length $$$31$$$) representing the bits sent by Aisha.\nThis procedure returns a tainted packet $$$B$$$ representing the bits that will be received by Basma.\nThis procedure can be called at most $$$100$$$ times in each invocation of\nsend_message\n.\nThe second procedure you should implement is:\nstd::vector<bool> receive_message(std::vector<std::vector<bool» R)\n$$$R$$$: an array describing the tainted packets. The packets originate from packets sent by Aisha in one\nsend_message\ncall and are given\nin the order they were sent\nby Aisha. Each element of $$$R$$$ is an array of length $$$31$$$, representing a tainted packet.\nThis procedure should return an array of $$$S$$$ bits that is equal to the original message $$$M$$$.\nThis procedure may be called\nmultiple times\nin each test case,\nexactly once\nfor each corresponding\nsend_message\ncall. The\norder of\nreceive_message\nprocedure calls\nis not necessarily the same as the order of the corresponding\nsend_message\ncalls.\nNote that in the grading system the\nsend_message\nand\nreceive_message\nprocedures are called in\ntwo separate programs\n.\nInput\nThe sample grader is not adaptive. Instead, Cleopatra fills consecutive bits she controls with alternating $$$0$$$ and $$$1$$$ bits, as described in the example above.\nThe first line of the input contains an integer $$$T$$$, specifying the number of scenarios.\n$$$T$$$ scenarios follow. Each of them is provided in the following format:\nline $$$1$$$: $$$S$$$ ($$$1\\le S \\le 1024$$$)\nline $$$2$$$: $$$M[0]\\; M[1]\\ldots M[S-1]$$$\nline $$$3$$$: $$$C[0]\\; C[1]\\ldots C[30]$$$\n$$$C$$$ has exactly $$$31$$$ elements, out of which $$$16$$$ are equal to $$$0$$$ and $$$15$$$ are equal to $$$1$$$.\nOutput\nThe sample grader writes the result of each of the $$$T$$$ scenarios in the same order as they are provided in the input in the following format:\nline $$$1$$$: $$$K$$$ $$$L$$$\nline $$$2$$$: $$$D[0]\\; D[1]\\; \\ldots D[L-1]$$$\nHere, $$$K$$$ is the number of calls to\nsend_packet\n, $$$D$$$ is the message returned by\nreceive_message\nand $$$L$$$ is its length.\nScoring\nIf in any of the test cases, the calls to the procedure\nsend_packet\ndo not conform to the rules mentioned above, or the return value of any of the calls to procedure\nreceive_message\nis incorrect, the score of your solution for that test case will be $$$0$$$.\nOtherwise, let $$$Q$$$ be the maximum number of calls to the procedure\nsend_packet\namong all invocations of\nsend_message\nover all test cases. Also let $$$X$$$ be equal to:\n1, if $$$Q \\le 66$$$\n$$$0.95^{Q-66}$$$, if $$$66 < Q \\le 100$$$\nThen, the score is calculated as follows:\nSubtask\nScore\nAdditional Constraints\n1\n$$$10 \\cdot X$$$\n$$$S \\le 64$$$\n2\n$$$90 \\cdot X$$$\nNo additional constraints.\nNote that in some cases the behaviour of the grader can be\nadaptive\n. This means that the values returned by\nsend_packet\nmay depend not just on its input arguments but also on many other things, including the inputs and return values of the prior calls to this procedure and pseudo- random numbers generated by the grader. The grader is\ndeterministic\nin the sense that if you run it twice and in both runs you send the same packets, it will make the same changes to them.\nNote\nConsider the following call.\nsend_message([0, 1, 1, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\nThe message that Aisha tries to send to Basma is $$$[0,\\; 1,\\; 1,\\; 0]$$$. The bits with indices from $$$0$$$ to $$$15$$$ cannot be changed by Cleopatra, while the bits with indices from $$$16$$$ to $$$30$$$ can be changed by Cleopatra.\nFor the sake of this example, let us assume that Cleopatra fills consecutive bits she controls with alternating $$$0$$$ and $$$1$$$, i.e. she assigns $$$0$$$ to the first index she controls (index $$$16$$$ in our case), $$$1$$$ to the second index she controls (index $$$17$$$), $$$0$$$ to the third index she controls (index $$$18$$$), and so on.\nAisha can decide to send two bits from the original message in one packet as follows: she will send the first bit at the first $$$8$$$ indices she controls and the second bit at the following $$$8$$$ indices she controls.\nAisha then chooses to send the following packet:\nsend_packet([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\nNote that Cleopatra can change bits with the last $$$15$$$ indices, so Aisha can set them arbitrarily, as they might be overwritten. With the assumed strategy of Cleopatra, the procedure returns: $$$[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]$$$. Aisha decides to send the last two bits of $$$M$$$ in the second packet in a similar way as before:\nsend_packet([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\nWith the assumed strategy of Cleopatra, the procedure returns: [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0].\nAisha can send more packets, but she chooses not to.\nThe grader then makes the following procedure call:\nreceive_message([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]])\nBasma recovers message $$$M$$$ as follows. From each packet she takes the first bit that occurs twice in a row, and the last bit that occurs twice in a row. That is, from the first packet, she takes bits $$$[0,\\; 1]$$$, and from the second packet she takes bits $$$[1,\\; 0]$$$. By putting them together, she recovers the message $$$[0,\\; 1,\\; 1,\\; 0]$$$, which is the correct return value for this call to\nreceive_message\n.\nIt can be shown that with the assumed strategy of Cleopatra and for messages of length $$$4$$$, this approach of Basma correctly recovers $$$M$$$, regardless of the value of $$$C$$$. However, it is not correct in the general case.",
    "_meta": {
      "index": 16,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/B",
      "uuid": "ps_cfa163cc7dc05e57eac0d410594dbe80853d601b"
    }
  },
  {
    "planning_view": {
      "title": "D. Languages",
      "task": "Identify language of 10,000 Wikipedia excerpts using correct/incorrect feedback after each guess",
      "given": [
        "56 languages (0-55) with Wikipedia excerpts",
        "Each excerpt: 100 symbols (1-65535)",
        "10,000 excerpts total in sequence"
      ],
      "goal": "Guess the language of each excerpt with maximum accuracy",
      "key_rules": [
        "Grader reveals correct language after each guess for learning",
        "Excerpts processed sequentially (10,000 total)",
        "Symbol encoding is arbitrary (1-65535) not Unicode"
      ],
      "target": {
        "1": {
          "points": 30,
          "req": "Achieve accuracy ≥0.3"
        },
        "2": {
          "points": 80,
          "req": "Score = 114×(accuracy - 0.3), max 110 points"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Languages",
      "contest": "IOI 2010 day 1",
      "one_line": "Identify language of 10,000 Wikipedia excerpts using correct/incorrect feedback after each guess",
      "given": [
        "56 languages (0-55) with Wikipedia excerpts",
        "Each excerpt: 100 symbols (1-65535)",
        "10,000 excerpts total in sequence"
      ],
      "goal": "Guess the language of each excerpt with maximum accuracy",
      "mechanism": "Call language(L) after each excerpt; grader returns correct language for learning",
      "success_condition": "Accuracy = fraction of correct guesses across all 10,000 excerpts",
      "constraints": {
        "critical": [
          "Grader reveals correct language after each guess for learning",
          "Excerpts processed sequentially (10,000 total)",
          "Symbol encoding is arbitrary (1-65535) not Unicode"
        ],
        "subtasks": {
          "1": {
            "points": 30,
            "req": "Achieve accuracy ≥0.3"
          },
          "2": {
            "points": 80,
            "req": "Score = 114×(accuracy - 0.3), max 110 points"
          }
        }
      },
      "limits": {
        "time": "5 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Languages",
        "contest": "IOI 2010 day 1",
        "one_line": "Identify language of 10,000 Wikipedia excerpts using correct/incorrect feedback after each guess"
      },
      "problem": {
        "given": [
          "56 languages (0-55) with Wikipedia excerpts",
          "Each excerpt: 100 symbols (1-65535)",
          "10,000 excerpts total in sequence"
        ],
        "goal": "Guess the language of each excerpt with maximum accuracy",
        "mechanism": "Call language(L) after each excerpt; grader returns correct language for learning",
        "success_condition": "Accuracy = fraction of correct guesses across all 10,000 excerpts"
      },
      "constraints": {
        "critical": [
          "Grader reveals correct language after each guess for learning",
          "Excerpts processed sequentially (10,000 total)",
          "Symbol encoding is arbitrary (1-65535) not Unicode"
        ],
        "subtasks": {
          "1": {
            "points": 30,
            "req": "Achieve accuracy ≥0.3"
          },
          "2": {
            "points": 80,
            "req": "Score = 114×(accuracy - 0.3), max 110 points"
          }
        }
      },
      "implementation": {
        "function_to_write": "void excerpt(const std::vector<int>& E)",
        "available_api": {
          "language": {
            "signature": "int language(int L)",
            "params": "L: guessed language (0-55)",
            "returns": "Correct language for current excerpt",
            "side_effect": "None - used for scoring and learning"
          }
        },
        "requirements": [
          "Must call language(L) exactly once per excerpt call",
          "Symbols are integers 1-65535",
          "Languages are integers 0-55"
        ]
      },
      "limits": {
        "time": "5 seconds",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "You are to write an interactive program that, given a sequence of Wikipedia excerpts (see example below), guesses the language of each, in turn. After each guess, your program is given the correct answer, so that it may learn to make better guesses the longer it plays.\nEach language is represented by a number L between $$$0$$$ and $$$55$$$. Each excerpt has exactly $$$100$$$ symbols, represented as an array $$$E$$$ of $$$100$$$ integers between $$$1$$$ and $$$65\\,535$$$. These integers between $$$1$$$ and $$$65\\,535$$$ have been assigned arbitrarily, and do not correspond to any standard encoding.\nYou are to implement the procedure\nexcerpt(E)\nwhere $$$E$$$ is an array of $$$100$$$ numbers representing a Wikipedia excerpt as described above. Your implementation must call\nlanguage(L)\nonce, where $$$L$$$ is its guess of the language of the Wikipedia edition from which $$$E$$$ was extracted. The grading server implements\nlanguage(L)\n, which scores your guess and returns the correct language. That is, the guess was correct if\nlanguage(L) = L\n.\nThe grading server calls\nexcerpt(E)\n$$$10\\,000$$$ times, once for each excerpt in its input file. Your implementation's accuracy is the fraction of excerpts for which\nexcerpt(E)\nguessed the correct language.\nYou may use any method you wish to solve this problem. Rocchio's method is an approach that will yield accuracy of approximately $$$0.4$$$. Rocchio's method computes the similarity of $$$E$$$ to each language $$$L$$$ seen so far, and chooses the language that is most similar. Similarity is defined as the total number of distinct symbols in E that appear anywhere among the previous excerpts from language\nL\n.\nNote that the input data have been downloaded from real Wikipedia articles, and that there may be a few malformed characters or fragments of text. This is to be expected, and forms part of the task.\nFor illustration only, we show the textual representation of excerpts from 56 language-specific editions of Wikipedia.\n1. Yshokkie word meestal in Kanada , die noorde van die VSA en in Europa gespeel. Dit is bekend as 'n b\n2. وهو المنتج الذي يجعل المنظم ال يكسب ربحا وال يخسر ويحصل على ، Producer Marginal المنتج الحدي دخل يكف\n3. \"BAKILI\" Futbol Klubu 1995-ci ildə Misir Səttаr oğlu Əbilov tərəfindən yаrаdılmış və həvəskаr futbol\n4. Квинт Фулвий Флак (Quintus Fulvius Flaccus; † 205 пр.н.е. ) e политик и генерал на Римската републик\n5. ইন্ডিয়ান ইনস্টিটিউি অফ স ়াশ্য়াল ওযযলযফয়ার অয়াি স্টিজযন ম্য়াযনজযম্ন্ট ( ংযেযে আইআইএ ডস্টিউস্টিএম্ )\n6. 5. juni ( lipanj ) ( 5.6. ) je 156. dan godine po gregorijanskom kalendaru (157. u prestupnoj godini\n7. La Caunette és un municipi francès , situat al departament de l' Erau i a la regió de Llenguadoc-Ros\n8. Praha je malé městečko v Texasu , které leží cca 85 km na jihozápad od Austinu . Bylo založeno\n9. Graeme Allen Brown (født 9. april 1979 i Darwin , Northern Territory , Australien ) er en australsk\n10. Der Plattiger Habach ( 3.214 m ü. A. , nach anderen Angaben nur 3.207 m [1] )\n11. Το Νησί Γκρέιτ Μπάρριερ ( Αγγλικά : Great Barrier Island , Μαορί : Motu Aotea ) είναι νησί στα βόρει\n12. Sid Bernstein Presents... is a 2010 feature-length documentary film by directors Jason Ressler and E\n13. El término latino lex loci celebrationis aplicado al derecho internacional privado quiere decir: \"le\n14. Apollo 5 oli kosmoselaev , mis sooritas Apollo programmi teise mehitamata lennu. Lennu käigus testit\n15. هزار و سیصد و پنجاهمین سیارک( TAنامگذاری :1934 ، Rosselia به انگلیسی : 1350 (سیارک ۱۳۵۰ کشف شدهاس\n16. V. I. Beretti (myös Vikenty Ivanovitš Beretti , alk. Vincent Beretti ; 1781 Milano Italia – 18. elok\n17. Le 5 e bataillon de parachutistes vietnamiens (ou 5 e BPVN ou encore 5 e Bawouan ) est une unité par\n18. Amina Sarauniyar Zazzau,, wadda ta rayu daga shekarar 1533 zuwa 1610, ɗaya ce daga cikin 'ya'ya biyu\nב מתמטיקה , השערת רימן היא השערה שהציע בשנת 1859 ה מתמטיקאי ברנרד רימן , מגדולי .19 המתמטיקאים של אותה ע\n20. Sudski proces Doe protiv Boltona je sudski proces iz 1973 . godine kojim je američki Vrhovni sud uki\n21. Owen Cunningham Wilson ( 1968 . november 18. , Dallas , Texas , Egyesült Államok ) amerikai színész\n22. Հայ Կաթողիկե Եկեղեցին պատկանում է Արևելյան Կաթոլիկ Եկեղեցիներին և այսպիսով ենթարկվում է Հռոմի Պապի ա\n23. Dionysios dari Halicarnassus ( Bahasa Yunani : Διονύσιος Ἀλεξάνδρου Ἀλικαρνᾱσσεύς , Dionysios putra\n24. Nnamdi \"Zik\" Azikiwe , bu onye isi-ala izizi Nijiria nwere. Ochichi ya bidolu na afo 1954 welu ruo n\n25. La Riserva naturale orientata Serre della Pizzuta è un'area protetta del dipartimento Regionale di S\n26. 石橋和義 （いしばし かずよし/まさよし、生没年不詳）は、詳。 石橋氏 初 代当主。初名氏義。 尾張 三郎を通称とし、官途は、 左近将監 → 三河守 → 左 衛門佐 。 足利直義\n27. კორბინ ბლიუ ( ინგლ. Corbin Bleu ; დ. 21 თებერვალი , 1989 , დაბადების ადგილი ბრუკლინი , ნიუ-იორკი , ა\n28. Та́рья Ка́арина Ха́лонен (Tarja Kaarina Halonen)); 24 желтоқсан , 1943 , Каллио , Хельсинки , Финлан\n29. 딜롱 ( Dilong )은 중국 랴오닝(Liaoning) 지방의 익시안충(Yixian Formation)에서 온전한 4구의 화석으로 발견되었다. 이 공룡은 가장 원시적인 초기의 티\n30. Сүймөнкул Чокморов - советтик актёр. Жетинин айынын 9 (ноябрь) 1939-жылы, Фрунзе шаарын жанындагы Чо\n31. D' Mirjam vun Abellin war eng Nonn a Mystikerin , och \" Maria vum gekräizegte Jesus \" genannt. Si as\n32. Panopea abrupta ( angl. Geoduck ) - jūrinių dvigeldžių moliuskų rūšis, priklausanti Hiatellidae šeim\n33. \"Dzimis Latvijā\" ir Liepājas dueta Fomins & Kleins 2004 . gada 23. februārī izdotais otrais albu\n34. I Ludwik Lejzer Zamenhof dia dokotera mpijery maso nipetraka any Polonia . Fantantsika izy ankehitri\n35. Седумстотини милиони малечки алвеоли во белите дробови , всушност се шупливи чаури - алвеоли прекрие\n36. Энэхүү шувуу нь Бутан , Хятад , Гонконг , Энэтхэг , Пакистан , Иран , Япон , Казакстан , Солонгос ,\n37. भारतातील महाराष्ट्रराज्याच्या नागपूर पासुन २१६ कि.मी. दू र असलेलेएि गाव. तेवैनगंगा नदीच्या िाठावर\n38. De Slotervaart was oorspronkelijk de waterweg die sinds de Middeleeuwen het dorp Sloten verbond met\n39. Macierz S (macierz rozpraszania, od ang. scattering matrix ) jest centralnym elementem w mechanice k\n40. A Hora do Rush 3 ( Rush Hour 3 , no original) é o terceiro filme da franquia Rush Hour . Dirigido po\n41. Coordonate : 51°34′0″N 12°3′0″E / 51.56667 , 12.05 Brachstedt este o comună din landul Saxonia-A\n42. Гробницы императоров династии Мин и Цин — памятник Всемирного наследия ЮНЕСКО , состоящий из несколь\n43. Kovalentni radijus atoma - ponekad se naziva i valentni radijus. Kovalentni radijus je srednje rasto\n44. Koniecpol je mesto v Poľsku v Sliezskom vojvodstve v okrese Powiat częstochowski v rovnomennej gmine\n45. Hoxhë Vokrri vije nga Shqipëria ishte një klerik shqiptar i cili luftonte për Çështjën Kombëtare . A\n46. Гурдијеље је насеље у општини Тутин у Рашком округу . Према попису из 2002. било је 93 становника (п\n47. Underhållsstöd betalas ut av Försäkringskassan (FK) till en förälder som är vårdnadshavare och bor e\n48. இந்தியாவின் தேசிய நநடுஞ்சாலைகள் நடுவண் அரசின் தேசிய நநடுஞ்சாலைே்துலையாை் பராமரிக்கப்படுகின் ைன. நபரு\n49. Дар он зиндаги .маишат ,фаолияти мехнати,муборизаи ичтимои, русуму омол, хислат ва эхсосоти халк ифо\n50. ไฟทอฟธอรา อินเฟสทันส ( อังกฤษ : Phytophthora infestans ) คอืเชือ้ ราโอโอไมซีท หรือ ราน ้า ที ่ เป็นสาเห\n51. ABUL FAWARIS BERRANY - 11. asyrda Orta Aziýadaky oguz taýpalarynyň berrany dinastiýasynyň wekili. Ol\n52. Egemenlik ya da hâkimiyet , bir toprak parçası ya da mekan üzerindeki kural koyma gücü ve hukuk yara\n53. Темне фентезі (від англ. Dark Fantasy - темне, похмуре фентезі ) - піджанр літератури, який включает\n54. Paris By Night 84: In Atlanta - Passport to Music & Fashion (Âm nhạc và Thời trang) là chương tr\n55. ISO 3166-2:GU ni akoole ninu ISO 3166-2 , apa opagun ISO 3166 ti International Organization for Stan\n56. 下卡姆斯克 （ 俄文 ： Нижнека́мск ； 韃靼語 ： Түбəн Кама/Tübän Kama ）是 俄 羅斯 韃靼斯坦共和國 東北部的一個城市，位於 卡馬河 南岸。 2002年 人口22\nThe sample input, you can download with grader archive, contains 10 000 such examples. The 56 languages are those listed as \"mother tongue\" in the IOI 2010 registration data. The language for each excerpt is chosen at random from these 56 languages, and each excerpt is taken from the first paragraph of an article chosen at random from the corresponding Wikipedia edition. Each line of the file contains:\nThe two-letter ISO code for the Wikipedia language edition;\n100 numbers between 1 and 65 535, representing the first 100 symbols, in sequence, of the first paragraph of the article;\nThe official grader uses 10 000 different excerpts, selected in the same way from the same 56 Wikipedia editions. However, the grader assigns a different number between 0 and 55 to each language, and a different number between 1 and 65 535 to each symbol.\nScoring\nSubtask 1 [30 points]\nYour submission must achieve accuracy of $$$0.3$$$ or better on the grading server.\nSubtask 2 [up to 80 points]\nYour score will be $$$114\\cdot (\\alpha - 0.3)$$$, rounded to the nearest integer, where $$$\\alpha$$$ is the accuracy of your submission.\nYou would be tested on both example and secret test. You can receive at most $$$110$$$ points on secret test. Because of technical reasons, we can't set $$$0$$$ points for public test. So, you can receive $$$0.01$$$ points for public test. Don't be surprised much by this."
    },
    "original": "You are to write an interactive program that, given a sequence of Wikipedia excerpts (see example below), guesses the language of each, in turn. After each guess, your program is given the correct answer, so that it may learn to make better guesses the longer it plays.\nEach language is represented by a number L between $$$0$$$ and $$$55$$$. Each excerpt has exactly $$$100$$$ symbols, represented as an array $$$E$$$ of $$$100$$$ integers between $$$1$$$ and $$$65\\,535$$$. These integers between $$$1$$$ and $$$65\\,535$$$ have been assigned arbitrarily, and do not correspond to any standard encoding.\nYou are to implement the procedure\nexcerpt(E)\nwhere $$$E$$$ is an array of $$$100$$$ numbers representing a Wikipedia excerpt as described above. Your implementation must call\nlanguage(L)\nonce, where $$$L$$$ is its guess of the language of the Wikipedia edition from which $$$E$$$ was extracted. The grading server implements\nlanguage(L)\n, which scores your guess and returns the correct language. That is, the guess was correct if\nlanguage(L) = L\n.\nThe grading server calls\nexcerpt(E)\n$$$10\\,000$$$ times, once for each excerpt in its input file. Your implementation's accuracy is the fraction of excerpts for which\nexcerpt(E)\nguessed the correct language.\nYou may use any method you wish to solve this problem. Rocchio's method is an approach that will yield accuracy of approximately $$$0.4$$$. Rocchio's method computes the similarity of $$$E$$$ to each language $$$L$$$ seen so far, and chooses the language that is most similar. Similarity is defined as the total number of distinct symbols in E that appear anywhere among the previous excerpts from language\nL\n.\nNote that the input data have been downloaded from real Wikipedia articles, and that there may be a few malformed characters or fragments of text. This is to be expected, and forms part of the task.\nFor illustration only, we show the textual representation of excerpts from 56 language-specific editions of Wikipedia.\n1. Yshokkie word meestal in Kanada , die noorde van die VSA en in Europa gespeel. Dit is bekend as 'n b\n2. وهو المنتج الذي يجعل المنظم ال يكسب ربحا وال يخسر ويحصل على ، Producer Marginal المنتج الحدي دخل يكف\n3. \"BAKILI\" Futbol Klubu 1995-ci ildə Misir Səttаr oğlu Əbilov tərəfindən yаrаdılmış və həvəskаr futbol\n4. Квинт Фулвий Флак (Quintus Fulvius Flaccus; † 205 пр.н.е. ) e политик и генерал на Римската републик\n5. ইন্ডিয়ান ইনস্টিটিউি অফ স ়াশ্য়াল ওযযলযফয়ার অয়াি স্টিজযন ম্য়াযনজযম্ন্ট ( ংযেযে আইআইএ ডস্টিউস্টিএম্ )\n6. 5. juni ( lipanj ) ( 5.6. ) je 156. dan godine po gregorijanskom kalendaru (157. u prestupnoj godini\n7. La Caunette és un municipi francès , situat al departament de l' Erau i a la regió de Llenguadoc-Ros\n8. Praha je malé městečko v Texasu , které leží cca 85 km na jihozápad od Austinu . Bylo založeno\n9. Graeme Allen Brown (født 9. april 1979 i Darwin , Northern Territory , Australien ) er en australsk\n10. Der Plattiger Habach ( 3.214 m ü. A. , nach anderen Angaben nur 3.207 m [1] )\n11. Το Νησί Γκρέιτ Μπάρριερ ( Αγγλικά : Great Barrier Island , Μαορί : Motu Aotea ) είναι νησί στα βόρει\n12. Sid Bernstein Presents... is a 2010 feature-length documentary film by directors Jason Ressler and E\n13. El término latino lex loci celebrationis aplicado al derecho internacional privado quiere decir: \"le\n14. Apollo 5 oli kosmoselaev , mis sooritas Apollo programmi teise mehitamata lennu. Lennu käigus testit\n15. هزار و سیصد و پنجاهمین سیارک( TAنامگذاری :1934 ، Rosselia به انگلیسی : 1350 (سیارک ۱۳۵۰ کشف شدهاس\n16. V. I. Beretti (myös Vikenty Ivanovitš Beretti , alk. Vincent Beretti ; 1781 Milano Italia – 18. elok\n17. Le 5 e bataillon de parachutistes vietnamiens (ou 5 e BPVN ou encore 5 e Bawouan ) est une unité par\n18. Amina Sarauniyar Zazzau,, wadda ta rayu daga shekarar 1533 zuwa 1610, ɗaya ce daga cikin 'ya'ya biyu\nב מתמטיקה , השערת רימן היא השערה שהציע בשנת 1859 ה מתמטיקאי ברנרד רימן , מגדולי .19 המתמטיקאים של אותה ע\n20. Sudski proces Doe protiv Boltona je sudski proces iz 1973 . godine kojim je američki Vrhovni sud uki\n21. Owen Cunningham Wilson ( 1968 . november 18. , Dallas , Texas , Egyesült Államok ) amerikai színész\n22. Հայ Կաթողիկե Եկեղեցին պատկանում է Արևելյան Կաթոլիկ Եկեղեցիներին և այսպիսով ենթարկվում է Հռոմի Պապի ա\n23. Dionysios dari Halicarnassus ( Bahasa Yunani : Διονύσιος Ἀλεξάνδρου Ἀλικαρνᾱσσεύς , Dionysios putra\n24. Nnamdi \"Zik\" Azikiwe , bu onye isi-ala izizi Nijiria nwere. Ochichi ya bidolu na afo 1954 welu ruo n\n25. La Riserva naturale orientata Serre della Pizzuta è un'area protetta del dipartimento Regionale di S\n26. 石橋和義 （いしばし かずよし/まさよし、生没年不詳）は、詳。 石橋氏 初 代当主。初名氏義。 尾張 三郎を通称とし、官途は、 左近将監 → 三河守 → 左 衛門佐 。 足利直義\n27. კორბინ ბლიუ ( ინგლ. Corbin Bleu ; დ. 21 თებერვალი , 1989 , დაბადების ადგილი ბრუკლინი , ნიუ-იორკი , ა\n28. Та́рья Ка́арина Ха́лонен (Tarja Kaarina Halonen)); 24 желтоқсан , 1943 , Каллио , Хельсинки , Финлан\n29. 딜롱 ( Dilong )은 중국 랴오닝(Liaoning) 지방의 익시안충(Yixian Formation)에서 온전한 4구의 화석으로 발견되었다. 이 공룡은 가장 원시적인 초기의 티\n30. Сүймөнкул Чокморов - советтик актёр. Жетинин айынын 9 (ноябрь) 1939-жылы, Фрунзе шаарын жанындагы Чо\n31. D' Mirjam vun Abellin war eng Nonn a Mystikerin , och \" Maria vum gekräizegte Jesus \" genannt. Si as\n32. Panopea abrupta ( angl. Geoduck ) - jūrinių dvigeldžių moliuskų rūšis, priklausanti Hiatellidae šeim\n33. \"Dzimis Latvijā\" ir Liepājas dueta Fomins & Kleins 2004 . gada 23. februārī izdotais otrais albu\n34. I Ludwik Lejzer Zamenhof dia dokotera mpijery maso nipetraka any Polonia . Fantantsika izy ankehitri\n35. Седумстотини милиони малечки алвеоли во белите дробови , всушност се шупливи чаури - алвеоли прекрие\n36. Энэхүү шувуу нь Бутан , Хятад , Гонконг , Энэтхэг , Пакистан , Иран , Япон , Казакстан , Солонгос ,\n37. भारतातील महाराष्ट्रराज्याच्या नागपूर पासुन २१६ कि.मी. दू र असलेलेएि गाव. तेवैनगंगा नदीच्या िाठावर\n38. De Slotervaart was oorspronkelijk de waterweg die sinds de Middeleeuwen het dorp Sloten verbond met\n39. Macierz S (macierz rozpraszania, od ang. scattering matrix ) jest centralnym elementem w mechanice k\n40. A Hora do Rush 3 ( Rush Hour 3 , no original) é o terceiro filme da franquia Rush Hour . Dirigido po\n41. Coordonate : 51°34′0″N 12°3′0″E / 51.56667 , 12.05 Brachstedt este o comună din landul Saxonia-A\n42. Гробницы императоров династии Мин и Цин — памятник Всемирного наследия ЮНЕСКО , состоящий из несколь\n43. Kovalentni radijus atoma - ponekad se naziva i valentni radijus. Kovalentni radijus je srednje rasto\n44. Koniecpol je mesto v Poľsku v Sliezskom vojvodstve v okrese Powiat częstochowski v rovnomennej gmine\n45. Hoxhë Vokrri vije nga Shqipëria ishte një klerik shqiptar i cili luftonte për Çështjën Kombëtare . A\n46. Гурдијеље је насеље у општини Тутин у Рашком округу . Према попису из 2002. било је 93 становника (п\n47. Underhållsstöd betalas ut av Försäkringskassan (FK) till en förälder som är vårdnadshavare och bor e\n48. இந்தியாவின் தேசிய நநடுஞ்சாலைகள் நடுவண் அரசின் தேசிய நநடுஞ்சாலைே்துலையாை் பராமரிக்கப்படுகின் ைன. நபரு\n49. Дар он зиндаги .маишат ,фаолияти мехнати,муборизаи ичтимои, русуму омол, хислат ва эхсосоти халк ифо\n50. ไฟทอฟธอรา อินเฟสทันส ( อังกฤษ : Phytophthora infestans ) คอืเชือ้ ราโอโอไมซีท หรือ ราน ้า ที ่ เป็นสาเห\n51. ABUL FAWARIS BERRANY - 11. asyrda Orta Aziýadaky oguz taýpalarynyň berrany dinastiýasynyň wekili. Ol\n52. Egemenlik ya da hâkimiyet , bir toprak parçası ya da mekan üzerindeki kural koyma gücü ve hukuk yara\n53. Темне фентезі (від англ. Dark Fantasy - темне, похмуре фентезі ) - піджанр літератури, який включает\n54. Paris By Night 84: In Atlanta - Passport to Music & Fashion (Âm nhạc và Thời trang) là chương tr\n55. ISO 3166-2:GU ni akoole ninu ISO 3166-2 , apa opagun ISO 3166 ti International Organization for Stan\n56. 下卡姆斯克 （ 俄文 ： Нижнека́мск ； 韃靼語 ： Түбəн Кама/Tübän Kama ）是 俄 羅斯 韃靼斯坦共和國 東北部的一個城市，位於 卡馬河 南岸。 2002年 人口22\nThe sample input, you can download with grader archive, contains 10 000 such examples. The 56 languages are those listed as \"mother tongue\" in the IOI 2010 registration data. The language for each excerpt is chosen at random from these 56 languages, and each excerpt is taken from the first paragraph of an article chosen at random from the corresponding Wikipedia edition. Each line of the file contains:\nThe two-letter ISO code for the Wikipedia language edition;\n100 numbers between 1 and 65 535, representing the first 100 symbols, in sequence, of the first paragraph of the article;\nThe official grader uses 10 000 different excerpts, selected in the same way from the same 56 Wikipedia editions. However, the grader assigns a different number between 0 and 55 to each language, and a different number between 1 and 65 535 to each symbol.\nScoring\nSubtask 1 [30 points]\nYour submission must achieve accuracy of $$$0.3$$$ or better on the grading server.\nSubtask 2 [up to 80 points]\nYour score will be $$$114\\cdot (\\alpha - 0.3)$$$, rounded to the nearest integer, where $$$\\alpha$$$ is the accuracy of your submission.\nYou would be tested on both example and secret test. You can receive at most $$$110$$$ points on secret test. Because of technical reasons, we can't set $$$0$$$ points for public test. So, you can receive $$$0.01$$$ points for public test. Don't be surprised much by this.",
    "_meta": {
      "index": 17,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/D",
      "uuid": "ps_304b93c8d11a878700520b7c49fed2015e432731"
    }
  },
  {
    "planning_view": {
      "title": "A5. Pebbling odometer - subtask 5",
      "task": "Find cell with minimum pebbles on 256x256 grid using odometer language",
      "given": [
        "256x256 grid with 0-15 pebbles per cell",
        "Odometer starts at (0,0) facing north",
        "Pebble counts preserved after execution"
      ],
      "goal": "Stop at a cell with minimum pebble count among all cells",
      "key_rules": [
        "Must use odometer-specific language (not general programming)",
        "Grid is 256x256 with coordinates 0-255",
        "Cells can hold 0-15 pebbles",
        "Final grid state must match initial state",
        "Program size determines score (smaller = better)"
      ],
      "target": {
        "5": {
          "points": 28,
          "req": "Find cell with minimum pebbles; score depends on program size"
        }
      }
    },
    "algorithm_view": {
      "title": "A5. Pebbling odometer - subtask 5",
      "contest": "IOI 2012 day 1",
      "one_line": "Find cell with minimum pebbles on 256x256 grid using odometer language",
      "given": [
        "256x256 grid with 0-15 pebbles per cell",
        "Odometer starts at (0,0) facing north",
        "Pebble counts preserved after execution"
      ],
      "goal": "Stop at a cell with minimum pebble count among all cells",
      "mechanism": "Program odometer with movement, pebble detection, and conditional jumps",
      "success_condition": "Odometer stops at cell (i,j) where every other cell has ≥ pebbles than (i,j)",
      "constraints": {
        "critical": [
          "Must use odometer-specific language (not general programming)",
          "Grid is 256x256 with coordinates 0-255",
          "Cells can hold 0-15 pebbles",
          "Final grid state must match initial state",
          "Program size determines score (smaller = better)"
        ],
        "subtasks": {
          "5": {
            "points": 28,
            "req": "Find cell with minimum pebbles; score depends on program size"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A5. Pebbling odometer - subtask 5",
        "contest": "IOI 2012 day 1",
        "one_line": "Find cell with minimum pebbles on 256x256 grid using odometer language"
      },
      "problem": {
        "given": [
          "256x256 grid with 0-15 pebbles per cell",
          "Odometer starts at (0,0) facing north",
          "Pebble counts preserved after execution"
        ],
        "goal": "Stop at a cell with minimum pebble count among all cells",
        "mechanism": "Program odometer with movement, pebble detection, and conditional jumps",
        "success_condition": "Odometer stops at cell (i,j) where every other cell has ≥ pebbles than (i,j)"
      },
      "constraints": {
        "critical": [
          "Must use odometer-specific language (not general programming)",
          "Grid is 256x256 with coordinates 0-255",
          "Cells can hold 0-15 pebbles",
          "Final grid state must match initial state",
          "Program size determines score (smaller = better)"
        ],
        "subtasks": {
          "5": {
            "points": 28,
            "req": "Find cell with minimum pebbles; score depends on program size"
          }
        }
      },
      "implementation": {
        "function_to_write": "Complete odometer program",
        "available_api": {
          "move": {
            "signature": "move",
            "params": "none",
            "returns": "none",
            "side_effect": "Move forward one cell in current direction if possible"
          },
          "left/right": {
            "signature": "left / right",
            "params": "none",
            "returns": "none",
            "side_effect": "Turn 90 degrees left/right"
          },
          "get/put": {
            "signature": "get / put",
            "params": "none",
            "returns": "none",
            "side_effect": "Remove/add pebble from/to current cell"
          },
          "jump/border/pebble": {
            "signature": "jump L / border L / pebble L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Conditional jumps based on border status or pebble presence"
          },
          "halt": {
            "signature": "halt",
            "params": "none",
            "returns": "none",
            "side_effect": "Terminates program"
          }
        },
        "requirements": [
          "Program in odometer-specific language",
          "Max 1 command per line",
          "Labels declared with 'L:' syntax",
          "Comments start with #",
          "Program size ≤ 444 for full score"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask 5. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$."
    },
    "original": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask 5. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$.",
    "_meta": {
      "index": 18,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A5",
      "uuid": "ps_fbcfc69e172709287a13a6f50716aa7ba67ea9d2"
    }
  },
  {
    "planning_view": {
      "title": "A3. Pebbling odometer - subtask 3",
      "task": "Position odometer at midpoint of two pebbles in row 0 under execution limit",
      "given": [
        "256×256 grid with cells (0-255, 0-255)",
        "Odometer starts at (0,0) facing north",
        "Exactly two pebbles in row 0 at distinct positions (0,x) and (0,y)",
        "x + y is even"
      ],
      "goal": "Leave odometer at cell (0, (x+y)/2)",
      "key_rules": [
        "Program must be written in odometer language with ≤100 commands",
        "Execution length ≤200,000 steps",
        "Each command execution counts as a step",
        "Cells hold max 15 pebbles"
      ],
      "target": {
        "3": {
          "points": 19,
          "req": "End at midpoint of two pebbles in row 0"
        }
      }
    },
    "algorithm_view": {
      "title": "A3. Pebbling odometer - subtask 3",
      "contest": "IOI 2012 day 1",
      "one_line": "Position odometer at midpoint of two pebbles in row 0 under execution limit",
      "given": [
        "256×256 grid with cells (0-255, 0-255)",
        "Odometer starts at (0,0) facing north",
        "Exactly two pebbles in row 0 at distinct positions (0,x) and (0,y)",
        "x + y is even"
      ],
      "goal": "Leave odometer at cell (0, (x+y)/2)",
      "mechanism": "Program uses movement commands (left/right/move), pebble manipulation (get/put), and conditional jumps based on border/pebble checks",
      "success_condition": "Odometer ends exactly at midpoint cell between the two pebble positions",
      "constraints": {
        "critical": [
          "Program must be written in odometer language with ≤100 commands",
          "Execution length ≤200,000 steps",
          "Each command execution counts as a step",
          "Cells hold max 15 pebbles"
        ],
        "subtasks": {
          "3": {
            "points": 19,
            "req": "End at midpoint of two pebbles in row 0"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A3. Pebbling odometer - subtask 3",
        "contest": "IOI 2012 day 1",
        "one_line": "Position odometer at midpoint of two pebbles in row 0 under execution limit"
      },
      "problem": {
        "given": [
          "256×256 grid with cells (0-255, 0-255)",
          "Odometer starts at (0,0) facing north",
          "Exactly two pebbles in row 0 at distinct positions (0,x) and (0,y)",
          "x + y is even"
        ],
        "goal": "Leave odometer at cell (0, (x+y)/2)",
        "mechanism": "Program uses movement commands (left/right/move), pebble manipulation (get/put), and conditional jumps based on border/pebble checks",
        "success_condition": "Odometer ends exactly at midpoint cell between the two pebble positions"
      },
      "constraints": {
        "critical": [
          "Program must be written in odometer language with ≤100 commands",
          "Execution length ≤200,000 steps",
          "Each command execution counts as a step",
          "Cells hold max 15 pebbles"
        ],
        "subtasks": {
          "3": {
            "points": 19,
            "req": "End at midpoint of two pebbles in row 0"
          }
        }
      },
      "implementation": {
        "function_to_write": "Complete odometer program file",
        "available_api": {
          "left": {
            "signature": "left",
            "params": "None",
            "returns": "None",
            "side_effect": "Turn 90° counterclockwise"
          },
          "right": {
            "signature": "right",
            "params": "None",
            "returns": "None",
            "side_effect": "Turn 90° clockwise"
          },
          "move": {
            "signature": "move",
            "params": "None",
            "returns": "None",
            "side_effect": "Move forward if possible"
          },
          "get": {
            "signature": "get",
            "params": "None",
            "returns": "None",
            "side_effect": "Remove pebble from current cell if available"
          },
          "put": {
            "signature": "put",
            "params": "None",
            "returns": "None",
            "side_effect": "Add pebble to current cell if <15"
          },
          "halt": {
            "signature": "halt",
            "params": "None",
            "returns": "None",
            "side_effect": "Terminate execution"
          },
          "border": {
            "signature": "border L",
            "params": "L: label name",
            "returns": "None",
            "side_effect": "Jump to label L if at border facing edge"
          },
          "pebble": {
            "signature": "pebble L",
            "params": "L: label name",
            "returns": "None",
            "side_effect": "Jump to label L if current cell has ≥1 pebble"
          },
          "jump": {
            "signature": "jump L",
            "params": "L: label name",
            "returns": "None",
            "side_effect": "Unconditional jump to label L"
          }
        },
        "requirements": [
          "Submit complete .txt file with odometer program",
          "Maximum 5 MiB file size",
          "Labels: case-sensitive strings ≤128 chars (a-z,A-Z,0-9)",
          "Comments with #, empty lines ignored",
          "Label declarations (L:) not counted in program size"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask 3. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$."
    },
    "original": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask 3. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$.",
    "_meta": {
      "index": 19,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A3",
      "uuid": "ps_002f2c9c735edfb06eb5b25da108554f48c9eabd"
    }
  },
  {
    "planning_view": {
      "title": "F. Ancient Books",
      "task": "Sort books on n tables with permutation p starting/ending at s ≤1000000",
      "given": [
        "n tables labeled 0 to n-1",
        "Each table has exactly one ancient book",
        "Permutation p describes final arrangement",
        "Start and end at table s"
      ],
      "goal": "Sort books to correct tables with minimum walking distance",
      "key_rules": [
        "Cannot carry more than one book at a time",
        "Can only pick up from non-empty table when not carrying",
        "Can only swap when carrying and table has book",
        "Can only place when carrying and table is empty"
      ],
      "target": {
        "1": {
          "points": 12,
          "req": "n ≤ 4 and s = 0"
        },
        "2": {
          "points": 10,
          "req": "n ≤ 1000 and s = 0"
        },
        "3": {
          "points": 28,
          "req": "s = 0"
        },
        "4": {
          "points": 20,
          "req": "n ≤ 1000"
        },
        "5": {
          "points": 30,
          "req": "n ≤ 1000000"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Ancient Books",
      "contest": "IOI 2017 day 2",
      "one_line": "Sort books on n tables with permutation p starting/ending at s ≤1000000",
      "given": [
        "n tables labeled 0 to n-1",
        "Each table has exactly one ancient book",
        "Permutation p describes final arrangement",
        "Start and end at table s"
      ],
      "goal": "Sort books to correct tables with minimum walking distance",
      "mechanism": "Librarian can pick up, swap, or place books while moving between tables",
      "success_condition": "Book originally at table i ends at table p[i] for all i",
      "constraints": {
        "critical": [
          "Cannot carry more than one book at a time",
          "Can only pick up from non-empty table when not carrying",
          "Can only swap when carrying and table has book",
          "Can only place when carrying and table is empty"
        ],
        "subtasks": {
          "1": {
            "points": 12,
            "req": "n ≤ 4 and s = 0"
          },
          "2": {
            "points": 10,
            "req": "n ≤ 1000 and s = 0"
          },
          "3": {
            "points": 28,
            "req": "s = 0"
          },
          "4": {
            "points": 20,
            "req": "n ≤ 1000"
          },
          "5": {
            "points": 30,
            "req": "n ≤ 1000000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Ancient Books",
        "contest": "IOI 2017 day 2",
        "one_line": "Sort books on n tables with permutation p starting/ending at s ≤1000000"
      },
      "problem": {
        "given": [
          "n tables labeled 0 to n-1",
          "Each table has exactly one ancient book",
          "Permutation p describes final arrangement",
          "Start and end at table s"
        ],
        "goal": "Sort books to correct tables with minimum walking distance",
        "mechanism": "Librarian can pick up, swap, or place books while moving between tables",
        "success_condition": "Book originally at table i ends at table p[i] for all i"
      },
      "constraints": {
        "critical": [
          "Cannot carry more than one book at a time",
          "Can only pick up from non-empty table when not carrying",
          "Can only swap when carrying and table has book",
          "Can only place when carrying and table is empty"
        ],
        "subtasks": {
          "1": {
            "points": 12,
            "req": "n ≤ 4 and s = 0"
          },
          "2": {
            "points": 10,
            "req": "n ≤ 1000 and s = 0"
          },
          "3": {
            "points": 28,
            "req": "s = 0"
          },
          "4": {
            "points": 20,
            "req": "n ≤ 1000"
          },
          "5": {
            "points": 30,
            "req": "n ≤ 1000000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 minimum_walk(int[] p, int s)",
        "available_api": {},
        "requirements": [
          "Returns minimum total walking distance in meters",
          "Distance between tables i and j is |j-i|",
          "Input array p contains distinct integers 0 to n-1",
          "0 ≤ s ≤ n-1"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "4 0\n0 2 3 1",
          "output": "6"
        }
      ],
      "original_statement": "The city of Tehran is home to the National Library of Iran. The main treasure of this library is located in a long hall with a row of $$$n$$$ tables, labeled $$$0$$$ through $$$n-1$$$ from left to right. On each table there is one ancient handwritten book being displayed. These books are ordered based on their ages, which makes it hard for the visitors to search for books by title. So, the library manager has decided to sort the books in alphabetical order of their titles.\nAryan, a librarian, is going to do the job. He has created a list $$$p$$$ of length $$$n$$$, containing different integers from $$$0$$$ to $$$n-1$$$. This list describes the changes needed to rearrange the books into alphabetical order: for all $$$0 \\le i < n$$$, the book that is currently on table $$$i$$$ should be moved to table $$$p[i]$$$.\nAryan starts sorting the books at table $$$s$$$. He wants to return to the same table after finishing the job. Since the books are very valuable, he cannot carry more than one book at any time. While sorting the books Aryan will perform a sequence of actions. Each of those actions has to be one of the following:\nIf he is not carrying a book and there is a book on the table he is at, he can pick up this book.\nIf he is carrying a book and there is another book on the table he is at, he can switch the book he is carrying with the one on the table.\nIf he is carrying a book and he is at an empty table, he can put the book he is carrying on the table.\nHe can walk to any table. He may carry a single book while he does so.\nFor all $$$0 \\le i, j < n$$$, the distance between tables $$$i$$$ and $$$j$$$ is precisely $$$|j-i|$$$ meters. Your task is to compute the minimum total distance Aryan needs to walk in order to sort all the books.\nImplementation details\nYou should implement the following procedure:\nint64 minimum_walk(int[] p, int s)\n$$$p$$$ is an array of length $$$n$$$. The book that is on table $$$i$$$ at the beginning should be taken by Aryan to table $$$p[i]$$$ (for all $$$0 \\le i < n$$$).\n$$$s$$$ is the label of the table where Aryan is at the beginning, and where he should be after sorting the books.\nThis procedure should return the minimum total distance (in meters) Aryan has to walk in order to sort the books.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$s$$$ ($$$1 \\le n \\le 1\\,000\\,000$$$, $$$0 \\le s \\le n-1$$$)\nline 2: $$$p[0], p[1], \\ldots, [n - 1]$$$\nArray $$$p$$$ contains $$$n$$$ distinct integers between $$$0$$$ and $$$n-1$$$, inclusive.\nOutput\nThe sample grader prints a single line containing the return value of\nminimum_walk\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n12\n$$$n \\le 4$$$ and $$$s = 0$$$\n2\n10\n$$$n \\le 1000$$$ and $$$s = 0$$$\n3\n28\n$$$s = 0$$$\n4\n20\n$$$n \\le 1000$$$\n5\n30\nno additional constraints\nExample\nNote\nminimum_walk([0, 2, 3, 1], 0)\nIn this example, $$$n=4$$$ and Aryan is at table $$$0$$$ at the beginning. He sorts the books as follows:\nHe walks to table $$$1$$$ and picks up the book lying on it. This book should be put on table $$$2$$$.\nThen, he walks to table $$$2$$$ and switches the book he is carrying with the book on the table. The new book he is carrying should be put on table $$$3$$$.\nThen, he walks to table $$$3$$$ and switches the book he is carrying with the book on the table. The new book he is carrying should be put on table $$$1$$$.\nThen, he walks to table $$$1$$$ and puts the book he is carrying on the table.\nFinally, he walks back to table $$$0$$$.\nNote that book on table $$$0$$$ is already in the correct place, table $$$0$$$, so Aryan does not have to pick it up. The total distance he walks in this solution is $$$6$$$ meters. This is the optimal solution; hence, the procedure should return $$$6$$$."
    },
    "original": "The city of Tehran is home to the National Library of Iran. The main treasure of this library is located in a long hall with a row of $$$n$$$ tables, labeled $$$0$$$ through $$$n-1$$$ from left to right. On each table there is one ancient handwritten book being displayed. These books are ordered based on their ages, which makes it hard for the visitors to search for books by title. So, the library manager has decided to sort the books in alphabetical order of their titles.\nAryan, a librarian, is going to do the job. He has created a list $$$p$$$ of length $$$n$$$, containing different integers from $$$0$$$ to $$$n-1$$$. This list describes the changes needed to rearrange the books into alphabetical order: for all $$$0 \\le i < n$$$, the book that is currently on table $$$i$$$ should be moved to table $$$p[i]$$$.\nAryan starts sorting the books at table $$$s$$$. He wants to return to the same table after finishing the job. Since the books are very valuable, he cannot carry more than one book at any time. While sorting the books Aryan will perform a sequence of actions. Each of those actions has to be one of the following:\nIf he is not carrying a book and there is a book on the table he is at, he can pick up this book.\nIf he is carrying a book and there is another book on the table he is at, he can switch the book he is carrying with the one on the table.\nIf he is carrying a book and he is at an empty table, he can put the book he is carrying on the table.\nHe can walk to any table. He may carry a single book while he does so.\nFor all $$$0 \\le i, j < n$$$, the distance between tables $$$i$$$ and $$$j$$$ is precisely $$$|j-i|$$$ meters. Your task is to compute the minimum total distance Aryan needs to walk in order to sort all the books.\nImplementation details\nYou should implement the following procedure:\nint64 minimum_walk(int[] p, int s)\n$$$p$$$ is an array of length $$$n$$$. The book that is on table $$$i$$$ at the beginning should be taken by Aryan to table $$$p[i]$$$ (for all $$$0 \\le i < n$$$).\n$$$s$$$ is the label of the table where Aryan is at the beginning, and where he should be after sorting the books.\nThis procedure should return the minimum total distance (in meters) Aryan has to walk in order to sort the books.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$s$$$ ($$$1 \\le n \\le 1\\,000\\,000$$$, $$$0 \\le s \\le n-1$$$)\nline 2: $$$p[0], p[1], \\ldots, [n - 1]$$$\nArray $$$p$$$ contains $$$n$$$ distinct integers between $$$0$$$ and $$$n-1$$$, inclusive.\nOutput\nThe sample grader prints a single line containing the return value of\nminimum_walk\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n12\n$$$n \\le 4$$$ and $$$s = 0$$$\n2\n10\n$$$n \\le 1000$$$ and $$$s = 0$$$\n3\n28\n$$$s = 0$$$\n4\n20\n$$$n \\le 1000$$$\n5\n30\nno additional constraints\nExample\nNote\nminimum_walk([0, 2, 3, 1], 0)\nIn this example, $$$n=4$$$ and Aryan is at table $$$0$$$ at the beginning. He sorts the books as follows:\nHe walks to table $$$1$$$ and picks up the book lying on it. This book should be put on table $$$2$$$.\nThen, he walks to table $$$2$$$ and switches the book he is carrying with the book on the table. The new book he is carrying should be put on table $$$3$$$.\nThen, he walks to table $$$3$$$ and switches the book he is carrying with the book on the table. The new book he is carrying should be put on table $$$1$$$.\nThen, he walks to table $$$1$$$ and puts the book he is carrying on the table.\nFinally, he walks back to table $$$0$$$.\nNote that book on table $$$0$$$ is already in the correct place, table $$$0$$$, so Aryan does not have to pick it up. The total distance he walks in this solution is $$$6$$$ meters. This is the optimal solution; hence, the procedure should return $$$6$$$.",
    "_meta": {
      "index": 21,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/F",
      "uuid": "ps_d48150686771b4438f3e4e04f3905189b8eb9442"
    }
  },
  {
    "planning_view": {
      "title": "B. Race",
      "task": "Find path length exactly K km using fewest edges in tree, else return -1",
      "given": [
        "N cities (0..N-1) connected by N-1 highways forming a tree",
        "Each highway has integer length in km",
        "Required total path length K"
      ],
      "goal": "Find minimum number of highways on a valid race course of length exactly K",
      "key_rules": [
        "Path must be simple (no repeated cities or highways)",
        "Path must have exactly length K (neither more nor less)",
        "Start and end cities must be different"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "N ≤ 100, K ≤ 100, linear tree structure"
        },
        "2": {
          "points": 12,
          "req": "N ≤ 1,000, K ≤ 1,000,000"
        },
        "3": {
          "points": 22,
          "req": "N ≤ 200,000, K ≤ 100"
        },
        "4": {
          "points": 57,
          "req": "N ≤ 200,000, K ≤ 1,000,000"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Race",
      "contest": "IOI 2011 day 1",
      "one_line": "Find path length exactly K km using fewest edges in tree, else return -1",
      "given": [
        "N cities (0..N-1) connected by N-1 highways forming a tree",
        "Each highway has integer length in km",
        "Required total path length K"
      ],
      "goal": "Find minimum number of highways on a valid race course of length exactly K",
      "mechanism": "The course must be a simple path between two different cities with total length = K",
      "success_condition": "Return the minimum number of edges in such a path, or -1 if no path exists",
      "constraints": {
        "critical": [
          "Path must be simple (no repeated cities or highways)",
          "Path must have exactly length K (neither more nor less)",
          "Start and end cities must be different"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N ≤ 100, K ≤ 100, linear tree structure"
          },
          "2": {
            "points": 12,
            "req": "N ≤ 1,000, K ≤ 1,000,000"
          },
          "3": {
            "points": 22,
            "req": "N ≤ 200,000, K ≤ 100"
          },
          "4": {
            "points": 57,
            "req": "N ≤ 200,000, K ≤ 1,000,000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Race",
        "contest": "IOI 2011 day 1",
        "one_line": "Find path length exactly K km using fewest edges in tree, else return -1"
      },
      "problem": {
        "given": [
          "N cities (0..N-1) connected by N-1 highways forming a tree",
          "Each highway has integer length in km",
          "Required total path length K"
        ],
        "goal": "Find minimum number of highways on a valid race course of length exactly K",
        "mechanism": "The course must be a simple path between two different cities with total length = K",
        "success_condition": "Return the minimum number of edges in such a path, or -1 if no path exists"
      },
      "constraints": {
        "critical": [
          "Path must be simple (no repeated cities or highways)",
          "Path must have exactly length K (neither more nor less)",
          "Start and end cities must be different"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N ≤ 100, K ≤ 100, linear tree structure"
          },
          "2": {
            "points": 12,
            "req": "N ≤ 1,000, K ≤ 1,000,000"
          },
          "3": {
            "points": 22,
            "req": "N ≤ 200,000, K ≤ 100"
          },
          "4": {
            "points": 57,
            "req": "N ≤ 200,000, K ≤ 1,000,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int best_path(int N, int K, vector<vector<int>> H, vector<int> L)",
        "available_api": {},
        "requirements": [
          "Cities are 0-indexed (0 to N-1)",
          "H is 2D array with H[i][0] and H[i][1] for highway endpoints",
          "L contains corresponding highway lengths",
          "Must return minimum edge count or -1"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "4 3\n0 1 1\n1 2 2\n1 3 4",
          "output": "2"
        }
      ],
      "original_statement": "In conjunction with the IOI, Pattaya City will host a race: the International Olympiad in Racing (IOR) 2011. As the host, we have to find the best possible course for the race.\nIn the Pattaya-Chonburi metropolitan area, there are $$$N$$$ cities connected by a network of $$$N-1$$$ highways. Each highway is bidirectional, connects two different cities, and has an integer length in kilometers. Furthermore, there is exactly one possible path connecting any pair of cities. That is, there is exactly one way to travel from one city to another city by a sequence of highways without visiting any city twice.\nThe IOR has specific regulations that require the course to be a path whose total length is exactly $$$K$$$ kilometers, starting and ending in different cities. Obviously, no highway (and therefore also no city) may be used twice on the course to prevent collisions. To minimize traffic disruption, the course must contain as few highways as possible.\nWrite a procedure\nbest_path(N,K,H,L)\nthat takes the following parameters:\n$$$N$$$— the number of cities. The cities are numbered $$$0$$$ through $$$N-1$$$.\n$$$K$$$— the required distance for the race course.\n$$$H$$$— a two-dimensional array representing highways. For $$$0 \\le i < N-1$$$, highway $$$i$$$ connects the cities $$$H[i][0]$$$ and $$$H[i][1]$$$.\n$$$L$$$— a one-dimensional array representing the lengths of the highways. For $$$0 \\le i < N-1$$$, the length of highway $$$i$$$ is $$$L[i]$$$.\nYou may assume that all values in the array $$$H$$$ are between $$$0$$$ and $$$N-1$$$, inclusive, and that the highways described by this array connect all cities as described above. You may also assume that all values in the array $$$L$$$ are integers between $$$0$$$ and $$$1\\,000\\,000$$$, inclusive. Your procedure must return the minimum number of highways on a valid race course of length exactly $$$K$$$. If there is no such course, your procedure must return $$$-1$$$.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$N$$$ and $$$K$$$.\nLines $$$2$$$ to $$$N$$$: information on the highways; i.e., line $$$i+2$$$ contains $$$H[i][0]$$$, $$$H[i][1]$$$, and $$$L[i]$$$, separated by a space, for $$$0 \\le i < N-1$$$.\nLine $$$N+1$$$: the expected solution.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$K$$$\nAdditional Input Constraints\n1\n9\n$$$1 \\le N \\le 100$$$\n$$$1 \\le K \\le 100$$$\nThe network of highways forms the simplest possible line: For $$$0 \\le i < N-1$$$, highway $$$i$$$ connects cities $$$i$$$ and $$$i+1$$$.\n2\n12\n$$$1 \\le N \\le 1\\,000$$$\n$$$1 \\le K \\le 1\\,000\\,000$$$\n—\n3\n22\n$$$1 \\le N \\le 200\\,000$$$\n$$$1 \\le K \\le 100$$$\n—\n4\n57\n$$$1 \\le N \\le 200\\,000$$$\n$$$1 \\le K \\le 1\\,000\\,000$$$\n—\nExamples\nNote\nIn the first example, the course can start in city $$$0$$$, go to city $$$1$$$, and terminate in city $$$2$$$. Its length will be exactly $$$1 + 2 = 3$$$ km, and it consists of two highways. This is the best possible course; therefore\nbest_path(N,K,H,L)\nmust return $$$2$$$.\nThere is no valid course in the second example. In this case,\nbest_path(N,K,H,L)\nmust return $$$-1$$$.\nIn the third example, one possible course consists of $$$3$$$ highways: from city $$$6$$$ via city $$$0$$$ and city $$$2$$$ to city $$$3$$$. Another course starts in city $$$10$$$ and goes via city $$$8$$$ to city $$$6$$$. Both of these courses have length exactly $$$12$$$ km, as required. The second one is optimal, as there is no valid course with a single highway. Hence,\nbest_path(N,K,H,L)\nmust return $$$2$$$."
    },
    "original": "In conjunction with the IOI, Pattaya City will host a race: the International Olympiad in Racing (IOR) 2011. As the host, we have to find the best possible course for the race.\nIn the Pattaya-Chonburi metropolitan area, there are $$$N$$$ cities connected by a network of $$$N-1$$$ highways. Each highway is bidirectional, connects two different cities, and has an integer length in kilometers. Furthermore, there is exactly one possible path connecting any pair of cities. That is, there is exactly one way to travel from one city to another city by a sequence of highways without visiting any city twice.\nThe IOR has specific regulations that require the course to be a path whose total length is exactly $$$K$$$ kilometers, starting and ending in different cities. Obviously, no highway (and therefore also no city) may be used twice on the course to prevent collisions. To minimize traffic disruption, the course must contain as few highways as possible.\nWrite a procedure\nbest_path(N,K,H,L)\nthat takes the following parameters:\n$$$N$$$— the number of cities. The cities are numbered $$$0$$$ through $$$N-1$$$.\n$$$K$$$— the required distance for the race course.\n$$$H$$$— a two-dimensional array representing highways. For $$$0 \\le i < N-1$$$, highway $$$i$$$ connects the cities $$$H[i][0]$$$ and $$$H[i][1]$$$.\n$$$L$$$— a one-dimensional array representing the lengths of the highways. For $$$0 \\le i < N-1$$$, the length of highway $$$i$$$ is $$$L[i]$$$.\nYou may assume that all values in the array $$$H$$$ are between $$$0$$$ and $$$N-1$$$, inclusive, and that the highways described by this array connect all cities as described above. You may also assume that all values in the array $$$L$$$ are integers between $$$0$$$ and $$$1\\,000\\,000$$$, inclusive. Your procedure must return the minimum number of highways on a valid race course of length exactly $$$K$$$. If there is no such course, your procedure must return $$$-1$$$.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$N$$$ and $$$K$$$.\nLines $$$2$$$ to $$$N$$$: information on the highways; i.e., line $$$i+2$$$ contains $$$H[i][0]$$$, $$$H[i][1]$$$, and $$$L[i]$$$, separated by a space, for $$$0 \\le i < N-1$$$.\nLine $$$N+1$$$: the expected solution.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$K$$$\nAdditional Input Constraints\n1\n9\n$$$1 \\le N \\le 100$$$\n$$$1 \\le K \\le 100$$$\nThe network of highways forms the simplest possible line: For $$$0 \\le i < N-1$$$, highway $$$i$$$ connects cities $$$i$$$ and $$$i+1$$$.\n2\n12\n$$$1 \\le N \\le 1\\,000$$$\n$$$1 \\le K \\le 1\\,000\\,000$$$\n—\n3\n22\n$$$1 \\le N \\le 200\\,000$$$\n$$$1 \\le K \\le 100$$$\n—\n4\n57\n$$$1 \\le N \\le 200\\,000$$$\n$$$1 \\le K \\le 1\\,000\\,000$$$\n—\nExamples\nNote\nIn the first example, the course can start in city $$$0$$$, go to city $$$1$$$, and terminate in city $$$2$$$. Its length will be exactly $$$1 + 2 = 3$$$ km, and it consists of two highways. This is the best possible course; therefore\nbest_path(N,K,H,L)\nmust return $$$2$$$.\nThere is no valid course in the second example. In this case,\nbest_path(N,K,H,L)\nmust return $$$-1$$$.\nIn the third example, one possible course consists of $$$3$$$ highways: from city $$$6$$$ via city $$$0$$$ and city $$$2$$$ to city $$$3$$$. Another course starts in city $$$10$$$ and goes via city $$$8$$$ to city $$$6$$$. Both of these courses have length exactly $$$12$$$ km, as required. The second one is optimal, as there is no valid course with a single highway. Hence,\nbest_path(N,K,H,L)\nmust return $$$2$$$.",
    "_meta": {
      "index": 22,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/B",
      "uuid": "ps_033b3a4b7954e18f4199f2ff53ba9f27c3954950"
    }
  },
  {
    "planning_view": {
      "title": "B. Hotter Colder",
      "task": "Find Jill's number in ≤18 calls using hotter/colder responses",
      "given": [
        "Jill has a secret number between 1 and N",
        "First Guess() call returns 'same'",
        "Each subsequent Guess(G) returns hotter/colder/same compared to previous guess"
      ],
      "goal": "Determine Jill's secret number using as few Guess() calls as possible",
      "key_rules": [
        "First Guess() call always returns 'same'",
        "Responses compare current guess to previous guess (not running distance)",
        "Secret number remains fixed during each HC(N) call"
      ],
      "target": {
        "1": {
          "points": 25,
          "req": "At most 500 Guess() calls per HC(N) (N ≤ 500)"
        },
        "2": {
          "points": 25,
          "req": "At most 18 Guess() calls per HC(N) (N ≤ 500)"
        },
        "3": {
          "points": 25,
          "req": "At most 16 Guess() calls per HC(N) (N ≤ 500)"
        },
        "4": {
          "points": "up to 25",
          "req": "Score based on call count relative to W where 2^W ≤ 3N (N ≤ 500,000,000)"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Hotter Colder",
      "contest": "IOI 2010 day 1",
      "one_line": "Find Jill's number in ≤18 calls using hotter/colder responses",
      "given": [
        "Jill has a secret number between 1 and N",
        "First Guess() call returns 'same'",
        "Each subsequent Guess(G) returns hotter/colder/same compared to previous guess"
      ],
      "goal": "Determine Jill's secret number using as few Guess() calls as possible",
      "mechanism": "Call Guess(G) to get response: hotter means G closer to secret than previous guess, colder means farther, same means equal distance",
      "success_condition": "HC(N) must return Jill's exact secret number",
      "constraints": {
        "critical": [
          "First Guess() call always returns 'same'",
          "Responses compare current guess to previous guess (not running distance)",
          "Secret number remains fixed during each HC(N) call"
        ],
        "subtasks": {
          "1": {
            "points": 25,
            "req": "At most 500 Guess() calls per HC(N) (N ≤ 500)"
          },
          "2": {
            "points": 25,
            "req": "At most 18 Guess() calls per HC(N) (N ≤ 500)"
          },
          "3": {
            "points": 25,
            "req": "At most 16 Guess() calls per HC(N) (N ≤ 500)"
          },
          "4": {
            "points": "up to 25",
            "req": "Score based on call count relative to W where 2^W ≤ 3N (N ≤ 500,000,000)"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Hotter Colder",
        "contest": "IOI 2010 day 1",
        "one_line": "Find Jill's number in ≤18 calls using hotter/colder responses"
      },
      "problem": {
        "given": [
          "Jill has a secret number between 1 and N",
          "First Guess() call returns 'same'",
          "Each subsequent Guess(G) returns hotter/colder/same compared to previous guess"
        ],
        "goal": "Determine Jill's secret number using as few Guess() calls as possible",
        "mechanism": "Call Guess(G) to get response: hotter means G closer to secret than previous guess, colder means farther, same means equal distance",
        "success_condition": "HC(N) must return Jill's exact secret number"
      },
      "constraints": {
        "critical": [
          "First Guess() call always returns 'same'",
          "Responses compare current guess to previous guess (not running distance)",
          "Secret number remains fixed during each HC(N) call"
        ],
        "subtasks": {
          "1": {
            "points": 25,
            "req": "At most 500 Guess() calls per HC(N) (N ≤ 500)"
          },
          "2": {
            "points": 25,
            "req": "At most 18 Guess() calls per HC(N) (N ≤ 500)"
          },
          "3": {
            "points": 25,
            "req": "At most 16 Guess() calls per HC(N) (N ≤ 500)"
          },
          "4": {
            "points": "up to 25",
            "req": "Score based on call count relative to W where 2^W ≤ 3N (N ≤ 500,000,000)"
          }
        }
      },
      "implementation": {
        "function_to_write": "int HC(int N)",
        "available_api": {
          "Guess": {
            "signature": "int Guess(int G)",
            "params": "G: number to guess (1 ≤ G ≤ N)",
            "returns": "1 (hotter), -1 (colder), or 0 (same)",
            "side_effect": "None beyond tracking for comparison"
          }
        },
        "requirements": [
          "HC(N) must return the correct secret number",
          "Initialize all variables on each HC() call",
          "N can be up to 500,000,000",
          "Must handle large N efficiently"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "Jack and Jill play a game called Hotter, Colder. Jill has a number between $$$1$$$ and $$$N$$$, and Jack makes repeated attempts to guess it.\nEach of Jack's guesses is a number between $$$1$$$ and $$$N$$$. In response to each guess, Jill answers hotter, colder or same. For Jack's first guess, Jill answers same. For the remaining guesses Jill answers:\nhotter if this guess is closer to Jill's number than his previous guess\ncolder if this guess is farther from Jill's number than his previous guess\nsame if this guess is neither closer to nor further from Jill's number than his previous guess.\nYou are to implement a procedure\nHC(N)\nthat plays Jack's role. This implementation may repeatedly call\nGuess(G)\n, with $$$G$$$ a number between $$$1$$$ and $$$N$$$.\nGuess(G)\nwill return $$$1$$$ to indicate hotter, $$$-1$$$ to indicate colder or $$$0$$$ to indicate same.\nHC(N)\nmust return Jill's number.\nAs example, assume $$$N=5$$$, and Jill has chosen the number $$$2$$$. When procedure\nHC\nmakes the following sequence of calls to Guess, the results in the second column will be returned.\nCall\nReturned value\nExplanation\nGuess(5)\n0\nSame (first call)\nGuess(3)\n1\nHotter\nGuess(4)\n-1\nColder\nGuess(1)\n1\nHotter\nGuess(3)\n0\nSame\nAt this point Jack knows the answer, and\nHC\nshould return $$$2$$$. It has taken Jack $$$5$$$ guesses to determine Jill's number. You can do better.\nScoring\nSubtask 1 [25 points]\nHC(N)\nmust call\nGuess(G)\nat most $$$500$$$ times. There will be at most $$$125\\,250$$$ calls to\nHC(N)\n, with N between $$$1$$$ and $$$500$$$.\nSubtask 2 [25 points]\nHC(N)\nmust call\nGuess(G)\nat most $$$18$$$ times. There will be at most $$$125\\,250$$$ calls to\nHC(N)\n, with N between $$$1$$$ and $$$500$$$.\nSubtask 3 [25 points]\nHC(N) must call\nGuess(G)\nat most $$$16$$$ times. There will be at least $$$125\\,250$$$ calls to\nHC(N)\n, with N between $$$1$$$ and $$$500$$$.\nSubtask 4 [up to 25 points]\nLet $$$W$$$ be the largest integer, such that $$$2^W \\le 3 N$$$. For this subtask your solution will score:\n$$$0$$$ points, if\nHC(N)\ncalls\nGuess(G)\n$$$2W$$$ times or more\n$$$25\\alpha$$$ points, where $$$\\alpha$$$ is the largest real number, such that $$$0 < \\alpha < 1$$$ and\nHC(N)\ncalls\nGuess(G)\nat most $$$2W-\\alpha W$$$ times,\n25 points, if\nHC(N)\ncalls\nGuess(G)\nat most $$$W$$$ times.\nThere will be at most $$$1\\,000\\,000$$$ calls to\nHC(N)\nwith $$$N$$$ between $$$1$$$ and $$$500\\,000\\,000$$$.\nBe sure to initialize any variables used by\nHC\nevery time it is called."
    },
    "original": "Jack and Jill play a game called Hotter, Colder. Jill has a number between $$$1$$$ and $$$N$$$, and Jack makes repeated attempts to guess it.\nEach of Jack's guesses is a number between $$$1$$$ and $$$N$$$. In response to each guess, Jill answers hotter, colder or same. For Jack's first guess, Jill answers same. For the remaining guesses Jill answers:\nhotter if this guess is closer to Jill's number than his previous guess\ncolder if this guess is farther from Jill's number than his previous guess\nsame if this guess is neither closer to nor further from Jill's number than his previous guess.\nYou are to implement a procedure\nHC(N)\nthat plays Jack's role. This implementation may repeatedly call\nGuess(G)\n, with $$$G$$$ a number between $$$1$$$ and $$$N$$$.\nGuess(G)\nwill return $$$1$$$ to indicate hotter, $$$-1$$$ to indicate colder or $$$0$$$ to indicate same.\nHC(N)\nmust return Jill's number.\nAs example, assume $$$N=5$$$, and Jill has chosen the number $$$2$$$. When procedure\nHC\nmakes the following sequence of calls to Guess, the results in the second column will be returned.\nCall\nReturned value\nExplanation\nGuess(5)\n0\nSame (first call)\nGuess(3)\n1\nHotter\nGuess(4)\n-1\nColder\nGuess(1)\n1\nHotter\nGuess(3)\n0\nSame\nAt this point Jack knows the answer, and\nHC\nshould return $$$2$$$. It has taken Jack $$$5$$$ guesses to determine Jill's number. You can do better.\nScoring\nSubtask 1 [25 points]\nHC(N)\nmust call\nGuess(G)\nat most $$$500$$$ times. There will be at most $$$125\\,250$$$ calls to\nHC(N)\n, with N between $$$1$$$ and $$$500$$$.\nSubtask 2 [25 points]\nHC(N)\nmust call\nGuess(G)\nat most $$$18$$$ times. There will be at most $$$125\\,250$$$ calls to\nHC(N)\n, with N between $$$1$$$ and $$$500$$$.\nSubtask 3 [25 points]\nHC(N) must call\nGuess(G)\nat most $$$16$$$ times. There will be at least $$$125\\,250$$$ calls to\nHC(N)\n, with N between $$$1$$$ and $$$500$$$.\nSubtask 4 [up to 25 points]\nLet $$$W$$$ be the largest integer, such that $$$2^W \\le 3 N$$$. For this subtask your solution will score:\n$$$0$$$ points, if\nHC(N)\ncalls\nGuess(G)\n$$$2W$$$ times or more\n$$$25\\alpha$$$ points, where $$$\\alpha$$$ is the largest real number, such that $$$0 < \\alpha < 1$$$ and\nHC(N)\ncalls\nGuess(G)\nat most $$$2W-\\alpha W$$$ times,\n25 points, if\nHC(N)\ncalls\nGuess(G)\nat most $$$W$$$ times.\nThere will be at most $$$1\\,000\\,000$$$ calls to\nHC(N)\nwith $$$N$$$ between $$$1$$$ and $$$500\\,000\\,000$$$.\nBe sure to initialize any variables used by\nHC\nevery time it is called.",
    "_meta": {
      "index": 23,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/B",
      "uuid": "ps_49720261c3d9dfd5839864ee190240d66a6eb96d"
    }
  },
  {
    "planning_view": {
      "title": "B. Wiring",
      "task": "Connect red/blue points minimally such that each connects to opposite color",
      "given": [
        "Red and blue points at distinct integer positions",
        "Points are sorted in increasing order",
        "Each point can connect to multiple wires"
      ],
      "goal": "Find wiring scheme that minimizes total wire length",
      "key_rules": [
        "All n+m positions are distinct",
        "Each point must connect to at least one point of opposite color",
        "Multiple connections allowed per point"
      ],
      "target": {
        "1": {
          "points": 7,
          "req": "n, m ≤ 200"
        },
        "2": {
          "points": 13,
          "req": "All red points < all blue points"
        },
        "3": {
          "points": 10,
          "req": "Every 7 consecutive points has both colors"
        },
        "4": {
          "points": 25,
          "req": "Positions are 1 to n+m inclusive"
        },
        "5": {
          "points": 45,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Wiring",
      "contest": "IOI 2017 day 1",
      "one_line": "Connect red/blue points minimally such that each connects to opposite color",
      "given": [
        "Red and blue points at distinct integer positions",
        "Points are sorted in increasing order",
        "Each point can connect to multiple wires"
      ],
      "goal": "Find wiring scheme that minimizes total wire length",
      "mechanism": "A wire connects two points; length is distance between them",
      "success_condition": "Every connection point has ≥1 wire to opposite color point",
      "constraints": {
        "critical": [
          "All n+m positions are distinct",
          "Each point must connect to at least one point of opposite color",
          "Multiple connections allowed per point"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "n, m ≤ 200"
          },
          "2": {
            "points": 13,
            "req": "All red points < all blue points"
          },
          "3": {
            "points": 10,
            "req": "Every 7 consecutive points has both colors"
          },
          "4": {
            "points": 25,
            "req": "Positions are 1 to n+m inclusive"
          },
          "5": {
            "points": 45,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Wiring",
        "contest": "IOI 2017 day 1",
        "one_line": "Connect red/blue points minimally such that each connects to opposite color"
      },
      "problem": {
        "given": [
          "Red and blue points at distinct integer positions",
          "Points are sorted in increasing order",
          "Each point can connect to multiple wires"
        ],
        "goal": "Find wiring scheme that minimizes total wire length",
        "mechanism": "A wire connects two points; length is distance between them",
        "success_condition": "Every connection point has ≥1 wire to opposite color point"
      },
      "constraints": {
        "critical": [
          "All n+m positions are distinct",
          "Each point must connect to at least one point of opposite color",
          "Multiple connections allowed per point"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "n, m ≤ 200"
          },
          "2": {
            "points": 13,
            "req": "All red points < all blue points"
          },
          "3": {
            "points": 10,
            "req": "Every 7 consecutive points has both colors"
          },
          "4": {
            "points": 25,
            "req": "Positions are 1 to n+m inclusive"
          },
          "5": {
            "points": 45,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 min_total_length(int[] r, int[] b)",
        "available_api": {
          "min_total_length": {
            "signature": "int64 min_total_length(int[] r, int[] b)",
            "params": "r: sorted red positions, b: sorted blue positions",
            "returns": "Minimum total wire length",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Return type must be int64",
          "Input arrays are already sorted",
          "All positions are distinct non-negative integers"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "4 5\n1 2 3 7\n0 4 5 9 10",
          "output": "10"
        }
      ],
      "original_statement": "Maryam is an electrical engineer. She is designing wiring on a communication tower. On the tower there are some connection points, placed at distinct heights. A wire can be used to connect any two connection points. Each connection point can be connected to an arbitrary number of wires. There are two types of connection points: red and blue.\nFor the purpose of this problem the tower should be viewed as a line and the connection points as blue and red points that are at non-negative integer coordinates on this line. The length of a wire is the distance between the two connection points it connects.\nYour goal is to help Maryam find a wiring scheme such that:\nEach connection point has at least one wire to a connection point of a different color.\nThe total length of the wires is minimized.\nImplementation details\nYou should implement the following procedure:\nint64 min_total_length(int[] r, int[] b)\n$$$r$$$: array of length $$$n$$$ containing the positions of the red connection points in increasing order.\n$$$b$$$: array of length $$$m$$$ containing the positions of the blue connection points in increasing order.\nThis procedure should return the minimum total length of wires, among all valid wiring schemes.\nNote that the return type of this procedure is 'int64'.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$m$$$ ($$$1 \\le n, m \\le 100\\,000$$$).\nline 2: $$$r[0], r[1], \\ldots, r[n - 1]$$$, $$$0 \\le r[i] \\le 10^9$$$\nline 3: $$$b[0], b[1], \\ldots, b[m - 1]$$$, $$$0 \\le b[i] \\le 10^9$$$\nEach of the arrays $$$r$$$ and $$$b$$$ is sorted in ascending order.\nAll $$$n + m$$$ values in the arrays $$$r$$$ and $$$b$$$ are distinct.\nOutput\nThe sample grader prints a single line containing the return value of\nmin_total_length\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n7\n$$$n, m \\leq 200$$$\n2\n13\nAll red connection points have positions smaller than any blue connection points\n3\n10\nThere is at least one red connection point and one blue connection point among every $$$7$$$ consecutive connection points\n4\n25\nAll connection points have different positions in the range $$$[1, n + m]$$$\n5\n45\nNo additional constraints\nExample\nNote\nmin_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])\nThe figure below illustrates this example.\nThe tower is shown horizontally.\nIn the black-and-white printed version of the problem statement the red connection points are dark and the blue ones are light.\nThere are $$$4$$$ red connection points, located at positions $$$1, 2, 3,$$$ and $$$7$$$.\nThere are $$$5$$$ blue connection points, located at positions $$$0, 4, 5, 9,$$$ and $$$10$$$.\nOne optimal solution is shown in the figure above.\nIn this solution, the total length of the wires is $$$1 + 2 + 2 + 2 + 3 = 10$$$, which is optimal. So, the procedure should return $$$10$$$.\nNote that two wires are connected to the connection point at position $$$7$$$."
    },
    "original": "Maryam is an electrical engineer. She is designing wiring on a communication tower. On the tower there are some connection points, placed at distinct heights. A wire can be used to connect any two connection points. Each connection point can be connected to an arbitrary number of wires. There are two types of connection points: red and blue.\nFor the purpose of this problem the tower should be viewed as a line and the connection points as blue and red points that are at non-negative integer coordinates on this line. The length of a wire is the distance between the two connection points it connects.\nYour goal is to help Maryam find a wiring scheme such that:\nEach connection point has at least one wire to a connection point of a different color.\nThe total length of the wires is minimized.\nImplementation details\nYou should implement the following procedure:\nint64 min_total_length(int[] r, int[] b)\n$$$r$$$: array of length $$$n$$$ containing the positions of the red connection points in increasing order.\n$$$b$$$: array of length $$$m$$$ containing the positions of the blue connection points in increasing order.\nThis procedure should return the minimum total length of wires, among all valid wiring schemes.\nNote that the return type of this procedure is 'int64'.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$m$$$ ($$$1 \\le n, m \\le 100\\,000$$$).\nline 2: $$$r[0], r[1], \\ldots, r[n - 1]$$$, $$$0 \\le r[i] \\le 10^9$$$\nline 3: $$$b[0], b[1], \\ldots, b[m - 1]$$$, $$$0 \\le b[i] \\le 10^9$$$\nEach of the arrays $$$r$$$ and $$$b$$$ is sorted in ascending order.\nAll $$$n + m$$$ values in the arrays $$$r$$$ and $$$b$$$ are distinct.\nOutput\nThe sample grader prints a single line containing the return value of\nmin_total_length\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n7\n$$$n, m \\leq 200$$$\n2\n13\nAll red connection points have positions smaller than any blue connection points\n3\n10\nThere is at least one red connection point and one blue connection point among every $$$7$$$ consecutive connection points\n4\n25\nAll connection points have different positions in the range $$$[1, n + m]$$$\n5\n45\nNo additional constraints\nExample\nNote\nmin_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])\nThe figure below illustrates this example.\nThe tower is shown horizontally.\nIn the black-and-white printed version of the problem statement the red connection points are dark and the blue ones are light.\nThere are $$$4$$$ red connection points, located at positions $$$1, 2, 3,$$$ and $$$7$$$.\nThere are $$$5$$$ blue connection points, located at positions $$$0, 4, 5, 9,$$$ and $$$10$$$.\nOne optimal solution is shown in the figure above.\nIn this solution, the total length of the wires is $$$1 + 2 + 2 + 2 + 3 = 10$$$, which is optimal. So, the procedure should return $$$10$$$.\nNote that two wires are connected to the connection point at position $$$7$$$.",
    "_meta": {
      "index": 24,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/B",
      "uuid": "ps_f4c314256fd10edc54aa9f3c71f4922fef2d8c84"
    }
  },
  {
    "planning_view": {
      "title": "A. Combo",
      "task": "Find secret N-length string S using ≤8000 press() queries",
      "given": [
        "Secret string S of length N (1-2000)",
        "S uses only characters A,B,X,Y",
        "First character of S never reappears in S"
      ],
      "goal": "Determine the exact secret string S",
      "key_rules": [
        "Maximum 8000 press() calls per test case",
        "press(p) parameter p must be length 0-4N, contain only A,B,X,Y",
        "Grader is non-adaptive (S fixed at start)"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "N = 3"
        },
        "2": {
          "points": 95,
          "req": "Score scales with query count: max score with ≤N+2 queries"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Combo",
      "contest": "IOI 2018 day 1",
      "one_line": "Find secret N-length string S using ≤8000 press() queries",
      "given": [
        "Secret string S of length N (1-2000)",
        "S uses only characters A,B,X,Y",
        "First character of S never reappears in S"
      ],
      "goal": "Determine the exact secret string S",
      "mechanism": "Call press(p) to test sequence p; returns length of longest prefix of S that is substring of p",
      "success_condition": "Return value of guess_sequence must exactly equal secret S",
      "constraints": {
        "critical": [
          "Maximum 8000 press() calls per test case",
          "press(p) parameter p must be length 0-4N, contain only A,B,X,Y",
          "Grader is non-adaptive (S fixed at start)"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N = 3"
          },
          "2": {
            "points": 95,
            "req": "Score scales with query count: max score with ≤N+2 queries"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Combo",
        "contest": "IOI 2018 day 1",
        "one_line": "Find secret N-length string S using ≤8000 press() queries"
      },
      "problem": {
        "given": [
          "Secret string S of length N (1-2000)",
          "S uses only characters A,B,X,Y",
          "First character of S never reappears in S"
        ],
        "goal": "Determine the exact secret string S",
        "mechanism": "Call press(p) to test sequence p; returns length of longest prefix of S that is substring of p",
        "success_condition": "Return value of guess_sequence must exactly equal secret S"
      },
      "constraints": {
        "critical": [
          "Maximum 8000 press() calls per test case",
          "press(p) parameter p must be length 0-4N, contain only A,B,X,Y",
          "Grader is non-adaptive (S fixed at start)"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N = 3"
          },
          "2": {
            "points": 95,
            "req": "Score scales with query count: max score with ≤N+2 queries"
          }
        }
      },
      "implementation": {
        "function_to_write": "string guess_sequence(int N)",
        "available_api": {
          "press": {
            "signature": "int press(string p)",
            "params": "p: button sequence (length 0-4N, characters A,B,X,Y only)",
            "returns": "Length of longest prefix of S that is substring of p",
            "side_effect": "None"
          }
        },
        "requirements": [
          "guess_sequence called exactly once per test case",
          "press calls limited to 8000",
          "Return exact string S"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      },
      "samples": [],
      "original_statement": "You are playing an action video game. The game controller has $$$4$$$ buttons, A, B, X, and Y. In this game, you can get coins with combo moves. You can make a combo move by pressing buttons in sequence.\nThis game has a secret sequence of buttons, which can be represented as a string $$$S$$$ of those $$$4$$$ characters. You don't know the string $$$S$$$, but you know its length $$$N$$$.\nYou also know that the first character of $$$S$$$ never reappears in it. For example, $$$S$$$ can be\n\"ABXYY\"\nor\n\"XYYAA\"\n, but cannot be\n\"AAAAA\"\nor\n\"BXYBX\"\n.\nYou can press a sequence of up to $$$4 \\cdot N$$$ buttons for a combo move. Let $$$p$$$ be the string which represents the sequence of the buttons you pressed. The number of coins you get for this move is calculated as the length of the longest prefix of $$$S$$$ which is also a substring of $$$p$$$. A substring of a string $$$t$$$ is a contiguous (possibly empty) sequence of characters within $$$t$$$. A prefix of $$$t$$$ is a substring of $$$t$$$ that is empty or contains the first character of $$$t$$$.\nFor example, if $$$S$$$ is\n\"ABXYY\"\nand $$$p$$$ is \"XXYYABYABXAY\", you will get $$$3$$$ coins because\n\"ABX\"\nis the longest prefix of $$$S$$$ that is also a substring of $$$p$$$.\nYour task is to determine the secret string $$$S$$$ using few combo moves.\nImplementation details\nYou should implement the following function:\nstring guess_sequence(int N)\n$$$N$$$: the length of string $$$S$$$.\nThis function is called exactly once for each test case.\nThis function should return the string $$$S$$$.\nYour program can call the following function:\nint press(string p)\n$$$p$$$: a sequence of buttons you press.\n$$$p$$$ must be a string of length between $$$0$$$ and $$$4 \\cdot N$$$, inclusive. Each character of $$$p$$$ must be A, B, X, or Y.\nYou cannot call this function more than $$$8\\,000$$$ times for each test case.\nThis function returns the number of coins you get when you press the sequence of buttons represented by $$$p$$$.\nIf some of the above conditions are not satisfied, your program is judged as\nWrong Answer\n. Otherwise, your program is judged as\nAccepted\nand your score is calculated by the number of calls to\npress\n(see Subtasks).\nExample\nLet $$$S$$$ be\n\"ABXYY\"\n. The grader calls\nguess_sequence(5)\n. An example of communication is shown below.\nCall\nReturn\npress(\"XXYYABYABXAY\")\n$$$3$$$\npress(\"ABXYY\")\n$$$5$$$\npress(\"ABXYYABXYY\")\n$$$5$$$\npress(\"\")\n$$$0$$$\npress(\"X\")\n$$$0$$$\npress(\"BXYY)\n$$$0$$$\npress(\"YYXBA\")\n$$$1$$$\npress(\"AY\")\n$$$1$$$\nFor the first call to\npress\n,\n\"ABX\"\nappears in\n\"XXYYABYABXAY\"\nas a substring but\n\"ABXY\"\ndoes not, so $$$3$$$ is returned.\nFor the third call to\npress\n,\n\"ABXYY\"\nitself appears in\n\"ABXYYABXYY\"\nas a substring, so $$$5$$$ is returned.\nFor the sixth call to press, no prefix of\n\"ABXYY\"\nbut the empty string appears in\n\"BXYY\"\nas a substring, so $$$0$$$ is returned.\nFinally,\nguess_sequence(5)\nshould return\n\"ABXYY\"\n.\nThe file\nsample-01-in.txt\nin the zipped attachment package corresponds to this example.\nConstraints\n$$$1 \\le N \\le 2000$$$\nEach character of the string is A, B, X, or Y.\nThe first character of $$$S$$$ never reappears in $$$S$$$.\nIn this problem, the grader is NOT adaptive. This means that $$$S$$$ is fixed at the beginning of the running of the grader and it does not depend on the queries asked by your solution.\nSample grader\nThe sample grader reads the input in the following format:\nline 1: $$$S$$$\nIf your program is judged as\nAccepted\n, the sample grader prints\n\"Accepted: q\"\nwith $$$q$$$ being the number of calls to the function press.\nIf your program is judged as\nWrong Answer\n, it prints\n\"Wrong Answer: MSG\"\n. The meaning of $$$MSG$$$ is as follows:\ninvalid press: A value of $$$p$$$ given to\npress\nis invalid. Namely, the length of $$$p$$$ is not between $$$0$$$ and $$$4N$$$, inclusive, or some character of $$$p$$$ is not A, B, X, or Y.\ntoo many moves: The function pressis called more than 8000 times.\nwrong guess: The return value of\nguess_sequence\nis not $$$S$$$.\nScoring\nSubtasks\n(5 points) N = 3\n(95 points) No additional constraints. For this subtask, your score for each test case is calculated as follows. Let $$$q$$$ be the number of calls to press.\nIf $$$q \\le N+2$$$, your score is $$$95$$$.\nIf $$$N+2 < q \\le N+10$$$, your score is $$$95 - 3 \\cdot (q - N-2)$$$.\nIf $$$N+10 < q \\le 2* N+1$$$, your score is $$$25$$$.\nIf $$$max\\{N+10, 2N+1\\} < q \\le 4N$$$, your score is $$$5$$$.\nOtherwise, your score is $$$0$$$.\nNote that your score for each subtask is the minimum of the scores for the test cases in the subtask."
    },
    "original": "You are playing an action video game. The game controller has $$$4$$$ buttons, A, B, X, and Y. In this game, you can get coins with combo moves. You can make a combo move by pressing buttons in sequence.\nThis game has a secret sequence of buttons, which can be represented as a string $$$S$$$ of those $$$4$$$ characters. You don't know the string $$$S$$$, but you know its length $$$N$$$.\nYou also know that the first character of $$$S$$$ never reappears in it. For example, $$$S$$$ can be\n\"ABXYY\"\nor\n\"XYYAA\"\n, but cannot be\n\"AAAAA\"\nor\n\"BXYBX\"\n.\nYou can press a sequence of up to $$$4 \\cdot N$$$ buttons for a combo move. Let $$$p$$$ be the string which represents the sequence of the buttons you pressed. The number of coins you get for this move is calculated as the length of the longest prefix of $$$S$$$ which is also a substring of $$$p$$$. A substring of a string $$$t$$$ is a contiguous (possibly empty) sequence of characters within $$$t$$$. A prefix of $$$t$$$ is a substring of $$$t$$$ that is empty or contains the first character of $$$t$$$.\nFor example, if $$$S$$$ is\n\"ABXYY\"\nand $$$p$$$ is \"XXYYABYABXAY\", you will get $$$3$$$ coins because\n\"ABX\"\nis the longest prefix of $$$S$$$ that is also a substring of $$$p$$$.\nYour task is to determine the secret string $$$S$$$ using few combo moves.\nImplementation details\nYou should implement the following function:\nstring guess_sequence(int N)\n$$$N$$$: the length of string $$$S$$$.\nThis function is called exactly once for each test case.\nThis function should return the string $$$S$$$.\nYour program can call the following function:\nint press(string p)\n$$$p$$$: a sequence of buttons you press.\n$$$p$$$ must be a string of length between $$$0$$$ and $$$4 \\cdot N$$$, inclusive. Each character of $$$p$$$ must be A, B, X, or Y.\nYou cannot call this function more than $$$8\\,000$$$ times for each test case.\nThis function returns the number of coins you get when you press the sequence of buttons represented by $$$p$$$.\nIf some of the above conditions are not satisfied, your program is judged as\nWrong Answer\n. Otherwise, your program is judged as\nAccepted\nand your score is calculated by the number of calls to\npress\n(see Subtasks).\nExample\nLet $$$S$$$ be\n\"ABXYY\"\n. The grader calls\nguess_sequence(5)\n. An example of communication is shown below.\nCall\nReturn\npress(\"XXYYABYABXAY\")\n$$$3$$$\npress(\"ABXYY\")\n$$$5$$$\npress(\"ABXYYABXYY\")\n$$$5$$$\npress(\"\")\n$$$0$$$\npress(\"X\")\n$$$0$$$\npress(\"BXYY)\n$$$0$$$\npress(\"YYXBA\")\n$$$1$$$\npress(\"AY\")\n$$$1$$$\nFor the first call to\npress\n,\n\"ABX\"\nappears in\n\"XXYYABYABXAY\"\nas a substring but\n\"ABXY\"\ndoes not, so $$$3$$$ is returned.\nFor the third call to\npress\n,\n\"ABXYY\"\nitself appears in\n\"ABXYYABXYY\"\nas a substring, so $$$5$$$ is returned.\nFor the sixth call to press, no prefix of\n\"ABXYY\"\nbut the empty string appears in\n\"BXYY\"\nas a substring, so $$$0$$$ is returned.\nFinally,\nguess_sequence(5)\nshould return\n\"ABXYY\"\n.\nThe file\nsample-01-in.txt\nin the zipped attachment package corresponds to this example.\nConstraints\n$$$1 \\le N \\le 2000$$$\nEach character of the string is A, B, X, or Y.\nThe first character of $$$S$$$ never reappears in $$$S$$$.\nIn this problem, the grader is NOT adaptive. This means that $$$S$$$ is fixed at the beginning of the running of the grader and it does not depend on the queries asked by your solution.\nSample grader\nThe sample grader reads the input in the following format:\nline 1: $$$S$$$\nIf your program is judged as\nAccepted\n, the sample grader prints\n\"Accepted: q\"\nwith $$$q$$$ being the number of calls to the function press.\nIf your program is judged as\nWrong Answer\n, it prints\n\"Wrong Answer: MSG\"\n. The meaning of $$$MSG$$$ is as follows:\ninvalid press: A value of $$$p$$$ given to\npress\nis invalid. Namely, the length of $$$p$$$ is not between $$$0$$$ and $$$4N$$$, inclusive, or some character of $$$p$$$ is not A, B, X, or Y.\ntoo many moves: The function pressis called more than 8000 times.\nwrong guess: The return value of\nguess_sequence\nis not $$$S$$$.\nScoring\nSubtasks\n(5 points) N = 3\n(95 points) No additional constraints. For this subtask, your score for each test case is calculated as follows. Let $$$q$$$ be the number of calls to press.\nIf $$$q \\le N+2$$$, your score is $$$95$$$.\nIf $$$N+2 < q \\le N+10$$$, your score is $$$95 - 3 \\cdot (q - N-2)$$$.\nIf $$$N+10 < q \\le 2* N+1$$$, your score is $$$25$$$.\nIf $$$max\\{N+10, 2N+1\\} < q \\le 4N$$$, your score is $$$5$$$.\nOtherwise, your score is $$$0$$$.\nNote that your score for each subtask is the minimum of the scores for the test cases in the subtask.",
    "_meta": {
      "index": 25,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/A",
      "uuid": "ps_8f75a36b189147e5d8740dfa224ed8c6b127602a"
    }
  },
  {
    "planning_view": {
      "title": "C. Rectangles",
      "task": "Count rectangles where each cell has 4 adjacent boundary cells all taller",
      "given": [
        "n × m grid of heights a[i][j]",
        "Rows 0 to n-1, columns 0 to m-1",
        "Rectangle cannot touch grid boundaries"
      ],
      "goal": "Count all valid inner rectangles (r1, r2, c1, c2)",
      "key_rules": [
        "Rectangle must have 1 ≤ r1 ≤ r2 ≤ n-2 and 1 ≤ c1 ≤ c2 ≤ m-2",
        "For each cell (i,j) in rectangle: a[i][j] < min(a[i][c1-1], a[i][c2+1], a[r1-1][j], a[r2+1][j])",
        "Constraints apply to every cell in the rectangle"
      ],
      "target": {
        "1": {
          "points": 8,
          "req": "n, m ≤ 30"
        },
        "2": {
          "points": 7,
          "req": "n, m ≤ 80"
        },
        "3": {
          "points": 12,
          "req": "n, m ≤ 200"
        },
        "4": {
          "points": 22,
          "req": "n, m ≤ 700"
        },
        "5": {
          "points": 10,
          "req": "n ≤ 3"
        },
        "6": {
          "points": 13,
          "req": "All heights 0 or 1"
        },
        "7": {
          "points": 28,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Rectangles",
      "contest": "IOI 2019 day 1",
      "one_line": "Count rectangles where each cell has 4 adjacent boundary cells all taller",
      "given": [
        "n × m grid of heights a[i][j]",
        "Rows 0 to n-1, columns 0 to m-1",
        "Rectangle cannot touch grid boundaries"
      ],
      "goal": "Count all valid inner rectangles (r1, r2, c1, c2)",
      "mechanism": "A rectangle is valid if each interior cell is strictly smaller than its four adjacent boundary cells (left, right, top, bottom)",
      "success_condition": "Return total number of valid rectangles satisfying all constraints",
      "constraints": {
        "critical": [
          "Rectangle must have 1 ≤ r1 ≤ r2 ≤ n-2 and 1 ≤ c1 ≤ c2 ≤ m-2",
          "For each cell (i,j) in rectangle: a[i][j] < min(a[i][c1-1], a[i][c2+1], a[r1-1][j], a[r2+1][j])",
          "Constraints apply to every cell in the rectangle"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "n, m ≤ 30"
          },
          "2": {
            "points": 7,
            "req": "n, m ≤ 80"
          },
          "3": {
            "points": 12,
            "req": "n, m ≤ 200"
          },
          "4": {
            "points": 22,
            "req": "n, m ≤ 700"
          },
          "5": {
            "points": 10,
            "req": "n ≤ 3"
          },
          "6": {
            "points": 13,
            "req": "All heights 0 or 1"
          },
          "7": {
            "points": 28,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Rectangles",
        "contest": "IOI 2019 day 1",
        "one_line": "Count rectangles where each cell has 4 adjacent boundary cells all taller"
      },
      "problem": {
        "given": [
          "n × m grid of heights a[i][j]",
          "Rows 0 to n-1, columns 0 to m-1",
          "Rectangle cannot touch grid boundaries"
        ],
        "goal": "Count all valid inner rectangles (r1, r2, c1, c2)",
        "mechanism": "A rectangle is valid if each interior cell is strictly smaller than its four adjacent boundary cells (left, right, top, bottom)",
        "success_condition": "Return total number of valid rectangles satisfying all constraints"
      },
      "constraints": {
        "critical": [
          "Rectangle must have 1 ≤ r1 ≤ r2 ≤ n-2 and 1 ≤ c1 ≤ c2 ≤ m-2",
          "For each cell (i,j) in rectangle: a[i][j] < min(a[i][c1-1], a[i][c2+1], a[r1-1][j], a[r2+1][j])",
          "Constraints apply to every cell in the rectangle"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "n, m ≤ 30"
          },
          "2": {
            "points": 7,
            "req": "n, m ≤ 80"
          },
          "3": {
            "points": 12,
            "req": "n, m ≤ 200"
          },
          "4": {
            "points": 22,
            "req": "n, m ≤ 700"
          },
          "5": {
            "points": 10,
            "req": "n ≤ 3"
          },
          "6": {
            "points": 13,
            "req": "All heights 0 or 1"
          },
          "7": {
            "points": 28,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 count_rectangles(int[][] a)",
        "available_api": {
          "count_rectangles": {
            "signature": "int64 count_rectangles(int[][] a)",
            "params": "a: 2D n×m array of integers representing heights",
            "returns": "Number of valid rectangles",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Return type int64 (long long in C++)",
          "0-indexed grid: rows 0..n-1, columns 0..m-1",
          "Input constraints: 1 ≤ n, m ≤ 2500, 0 ≤ a[i][j] ≤ 7,000,000"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "6 5\n4 8 7 5 6\n7 4 10 3 5\n9 7 20 14 2\n9 14 7 3 6\n5 7 5 2 7\n4 5 13 5 6",
          "output": "6"
        }
      ],
      "original_statement": "In the early 19th century, the ruler Hoseyngulu Khan Sardar ordered a palace to be built on a plateau overseeing a beautiful river. The plateau is modeled as an $$$n \\times m$$$ grid of square cells. The rows of the grid are numbered $$$0$$$ through $$$n-1$$$, and the columns are numbered $$$0$$$ through $$$m-1$$$. We refer to the cell in row $$$i$$$ and column $$$j$$$ ($$$0 \\leq i \\leq n-1, 0 \\leq j \\leq m-1$$$) as cell $$$(i,j)$$$. Each cell $$$(i,j)$$$ has a specific height, denoted by $$$a[i][j]$$$.\nHoseyngulu Khan Sardar asked his architects to choose a rectangular\narea\nto build the palace. The area should not contain any cell from the grid boundaries (row $$$0$$$, row $$$n-1$$$, column $$$0$$$, and column $$$m-1$$$). Hence, the architects should choose four integers $$$r_1$$$, $$$r_2$$$, $$$c_1$$$, and $$$c_2$$$ ($$$1 \\leq r_1 \\leq r_2 \\leq n-2$$$ and $$$1 \\leq c_1 \\leq c_2 \\leq m-2$$$), which define an area consisting of all cells $$$(i, j)$$$ such that $$$r_1 \\leq i \\leq r_2$$$ and $$$c_1 \\leq j \\leq c_2$$$.\nIn addition, an area is considered\nvalid\n, if and only if for every cell $$$(i, j)$$$ in the area, the following condition holds:\nConsider the two cells adjacent to the area in row $$$i$$$ (cell $$$(i, c_1-1)$$$ and cell $$$(i, c_2+1)$$$) and the two cells adjacent to the area in column $$$j$$$ (cell $$$(r_1-1, j)$$$ and cell $$$(r_2+1, j)$$$). The height of cell $$$(i,j)$$$ should be strictly smaller than the heights of all these four cells.\nYour task is to help the architects find the number of valid areas for the palace (i.e., the number of choices of $$$r_1$$$, $$$r_2$$$, $$$c_1$$$ and $$$c_2$$$ that define a valid area).\nImplementation details\nYou should implement the following procedure:\nint64 count_rectangles(int[][] a)\n$$$a$$$: a two-dimensional $$$n$$$ by $$$m$$$ array of integers representing the heights of the cells.\nThis procedure should return the number of valid areas for the palace.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$m$$$ ($$$1 \\leq n, m \\leq 2500$$$)\nline $$$2+i$$$ (for $$$0 \\leq i \\leq n-1$$$): $$$a[i][0], a[i][1], \\ldots, a[i][m-1]$$$ ($$$0 \\leq a[i][j] \\leq 7\\,000\\,000$$$)\nOutput\nThe sample grader prints a single line containing the return value of\ncount_rectangles\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n8\n$$$n, m \\leq 30$$$\n2\n7\n$$$n, m \\leq 80$$$\n3\n12\n$$$n, m \\leq 200$$$\n4\n22\n$$$n, m \\leq 700$$$\n5\n10\n$$$n \\leq 3$$$\n6\n13\n$$$0 \\leq a[i][j] \\leq 1$$$ (for all $$$0 \\leq i \\leq n-1, 0 \\leq j \\leq m-1$$$)\n7\n28\nno additional constraints\nExample\nNote\nExample 1\nConsider the following call.\ncount_rectangles([[4,  8,  7,  5,  6],\n[7,  4,  10, 3,  5],\n[9,  7,  20, 14, 2],\n[9,  14, 7,  3,  6],\n[5,  7,  5,  2,  7],\n[4,  5,  13, 5,  6]])\nThere are $$$6$$$ valid areas, listed below:\n$$$r_1 = r_2 = c_1 = c_2 = 1$$$\n$$$r_1 = 1, r_2 = 2, c_1 = c_2 = 1$$$\n$$$r_1 = r_2 = 1, c_1 = c_2 = 3$$$\n$$$r_1 = r_2 = 4, c_1 = 2, c_2 = 3$$$\n$$$r_1 = r_2 = 4, c_1 = c_2 = 3$$$\n$$$r_1 = 3, r_2 = 4, c_1 = c_2 = 3$$$\nFor example $$$r_1 = 1, r_2 = 2, c_1 = c_2 = 1$$$ is a valid area because both following conditions hold:\n$$$a[1][1]=4$$$ is strictly smaller than $$$a[0][1]=8$$$, $$$a[3][1]=14$$$, $$$a[1][0]=7$$$, and $$$a[1][2]=10$$$.\n$$$a[2][1]=7$$$ is strictly smaller than $$$a[0][1]=8$$$, $$$a[3][1]=14$$$, $$$a[2][0]=9$$$, and $$$a[2][2]=20$$$."
    },
    "original": "In the early 19th century, the ruler Hoseyngulu Khan Sardar ordered a palace to be built on a plateau overseeing a beautiful river. The plateau is modeled as an $$$n \\times m$$$ grid of square cells. The rows of the grid are numbered $$$0$$$ through $$$n-1$$$, and the columns are numbered $$$0$$$ through $$$m-1$$$. We refer to the cell in row $$$i$$$ and column $$$j$$$ ($$$0 \\leq i \\leq n-1, 0 \\leq j \\leq m-1$$$) as cell $$$(i,j)$$$. Each cell $$$(i,j)$$$ has a specific height, denoted by $$$a[i][j]$$$.\nHoseyngulu Khan Sardar asked his architects to choose a rectangular\narea\nto build the palace. The area should not contain any cell from the grid boundaries (row $$$0$$$, row $$$n-1$$$, column $$$0$$$, and column $$$m-1$$$). Hence, the architects should choose four integers $$$r_1$$$, $$$r_2$$$, $$$c_1$$$, and $$$c_2$$$ ($$$1 \\leq r_1 \\leq r_2 \\leq n-2$$$ and $$$1 \\leq c_1 \\leq c_2 \\leq m-2$$$), which define an area consisting of all cells $$$(i, j)$$$ such that $$$r_1 \\leq i \\leq r_2$$$ and $$$c_1 \\leq j \\leq c_2$$$.\nIn addition, an area is considered\nvalid\n, if and only if for every cell $$$(i, j)$$$ in the area, the following condition holds:\nConsider the two cells adjacent to the area in row $$$i$$$ (cell $$$(i, c_1-1)$$$ and cell $$$(i, c_2+1)$$$) and the two cells adjacent to the area in column $$$j$$$ (cell $$$(r_1-1, j)$$$ and cell $$$(r_2+1, j)$$$). The height of cell $$$(i,j)$$$ should be strictly smaller than the heights of all these four cells.\nYour task is to help the architects find the number of valid areas for the palace (i.e., the number of choices of $$$r_1$$$, $$$r_2$$$, $$$c_1$$$ and $$$c_2$$$ that define a valid area).\nImplementation details\nYou should implement the following procedure:\nint64 count_rectangles(int[][] a)\n$$$a$$$: a two-dimensional $$$n$$$ by $$$m$$$ array of integers representing the heights of the cells.\nThis procedure should return the number of valid areas for the palace.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$m$$$ ($$$1 \\leq n, m \\leq 2500$$$)\nline $$$2+i$$$ (for $$$0 \\leq i \\leq n-1$$$): $$$a[i][0], a[i][1], \\ldots, a[i][m-1]$$$ ($$$0 \\leq a[i][j] \\leq 7\\,000\\,000$$$)\nOutput\nThe sample grader prints a single line containing the return value of\ncount_rectangles\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n8\n$$$n, m \\leq 30$$$\n2\n7\n$$$n, m \\leq 80$$$\n3\n12\n$$$n, m \\leq 200$$$\n4\n22\n$$$n, m \\leq 700$$$\n5\n10\n$$$n \\leq 3$$$\n6\n13\n$$$0 \\leq a[i][j] \\leq 1$$$ (for all $$$0 \\leq i \\leq n-1, 0 \\leq j \\leq m-1$$$)\n7\n28\nno additional constraints\nExample\nNote\nExample 1\nConsider the following call.\ncount_rectangles([[4,  8,  7,  5,  6],\n[7,  4,  10, 3,  5],\n[9,  7,  20, 14, 2],\n[9,  14, 7,  3,  6],\n[5,  7,  5,  2,  7],\n[4,  5,  13, 5,  6]])\nThere are $$$6$$$ valid areas, listed below:\n$$$r_1 = r_2 = c_1 = c_2 = 1$$$\n$$$r_1 = 1, r_2 = 2, c_1 = c_2 = 1$$$\n$$$r_1 = r_2 = 1, c_1 = c_2 = 3$$$\n$$$r_1 = r_2 = 4, c_1 = 2, c_2 = 3$$$\n$$$r_1 = r_2 = 4, c_1 = c_2 = 3$$$\n$$$r_1 = 3, r_2 = 4, c_1 = c_2 = 3$$$\nFor example $$$r_1 = 1, r_2 = 2, c_1 = c_2 = 1$$$ is a valid area because both following conditions hold:\n$$$a[1][1]=4$$$ is strictly smaller than $$$a[0][1]=8$$$, $$$a[3][1]=14$$$, $$$a[1][0]=7$$$, and $$$a[1][2]=10$$$.\n$$$a[2][1]=7$$$ is strictly smaller than $$$a[0][1]=8$$$, $$$a[3][1]=14$$$, $$$a[2][0]=9$$$, and $$$a[2][2]=20$$$.",
    "_meta": {
      "index": 26,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/C",
      "uuid": "ps_b9c76019b42293e67c69604c279e2416d2c48a63"
    }
  },
  {
    "planning_view": {
      "title": "A. Rail",
      "task": "Locate n stations on rail line using distance queries under call limits",
      "given": [
        "Rail line with m blocks (0 to m-1)",
        "Station 0 is known at block 'first' (type C)",
        "Three block types: C, D, empty",
        "Distances are shortest connector counts"
      ],
      "goal": "Determine block number and type (C=1, D=2) for each station",
      "key_rules": [
        "Stations connected: any station reachable from any other",
        "Station 0 always in type C block",
        "Call limits on getDistance() vary by subtask"
      ],
      "target": {
        "1": {
          "points": 8,
          "req": "n≤100, unlimited calls, all non-0 stations type D"
        },
        "2": {
          "points": 22,
          "req": "n≤100, unlimited calls, stations right of 0: D, left of 0: C"
        },
        "3": {
          "points": 26,
          "req": "n≤5000, n(n-1)/2 calls max"
        },
        "4": {
          "points": 44,
          "req": "n≤5000, 3(n-1) calls max"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Rail",
      "contest": "IOI 2014 day 1",
      "one_line": "Locate n stations on rail line using distance queries under call limits",
      "given": [
        "Rail line with m blocks (0 to m-1)",
        "Station 0 is known at block 'first' (type C)",
        "Three block types: C, D, empty",
        "Distances are shortest connector counts"
      ],
      "goal": "Determine block number and type (C=1, D=2) for each station",
      "mechanism": "Query getDistance(i,j) to get shortest path length between stations",
      "success_condition": "Correctly fill location[] and stype[] arrays for all stations",
      "constraints": {
        "critical": [
          "Stations connected: any station reachable from any other",
          "Station 0 always in type C block",
          "Call limits on getDistance() vary by subtask"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "n≤100, unlimited calls, all non-0 stations type D"
          },
          "2": {
            "points": 22,
            "req": "n≤100, unlimited calls, stations right of 0: D, left of 0: C"
          },
          "3": {
            "points": 26,
            "req": "n≤5000, n(n-1)/2 calls max"
          },
          "4": {
            "points": 44,
            "req": "n≤5000, 3(n-1) calls max"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Rail",
        "contest": "IOI 2014 day 1",
        "one_line": "Locate n stations on rail line using distance queries under call limits"
      },
      "problem": {
        "given": [
          "Rail line with m blocks (0 to m-1)",
          "Station 0 is known at block 'first' (type C)",
          "Three block types: C, D, empty",
          "Distances are shortest connector counts"
        ],
        "goal": "Determine block number and type (C=1, D=2) for each station",
        "mechanism": "Query getDistance(i,j) to get shortest path length between stations",
        "success_condition": "Correctly fill location[] and stype[] arrays for all stations"
      },
      "constraints": {
        "critical": [
          "Stations connected: any station reachable from any other",
          "Station 0 always in type C block",
          "Call limits on getDistance() vary by subtask"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "n≤100, unlimited calls, all non-0 stations type D"
          },
          "2": {
            "points": 22,
            "req": "n≤100, unlimited calls, stations right of 0: D, left of 0: C"
          },
          "3": {
            "points": 26,
            "req": "n≤5000, n(n-1)/2 calls max"
          },
          "4": {
            "points": 44,
            "req": "n≤5000, 3(n-1) calls max"
          }
        }
      },
      "implementation": {
        "function_to_write": "void findLocation(int n, int first, int location[], int stype[])",
        "available_api": {
          "getDistance": {
            "signature": "int getDistance(int i, int j)",
            "params": "i, j: station indices (0 to n-1)",
            "returns": "Shortest distance (connector count) between stations i and j",
            "side_effect": "None"
          }
        },
        "requirements": [
          "location[0] must be set to 'first'",
          "stype[0] must be set to 1 (type C)",
          "Arrays are 0-indexed",
          "Invalid i/j returns -1"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "Taiwan has a big railway line connecting the western and eastern shores of the island. The line consists of blocks $$$m$$$. The consecutive blocks are numbered $$$0, \\ldots, m - 1$$$, starting from the western end. Each block has a one-way west-bound track on the north, a one-way east-bound track on the south, and optionally a train station between them.\nThere are three types of blocks. A type $$$C$$$ block has a train station that you must enter from the northern track and exit to the southern track, a type $$$D$$$ block has a train station that you must enter from the southern track and exit to the northern track, and a type empty block has no train station. For example, in the following figure block 0 is type empty, block 1 is type $$$C$$$, and block 5 is type $$$D$$$. Blocks connect to each other horizontally. Tracks of adjacent blocks are joined by connectors, shown as shaded rectangles in the following figure.\nThe railsystem has $$$n$$$ stations numbered from $$$0$$$ to $$$n - 1$$$. We assume that we can go from any station to any other station by following the track. For example we can go from station 0 to station 2 by starting from block 2, then passing through blocks 3 and 4 by the southern track, and then passing through station 1, then passing through block 4 by the northern track, and finally reaching station 2 at block 3.\nSince there are multiple possible routes, the distance from one station to another is defined as the minimum number of connectors the route passes through. For example the shortest route from station 0 to 2 is through blocks $$$2-3-4-5-4-3$$$ and passes through 5 connectors, so the distance is $$$5$$$.\nA computer system manages the railsystem. Unfortunately after a power outage the computer no longer knows where the stations are and what types of blocks they are in. The only clue the computer has is the block number of station 0, which is always in a type $$$C$$$ block. Fortunately the computer can query the distance from any station to any other station. For example, the computer can query \"what is the distance from station $$$0$$$ to station $$$2$$$?\" and it will receive $$$5$$$.\nTask\nYou need to implement a function\nfindLocation\nthat determines for each station the block number and block type.\nvoid findLocation(int n, int first, int location[], int stype[])\n$$$n$$$: the number of stations.\n$$$first$$$: the block number of station $$$0$$$.\n$$$location$$$: array of size $$$n$$$; you should place the block number of station $$$i$$$ into $$$location[i]$$$.\n$$$stype$$$: array of size $$$n$$$; you should place the block type of station $$$i$$$ into $$$stype[i]$$$: $$$1$$$ for type $$$C$$$ and $$$2$$$ for type $$$D$$$.\nYou can call a function\nint getDistance(int i, int j)\nto help you find the locations and types of stations.\ngetDistance(i, j)\nreturns the distance from station $$$i$$$ to station $$$j$$$\ngetDistance(i, i)\nwill return $$$0$$$\ngetDistance(i, j)\nwill return $$$-1$$$ if $$$i$$$ or $$$j$$$ is outside the range $$$0 \\le i, j \\le n - 1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: the subtask number\nline 2: $$$n$$$\nlines $$$3 + i (0 \\le i \\le n - 1)$$$: $$$stype[i]$$$ ($$$1$$$ for type $$$C$$$ and $$$2$$$ for type $$$D$$$), $$$location[i]$$$.\nOutput\nThe sample grader will print\nCorrect\nif $$$location[0] \\ldots location[n - 1]$$$ and $$$stype[0] \\ldots stype[n - 1]$$$ computed by your program match the input when\nfindLocation\nreturns, or\nIncorrect\nif they do not match.\nScoring\nIn allsubtasks the number of blocks $$$m$$$ is no more than $$$1\\,000\\,000$$$. In some subtasks the number of calls to\ngetDistance\nis limited. The limit varies by subtask. Your program will receive 'wrong answer' if it exceeds this limit.\nSubtask\nPoints\n$$$n$$$\ngetDistance calls\nnote\n1\n8\n$$$1 \\le n \\le 100$$$\nunlimited\nAllstations except $$$0$$$ are in type $$$D$$$ blocks.\n2\n22\n$$$1 \\le n \\le 100$$$\nunlimited\nAllstations to the right of station $$$0$$$ are in type $$$D$$$ blocks, and allstations to the left of station $$$0$$$ are in type $$$C$$$ blocks.\n3\n26\n$$$1 \\le N \\le 5\\,000$$$\n$$$n(n - 1) / 2$$$\nNo additional limits\n4\n44\n$$$1 \\le N \\le 5\\,000$$$\n$$$3(n - 1)$$$\nNo additional limits"
    },
    "original": "Taiwan has a big railway line connecting the western and eastern shores of the island. The line consists of blocks $$$m$$$. The consecutive blocks are numbered $$$0, \\ldots, m - 1$$$, starting from the western end. Each block has a one-way west-bound track on the north, a one-way east-bound track on the south, and optionally a train station between them.\nThere are three types of blocks. A type $$$C$$$ block has a train station that you must enter from the northern track and exit to the southern track, a type $$$D$$$ block has a train station that you must enter from the southern track and exit to the northern track, and a type empty block has no train station. For example, in the following figure block 0 is type empty, block 1 is type $$$C$$$, and block 5 is type $$$D$$$. Blocks connect to each other horizontally. Tracks of adjacent blocks are joined by connectors, shown as shaded rectangles in the following figure.\nThe railsystem has $$$n$$$ stations numbered from $$$0$$$ to $$$n - 1$$$. We assume that we can go from any station to any other station by following the track. For example we can go from station 0 to station 2 by starting from block 2, then passing through blocks 3 and 4 by the southern track, and then passing through station 1, then passing through block 4 by the northern track, and finally reaching station 2 at block 3.\nSince there are multiple possible routes, the distance from one station to another is defined as the minimum number of connectors the route passes through. For example the shortest route from station 0 to 2 is through blocks $$$2-3-4-5-4-3$$$ and passes through 5 connectors, so the distance is $$$5$$$.\nA computer system manages the railsystem. Unfortunately after a power outage the computer no longer knows where the stations are and what types of blocks they are in. The only clue the computer has is the block number of station 0, which is always in a type $$$C$$$ block. Fortunately the computer can query the distance from any station to any other station. For example, the computer can query \"what is the distance from station $$$0$$$ to station $$$2$$$?\" and it will receive $$$5$$$.\nTask\nYou need to implement a function\nfindLocation\nthat determines for each station the block number and block type.\nvoid findLocation(int n, int first, int location[], int stype[])\n$$$n$$$: the number of stations.\n$$$first$$$: the block number of station $$$0$$$.\n$$$location$$$: array of size $$$n$$$; you should place the block number of station $$$i$$$ into $$$location[i]$$$.\n$$$stype$$$: array of size $$$n$$$; you should place the block type of station $$$i$$$ into $$$stype[i]$$$: $$$1$$$ for type $$$C$$$ and $$$2$$$ for type $$$D$$$.\nYou can call a function\nint getDistance(int i, int j)\nto help you find the locations and types of stations.\ngetDistance(i, j)\nreturns the distance from station $$$i$$$ to station $$$j$$$\ngetDistance(i, i)\nwill return $$$0$$$\ngetDistance(i, j)\nwill return $$$-1$$$ if $$$i$$$ or $$$j$$$ is outside the range $$$0 \\le i, j \\le n - 1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: the subtask number\nline 2: $$$n$$$\nlines $$$3 + i (0 \\le i \\le n - 1)$$$: $$$stype[i]$$$ ($$$1$$$ for type $$$C$$$ and $$$2$$$ for type $$$D$$$), $$$location[i]$$$.\nOutput\nThe sample grader will print\nCorrect\nif $$$location[0] \\ldots location[n - 1]$$$ and $$$stype[0] \\ldots stype[n - 1]$$$ computed by your program match the input when\nfindLocation\nreturns, or\nIncorrect\nif they do not match.\nScoring\nIn allsubtasks the number of blocks $$$m$$$ is no more than $$$1\\,000\\,000$$$. In some subtasks the number of calls to\ngetDistance\nis limited. The limit varies by subtask. Your program will receive 'wrong answer' if it exceeds this limit.\nSubtask\nPoints\n$$$n$$$\ngetDistance calls\nnote\n1\n8\n$$$1 \\le n \\le 100$$$\nunlimited\nAllstations except $$$0$$$ are in type $$$D$$$ blocks.\n2\n22\n$$$1 \\le n \\le 100$$$\nunlimited\nAllstations to the right of station $$$0$$$ are in type $$$D$$$ blocks, and allstations to the left of station $$$0$$$ are in type $$$C$$$ blocks.\n3\n26\n$$$1 \\le N \\le 5\\,000$$$\n$$$n(n - 1) / 2$$$\nNo additional limits\n4\n44\n$$$1 \\le N \\le 5\\,000$$$\n$$$3(n - 1)$$$\nNo additional limits",
    "_meta": {
      "index": 27,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/A",
      "uuid": "ps_e3a48da5f8294f3b868ed6bc57926045b30c1682"
    }
  },
  {
    "planning_view": {
      "title": "D. Packing Biscuits",
      "task": "Count possible tastiness values y for x identical bags given biscuit counts",
      "given": [
        "x identical bags to pack",
        "k biscuit types (0 to k-1)",
        "Type i has tastiness 2^i",
        "a[i] biscuits available of type i"
      ],
      "goal": "Find number of distinct y values such that x bags can each have total tastiness y",
      "key_rules": [
        "Bags are identical (same y for all)",
        "Total biscuits used per type ≤ a[i]",
        "Sum of tastiness across all biscuits in pantry ≤ 10^18"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "q≤10, sum tastiness ≤100,000"
        },
        "2": {
          "points": 12,
          "req": "x=1, q≤10"
        },
        "3": {
          "points": 21,
          "req": "x≤10,000, q≤10"
        },
        "4": {
          "points": 35,
          "req": "Return value ≤200,000"
        },
        "5": {
          "points": 23,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Packing Biscuits",
      "contest": "IOI 2020 day 2",
      "one_line": "Count possible tastiness values y for x identical bags given biscuit counts",
      "given": [
        "x identical bags to pack",
        "k biscuit types (0 to k-1)",
        "Type i has tastiness 2^i",
        "a[i] biscuits available of type i"
      ],
      "goal": "Find number of distinct y values such that x bags can each have total tastiness y",
      "mechanism": "Distribute biscuits across x bags respecting supply limits per type",
      "success_condition": "Return count of achievable y values for given x and a",
      "constraints": {
        "critical": [
          "Bags are identical (same y for all)",
          "Total biscuits used per type ≤ a[i]",
          "Sum of tastiness across all biscuits in pantry ≤ 10^18"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "q≤10, sum tastiness ≤100,000"
          },
          "2": {
            "points": 12,
            "req": "x=1, q≤10"
          },
          "3": {
            "points": 21,
            "req": "x≤10,000, q≤10"
          },
          "4": {
            "points": 35,
            "req": "Return value ≤200,000"
          },
          "5": {
            "points": 23,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Packing Biscuits",
        "contest": "IOI 2020 day 2",
        "one_line": "Count possible tastiness values y for x identical bags given biscuit counts"
      },
      "problem": {
        "given": [
          "x identical bags to pack",
          "k biscuit types (0 to k-1)",
          "Type i has tastiness 2^i",
          "a[i] biscuits available of type i"
        ],
        "goal": "Find number of distinct y values such that x bags can each have total tastiness y",
        "mechanism": "Distribute biscuits across x bags respecting supply limits per type",
        "success_condition": "Return count of achievable y values for given x and a"
      },
      "constraints": {
        "critical": [
          "Bags are identical (same y for all)",
          "Total biscuits used per type ≤ a[i]",
          "Sum of tastiness across all biscuits in pantry ≤ 10^18"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "q≤10, sum tastiness ≤100,000"
          },
          "2": {
            "points": 12,
            "req": "x=1, q≤10"
          },
          "3": {
            "points": 21,
            "req": "x≤10,000, q≤10"
          },
          "4": {
            "points": 35,
            "req": "Return value ≤200,000"
          },
          "5": {
            "points": 23,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 count_tastiness(int64 x, int64[] a)",
        "available_api": {},
        "requirements": [
          "Procedure called q times (1≤q≤1000)",
          "k: 1 to 60, x: 1 to 10^18",
          "a[i]: 0 to 10^18",
          "Use 64-bit integers"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "Aunty Khong is organising a competition with $$$x$$$ participants, and wants to give each participant a\nbag of biscuits\n. There are $$$k$$$ different types of biscuits, numbered from $$$0$$$ to $$$k-1$$$. Each biscuit of type $$$i$$$ ($$$0 \\leq i \\leq k-1$$$) has a\ntastiness value\nof $$$2^i$$$. Aunty Khong has $$$a[i]$$$ (possibly zero) biscuits of type $$$i$$$ in her pantry.\nEach of Aunty Khong's bags will contain zero or more biscuits of each type. The total number of biscuits of type $$$i$$$ in all the bags must not exceed $$$a[i]$$$. The sum of tastiness values of all biscuits in a bag is called the\ntotal tastiness\nof the bag.\nHelp Aunty Khong find out how many different values of $$$y$$$ exist, such that it is possible to pack $$$x$$$ bags of biscuits, each having total tastiness equal to $$$y$$$.\nImplementation Details\nYou should implement the following proceedure:\nint64 count_tastiness(int64 x, int64[] a)\n$$$x$$$: the number of bags of biscuits to pack.\n$$$a$$$: an array of length $$$k$$$. For $$$0 \\leq i \\leq k-1$$$, $$$a[i]$$$ denotes the number of biscuits of type $$$i$$$ in the pantry.\nThe procedure should return the number of different values of $$$y$$$, such that Aunty can pack $$$x$$$ bags of biscuits, each one having a total tastiness of $$$y$$$.\nThe procedure is called a total of $$$q$$$ times (see Constraints and Subtasks sections for the allowed values of $$$q$$$). Each of these calls should be treated as a separate scenario.\nInput\nThe sample grader reads the input in the following format. The first line contains an integer $$$q$$$ ($$$1 \\leq q \\leq 1000$$$). After that, $$$q$$$ pairs of lines follow, and each pair describes a single scenario in the following format:\nline $$$1$$$: $$$k\\ x$$$ ($$$1 \\leq k \\leq 60$$$, $$$1 \\leq x \\leq 10^{18}$$$)\nline $$$2$$$: $$$a[0]\\ a[1]\\ldots a[k-1]$$$ ($$$0 \\leq a[i] \\leq 10^{18}$$$ (for all $$$0 \\leq i \\leq k-1$$$))\nFor each call to\ncount_tastiness\n, the sum of tastiness values of all biscuits in the pantry does not exceed $$$10^{18}$$$.\nOutput\nThe output of the sample grader is in the following format:\nline $$$i$$$ ($$$1 \\leq i \\leq q$$$): return value of\ncount_tastiness\nfor the $$$i$$$-th scenario in the input.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$q \\leq 10$$$, and for each call to\ncount_tastiness\n, the sum of tastiness values of all biscuits in the pantry does not exceed $$$100\\,000$$$.\n2\n12\n$$$x = 1$$$, $$$q \\leq 10$$$\n3\n21\n$$$x \\leq 10\\,000$$$, $$$q \\leq 10$$$\n4\n35\nThe correct return value of each call to\ncount_tastiness\ndoes not exceed $$$200\\,000$$$.\n5\n23\nNo additional constraints.\nNote\nExample 1\nConsider the following call:\ncount_tastiness(3, [5, 2, 1])\nThis means that Aunty wants to pack $$$3$$$ bags, and there are $$$3$$$ types of biscuits in the shop:\n$$$5$$$ biscuits of type $$$0$$$, each having a tastiness value $$$1$$$,\n$$$2$$$ biscuits of type $$$1$$$, each having a tastiness value $$$2$$$,\n$$$1$$$ biscuit of type $$$2$$$, each having a tastiness value $$$4$$$.\nThe possible values of $$$y$$$ are $$$[0, 1, 2, 3, 4]$$$. For instance, in order to pack $$$3$$$ bags of total tastiness $$$3$$$, Aunty can pack:\none bag containing three biscuits of type $$$0$$$, and\ntwo bags, each containing one biscuit of type $$$0$$$ and one biscuit of type $$$1$$$.\nSince there are $$$5$$$ possible values of $$$y$$$, the procedure should return $$$5$$$.\nExample 2\nConsider the following call:\ncount_tastiness(2, [2, 1, 2])\nThis means that Aunty wants to pack $$$2$$$ bags, and there are $$$3$$$ types of biscuits in the shop:\n$$$2$$$ biscuits of type $$$0$$$, each having a tastiness value $$$1$$$,\n$$$1$$$ biscuits of type $$$1$$$, each having a tastiness value $$$2$$$,\n$$$2$$$ biscuits of type $$$2$$$, each having a tastiness value $$$4$$$.\nThe possible values of $$$y$$$ are $$$[0,1,2,4,5,6]$$$. Since there are $$$6$$$ possible values of $$$y$$$, the procedure should return $$$6$$$."
    },
    "original": "Aunty Khong is organising a competition with $$$x$$$ participants, and wants to give each participant a\nbag of biscuits\n. There are $$$k$$$ different types of biscuits, numbered from $$$0$$$ to $$$k-1$$$. Each biscuit of type $$$i$$$ ($$$0 \\leq i \\leq k-1$$$) has a\ntastiness value\nof $$$2^i$$$. Aunty Khong has $$$a[i]$$$ (possibly zero) biscuits of type $$$i$$$ in her pantry.\nEach of Aunty Khong's bags will contain zero or more biscuits of each type. The total number of biscuits of type $$$i$$$ in all the bags must not exceed $$$a[i]$$$. The sum of tastiness values of all biscuits in a bag is called the\ntotal tastiness\nof the bag.\nHelp Aunty Khong find out how many different values of $$$y$$$ exist, such that it is possible to pack $$$x$$$ bags of biscuits, each having total tastiness equal to $$$y$$$.\nImplementation Details\nYou should implement the following proceedure:\nint64 count_tastiness(int64 x, int64[] a)\n$$$x$$$: the number of bags of biscuits to pack.\n$$$a$$$: an array of length $$$k$$$. For $$$0 \\leq i \\leq k-1$$$, $$$a[i]$$$ denotes the number of biscuits of type $$$i$$$ in the pantry.\nThe procedure should return the number of different values of $$$y$$$, such that Aunty can pack $$$x$$$ bags of biscuits, each one having a total tastiness of $$$y$$$.\nThe procedure is called a total of $$$q$$$ times (see Constraints and Subtasks sections for the allowed values of $$$q$$$). Each of these calls should be treated as a separate scenario.\nInput\nThe sample grader reads the input in the following format. The first line contains an integer $$$q$$$ ($$$1 \\leq q \\leq 1000$$$). After that, $$$q$$$ pairs of lines follow, and each pair describes a single scenario in the following format:\nline $$$1$$$: $$$k\\ x$$$ ($$$1 \\leq k \\leq 60$$$, $$$1 \\leq x \\leq 10^{18}$$$)\nline $$$2$$$: $$$a[0]\\ a[1]\\ldots a[k-1]$$$ ($$$0 \\leq a[i] \\leq 10^{18}$$$ (for all $$$0 \\leq i \\leq k-1$$$))\nFor each call to\ncount_tastiness\n, the sum of tastiness values of all biscuits in the pantry does not exceed $$$10^{18}$$$.\nOutput\nThe output of the sample grader is in the following format:\nline $$$i$$$ ($$$1 \\leq i \\leq q$$$): return value of\ncount_tastiness\nfor the $$$i$$$-th scenario in the input.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$q \\leq 10$$$, and for each call to\ncount_tastiness\n, the sum of tastiness values of all biscuits in the pantry does not exceed $$$100\\,000$$$.\n2\n12\n$$$x = 1$$$, $$$q \\leq 10$$$\n3\n21\n$$$x \\leq 10\\,000$$$, $$$q \\leq 10$$$\n4\n35\nThe correct return value of each call to\ncount_tastiness\ndoes not exceed $$$200\\,000$$$.\n5\n23\nNo additional constraints.\nNote\nExample 1\nConsider the following call:\ncount_tastiness(3, [5, 2, 1])\nThis means that Aunty wants to pack $$$3$$$ bags, and there are $$$3$$$ types of biscuits in the shop:\n$$$5$$$ biscuits of type $$$0$$$, each having a tastiness value $$$1$$$,\n$$$2$$$ biscuits of type $$$1$$$, each having a tastiness value $$$2$$$,\n$$$1$$$ biscuit of type $$$2$$$, each having a tastiness value $$$4$$$.\nThe possible values of $$$y$$$ are $$$[0, 1, 2, 3, 4]$$$. For instance, in order to pack $$$3$$$ bags of total tastiness $$$3$$$, Aunty can pack:\none bag containing three biscuits of type $$$0$$$, and\ntwo bags, each containing one biscuit of type $$$0$$$ and one biscuit of type $$$1$$$.\nSince there are $$$5$$$ possible values of $$$y$$$, the procedure should return $$$5$$$.\nExample 2\nConsider the following call:\ncount_tastiness(2, [2, 1, 2])\nThis means that Aunty wants to pack $$$2$$$ bags, and there are $$$3$$$ types of biscuits in the shop:\n$$$2$$$ biscuits of type $$$0$$$, each having a tastiness value $$$1$$$,\n$$$1$$$ biscuits of type $$$1$$$, each having a tastiness value $$$2$$$,\n$$$2$$$ biscuits of type $$$2$$$, each having a tastiness value $$$4$$$.\nThe possible values of $$$y$$$ are $$$[0,1,2,4,5,6]$$$. Since there are $$$6$$$ possible values of $$$y$$$, the procedure should return $$$6$$$.",
    "_meta": {
      "index": 28,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/D",
      "uuid": "ps_321203a0a96fd4172029a9deb3c08e540a3b5029"
    }
  },
  {
    "planning_view": {
      "title": "E. Robots",
      "task": "Schedule T toys to A weak (weight-limit) and B small (size-limit) robots for minimum time",
      "given": [
        "T toys with weight W[i] and size S[i]",
        "A weak robots with weight limits X[i]",
        "B small robots with size limits Y[i]",
        "Weak robots can carry: toy weight < robot weight limit",
        "Small robots can carry: toy size < robot size limit"
      ],
      "goal": "Find minimum minutes to clear all toys, or determine if impossible",
      "key_rules": [
        "Weak robot: toy weight < robot weight limit (size irrelevant)",
        "Small robot: toy size < robot size limit (weight irrelevant)",
        "Each robot handles one toy per minute",
        "Robots work in parallel"
      ],
      "target": {
        "1": {
          "points": 14,
          "req": "T=2 and A+B=2 (exactly two toys and two robots)"
        },
        "2": {
          "points": 14,
          "req": "B=0 (all robots are weak)"
        },
        "3": {
          "points": 25,
          "req": "T≤50 and A+B≤50"
        },
        "4": {
          "points": 37,
          "req": "T≤10,000 and A+B≤1,000"
        },
        "5": {
          "points": 10,
          "req": "None (full constraints)"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Robots",
      "contest": "IOI 2013 day 2",
      "one_line": "Schedule T toys to A weak (weight-limit) and B small (size-limit) robots for minimum time",
      "given": [
        "T toys with weight W[i] and size S[i]",
        "A weak robots with weight limits X[i]",
        "B small robots with size limits Y[i]",
        "Weak robots can carry: toy weight < robot weight limit",
        "Small robots can carry: toy size < robot size limit"
      ],
      "goal": "Find minimum minutes to clear all toys, or determine if impossible",
      "mechanism": "Each robot handles one toy per minute; multiple robots work simultaneously",
      "success_condition": "All toys assigned to compatible robots with minimum parallel time",
      "constraints": {
        "critical": [
          "Weak robot: toy weight < robot weight limit (size irrelevant)",
          "Small robot: toy size < robot size limit (weight irrelevant)",
          "Each robot handles one toy per minute",
          "Robots work in parallel"
        ],
        "subtasks": {
          "1": {
            "points": 14,
            "req": "T=2 and A+B=2 (exactly two toys and two robots)"
          },
          "2": {
            "points": 14,
            "req": "B=0 (all robots are weak)"
          },
          "3": {
            "points": 25,
            "req": "T≤50 and A+B≤50"
          },
          "4": {
            "points": 37,
            "req": "T≤10,000 and A+B≤1,000"
          },
          "5": {
            "points": 10,
            "req": "None (full constraints)"
          }
        }
      },
      "limits": {
        "time": "4 seconds",
        "memory": "64 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Robots",
        "contest": "IOI 2013 day 2",
        "one_line": "Schedule T toys to A weak (weight-limit) and B small (size-limit) robots for minimum time"
      },
      "problem": {
        "given": [
          "T toys with weight W[i] and size S[i]",
          "A weak robots with weight limits X[i]",
          "B small robots with size limits Y[i]",
          "Weak robots can carry: toy weight < robot weight limit",
          "Small robots can carry: toy size < robot size limit"
        ],
        "goal": "Find minimum minutes to clear all toys, or determine if impossible",
        "mechanism": "Each robot handles one toy per minute; multiple robots work simultaneously",
        "success_condition": "All toys assigned to compatible robots with minimum parallel time"
      },
      "constraints": {
        "critical": [
          "Weak robot: toy weight < robot weight limit (size irrelevant)",
          "Small robot: toy size < robot size limit (weight irrelevant)",
          "Each robot handles one toy per minute",
          "Robots work in parallel"
        ],
        "subtasks": {
          "1": {
            "points": 14,
            "req": "T=2 and A+B=2 (exactly two toys and two robots)"
          },
          "2": {
            "points": 14,
            "req": "B=0 (all robots are weak)"
          },
          "3": {
            "points": 25,
            "req": "T≤50 and A+B≤50"
          },
          "4": {
            "points": 37,
            "req": "T≤10,000 and A+B≤1,000"
          },
          "5": {
            "points": 10,
            "req": "None (full constraints)"
          }
        }
      },
      "implementation": {
        "function_to_write": "int putaway(int A, int B, int T, int X[], int Y[], int W[], int S[])",
        "available_api": {
          "putaway": {
            "signature": "int putaway(int A, int B, int T, int X[], int Y[], int W[], int S[])",
            "params": "A: weak robots count, B: small robots count, T: toys count, X[]: weak robot weight limits, Y[]: small robot size limits, W[]: toy weights, S[]: toy sizes",
            "returns": "Minimum minutes or -1 if impossible",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Must #include \"robots.h\"",
          "No main() function",
          "Handle large constraints: T up to 1,000,000, values up to 2,000,000,000"
        ]
      },
      "limits": {
        "time": "4 seconds",
        "memory": "64 megabytes"
      },
      "samples": [
        {
          "input": "3 2 10\n6 2 9\n4 7\n4 6\n8 5\n2 3\n7 9\n1 8\n5 1\n3 3\n8 7\n7 6\n10 5",
          "output": "3"
        }
      ],
      "original_statement": "Marita's little brother has left toys all over the living room floor! Fortunately, Marita has developed special robots to clean up the toys. She needs your help to determine which robots should pick up which toys.\nThere are $$$T$$$ toys, each with an integer weight $$$W[i]$$$ and an integer size $$$S[i]$$$. Robots come in two kinds:\nweak\nand\nsmall\n.\nThere are $$$A$$$ weak robots. Each weak robot has a weight limit $$$X[i]$$$, and can carry any toy of weight strictly less than $$$X[i]$$$. The size of the toy does not matter.\nThere are $$$B$$$ small robots. Each small robot has a size limit $$$Y[i]$$$, and can carry any toy of size strictly less than $$$Y[i]$$$. The weight of the toy does not matter.\nEach of Marita's robots takes one minute to put each toy away. Different robots can put away different toys at the same time.\nYour task is to determine whether Marita's robots can put all the toys away, and if so, the shortest time in which they can do this.\nYou should submit a file implementing the function\nputaway()\nas follows:\nint putaway(int A, int B, int T, int X[], int Y[], int W[], int S[]);\nThis function should calculate the smallest number of minutes required for the robots to put all of the toys away, or should return $$$-1$$$ if this is not possible.\nParameters:\n$$$A$$$: The number of weak robots.\n$$$B$$$: The number of small robots.\n$$$T$$$: The number of toys.\n$$$X$$$: An array of length $$$A$$$ containing integers that specify the weight limit for each weak robot.\n$$$Y$$$: An array of length $$$B$$$ containing integers that specify the size limit for each small robot.\n$$$W$$$: An array of length $$$T$$$ containing integers that give the weight of each toy.\n$$$S$$$: An array of length $$$T$$$ containing integers that give the size of each toy.\nReturns\n: The smallest number of minutes required to put all of the toys away, or $$$-1$$$ if this is not possible.\nInput\nThe grader reads input in the following format:\nline $$$1$$$: $$$A\\ B\\ T$$$\nline $$$2$$$: $$$X[0]\\dots X[A - 1]$$$\nline $$$3$$$: $$$Y[0]\\dots Y[B- 1]$$$\nthe next $$$T$$$ lines: $$$W[i]\\ S[i]$$$\nScoring\nFull constraints:\n$$$1 \\leq T \\leq 1\\,000\\,000$$$\n$$$0\\leq A,B\\leq 50\\,000$$$ and $$$1\\leq A+B$$$\n$$$1 \\leq X[i], Y[i], W[i], S[i] \\leq 2\\,000\\,000\\,000$$$\nSubtask\nPoints\nAdditional Input Constraints\n1\n14\n$$$T=2$$$ and $$$A+B=2$$$ (exactly two toys and two robots)\n2\n14\n$$$B = 0$$$ (all robots are weak)\n3\n25\n$$$T\\leq 50$$$ and $$$A+B\\leq 50$$$\n4\n37\n$$$T\\leq 10,000$$$ and $$$A+B\\leq 1\\,000$$$\n5\n10\n(\nNone\n)\nExamples\nNote\nConsider the first example. The shortest time to put all the toys away is three minutes:\nWeak robot 0\nWeak robot 1\nWeak robot 2\nSmall robot 0\nSmall robot 1\nFirst minute\nToy 0\nToy 4\nToy 1\nToy 6\nToy 2\nSecond minute\nToy 5\nToy 3\nToy 8\nThird minute\nToy 7\nToy 9\nIn the second example no robot can pick up the toy of weight $$$5$$$ and size $$$3$$$, and so it is impossible for the robots to put all of the toys away.\nYou must\n#include \"robots.h\"\nin your submission."
    },
    "original": "Marita's little brother has left toys all over the living room floor! Fortunately, Marita has developed special robots to clean up the toys. She needs your help to determine which robots should pick up which toys.\nThere are $$$T$$$ toys, each with an integer weight $$$W[i]$$$ and an integer size $$$S[i]$$$. Robots come in two kinds:\nweak\nand\nsmall\n.\nThere are $$$A$$$ weak robots. Each weak robot has a weight limit $$$X[i]$$$, and can carry any toy of weight strictly less than $$$X[i]$$$. The size of the toy does not matter.\nThere are $$$B$$$ small robots. Each small robot has a size limit $$$Y[i]$$$, and can carry any toy of size strictly less than $$$Y[i]$$$. The weight of the toy does not matter.\nEach of Marita's robots takes one minute to put each toy away. Different robots can put away different toys at the same time.\nYour task is to determine whether Marita's robots can put all the toys away, and if so, the shortest time in which they can do this.\nYou should submit a file implementing the function\nputaway()\nas follows:\nint putaway(int A, int B, int T, int X[], int Y[], int W[], int S[]);\nThis function should calculate the smallest number of minutes required for the robots to put all of the toys away, or should return $$$-1$$$ if this is not possible.\nParameters:\n$$$A$$$: The number of weak robots.\n$$$B$$$: The number of small robots.\n$$$T$$$: The number of toys.\n$$$X$$$: An array of length $$$A$$$ containing integers that specify the weight limit for each weak robot.\n$$$Y$$$: An array of length $$$B$$$ containing integers that specify the size limit for each small robot.\n$$$W$$$: An array of length $$$T$$$ containing integers that give the weight of each toy.\n$$$S$$$: An array of length $$$T$$$ containing integers that give the size of each toy.\nReturns\n: The smallest number of minutes required to put all of the toys away, or $$$-1$$$ if this is not possible.\nInput\nThe grader reads input in the following format:\nline $$$1$$$: $$$A\\ B\\ T$$$\nline $$$2$$$: $$$X[0]\\dots X[A - 1]$$$\nline $$$3$$$: $$$Y[0]\\dots Y[B- 1]$$$\nthe next $$$T$$$ lines: $$$W[i]\\ S[i]$$$\nScoring\nFull constraints:\n$$$1 \\leq T \\leq 1\\,000\\,000$$$\n$$$0\\leq A,B\\leq 50\\,000$$$ and $$$1\\leq A+B$$$\n$$$1 \\leq X[i], Y[i], W[i], S[i] \\leq 2\\,000\\,000\\,000$$$\nSubtask\nPoints\nAdditional Input Constraints\n1\n14\n$$$T=2$$$ and $$$A+B=2$$$ (exactly two toys and two robots)\n2\n14\n$$$B = 0$$$ (all robots are weak)\n3\n25\n$$$T\\leq 50$$$ and $$$A+B\\leq 50$$$\n4\n37\n$$$T\\leq 10,000$$$ and $$$A+B\\leq 1\\,000$$$\n5\n10\n(\nNone\n)\nExamples\nNote\nConsider the first example. The shortest time to put all the toys away is three minutes:\nWeak robot 0\nWeak robot 1\nWeak robot 2\nSmall robot 0\nSmall robot 1\nFirst minute\nToy 0\nToy 4\nToy 1\nToy 6\nToy 2\nSecond minute\nToy 5\nToy 3\nToy 8\nThird minute\nToy 7\nToy 9\nIn the second example no robot can pick up the toy of weight $$$5$$$ and size $$$3$$$, and so it is impossible for the robots to put all of the toys away.\nYou must\n#include \"robots.h\"\nin your submission.",
    "_meta": {
      "index": 29,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/E",
      "uuid": "ps_9a21096502b5412aeeccbc8f7d40b74807b7a944"
    }
  },
  {
    "planning_view": {
      "title": "A. Cluedo",
      "task": "Find correct murderer-location-weapon combination using Theory(M,L,W) in ≤20 calls",
      "given": [
        "6 murderers (1-6)",
        "10 locations (1-10)",
        "6 weapons (1-6)",
        "One correct combination of (M,L,W)"
      ],
      "goal": "Determine the correct combination of murderer, location, and weapon",
      "key_rules": [
        "Theory returns 1 if murderer wrong, 2 if location wrong, 3 if weapon wrong",
        "If multiple wrong, Jack picks one arbitrarily",
        "Solve called up to 100 times per test run"
      ],
      "target": {
        "1": {
          "points": 50,
          "req": "At most 360 Theory calls per Solve"
        },
        "2": {
          "points": 50,
          "req": "At most 20 Theory calls per Solve"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Cluedo",
      "contest": "IOI 2010 day 1",
      "one_line": "Find correct murderer-location-weapon combination using Theory(M,L,W) in ≤20 calls",
      "given": [
        "6 murderers (1-6)",
        "10 locations (1-10)",
        "6 weapons (1-6)",
        "One correct combination of (M,L,W)"
      ],
      "goal": "Determine the correct combination of murderer, location, and weapon",
      "mechanism": "Call Theory(M,L,W) to test theories; returns 0 if correct, otherwise indicates which category is wrong",
      "success_condition": "Theory(M,L,W) returns 0 (all three categories correct)",
      "constraints": {
        "critical": [
          "Theory returns 1 if murderer wrong, 2 if location wrong, 3 if weapon wrong",
          "If multiple wrong, Jack picks one arbitrarily",
          "Solve called up to 100 times per test run"
        ],
        "subtasks": {
          "1": {
            "points": 50,
            "req": "At most 360 Theory calls per Solve"
          },
          "2": {
            "points": 50,
            "req": "At most 20 Theory calls per Solve"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Cluedo",
        "contest": "IOI 2010 day 1",
        "one_line": "Find correct murderer-location-weapon combination using Theory(M,L,W) in ≤20 calls"
      },
      "problem": {
        "given": [
          "6 murderers (1-6)",
          "10 locations (1-10)",
          "6 weapons (1-6)",
          "One correct combination of (M,L,W)"
        ],
        "goal": "Determine the correct combination of murderer, location, and weapon",
        "mechanism": "Call Theory(M,L,W) to test theories; returns 0 if correct, otherwise indicates which category is wrong",
        "success_condition": "Theory(M,L,W) returns 0 (all three categories correct)"
      },
      "constraints": {
        "critical": [
          "Theory returns 1 if murderer wrong, 2 if location wrong, 3 if weapon wrong",
          "If multiple wrong, Jack picks one arbitrarily",
          "Solve called up to 100 times per test run"
        ],
        "subtasks": {
          "1": {
            "points": 50,
            "req": "At most 360 Theory calls per Solve"
          },
          "2": {
            "points": 50,
            "req": "At most 20 Theory calls per Solve"
          }
        }
      },
      "implementation": {
        "function_to_write": "void Solve()",
        "available_api": {
          "Theory": {
            "signature": "int Theory(int M, int L, int W)",
            "params": "M: murderer (1-6), L: location (1-10), W: weapon (1-6)",
            "returns": "0 if correct, 1 if murderer wrong, 2 if location wrong, 3 if weapon wrong",
            "side_effect": "None beyond the return value"
          }
        },
        "requirements": [
          "Initialize variables each time Solve is called",
          "Must terminate after Theory returns 0",
          "M, L, W must be within valid ranges"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "Dr. Black has been murdered. Detective Jill must determine the murderer, the location, and the weapon. There are six possible murderers, numbered 1 to 6. There are ten possible locations, numbered 1 to 10. There are six possible weapons, numbered 1 to 6.\nFor illustration only, we show the names of the possible murderers, locations and weapons. The names are not required to solve the task.\nMurderer\nLocation\nWeapon\nProfessor Plum\nMiss Scarlet\nColonel Mustard\nMrs. White\nReverend Green\nMrs. Peacock\n—\nBallroom\nKitchen\nConservatory\nDining Room\nBilliard Room\nLibrary\nLounge\nHall\nStudy\nCellar\n—\nLead pipe\nDagger\nCandlestick\nRevolver\nRope\nSpanner\n—\nJill repeatedly tries to guess the correct combination of murderer, location and weapon. Each guess is called a theory. She asks her assistant Jack to confirm or to refute each theory in turn. When Jack confirms a theory, Jill is done. When Jack refutes a theory, he reports to Jill that one of the murderer, location or weapon is wrong.\nYou are to implement the procedure\nSolve\nthat plays Jill's role. The grader will call\nSolve\nmany times, each time with a new case to be solved.\nSolve\nmust repeatedly call\nTheory(M,L,W)\n, which is implemented by the grader.\nM\n,\nL\nand\nW\nare numbers denoting a particular combination of murderer, location and weapon.\nTheory(M,L,W)\nreturns 0 if the theory is correct. If the theory is wrong, a value of 1, 2 or 3 is returned. 1 indicates that the murderer is wrong; 2 indicates that the location is wrong; 3 indicates that the weapon is wrong. If more than one is wrong, Jack picks one arbitrarily between the wrong ones (not necessarily in a deterministic way). When\nTheory(M,L,W)\nreturns 0,\nSolve\nshould return.\nExample\nAs example, assume that Miss Scarlet committed the murder (Murderer 2) in the conservatory (Location 3) using a revolver (Weapon 4). When procedure\nSolve\nmakes the following calls to function\nTheory\n, the results in the second column could be returned.\nCall\nReturned value\nExplanation\nTheory(1, 1, 1)\n1, or 2, or 3\nAll three are wrong\nTheory(3, 3, 3)\n1, or 3\nOnly the location is correct\nTheory(5, 3, 4)\n1\nOnly the murderer is wrong\nTheory(2, 3, 4)\n0\nAll are correct\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n50\nEach test run may call\nSolve\nup to $$$100$$$ times. Each call might correspond to a different combination of murderer, location and weapon as the answer. Each time\nSolve\nis called, it must find the correct theory with no more than $$$360$$$ calls to\nTheory(M,L,W)\n. Be sure to initialize any variables used by Solve every time it is called.\n2\n50\nEach test run may call\nSolve\nup to $$$100$$$ times. Each time\nSolve\nis called, it must find the correct theory with no more than $$$20$$$ calls to\nTheory(M,L,W)\n. Be sure to initialize any variables used by\nSolve\nevery time it is called."
    },
    "original": "Dr. Black has been murdered. Detective Jill must determine the murderer, the location, and the weapon. There are six possible murderers, numbered 1 to 6. There are ten possible locations, numbered 1 to 10. There are six possible weapons, numbered 1 to 6.\nFor illustration only, we show the names of the possible murderers, locations and weapons. The names are not required to solve the task.\nMurderer\nLocation\nWeapon\nProfessor Plum\nMiss Scarlet\nColonel Mustard\nMrs. White\nReverend Green\nMrs. Peacock\n—\nBallroom\nKitchen\nConservatory\nDining Room\nBilliard Room\nLibrary\nLounge\nHall\nStudy\nCellar\n—\nLead pipe\nDagger\nCandlestick\nRevolver\nRope\nSpanner\n—\nJill repeatedly tries to guess the correct combination of murderer, location and weapon. Each guess is called a theory. She asks her assistant Jack to confirm or to refute each theory in turn. When Jack confirms a theory, Jill is done. When Jack refutes a theory, he reports to Jill that one of the murderer, location or weapon is wrong.\nYou are to implement the procedure\nSolve\nthat plays Jill's role. The grader will call\nSolve\nmany times, each time with a new case to be solved.\nSolve\nmust repeatedly call\nTheory(M,L,W)\n, which is implemented by the grader.\nM\n,\nL\nand\nW\nare numbers denoting a particular combination of murderer, location and weapon.\nTheory(M,L,W)\nreturns 0 if the theory is correct. If the theory is wrong, a value of 1, 2 or 3 is returned. 1 indicates that the murderer is wrong; 2 indicates that the location is wrong; 3 indicates that the weapon is wrong. If more than one is wrong, Jack picks one arbitrarily between the wrong ones (not necessarily in a deterministic way). When\nTheory(M,L,W)\nreturns 0,\nSolve\nshould return.\nExample\nAs example, assume that Miss Scarlet committed the murder (Murderer 2) in the conservatory (Location 3) using a revolver (Weapon 4). When procedure\nSolve\nmakes the following calls to function\nTheory\n, the results in the second column could be returned.\nCall\nReturned value\nExplanation\nTheory(1, 1, 1)\n1, or 2, or 3\nAll three are wrong\nTheory(3, 3, 3)\n1, or 3\nOnly the location is correct\nTheory(5, 3, 4)\n1\nOnly the murderer is wrong\nTheory(2, 3, 4)\n0\nAll are correct\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n50\nEach test run may call\nSolve\nup to $$$100$$$ times. Each call might correspond to a different combination of murderer, location and weapon as the answer. Each time\nSolve\nis called, it must find the correct theory with no more than $$$360$$$ calls to\nTheory(M,L,W)\n. Be sure to initialize any variables used by Solve every time it is called.\n2\n50\nEach test run may call\nSolve\nup to $$$100$$$ times. Each time\nSolve\nis called, it must find the correct theory with no more than $$$20$$$ calls to\nTheory(M,L,W)\n. Be sure to initialize any variables used by\nSolve\nevery time it is called.",
    "_meta": {
      "index": 30,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/A",
      "uuid": "ps_7563ca895a8bd6a13eaf15fc30973daf174a09bd"
    }
  },
  {
    "planning_view": {
      "title": "F. Traffic Congestion",
      "task": "Choose arena city to minimize maximum road congestion in tree network",
      "given": [
        "N cities connected by N-1 roads forming a tree",
        "Each city i has P[i] hockey fans",
        "All roads are bidirectional with unique paths between cities"
      ],
      "goal": "Select arena city minimizing maximum congestion on any road",
      "key_rules": [
        "Network is a tree (exactly one path between any two cities)",
        "Total fans ≤ 2,000,000,000",
        "Road congestion = sum of fans whose path includes that road",
        "If multiple optimal cities, choose any"
      ],
      "target": {
        "1": {
          "points": 25,
          "req": "N ≤ 1,000; cities in straight line (chain: S[i]=i, D[i]=i+1)"
        },
        "2": {
          "points": 25,
          "req": "N ≤ 1,000,000; cities in straight line (chain)"
        },
        "3": {
          "points": 25,
          "req": "N ≤ 1,000; general tree structure"
        },
        "4": {
          "points": 25,
          "req": "N ≤ 1,000,000; general tree structure"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Traffic Congestion",
      "contest": "IOI 2010 day 2",
      "one_line": "Choose arena city to minimize maximum road congestion in tree network",
      "given": [
        "N cities connected by N-1 roads forming a tree",
        "Each city i has P[i] hockey fans",
        "All roads are bidirectional with unique paths between cities"
      ],
      "goal": "Select arena city minimizing maximum congestion on any road",
      "mechanism": "After game, all fans travel from arena to home cities; congestion on road = total fans crossing it",
      "success_condition": "Return city number where worst-case road congestion is minimized",
      "constraints": {
        "critical": [
          "Network is a tree (exactly one path between any two cities)",
          "Total fans ≤ 2,000,000,000",
          "Road congestion = sum of fans whose path includes that road",
          "If multiple optimal cities, choose any"
        ],
        "subtasks": {
          "1": {
            "points": 25,
            "req": "N ≤ 1,000; cities in straight line (chain: S[i]=i, D[i]=i+1)"
          },
          "2": {
            "points": 25,
            "req": "N ≤ 1,000,000; cities in straight line (chain)"
          },
          "3": {
            "points": 25,
            "req": "N ≤ 1,000; general tree structure"
          },
          "4": {
            "points": 25,
            "req": "N ≤ 1,000,000; general tree structure"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Traffic Congestion",
        "contest": "IOI 2010 day 2",
        "one_line": "Choose arena city to minimize maximum road congestion in tree network"
      },
      "problem": {
        "given": [
          "N cities connected by N-1 roads forming a tree",
          "Each city i has P[i] hockey fans",
          "All roads are bidirectional with unique paths between cities"
        ],
        "goal": "Select arena city minimizing maximum congestion on any road",
        "mechanism": "After game, all fans travel from arena to home cities; congestion on road = total fans crossing it",
        "success_condition": "Return city number where worst-case road congestion is minimized"
      },
      "constraints": {
        "critical": [
          "Network is a tree (exactly one path between any two cities)",
          "Total fans ≤ 2,000,000,000",
          "Road congestion = sum of fans whose path includes that road",
          "If multiple optimal cities, choose any"
        ],
        "subtasks": {
          "1": {
            "points": 25,
            "req": "N ≤ 1,000; cities in straight line (chain: S[i]=i, D[i]=i+1)"
          },
          "2": {
            "points": 25,
            "req": "N ≤ 1,000,000; cities in straight line (chain)"
          },
          "3": {
            "points": 25,
            "req": "N ≤ 1,000; general tree structure"
          },
          "4": {
            "points": 25,
            "req": "N ≤ 1,000,000; general tree structure"
          }
        }
      },
      "implementation": {
        "function_to_write": "int LocateCentre(int N, int P[], int S[], int D[])",
        "available_api": {
          "LocateCentre": {
            "signature": "int LocateCentre(int N, int P[], int S[], int D[])",
            "params": "N: number of cities (0 to N-1), P: array of fan counts per city, S/D: arrays of road endpoints (N-1 edges)",
            "returns": "Optimal arena city number (0-indexed)",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Cities are 0-indexed (0 to N-1)",
          "P array has length N",
          "S and D arrays each have length N-1",
          "Function must return integer city number"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "5\n10 10 10 10 10\n0 1\n1 2\n2 3\n3 4",
          "output": "2"
        }
      ],
      "original_statement": "Although Canada is a large country, many areas are uninhabited, and most of the population lives near the southern border. The TransCanada Highway, completed in 1962, connects the people living in this strip of land, from St. John's in the East to Victoria in the West, a distance of 7 821 km.\nCanadians like hockey. After a hockey game, thousands of fans get in their cars and drive home from the game, causing heavy congestion on the roads. A wealthy entrepreneur wants to buy a hockey team and build a new hockey arena. Your task is to help him select a location for the arena to minimize the traffic congestion after a hockey game.\nThe country is organized into cities connected by a network of roads. All roads are bidirectional, and there is exactly one route connecting any pair of cities. A route connecting the cities $$$c_0$$$ and $$$c_k$$$ is a sequence of distinct cities $$$c_0, \\cdots, c_k$$$ such that there is a road from $$$c_{i-1}$$$ to $$$c_i$$$ for each $$$i$$$. The new arena must be built in one of the cities, which we will call the arena city. After a hockey game, all of the hockey fans travel from the arena city to their home city, except those who already live in the arena city. The amount of congestion on each road is proportional to the number of hockey fans that travel along the road. You must locate the arena city such that the amount of congestion on the most congested road is as small as possible. If there are several equally good locations, you may choose any one.\nYou are to implement a procedure\nLocateCentre(N,P,S,D)\n. $$$N$$$ is a positive integer, the number of cities. The cities are numbered from $$$0$$$ to $$$N-1$$$. $$$P$$$ is an array of $$$N$$$ positive integers; for each $$$i$$$, $$$P[i]$$$ is the number of hockey fans living in the city numbered $$$i$$$. The total number of hockey fans in all the cities will be at most $$$2\\,000\\,000\\,000$$$. $$$S$$$ and $$$D$$$ are arrays of $$$N-1$$$ integers each, specifying the locations of roads. For each $$$i$$$, there is a road connecting the two cities whose numbers are $$$S[i]$$$ and $$$D[i]$$$. The procedure must return an integer, the number of the city that should be the arena city.\nAs an example, consider the network of five cities in the left diagram on the top, where cities $$$0$$$, $$$1$$$ and $$$2$$$ contain $$$10$$$ hockey fans each, and cities $$$3$$$ and $$$4$$$ contain $$$20$$$ hockey fans each. The middle diagram shows the congestions when the new arena is in city $$$2$$$, the worst congestion being $$$40$$$ on the thicker arrow. The right diagram shows the congestions when the new arena is in city $$$3$$$, the worst congestion being $$$30$$$ on the thicker arrow. Therefore, city $$$3$$$ would be a better location for the arena than city $$$2$$$. The data for this example are in 3-rd example test.\nScoring\nSubtask\nPoints\n$$$N$$$\nAdditional Input Constraints\n1\n25\n$$$1 \\le N \\le 1\\,000$$$\nAssume that all the cities lie in a straight line from East to West, and that the roads all follow this straight line with no branches. More specifically, assume that for all $$$i$$$ with $$$0 \\le i \\le N-2$$$, $$$S[i] = i$$$ and $$$D[i] = i+1$$$.\n2\n25\n$$$1 \\le N \\le 1\\,000\\,000$$$\nAssume that all the cities lie in a straight line from East to West, and that the roads all follow this straight line with no branches. More specifically, assume that for all $$$i$$$ with $$$0 \\le i \\le N-2$$$, $$$S[i] = i$$$ and $$$D[i] = i+1$$$.\n3\n25\n$$$1 \\le N \\le 1\\,000$$$\n—\n4\n25\n$$$1 \\le N \\le 1\\,000\\,000$$$\n—\nExamples\nNote\nThe last two example are not allowed in first two subtasks, so they will be first tests of subtask 3."
    },
    "original": "Although Canada is a large country, many areas are uninhabited, and most of the population lives near the southern border. The TransCanada Highway, completed in 1962, connects the people living in this strip of land, from St. John's in the East to Victoria in the West, a distance of 7 821 km.\nCanadians like hockey. After a hockey game, thousands of fans get in their cars and drive home from the game, causing heavy congestion on the roads. A wealthy entrepreneur wants to buy a hockey team and build a new hockey arena. Your task is to help him select a location for the arena to minimize the traffic congestion after a hockey game.\nThe country is organized into cities connected by a network of roads. All roads are bidirectional, and there is exactly one route connecting any pair of cities. A route connecting the cities $$$c_0$$$ and $$$c_k$$$ is a sequence of distinct cities $$$c_0, \\cdots, c_k$$$ such that there is a road from $$$c_{i-1}$$$ to $$$c_i$$$ for each $$$i$$$. The new arena must be built in one of the cities, which we will call the arena city. After a hockey game, all of the hockey fans travel from the arena city to their home city, except those who already live in the arena city. The amount of congestion on each road is proportional to the number of hockey fans that travel along the road. You must locate the arena city such that the amount of congestion on the most congested road is as small as possible. If there are several equally good locations, you may choose any one.\nYou are to implement a procedure\nLocateCentre(N,P,S,D)\n. $$$N$$$ is a positive integer, the number of cities. The cities are numbered from $$$0$$$ to $$$N-1$$$. $$$P$$$ is an array of $$$N$$$ positive integers; for each $$$i$$$, $$$P[i]$$$ is the number of hockey fans living in the city numbered $$$i$$$. The total number of hockey fans in all the cities will be at most $$$2\\,000\\,000\\,000$$$. $$$S$$$ and $$$D$$$ are arrays of $$$N-1$$$ integers each, specifying the locations of roads. For each $$$i$$$, there is a road connecting the two cities whose numbers are $$$S[i]$$$ and $$$D[i]$$$. The procedure must return an integer, the number of the city that should be the arena city.\nAs an example, consider the network of five cities in the left diagram on the top, where cities $$$0$$$, $$$1$$$ and $$$2$$$ contain $$$10$$$ hockey fans each, and cities $$$3$$$ and $$$4$$$ contain $$$20$$$ hockey fans each. The middle diagram shows the congestions when the new arena is in city $$$2$$$, the worst congestion being $$$40$$$ on the thicker arrow. The right diagram shows the congestions when the new arena is in city $$$3$$$, the worst congestion being $$$30$$$ on the thicker arrow. Therefore, city $$$3$$$ would be a better location for the arena than city $$$2$$$. The data for this example are in 3-rd example test.\nScoring\nSubtask\nPoints\n$$$N$$$\nAdditional Input Constraints\n1\n25\n$$$1 \\le N \\le 1\\,000$$$\nAssume that all the cities lie in a straight line from East to West, and that the roads all follow this straight line with no branches. More specifically, assume that for all $$$i$$$ with $$$0 \\le i \\le N-2$$$, $$$S[i] = i$$$ and $$$D[i] = i+1$$$.\n2\n25\n$$$1 \\le N \\le 1\\,000\\,000$$$\nAssume that all the cities lie in a straight line from East to West, and that the roads all follow this straight line with no branches. More specifically, assume that for all $$$i$$$ with $$$0 \\le i \\le N-2$$$, $$$S[i] = i$$$ and $$$D[i] = i+1$$$.\n3\n25\n$$$1 \\le N \\le 1\\,000$$$\n—\n4\n25\n$$$1 \\le N \\le 1\\,000\\,000$$$\n—\nExamples\nNote\nThe last two example are not allowed in first two subtasks, so they will be first tests of subtask 3.",
    "_meta": {
      "index": 31,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/F",
      "uuid": "ps_bfc1e6dcc1f288df66e52d38dd5057ba610d6f86"
    }
  },
  {
    "planning_view": {
      "title": "B. Roller Coaster Railroad",
      "task": "Arrange n sections to minimize track length while satisfying speed constraints",
      "given": [
        "n special sections (0 to n-1)",
        "Each section i has entry speed limit s_i and exit speed t_i",
        "Train starts at 1 km/h"
      ],
      "goal": "Find minimum total track length connecting sections",
      "key_rules": [
        "Sections must be used exactly once",
        "Track length can be any non-negative integer",
        "Speed must be ≤ s_i when entering section i",
        "Speed becomes exactly t_i when leaving section i"
      ],
      "target": {
        "1": {
          "points": 11,
          "req": "n ≤ 8"
        },
        "2": {
          "points": 23,
          "req": "n ≤ 16"
        },
        "3": {
          "points": 30,
          "req": "n ≤ 200,000, only check if zero-length design exists"
        },
        "4": {
          "points": 36,
          "req": "n ≤ 200,000, find minimum total track length"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Roller Coaster Railroad",
      "contest": "IOI 2016 day 1",
      "one_line": "Arrange n sections to minimize track length while satisfying speed constraints",
      "given": [
        "n special sections (0 to n-1)",
        "Each section i has entry speed limit s_i and exit speed t_i",
        "Train starts at 1 km/h"
      ],
      "goal": "Find minimum total track length connecting sections",
      "mechanism": "Sections connected in order; each meter of track slows train by 1 km/h",
      "success_condition": "No speed limits violated, speed always positive",
      "constraints": {
        "critical": [
          "Sections must be used exactly once",
          "Track length can be any non-negative integer",
          "Speed must be ≤ s_i when entering section i",
          "Speed becomes exactly t_i when leaving section i"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "n ≤ 8"
          },
          "2": {
            "points": 23,
            "req": "n ≤ 16"
          },
          "3": {
            "points": 30,
            "req": "n ≤ 200,000, only check if zero-length design exists"
          },
          "4": {
            "points": 36,
            "req": "n ≤ 200,000, find minimum total track length"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Roller Coaster Railroad",
        "contest": "IOI 2016 day 1",
        "one_line": "Arrange n sections to minimize track length while satisfying speed constraints"
      },
      "problem": {
        "given": [
          "n special sections (0 to n-1)",
          "Each section i has entry speed limit s_i and exit speed t_i",
          "Train starts at 1 km/h"
        ],
        "goal": "Find minimum total track length connecting sections",
        "mechanism": "Sections connected in order; each meter of track slows train by 1 km/h",
        "success_condition": "No speed limits violated, speed always positive"
      },
      "constraints": {
        "critical": [
          "Sections must be used exactly once",
          "Track length can be any non-negative integer",
          "Speed must be ≤ s_i when entering section i",
          "Speed becomes exactly t_i when leaving section i"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "n ≤ 8"
          },
          "2": {
            "points": 23,
            "req": "n ≤ 16"
          },
          "3": {
            "points": 30,
            "req": "n ≤ 200,000, only check if zero-length design exists"
          },
          "4": {
            "points": 36,
            "req": "n ≤ 200,000, find minimum total track length"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 plan_roller_coaster(int[] s, int[] t)",
        "available_api": {
          "plan_roller_coaster": {
            "signature": "int64 plan_roller_coaster(int[] s, int[] t)",
            "params": "s: array of entry speed limits, t: array of exit speeds",
            "returns": "Minimum total track length (or 0/positive in subtask 3)",
            "side_effect": "None"
          }
        },
        "requirements": [
          "1 ≤ s_i, t_i ≤ 10^9",
          "n ≥ 2",
          "Return actual minimum in subtasks 1,2,4",
          "Return 0 if zero-length design exists in subtask 3, else positive"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "4\n1 7\n4 3\n5 8\n6 6",
          "output": "3"
        }
      ],
      "original_statement": "Anna is working in an amusement park and she is in charge of building the railroad for a new roller coaster. She has already designed $$$n$$$ special sections (conveniently numbered from $$$0$$$ to $$$n - 1$$$) that affect the speed of a roller coaster train. She now has to put them together and propose a final design of the roller coaster. For the purpose of this problem you may assume that the length of the train is zero.\nFor each $$$i$$$ between $$$0$$$ and $$$n - 1$$$, inclusive, the special section $$$i$$$ has two properties:\nwhen entering the section, there is a speed limit: the speed of the train must be\nless or equal to\n$$$s_i$$$ km/h (kilometers per hour),\nwhen leaving the section, the speed of the train is\nexactly\n$$$t_i$$$ km/h, regardless of the speed at which the train entered the section.\nThe finished roller coaster is a single railroad line that contains the $$$n$$$ special sections in some order. Each of the $$$n$$$ sections should be used exactly once. Consecutive sections are connected with tracks. Anna should choose the order of the $$$n$$$ sections and then decide the lengths of the tracks. The length of a track is measured in meters and may be equal to any non-negative integer (possibly zero).\nEach meter of the track between two special sections slows the train down by $$$1$$$ km/h. At the beginning of the ride, the train enters the first special section in the order selected by Anna, going at $$$1$$$ km/h.\nThe final design must satisfy the following requirements:\nthe train does not violate any speed limit when entering the special sections;\nthe speed of the train is positive at any moment.\nIn all subtasks except subtask 3, your task is to find the minimum possible total length of tracks between sections. In subtask 3 you only need to check whether there exists a valid roller coaster design, such that each track has zero length.\nImplementation details\nYou should implement the following function (method):\nint64 plan_roller_coaster(int[] s, int[] t)\n.\ns\n: array of length $$$n$$$, maximum allowed entry speeds.\nt\n: array of length $$$n$$$, exit speeds.\nIn all subtasks except subtask 3, the function should return the minimum possible total length of all tracks. In subtask 3 the function should return $$$0$$$ if there exists a valid roller coaster design such that each track has zero length, and any positive integer if it does not exist.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: integer $$$n$$$.\nline $$$2 + i$$$, for $$$i$$$ between $$$0$$$ and $$$n - 1$$$: integers $$$s_i$$$ and $$$t_i$$$.\nOutput\nOne number— the return value of function.\nScoring\nIn all subtasks $$$1 \\le s_i \\le 10^9$$$ and $$$1 \\le t_i \\le 10^9$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$2\\le n\\le 8$$$\n2\n23\n$$$2\\le n\\le 16$$$\n3\n30\n$$$2\\le n\\le 200\\,000$$$. In this subtask your program only needs to check whether the answer is zero or not. If the answer is not zero, any positive integer answer is considered correct\n4\n36\n$$$2\\le n\\le 200\\,000$$$\nExample\nNote\nExample\nplan_roller_coaster([1, 4, 5, 6], [7, 3, 8, 6])\nIn this example there are four special sections. The best solution is to build them in the order $$$0, 3, 1, 2$$$, and to connect them by tracks of lengths $$$1, 2, 0$$$ respectively. This is how a train travels along this railroad track:\nInitially the speed of the train is $$$1$$$ km/h.\nThe train starts the ride by entering special section $$$0$$$.\nThe train leaves section $$$0$$$ going at $$$7$$$ km/h.\nThen there is a track of length $$$1$$$ m. When the train reaches the end of the track, its speed is $$$6$$$ km/h.\nThe train enters special section $$$3$$$ going at $$$6$$$ km/h and leaves it at the same speed.\nAfter leaving section $$$3$$$, the train travels along a $$$2$$$m long track. Its speed decreases to $$$4$$$ km/h.\nThe train enters special section $$$1$$$ going at $$$4$$$ km/h and leaves it going at $$$3$$$ km/h.\nImmediately after special section $$$1$$$ the train enters special section $$$2$$$.\nThe train leaves section $$$2$$$. Its final speed is $$$8$$$ km/h.\nThe function should return the total length of tracks between the special sections: $$$1 + 2 + 0 = 3$$$."
    },
    "original": "Anna is working in an amusement park and she is in charge of building the railroad for a new roller coaster. She has already designed $$$n$$$ special sections (conveniently numbered from $$$0$$$ to $$$n - 1$$$) that affect the speed of a roller coaster train. She now has to put them together and propose a final design of the roller coaster. For the purpose of this problem you may assume that the length of the train is zero.\nFor each $$$i$$$ between $$$0$$$ and $$$n - 1$$$, inclusive, the special section $$$i$$$ has two properties:\nwhen entering the section, there is a speed limit: the speed of the train must be\nless or equal to\n$$$s_i$$$ km/h (kilometers per hour),\nwhen leaving the section, the speed of the train is\nexactly\n$$$t_i$$$ km/h, regardless of the speed at which the train entered the section.\nThe finished roller coaster is a single railroad line that contains the $$$n$$$ special sections in some order. Each of the $$$n$$$ sections should be used exactly once. Consecutive sections are connected with tracks. Anna should choose the order of the $$$n$$$ sections and then decide the lengths of the tracks. The length of a track is measured in meters and may be equal to any non-negative integer (possibly zero).\nEach meter of the track between two special sections slows the train down by $$$1$$$ km/h. At the beginning of the ride, the train enters the first special section in the order selected by Anna, going at $$$1$$$ km/h.\nThe final design must satisfy the following requirements:\nthe train does not violate any speed limit when entering the special sections;\nthe speed of the train is positive at any moment.\nIn all subtasks except subtask 3, your task is to find the minimum possible total length of tracks between sections. In subtask 3 you only need to check whether there exists a valid roller coaster design, such that each track has zero length.\nImplementation details\nYou should implement the following function (method):\nint64 plan_roller_coaster(int[] s, int[] t)\n.\ns\n: array of length $$$n$$$, maximum allowed entry speeds.\nt\n: array of length $$$n$$$, exit speeds.\nIn all subtasks except subtask 3, the function should return the minimum possible total length of all tracks. In subtask 3 the function should return $$$0$$$ if there exists a valid roller coaster design such that each track has zero length, and any positive integer if it does not exist.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: integer $$$n$$$.\nline $$$2 + i$$$, for $$$i$$$ between $$$0$$$ and $$$n - 1$$$: integers $$$s_i$$$ and $$$t_i$$$.\nOutput\nOne number— the return value of function.\nScoring\nIn all subtasks $$$1 \\le s_i \\le 10^9$$$ and $$$1 \\le t_i \\le 10^9$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$2\\le n\\le 8$$$\n2\n23\n$$$2\\le n\\le 16$$$\n3\n30\n$$$2\\le n\\le 200\\,000$$$. In this subtask your program only needs to check whether the answer is zero or not. If the answer is not zero, any positive integer answer is considered correct\n4\n36\n$$$2\\le n\\le 200\\,000$$$\nExample\nNote\nExample\nplan_roller_coaster([1, 4, 5, 6], [7, 3, 8, 6])\nIn this example there are four special sections. The best solution is to build them in the order $$$0, 3, 1, 2$$$, and to connect them by tracks of lengths $$$1, 2, 0$$$ respectively. This is how a train travels along this railroad track:\nInitially the speed of the train is $$$1$$$ km/h.\nThe train starts the ride by entering special section $$$0$$$.\nThe train leaves section $$$0$$$ going at $$$7$$$ km/h.\nThen there is a track of length $$$1$$$ m. When the train reaches the end of the track, its speed is $$$6$$$ km/h.\nThe train enters special section $$$3$$$ going at $$$6$$$ km/h and leaves it at the same speed.\nAfter leaving section $$$3$$$, the train travels along a $$$2$$$m long track. Its speed decreases to $$$4$$$ km/h.\nThe train enters special section $$$1$$$ going at $$$4$$$ km/h and leaves it going at $$$3$$$ km/h.\nImmediately after special section $$$1$$$ the train enters special section $$$2$$$.\nThe train leaves section $$$2$$$. Its final speed is $$$8$$$ km/h.\nThe function should return the total length of tracks between the special sections: $$$1 + 2 + 0 = 3$$$.",
    "_meta": {
      "index": 32,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/B",
      "uuid": "ps_cee7e813dc483700f0464598aec1511dec985ef7"
    }
  },
  {
    "planning_view": {
      "title": "F. Holiday",
      "task": "Visit maximum attractions in d days on 1D highway starting at city, cannot revisit cities",
      "given": [
        "n cities on a straight highway (0 to n-1)",
        "Starting city index",
        "d days for holiday",
        "Array of attractions per city"
      ],
      "goal": "Maximize total distinct attractions visited within d days",
      "key_rules": [
        "Cannot visit attractions in same city more than once",
        "Each day: move OR visit attractions (not both)",
        "Cities arranged linearly on 1D highway"
      ],
      "target": {
        "1": {
          "points": 7,
          "req": "n ≤ 20, any starting city"
        },
        "2": {
          "points": 23,
          "req": "n ≤ 100,000, attractions ≤ 100, start at city 0"
        },
        "3": {
          "points": 17,
          "req": "n ≤ 3,000, any starting city"
        },
        "4": {
          "points": 53,
          "req": "n ≤ 100,000, any starting city"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Holiday",
      "contest": "IOI 2014 day 2",
      "one_line": "Visit maximum attractions in d days on 1D highway starting at city, cannot revisit cities",
      "given": [
        "n cities on a straight highway (0 to n-1)",
        "Starting city index",
        "d days for holiday",
        "Array of attractions per city"
      ],
      "goal": "Maximize total distinct attractions visited within d days",
      "mechanism": "Each day: either move to adjacent city OR visit all attractions in current city (but never revisit same city)",
      "success_condition": "Collect maximum sum of unique city attractions within d days",
      "constraints": {
        "critical": [
          "Cannot visit attractions in same city more than once",
          "Each day: move OR visit attractions (not both)",
          "Cities arranged linearly on 1D highway"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "n ≤ 20, any starting city"
          },
          "2": {
            "points": 23,
            "req": "n ≤ 100,000, attractions ≤ 100, start at city 0"
          },
          "3": {
            "points": 17,
            "req": "n ≤ 3,000, any starting city"
          },
          "4": {
            "points": 53,
            "req": "n ≤ 100,000, any starting city"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "64 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Holiday",
        "contest": "IOI 2014 day 2",
        "one_line": "Visit maximum attractions in d days on 1D highway starting at city, cannot revisit cities"
      },
      "problem": {
        "given": [
          "n cities on a straight highway (0 to n-1)",
          "Starting city index",
          "d days for holiday",
          "Array of attractions per city"
        ],
        "goal": "Maximize total distinct attractions visited within d days",
        "mechanism": "Each day: either move to adjacent city OR visit all attractions in current city (but never revisit same city)",
        "success_condition": "Collect maximum sum of unique city attractions within d days"
      },
      "constraints": {
        "critical": [
          "Cannot visit attractions in same city more than once",
          "Each day: move OR visit attractions (not both)",
          "Cities arranged linearly on 1D highway"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "n ≤ 20, any starting city"
          },
          "2": {
            "points": 23,
            "req": "n ≤ 100,000, attractions ≤ 100, start at city 0"
          },
          "3": {
            "points": 17,
            "req": "n ≤ 3,000, any starting city"
          },
          "4": {
            "points": 53,
            "req": "n ≤ 100,000, any starting city"
          }
        }
      },
      "implementation": {
        "function_to_write": "long long int findMaxAttraction(int n, int start, int d, int attraction[])",
        "available_api": {
          "no_external_calls": {
            "signature": "None",
            "params": "No API calls needed",
            "returns": "N/A",
            "side_effect": "Implement function logic only"
          }
        },
        "requirements": [
          "Return type: long long int",
          "Parameters: n (cities count), start (starting city index), d (days), attraction[] (attractions per city)",
          "0 ≤ d ≤ 2n + floor(n/2)",
          "All attractions values are non-negative"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "64 megabytes"
      },
      "samples": [
        {
          "input": "5 2 7\n10 2 20 30 1",
          "output": "60",
          "explanation": "Day 1: visit city 2 (20), Day 2: move to city 3, Day 3: visit city 3 (30), Days 4-6: move to city 0, Day 7: visit city 0 (10). Total: 60"
        }
      ],
      "original_statement": "Jian-Jia is planning his next holiday in Taiwan. During his holiday, Jian-Jia moves from city to city and visits attractions in the cities.\nThere are $$$n$$$ cities in Taiwan, all located along a single highway. The cities are numbered consecutively from $$$0$$$ to $$$n - 1$$$. For city $$$i$$$, where $$$0 < i < n - 1$$$, the adjacent cities are $$$i - 1$$$ and $$$i + 1$$$. The only city adjacent to city $$$0$$$ is city $$$1$$$, and the only city adjacent to city $$$n - 1$$$ is city $$$n - 2$$$.\nEach city contains some number of attractions. Jian-Jia has $$$d$$$ days of holiday and plans to visit as many attractions as possible. Jian-Jia has already selected a city in which to start his holiday. In each day of his holiday Jian-Jia can either move to an adjacent city, or else visit all the attractions of the city he is staying, but not both. Jian-Jia will\nnever visit the attractions in the same city twice\neven if he stays in the city multiple times. Please help Jian-Jia plan his holiday so that he visits as many different attractions as possible.\nTask\nPlease implement a function\nfindMaxAttraction\nthat computes the maximum number of attractions Jian-Jia can visit.\nlong long int findMaxAttraction(int n, int start, int d, int attraction[])\n$$$n$$$: the number of cities.\n$$$start$$$: the index of the starting city.\n$$$d$$$: the number of days.\n$$$attraction$$$: array of length $$$n$$$; $$$attraction[i]$$$ is the number of attractions in city $$$i$$$, for $$$0 \\le i \\le n - 1$$$.\nThe function should return the maximum number of attractions Jian-Jia can visit.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$start$$$, $$$d$$$.\nline 2: $$$attraction[0], \\ldots, attraction[n - 1]$$$.\nOutput\nThe sample grader will print the return value of\nfindMaxAttraction\n.\nScoring\nIn all subtasks $$$0 \\le d \\le 2n + \\lfloor \\frac{n}{2} \\rfloor$$$, and the number of attractions in each city is nonnegative.\nSubtask\nPoints\n$$$n$$$\nmaximum number of attractions in a city\nstarting city\n1\n7\n$$$2 \\le n \\le 20$$$\n$$$1\\,000\\,000\\,000$$$\nno constraints\n2\n23\n$$$2 \\le n \\le 100\\,000$$$\n100\ncity 0\n3\n17\n$$$2 \\le n \\le 3\\,000$$$\n$$$1\\,000\\,000\\,000$$$\nno constraints\n4\n53\n$$$2 \\le n \\le 100\\,000$$$\n$$$1\\,000\\,000\\,000$$$\nno constraints\nExamples\nNote\nYou have to submit exactly one file, called\nholiday.cpp\n. This file should implement the subprogram described above using the following signatures. You also need to include a header file\nholiday.h\nfor C/C++ implementation.\nSuppose Jian-Jia has 7 days of holiday, there are 5 cities (listed in the table below), and he starts from city 2. On the first day Jian-Jia visits the 20 attractions in city 2. On the second day Jian-Jia moves from city 2 to city 3, and on the third day visits the 30 attractions in city 3. Jian-Jia then spends the next three days moving from city 3 to city 0, and visits the 10 attractions in city 0 on the seventh day. The total number of attractions Jian-Jia visits is $$$20 + 30 + 10 = 60$$$, which is the maximum number of attractions Jian-Jia can visit in 7 days when he starts from city 2.\nCity\nNumber of attractions\n0\n10\n1\n2\n2\n20\n3\n30\n4\n1\nDay\nAction\n1\nvisit the attractions in city 2\n2\nmove from city 2 to city 3\n3\nvisit the attractions in city 3\n4\nmove from city 3 to city 2\n5\nmove from city 2 to city 1\n6\nmove from city 1 to city 0\n7\nvisit the attractions in city 0"
    },
    "original": "Jian-Jia is planning his next holiday in Taiwan. During his holiday, Jian-Jia moves from city to city and visits attractions in the cities.\nThere are $$$n$$$ cities in Taiwan, all located along a single highway. The cities are numbered consecutively from $$$0$$$ to $$$n - 1$$$. For city $$$i$$$, where $$$0 < i < n - 1$$$, the adjacent cities are $$$i - 1$$$ and $$$i + 1$$$. The only city adjacent to city $$$0$$$ is city $$$1$$$, and the only city adjacent to city $$$n - 1$$$ is city $$$n - 2$$$.\nEach city contains some number of attractions. Jian-Jia has $$$d$$$ days of holiday and plans to visit as many attractions as possible. Jian-Jia has already selected a city in which to start his holiday. In each day of his holiday Jian-Jia can either move to an adjacent city, or else visit all the attractions of the city he is staying, but not both. Jian-Jia will\nnever visit the attractions in the same city twice\neven if he stays in the city multiple times. Please help Jian-Jia plan his holiday so that he visits as many different attractions as possible.\nTask\nPlease implement a function\nfindMaxAttraction\nthat computes the maximum number of attractions Jian-Jia can visit.\nlong long int findMaxAttraction(int n, int start, int d, int attraction[])\n$$$n$$$: the number of cities.\n$$$start$$$: the index of the starting city.\n$$$d$$$: the number of days.\n$$$attraction$$$: array of length $$$n$$$; $$$attraction[i]$$$ is the number of attractions in city $$$i$$$, for $$$0 \\le i \\le n - 1$$$.\nThe function should return the maximum number of attractions Jian-Jia can visit.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$start$$$, $$$d$$$.\nline 2: $$$attraction[0], \\ldots, attraction[n - 1]$$$.\nOutput\nThe sample grader will print the return value of\nfindMaxAttraction\n.\nScoring\nIn all subtasks $$$0 \\le d \\le 2n + \\lfloor \\frac{n}{2} \\rfloor$$$, and the number of attractions in each city is nonnegative.\nSubtask\nPoints\n$$$n$$$\nmaximum number of attractions in a city\nstarting city\n1\n7\n$$$2 \\le n \\le 20$$$\n$$$1\\,000\\,000\\,000$$$\nno constraints\n2\n23\n$$$2 \\le n \\le 100\\,000$$$\n100\ncity 0\n3\n17\n$$$2 \\le n \\le 3\\,000$$$\n$$$1\\,000\\,000\\,000$$$\nno constraints\n4\n53\n$$$2 \\le n \\le 100\\,000$$$\n$$$1\\,000\\,000\\,000$$$\nno constraints\nExamples\nNote\nYou have to submit exactly one file, called\nholiday.cpp\n. This file should implement the subprogram described above using the following signatures. You also need to include a header file\nholiday.h\nfor C/C++ implementation.\nSuppose Jian-Jia has 7 days of holiday, there are 5 cities (listed in the table below), and he starts from city 2. On the first day Jian-Jia visits the 20 attractions in city 2. On the second day Jian-Jia moves from city 2 to city 3, and on the third day visits the 30 attractions in city 3. Jian-Jia then spends the next three days moving from city 3 to city 0, and visits the 10 attractions in city 0 on the seventh day. The total number of attractions Jian-Jia visits is $$$20 + 30 + 10 = 60$$$, which is the maximum number of attractions Jian-Jia can visit in 7 days when he starts from city 2.\nCity\nNumber of attractions\n0\n10\n1\n2\n2\n20\n3\n30\n4\n1\nDay\nAction\n1\nvisit the attractions in city 2\n2\nmove from city 2 to city 3\n3\nvisit the attractions in city 3\n4\nmove from city 3 to city 2\n5\nmove from city 2 to city 1\n6\nmove from city 1 to city 0\n7\nvisit the attractions in city 0",
    "_meta": {
      "index": 33,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/F",
      "uuid": "ps_9cf3717b48a234baf175d9283176bd4c9bb07cfd"
    }
  },
  {
    "planning_view": {
      "title": "B. Art class",
      "task": "Classify painting styles (1-4) from RGB pixel data",
      "given": [
        "H x W grid of pixels (100 ≤ H,W ≤ 500)",
        "Each pixel has R,G,B values (0-255)",
        "Four art styles: neoplastic (1), impressionist (2), expressionist (3), colour field (4)"
      ],
      "goal": "Determine which style (1-4) the painting belongs to",
      "key_rules": [
        "No subtasks - scoring based on percentage of correct classifications",
        "Score scales linearly with accuracy: 0%<25%=0pts, 25%-50%=0-10pts, 50%-90%=10-100pts, ≥90%=100pts"
      ],
      "target": {}
    },
    "algorithm_view": {
      "title": "B. Art class",
      "contest": "IOI 2013 day 1",
      "one_line": "Classify painting styles (1-4) from RGB pixel data",
      "given": [
        "H x W grid of pixels (100 ≤ H,W ≤ 500)",
        "Each pixel has R,G,B values (0-255)",
        "Four art styles: neoplastic (1), impressionist (2), expressionist (3), colour field (4)"
      ],
      "goal": "Determine which style (1-4) the painting belongs to",
      "mechanism": "Analyze RGB pixel arrays to identify distinctive style patterns",
      "success_condition": "Return correct style number matching grader's classification",
      "constraints": {
        "critical": [
          "No subtasks - scoring based on percentage of correct classifications",
          "Score scales linearly with accuracy: 0%<25%=0pts, 25%-50%=0-10pts, 50%-90%=10-100pts, ≥90%=100pts"
        ],
        "subtasks": {}
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Art class",
        "contest": "IOI 2013 day 1",
        "one_line": "Classify painting styles (1-4) from RGB pixel data"
      },
      "problem": {
        "given": [
          "H x W grid of pixels (100 ≤ H,W ≤ 500)",
          "Each pixel has R,G,B values (0-255)",
          "Four art styles: neoplastic (1), impressionist (2), expressionist (3), colour field (4)"
        ],
        "goal": "Determine which style (1-4) the painting belongs to",
        "mechanism": "Analyze RGB pixel arrays to identify distinctive style patterns",
        "success_condition": "Return correct style number matching grader's classification"
      },
      "constraints": {
        "critical": [
          "No subtasks - scoring based on percentage of correct classifications",
          "Score scales linearly with accuracy: 0%<25%=0pts, 25%-50%=0-10pts, 50%-90%=10-100pts, ≥90%=100pts"
        ],
        "subtasks": {}
      },
      "implementation": {
        "function_to_write": "int style(int H, int W, int R[500][500], int G[500][500], int B[500][500])",
        "available_api": {
          "style": {
            "signature": "int style(int H, int W, int R[500][500], int G[500][500], int B[500][500])",
            "params": "H: rows (100-500), W: columns (100-500), R/G/B: 500x500 arrays of 0-255 values",
            "returns": "Style number (1, 2, 3, or 4)",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Must #include \"artclass.h\"",
          "Arrays are 500x500 maximum (use indices 0 to H-1, 0 to W-1)",
          "Return value must be 1, 2, 3, or 4"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "You have an Art History exam approaching, but you have been paying more attention to informatics at school than to your art classes! You will need to write a program to take the exam for you.\nThe exam will consist of several paintings. Each painting is an example of one of four distinctive styles, numbered 1, 2, 3 and 4.\nStyle 1 contains neoplastic modern art. For example:\nStyle 2 contains impressionist landscapes. For example:\nStyle 3 contains expressionist action paintings. For example:\nStyle 4 contains colour field paintings. For example:\nYour task is, given a digital image of a painting, to determine which style the painting belongs to.\nThe IOI judges have collected many images in each style. Nine images from each style have been chosen at random and included in the task materials you can download in problem materials section, so that you can examine them by hand and use them for testing. Each of them is given in two forms — jpeg picture, you can view, and text format, which would be given to your program. The remaining images will be given to your program during grading.\nThe image will be given as an $$$H \\times W$$$ grid of pixels. The rows of the image are numbered $$$0, \\dots, H - 1$$$ from top to bottom, and the columns are numbered $$$0, \\dots, W - 1$$$ from left to right.\nThe pixels are described using twodimensional arrays $$$R$$$, $$$G$$$ and $$$B$$$, which give the amount of red, green and blue respectively in each pixel of the image. These amounts range from $$$0$$$ (no red, green or blue) to $$$255$$$ (the maximum amount of red, green or blue).\nYou should submit a file that implements the function\nstyle()\non C/C++, as follows:\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]);\nThis function should determine the style of the image.\nParameters:\n$$$H$$$: The number of rows of pixels in the image.\n$$$W$$$: The number of columns of pixels in the image.\n$$$R$$$: A twodimensional array of size $$$H \\times W$$$, giving the amount of red in each pixel of the image.\n$$$G$$$: A twodimensional array of size $$$H \\times W$$$, giving the amount of green in each pixel of the image.\n$$$B$$$: A twodimensional array of size $$$H \\times W$$$, giving the amount of blue in each pixel of the image.\nReturns\n: The style of the image, which must be $$$1$$$, $$$2$$$, $$$3$$$ or $$$4$$$, as described above.\nEach array element $$$R[i][j]$$$, $$$G[i][j]$$$ and $$$B[i][j]$$$ refers to the pixel in row $$$i$$$ and column $$$j$$$, and will be an integer between $$$0$$$ and $$$255$$$ inclusive.\nInput\nThe grader reads input in following format:\nline $$$1$$$: $$$H\\ W$$$\nlines $$$2, \\dots, H \\cdot W + 1$$$ : $$$G[\\frac{i}{W}][i \\bmod W]\\ G[\\frac{i}{W}][i \\bmod W]\\ B[\\frac{i}{W}][i \\bmod W]$$$\nScoring\nThe constraints are:\n$$$100 \\leq H \\leq 500$$$\n$$$100 \\leq W \\leq 500$$$\nThere are no subtasks. Instead, your score for this task will be based on how many images your program correctly classifies.\nSuppose you correctly classify P percent of the images (so $$$0 \\leq P \\leq 100$$$):\nIf $$$P < 25$$$ then you will score $$$0$$$ points.\nIf $$$25 \\leq P < 50$$$ then you will score between $$$0$$$ and $$$10$$$ points, on a linear scale. Specifically, your score will be $$$10 \\cdot \\frac{P - 25}{25}$$$, rounded down to the nearest integer.\nIf $$$50 \\leq P < 90$$$ then you will score between $$$10$$$ and $$$100$$$ points, on a linear scale. Specifically, your score will be $$$10 + \\left(90 \\cdot \\frac{P - 50}{40}\\right)$$$, rounded down to the nearest integer.\nIf $$$90 \\leq P$$$ then you will score $$$100$$$ points.\nNote\nYou must\n#include \"artclass.h\""
    },
    "original": "You have an Art History exam approaching, but you have been paying more attention to informatics at school than to your art classes! You will need to write a program to take the exam for you.\nThe exam will consist of several paintings. Each painting is an example of one of four distinctive styles, numbered 1, 2, 3 and 4.\nStyle 1 contains neoplastic modern art. For example:\nStyle 2 contains impressionist landscapes. For example:\nStyle 3 contains expressionist action paintings. For example:\nStyle 4 contains colour field paintings. For example:\nYour task is, given a digital image of a painting, to determine which style the painting belongs to.\nThe IOI judges have collected many images in each style. Nine images from each style have been chosen at random and included in the task materials you can download in problem materials section, so that you can examine them by hand and use them for testing. Each of them is given in two forms — jpeg picture, you can view, and text format, which would be given to your program. The remaining images will be given to your program during grading.\nThe image will be given as an $$$H \\times W$$$ grid of pixels. The rows of the image are numbered $$$0, \\dots, H - 1$$$ from top to bottom, and the columns are numbered $$$0, \\dots, W - 1$$$ from left to right.\nThe pixels are described using twodimensional arrays $$$R$$$, $$$G$$$ and $$$B$$$, which give the amount of red, green and blue respectively in each pixel of the image. These amounts range from $$$0$$$ (no red, green or blue) to $$$255$$$ (the maximum amount of red, green or blue).\nYou should submit a file that implements the function\nstyle()\non C/C++, as follows:\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]);\nThis function should determine the style of the image.\nParameters:\n$$$H$$$: The number of rows of pixels in the image.\n$$$W$$$: The number of columns of pixels in the image.\n$$$R$$$: A twodimensional array of size $$$H \\times W$$$, giving the amount of red in each pixel of the image.\n$$$G$$$: A twodimensional array of size $$$H \\times W$$$, giving the amount of green in each pixel of the image.\n$$$B$$$: A twodimensional array of size $$$H \\times W$$$, giving the amount of blue in each pixel of the image.\nReturns\n: The style of the image, which must be $$$1$$$, $$$2$$$, $$$3$$$ or $$$4$$$, as described above.\nEach array element $$$R[i][j]$$$, $$$G[i][j]$$$ and $$$B[i][j]$$$ refers to the pixel in row $$$i$$$ and column $$$j$$$, and will be an integer between $$$0$$$ and $$$255$$$ inclusive.\nInput\nThe grader reads input in following format:\nline $$$1$$$: $$$H\\ W$$$\nlines $$$2, \\dots, H \\cdot W + 1$$$ : $$$G[\\frac{i}{W}][i \\bmod W]\\ G[\\frac{i}{W}][i \\bmod W]\\ B[\\frac{i}{W}][i \\bmod W]$$$\nScoring\nThe constraints are:\n$$$100 \\leq H \\leq 500$$$\n$$$100 \\leq W \\leq 500$$$\nThere are no subtasks. Instead, your score for this task will be based on how many images your program correctly classifies.\nSuppose you correctly classify P percent of the images (so $$$0 \\leq P \\leq 100$$$):\nIf $$$P < 25$$$ then you will score $$$0$$$ points.\nIf $$$25 \\leq P < 50$$$ then you will score between $$$0$$$ and $$$10$$$ points, on a linear scale. Specifically, your score will be $$$10 \\cdot \\frac{P - 25}{25}$$$, rounded down to the nearest integer.\nIf $$$50 \\leq P < 90$$$ then you will score between $$$10$$$ and $$$100$$$ points, on a linear scale. Specifically, your score will be $$$10 + \\left(90 \\cdot \\frac{P - 50}{40}\\right)$$$, rounded down to the nearest integer.\nIf $$$90 \\leq P$$$ then you will score $$$100$$$ points.\nNote\nYou must\n#include \"artclass.h\"",
    "_meta": {
      "index": 34,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/B",
      "uuid": "ps_bccec85a71255a50c7481008e04ea911d3e007b1"
    }
  },
  {
    "planning_view": {
      "title": "C. Crayfish scrivener",
      "task": "Implement text editor supporting TypeLetter, UndoCommands(U), and GetLetter(P) queries",
      "given": [
        "Start with empty text",
        "Commands: TypeLetter(L), UndoCommands(U), GetLetter(P)",
        "Undo can undo previous undos"
      ],
      "goal": "Answer GetLetter queries correctly after sequence of type/undo operations",
      "key_rules": [
        "Undo can undo previous undo commands (undoing undo redoes commands)",
        "GetLetter queries don't count as commands for undo purposes",
        "U never exceeds number of previous commands",
        "P always < current text length"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "≤100 total calls, no UndoCommands"
        },
        "2": {
          "points": 7,
          "req": "≤100 total calls, no undo of undos"
        },
        "3": {
          "points": 22,
          "req": "≤5,000 total calls"
        },
        "4": {
          "points": 26,
          "req": "≤1,000,000 total calls, all GetLetter after all other commands"
        },
        "5": {
          "points": 40,
          "req": "≤1,000,000 total calls, commands/queries interleaved"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Crayfish scrivener",
      "contest": "IOI 2012 day 1",
      "one_line": "Implement text editor supporting TypeLetter, UndoCommands(U), and GetLetter(P) queries",
      "given": [
        "Start with empty text",
        "Commands: TypeLetter(L), UndoCommands(U), GetLetter(P)",
        "Undo can undo previous undos"
      ],
      "goal": "Answer GetLetter queries correctly after sequence of type/undo operations",
      "mechanism": "UndoCommands(U) reverses last U commands: undoing TypeLetter removes last char, undoing UndoCommands redoes previous commands",
      "success_condition": "GetLetter(P) returns correct character at position P in current text state",
      "constraints": {
        "critical": [
          "Undo can undo previous undo commands (undoing undo redoes commands)",
          "GetLetter queries don't count as commands for undo purposes",
          "U never exceeds number of previous commands",
          "P always < current text length"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "≤100 total calls, no UndoCommands"
          },
          "2": {
            "points": 7,
            "req": "≤100 total calls, no undo of undos"
          },
          "3": {
            "points": 22,
            "req": "≤5,000 total calls"
          },
          "4": {
            "points": 26,
            "req": "≤1,000,000 total calls, all GetLetter after all other commands"
          },
          "5": {
            "points": 40,
            "req": "≤1,000,000 total calls, commands/queries interleaved"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Crayfish scrivener",
        "contest": "IOI 2012 day 1",
        "one_line": "Implement text editor supporting TypeLetter, UndoCommands(U), and GetLetter(P) queries"
      },
      "problem": {
        "given": [
          "Start with empty text",
          "Commands: TypeLetter(L), UndoCommands(U), GetLetter(P)",
          "Undo can undo previous undos"
        ],
        "goal": "Answer GetLetter queries correctly after sequence of type/undo operations",
        "mechanism": "UndoCommands(U) reverses last U commands: undoing TypeLetter removes last char, undoing UndoCommands redoes previous commands",
        "success_condition": "GetLetter(P) returns correct character at position P in current text state"
      },
      "constraints": {
        "critical": [
          "Undo can undo previous undo commands (undoing undo redoes commands)",
          "GetLetter queries don't count as commands for undo purposes",
          "U never exceeds number of previous commands",
          "P always < current text length"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "≤100 total calls, no UndoCommands"
          },
          "2": {
            "points": 7,
            "req": "≤100 total calls, no undo of undos"
          },
          "3": {
            "points": 22,
            "req": "≤5,000 total calls"
          },
          "4": {
            "points": 26,
            "req": "≤1,000,000 total calls, all GetLetter after all other commands"
          },
          "5": {
            "points": 40,
            "req": "≤1,000,000 total calls, commands/queries interleaved"
          }
        }
      },
      "implementation": {
        "function_to_write": "Multiple: Init(), TypeLetter(L), UndoCommands(U), GetLetter(P)",
        "available_api": {
          "Init": {
            "signature": "void Init()",
            "params": "none",
            "returns": "void",
            "side_effect": "Initializes data structures once at start"
          },
          "TypeLetter": {
            "signature": "void TypeLetter(char L)",
            "params": "L: lowercase letter a-z",
            "returns": "void",
            "side_effect": "Appends L to end of current text"
          },
          "UndoCommands": {
            "signature": "void UndoCommands(int U)",
            "params": "U: number of previous commands to undo",
            "returns": "void",
            "side_effect": "Reverses last U commands (can undo previous undos)"
          },
          "GetLetter": {
            "signature": "char GetLetter(int P)",
            "params": "P: position in text (0-indexed)",
            "returns": "Character at position P",
            "side_effect": "None (not considered a command)"
          }
        },
        "requirements": [
          "Exact function signatures must match",
          "No standard I/O interaction",
          "Text starts empty before Init()",
          "P always valid (< current text length)"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "14\nT a\nT b\nP 1\nT d\nU 2\nU 1\nP 2\nT e\nU 1\nU 5\nT c\nP 2\nU 2\nP 2",
          "output": "bdcd"
        }
      ],
      "original_statement": "Some people say that Leonardo was a great admirer of Johannes Gutenberg, the German blacksmith who invented movable-type printing, and that he paid homage by designing a machine called the crayfish scrivener — il gambero scrivano — a very simple typing device. It is somehow similar to a simple modern typewriter and accepts only two commands: one to type the next character and one to undo the most recent commands. The notable feature of the crayfish scrivener is that the undo command is extremely powerful: an undo is also considered to be a command itself, and can be undone.\nYour task is to realize a software version of the crayfish scrivener: it starts with an empty text and accepts a sequence of commands entered by the user, and queries for specific positions of the current version of the text, as follows.\nInit()\n— called once at the beginning of the execution, without arguments. It can be used for initializing data structures. It will never need to be undone.\nTypeLetter(L)\n— append to the end of the text a single lowercase letter $$$L$$$ chosen from $$$a, \\dots, z$$$.\nUndoCommands(U)\n— undo the the last $$$U$$$ commands, for a positive integer $$$U$$$.\nGetLetter(P)\n— return the letter at position $$$P$$$ in the current text, for a non-negative index $$$P$$$. The first letter in the text has index $$$0$$$. (This query is not a command and thus is ignored by the undo command.)\nAfter the initial call to\nInit()\n, the other routines can be called zero or more times in any order. It is guaranteed that $$$U$$$ will not exceed the number of previously received commands, and that $$$P$$$ will be less than the current text length (the number of letters in the current text).\nAs for\nUndoCommands(U)\n, it undoes the previous $$$U$$$ commands in reverse order: if the command to be undone is TypeLetter(L), then it removes $$$L$$$ from the end of the current text; if the command to be undone is\nUndoCommands(X)\nfor some value $$$X$$$, it re-does the previous $$$X$$$ commands in their original order.\nYou have to submit exactly one file, called\nscrivener.c\n,\nscrivener.cpp\nor\nscrivener.pas\n. This file must implement the subprograms described above using the following signatures:\nC/C++ programs:\nvoid Init();\nvoid TypeLetter(char L);\nvoid UndoCommands(int U);\nchar GetLetter(int P);\nPascal programs:\nprocedure Init;\nprocedure TypeLetter(L : Char);\nprocedure UndoCommands(U : LongInt);\nfunction GetLetter(P : LongInt) : Char;\nThese subprograms must behave as described above. Of course you are free to implement other subprograms for their internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nThe sample grader reads the input in the following format:\nline 1: the total number of commands and queries in the input;\non each following line:\n$$$T$$$ followed by a space and a lowercase letter for a\nTypeLetter\ncommand;\n$$$U$$$ followed by a space and an integer for\nUndoCommands\n;\n$$$P$$$ followed by a space and an integer for\nGetLetter\n.\nThe sample grader will print the characters returned by\nGetLetter\n, each one on a separate line.\nScoring\nSubtask 1 [5 points]\nThe total number of commands and queries is between $$$1$$$ and $$$100$$$ (inclusive) and there will be no calls to\nUndoCommands\n.\nSubtask 2 [7 points]\nThe total number of commands and queries is between $$$1$$$ and $$$100$$$ (inclusive) and no\nUndoCommands\nwill be undone.\nSubtask 3 [22 points]\nThe total number of commands and queries is between $$$1$$$ and $$$5\\,000$$$ (inclusive).\nSubtask 4 [26 points]\nThe total number of commands and queries is between $$$1$$$ and $$$1\\,000\\,000$$$ (inclusive). All calls to\nGetLetter\nwill occur after all calls to\nTypeLetter\nand\nUndoCommands\n.\nSubtask 5 [40 points]\nThe total number of commands and queries is between $$$1$$$ and $$$1\\,000\\,000$$$ (inclusive)\nExample\nNote\nExample\nWe show a possible sequence of calls, together with the state of the text after each call.\nCall\nReturns\nCurrent text\nInit()\nTypeLetter(a)\na\nTypeLetter(b)\nab\nGetLetter(1)\nb\nab\nTypeLetter(d)\nabd\nUndoCommands(2)\na\nUndoCommands(1)\nabd\nGetLetter(2)\nd\nabd\nTypeLetter(e)\nabde\nUndoCommands(1)\nabd\nUndoCommands(5)\nab\nTypeLetter(c)\nabc\nGetLetter(2)\nc\nabc\nUndoCommands(2)\nabd\nGetLetter(2)\nd\nabd"
    },
    "original": "Some people say that Leonardo was a great admirer of Johannes Gutenberg, the German blacksmith who invented movable-type printing, and that he paid homage by designing a machine called the crayfish scrivener — il gambero scrivano — a very simple typing device. It is somehow similar to a simple modern typewriter and accepts only two commands: one to type the next character and one to undo the most recent commands. The notable feature of the crayfish scrivener is that the undo command is extremely powerful: an undo is also considered to be a command itself, and can be undone.\nYour task is to realize a software version of the crayfish scrivener: it starts with an empty text and accepts a sequence of commands entered by the user, and queries for specific positions of the current version of the text, as follows.\nInit()\n— called once at the beginning of the execution, without arguments. It can be used for initializing data structures. It will never need to be undone.\nTypeLetter(L)\n— append to the end of the text a single lowercase letter $$$L$$$ chosen from $$$a, \\dots, z$$$.\nUndoCommands(U)\n— undo the the last $$$U$$$ commands, for a positive integer $$$U$$$.\nGetLetter(P)\n— return the letter at position $$$P$$$ in the current text, for a non-negative index $$$P$$$. The first letter in the text has index $$$0$$$. (This query is not a command and thus is ignored by the undo command.)\nAfter the initial call to\nInit()\n, the other routines can be called zero or more times in any order. It is guaranteed that $$$U$$$ will not exceed the number of previously received commands, and that $$$P$$$ will be less than the current text length (the number of letters in the current text).\nAs for\nUndoCommands(U)\n, it undoes the previous $$$U$$$ commands in reverse order: if the command to be undone is TypeLetter(L), then it removes $$$L$$$ from the end of the current text; if the command to be undone is\nUndoCommands(X)\nfor some value $$$X$$$, it re-does the previous $$$X$$$ commands in their original order.\nYou have to submit exactly one file, called\nscrivener.c\n,\nscrivener.cpp\nor\nscrivener.pas\n. This file must implement the subprograms described above using the following signatures:\nC/C++ programs:\nvoid Init();\nvoid TypeLetter(char L);\nvoid UndoCommands(int U);\nchar GetLetter(int P);\nPascal programs:\nprocedure Init;\nprocedure TypeLetter(L : Char);\nprocedure UndoCommands(U : LongInt);\nfunction GetLetter(P : LongInt) : Char;\nThese subprograms must behave as described above. Of course you are free to implement other subprograms for their internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nThe sample grader reads the input in the following format:\nline 1: the total number of commands and queries in the input;\non each following line:\n$$$T$$$ followed by a space and a lowercase letter for a\nTypeLetter\ncommand;\n$$$U$$$ followed by a space and an integer for\nUndoCommands\n;\n$$$P$$$ followed by a space and an integer for\nGetLetter\n.\nThe sample grader will print the characters returned by\nGetLetter\n, each one on a separate line.\nScoring\nSubtask 1 [5 points]\nThe total number of commands and queries is between $$$1$$$ and $$$100$$$ (inclusive) and there will be no calls to\nUndoCommands\n.\nSubtask 2 [7 points]\nThe total number of commands and queries is between $$$1$$$ and $$$100$$$ (inclusive) and no\nUndoCommands\nwill be undone.\nSubtask 3 [22 points]\nThe total number of commands and queries is between $$$1$$$ and $$$5\\,000$$$ (inclusive).\nSubtask 4 [26 points]\nThe total number of commands and queries is between $$$1$$$ and $$$1\\,000\\,000$$$ (inclusive). All calls to\nGetLetter\nwill occur after all calls to\nTypeLetter\nand\nUndoCommands\n.\nSubtask 5 [40 points]\nThe total number of commands and queries is between $$$1$$$ and $$$1\\,000\\,000$$$ (inclusive)\nExample\nNote\nExample\nWe show a possible sequence of calls, together with the state of the text after each call.\nCall\nReturns\nCurrent text\nInit()\nTypeLetter(a)\na\nTypeLetter(b)\nab\nGetLetter(1)\nb\nab\nTypeLetter(d)\nabd\nUndoCommands(2)\na\nUndoCommands(1)\nabd\nGetLetter(2)\nd\nabd\nTypeLetter(e)\nabde\nUndoCommands(1)\nabd\nUndoCommands(5)\nab\nTypeLetter(c)\nabc\nGetLetter(2)\nc\nabc\nUndoCommands(2)\nabd\nGetLetter(2)\nd\nabd",
    "_meta": {
      "index": 35,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/C",
      "uuid": "ps_96c2813cf6183c4a9441b2532f483bf9964037df"
    }
  },
  {
    "planning_view": {
      "title": "H. Saveit",
      "task": "Encode N*H hub distances compactly using ≤70,000 encode_bit() calls",
      "given": [
        "N cities (0 to N-1) with H hubs (cities 0 to H-1)",
        "Undirected graph via P edges in arrays A, B",
        "Graph connected, N ≤ 1000, H ≤ 36, all hubs connected to all cities"
      ],
      "goal": "Transmit hub-to-city distances from encode() to decode() using bits",
      "key_rules": [
        "Graph is connected (all hubs reach all cities)",
        "Hubs are cities 0 to H-1",
        "Must call hops(h, c, d) exactly H*N times"
      ],
      "target": {
        "1": {
          "points": 25,
          "req": "encode_bit() called ≤ 16,000,000 times"
        },
        "2": {
          "points": 25,
          "req": "encode_bit() called ≤ 360,000 times"
        },
        "3": {
          "points": 25,
          "req": "encode_bit() called ≤ 80,000 times"
        },
        "4": {
          "points": 25,
          "req": "encode_bit() called ≤ 70,000 times"
        }
      }
    },
    "algorithm_view": {
      "title": "H. Saveit",
      "contest": "IOI 2010 day 2",
      "one_line": "Encode N*H hub distances compactly using ≤70,000 encode_bit() calls",
      "given": [
        "N cities (0 to N-1) with H hubs (cities 0 to H-1)",
        "Undirected graph via P edges in arrays A, B",
        "Graph connected, N ≤ 1000, H ≤ 36, all hubs connected to all cities"
      ],
      "goal": "Transmit hub-to-city distances from encode() to decode() using bits",
      "mechanism": "encode() calls encode_bit(b) to send bits; decode() calls decode_bit() to receive bits, then reports all H*N distances via hops()",
      "success_condition": "decode() correctly reports all minimum hop distances from each hub to every city",
      "constraints": {
        "critical": [
          "Graph is connected (all hubs reach all cities)",
          "Hubs are cities 0 to H-1",
          "Must call hops(h, c, d) exactly H*N times"
        ],
        "subtasks": {
          "1": {
            "points": 25,
            "req": "encode_bit() called ≤ 16,000,000 times"
          },
          "2": {
            "points": 25,
            "req": "encode_bit() called ≤ 360,000 times"
          },
          "3": {
            "points": 25,
            "req": "encode_bit() called ≤ 80,000 times"
          },
          "4": {
            "points": 25,
            "req": "encode_bit() called ≤ 70,000 times"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "H. Saveit",
        "contest": "IOI 2010 day 2",
        "one_line": "Encode N*H hub distances compactly using ≤70,000 encode_bit() calls"
      },
      "problem": {
        "given": [
          "N cities (0 to N-1) with H hubs (cities 0 to H-1)",
          "Undirected graph via P edges in arrays A, B",
          "Graph connected, N ≤ 1000, H ≤ 36, all hubs connected to all cities"
        ],
        "goal": "Transmit hub-to-city distances from encode() to decode() using bits",
        "mechanism": "encode() calls encode_bit(b) to send bits; decode() calls decode_bit() to receive bits, then reports all H*N distances via hops()",
        "success_condition": "decode() correctly reports all minimum hop distances from each hub to every city"
      },
      "constraints": {
        "critical": [
          "Graph is connected (all hubs reach all cities)",
          "Hubs are cities 0 to H-1",
          "Must call hops(h, c, d) exactly H*N times"
        ],
        "subtasks": {
          "1": {
            "points": 25,
            "req": "encode_bit() called ≤ 16,000,000 times"
          },
          "2": {
            "points": 25,
            "req": "encode_bit() called ≤ 360,000 times"
          },
          "3": {
            "points": 25,
            "req": "encode_bit() called ≤ 80,000 times"
          },
          "4": {
            "points": 25,
            "req": "encode_bit() called ≤ 70,000 times"
          }
        }
      },
      "implementation": {
        "function_to_write": "void encode(int N, int H, int P, int A[], int B[]);\nvoid decode(int N, int H);",
        "available_api": {
          "encode_bit": {
            "signature": "void encode_bit(int b)",
            "params": "b: bit value (0 or 1)",
            "returns": "void",
            "side_effect": "Sends bit to decode() via decode_bit()"
          },
          "decode_bit": {
            "signature": "int decode_bit()",
            "params": "none",
            "returns": "Next bit (0 or 1) from encode_bit() sequence",
            "side_effect": "Consumes one bit from sequence"
          },
          "hops": {
            "signature": "void hops(int h, int c, int d)",
            "params": "h: hub ID (0 to H-1), c: city ID (0 to N-1), d: min hop distance",
            "returns": "void",
            "side_effect": "Records distance for grading"
          }
        },
        "requirements": [
          "Implement both encode() and decode() in same file",
          "decode() must call hops() exactly H*N times",
          "decode() must not call decode_bit() more times than encode() called encode_bit()"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "The Xedef Courier Company provides air package delivery among several cities. Some of these cities are Xedef hubs where special processing facilities are established. Each of Xedef's aircraft shuttles back and forth between one pair of cities, carrying packages in either direction as required.\nTo be shipped from one city to another, a package must be transported by a sequence of hops, where each hop carries the package between a pair of cities served by one of the aircraft. Furthermore, the sequence must include at least one of Xedef's hubs.\nTo facilitate routing, Xedef wishes to encode the length of the shortest sequence of hops from every city to every hub on the shipping label of every package. (The length of the shortest sequence leading from a hub to itself is zero.) Obviously, a compact representation of this information is required.\nYou are to implement two procedures,\nencode(N,H,P,A,B)\nand\ndecode(N,H)\n. $$$N$$$ is the number of cities and $$$H$$$ is the number of hubs. Assume that the cities are numbered from $$$0$$$ to $$$N-1$$$, and that the hubs are the cities with numbers between $$$0$$$ and $$$H-1$$$. Further assume that $$$N \\le 1000$$$ and $$$H \\le 36$$$. $$$P$$$ is the number of pairs of cities connected by aircraft. All (unordered) pairs of cities will be distinct. $$$A$$$ and $$$B$$$ are arrays of size $$$P$$$, such that the first pair of connected cities is $$$(A[0], B[0])$$$, the second pair is $$$(A[1], B[1])$$$, and so on.\nencode\nmust compute a sequence of bits from which decode can determine the number of hops from every city to every hub.\nencode\nwill transmit the sequence of bits to the grading server by a sequence of calls to\nencode_bit(b)\nwhere\nb\nis either $$$0$$$ or $$$1$$$.\ndecode\nwill receive the sequence of bits from the grading server by making calls to\ndecode_bit\n. The $$$i$$$-th call to\ndecode_bit\nwill return the value of $$$b$$$ from the $$$i$$$-th call to\nencode_bit(b)\n. Note that you must ensure that the number of times\ndecode\ncalls\ndecode_bit\nwill always be at most equal to the number of times\nencode\npreviously called\nencode_bit(b)\n.\nAfter decoding the numbers of hops, decode must call\nhops(h,c,d)\nfor every hub $$$h$$$ and every city $$$c$$$ (including every hub, that is, also for $$$c=h$$$), giving the minimum number $$$d$$$ of hops necessary to ship a package between $$$h$$$ and $$$c$$$. That is, there must be $$$N*H$$$ calls to\nhops(h,c,d)\n. The order does not matter. You are guaranteed that it is always possible to ship a package between every hub and every city.\nOn original IOI you need to submit 2 separate files with\nencode\nand\ndecode\nfunction, but here they must be implemented in one file. Anyway, between calling\nencode\nand\ndecode\nyour solution would be restarted, so no data could be saved. They must communicate only using\nencode_bit\n/\ndecode_bit\nfunctions. But for simplicity of testing, provided version of grader would call both functions in the same run.\nAs an example, consider the following diagram:\nIt shows five cities $$$N=5$$$ connected by seven aircraft $$$P=7$$$. Cities $$$0$$$, $$$1$$$ and $$$2$$$ are hubs $$$H=3$$$. One hop is needed to ship a package between hub $$$0$$$ and city $$$3$$$, whereas two hops are needed to ship a package between hub $$$2$$$ and city $$$3$$$. The entries in the following table are all $$$d$$$-values that decode must deliver by calling\nhops(h,c,d)\n:\n0\n1\n2\n3\n4\n0\n0\n1\n1\n1\n1\n1\n1\n0\n1\n1\n1\n2\n1\n1\n0\n2\n2\nScoring\nSubtask 1 [25 points]\nencode\nmust make no more than $$$16\\,000\\,000$$$ calls to\nencode_bit(b)\n.\nSubtask 2 [25 points]\nencode\nmust make no more than $$$360\\,000$$$ calls to\nencode_bit(b)\n.\nSubtask 3 [25 points]\nencode\nmust make no more than $$$80\\,000$$$ calls to\nencode_bit(b)\n.\nSubtask 4 [25 points]\nencode\nmust make no more than $$$70\\,000$$$ calls to\nencode_bit(b)\n."
    },
    "original": "The Xedef Courier Company provides air package delivery among several cities. Some of these cities are Xedef hubs where special processing facilities are established. Each of Xedef's aircraft shuttles back and forth between one pair of cities, carrying packages in either direction as required.\nTo be shipped from one city to another, a package must be transported by a sequence of hops, where each hop carries the package between a pair of cities served by one of the aircraft. Furthermore, the sequence must include at least one of Xedef's hubs.\nTo facilitate routing, Xedef wishes to encode the length of the shortest sequence of hops from every city to every hub on the shipping label of every package. (The length of the shortest sequence leading from a hub to itself is zero.) Obviously, a compact representation of this information is required.\nYou are to implement two procedures,\nencode(N,H,P,A,B)\nand\ndecode(N,H)\n. $$$N$$$ is the number of cities and $$$H$$$ is the number of hubs. Assume that the cities are numbered from $$$0$$$ to $$$N-1$$$, and that the hubs are the cities with numbers between $$$0$$$ and $$$H-1$$$. Further assume that $$$N \\le 1000$$$ and $$$H \\le 36$$$. $$$P$$$ is the number of pairs of cities connected by aircraft. All (unordered) pairs of cities will be distinct. $$$A$$$ and $$$B$$$ are arrays of size $$$P$$$, such that the first pair of connected cities is $$$(A[0], B[0])$$$, the second pair is $$$(A[1], B[1])$$$, and so on.\nencode\nmust compute a sequence of bits from which decode can determine the number of hops from every city to every hub.\nencode\nwill transmit the sequence of bits to the grading server by a sequence of calls to\nencode_bit(b)\nwhere\nb\nis either $$$0$$$ or $$$1$$$.\ndecode\nwill receive the sequence of bits from the grading server by making calls to\ndecode_bit\n. The $$$i$$$-th call to\ndecode_bit\nwill return the value of $$$b$$$ from the $$$i$$$-th call to\nencode_bit(b)\n. Note that you must ensure that the number of times\ndecode\ncalls\ndecode_bit\nwill always be at most equal to the number of times\nencode\npreviously called\nencode_bit(b)\n.\nAfter decoding the numbers of hops, decode must call\nhops(h,c,d)\nfor every hub $$$h$$$ and every city $$$c$$$ (including every hub, that is, also for $$$c=h$$$), giving the minimum number $$$d$$$ of hops necessary to ship a package between $$$h$$$ and $$$c$$$. That is, there must be $$$N*H$$$ calls to\nhops(h,c,d)\n. The order does not matter. You are guaranteed that it is always possible to ship a package between every hub and every city.\nOn original IOI you need to submit 2 separate files with\nencode\nand\ndecode\nfunction, but here they must be implemented in one file. Anyway, between calling\nencode\nand\ndecode\nyour solution would be restarted, so no data could be saved. They must communicate only using\nencode_bit\n/\ndecode_bit\nfunctions. But for simplicity of testing, provided version of grader would call both functions in the same run.\nAs an example, consider the following diagram:\nIt shows five cities $$$N=5$$$ connected by seven aircraft $$$P=7$$$. Cities $$$0$$$, $$$1$$$ and $$$2$$$ are hubs $$$H=3$$$. One hop is needed to ship a package between hub $$$0$$$ and city $$$3$$$, whereas two hops are needed to ship a package between hub $$$2$$$ and city $$$3$$$. The entries in the following table are all $$$d$$$-values that decode must deliver by calling\nhops(h,c,d)\n:\n0\n1\n2\n3\n4\n0\n0\n1\n1\n1\n1\n1\n1\n0\n1\n1\n1\n2\n1\n1\n0\n2\n2\nScoring\nSubtask 1 [25 points]\nencode\nmust make no more than $$$16\\,000\\,000$$$ calls to\nencode_bit(b)\n.\nSubtask 2 [25 points]\nencode\nmust make no more than $$$360\\,000$$$ calls to\nencode_bit(b)\n.\nSubtask 3 [25 points]\nencode\nmust make no more than $$$80\\,000$$$ calls to\nencode_bit(b)\n.\nSubtask 4 [25 points]\nencode\nmust make no more than $$$70\\,000$$$ calls to\nencode_bit(b)\n.",
    "_meta": {
      "index": 36,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/H",
      "uuid": "ps_d97ab4ea9e99257568355129b95d0ebdf5d1c33c"
    }
  },
  {
    "planning_view": {
      "title": "A. Dreaming",
      "task": "Connect disconnected components with new edges to minimize maximum pairwise distance",
      "given": [
        "N billabongs (water holes) numbered 0 to N-1",
        "M existing bidirectional trails with travel times",
        "New trails take L days to travel",
        "Graph may have multiple disconnected components"
      ],
      "goal": "Find minimum possible maximum travel time between any two billabongs after adding N-M-1 new trails",
      "key_rules": [
        "Graph may be disconnected (M ≤ N-1)",
        "Each new trail takes exactly L days to traverse",
        "Must connect all billabongs with exactly N-M-1 new trails",
        "Goal is to minimize the diameter of the resulting connected graph"
      ],
      "target": {
        "1": {
          "points": 14,
          "req": "M = N-2, each component is a path"
        },
        "2": {
          "points": 10,
          "req": "M = N-2 and N ≤ 100"
        },
        "3": {
          "points": 23,
          "req": "M = N-2"
        },
        "4": {
          "points": 18,
          "req": "At most one trail per billabong"
        },
        "5": {
          "points": 12,
          "req": "N ≤ 3,000"
        },
        "6": {
          "points": 23,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Dreaming",
      "contest": "IOI 2013 day 1",
      "one_line": "Connect disconnected components with new edges to minimize maximum pairwise distance",
      "given": [
        "N billabongs (water holes) numbered 0 to N-1",
        "M existing bidirectional trails with travel times",
        "New trails take L days to travel",
        "Graph may have multiple disconnected components"
      ],
      "goal": "Find minimum possible maximum travel time between any two billabongs after adding N-M-1 new trails",
      "mechanism": "Kangaroo adds N-M-1 new trails to connect all billabongs, minimizing the maximum travel time between any pair",
      "success_condition": "Return the smallest possible maximum travel time achievable",
      "constraints": {
        "critical": [
          "Graph may be disconnected (M ≤ N-1)",
          "Each new trail takes exactly L days to traverse",
          "Must connect all billabongs with exactly N-M-1 new trails",
          "Goal is to minimize the diameter of the resulting connected graph"
        ],
        "subtasks": {
          "1": {
            "points": 14,
            "req": "M = N-2, each component is a path"
          },
          "2": {
            "points": 10,
            "req": "M = N-2 and N ≤ 100"
          },
          "3": {
            "points": 23,
            "req": "M = N-2"
          },
          "4": {
            "points": 18,
            "req": "At most one trail per billabong"
          },
          "5": {
            "points": 12,
            "req": "N ≤ 3,000"
          },
          "6": {
            "points": 23,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "64 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Dreaming",
        "contest": "IOI 2013 day 1",
        "one_line": "Connect disconnected components with new edges to minimize maximum pairwise distance"
      },
      "problem": {
        "given": [
          "N billabongs (water holes) numbered 0 to N-1",
          "M existing bidirectional trails with travel times",
          "New trails take L days to travel",
          "Graph may have multiple disconnected components"
        ],
        "goal": "Find minimum possible maximum travel time between any two billabongs after adding N-M-1 new trails",
        "mechanism": "Kangaroo adds N-M-1 new trails to connect all billabongs, minimizing the maximum travel time between any pair",
        "success_condition": "Return the smallest possible maximum travel time achievable"
      },
      "constraints": {
        "critical": [
          "Graph may be disconnected (M ≤ N-1)",
          "Each new trail takes exactly L days to traverse",
          "Must connect all billabongs with exactly N-M-1 new trails",
          "Goal is to minimize the diameter of the resulting connected graph"
        ],
        "subtasks": {
          "1": {
            "points": 14,
            "req": "M = N-2, each component is a path"
          },
          "2": {
            "points": 10,
            "req": "M = N-2 and N ≤ 100"
          },
          "3": {
            "points": 23,
            "req": "M = N-2"
          },
          "4": {
            "points": 18,
            "req": "At most one trail per billabong"
          },
          "5": {
            "points": 12,
            "req": "N ≤ 3,000"
          },
          "6": {
            "points": 23,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int travelTime(int N, int M, int L, int A[], int B[], int T[])",
        "available_api": {},
        "requirements": [
          "Include \"dreaming.h\"",
          "Function must return the minimum possible maximum travel time"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "64 megabytes"
      },
      "samples": [
        {
          "input": "12 8 2\n0 8 4\n8 2 2\n2 7 4\n5 11 3\n5 1 7\n1 3 1\n1 9 5\n10 6 3",
          "output": "18"
        }
      ],
      "original_statement": "This story takes place a long time ago, when the world was new and the IOI had not yet been dreamt.\nSerpent lives in a land which has $$$N$$$ billabongs (water holes), numbered $$$0, \\dots, N - 1$$$. There are $$$M$$$ bidirectional trails, joining pairs of billabongs, which Serpent can travel along. Each pair of billabongs is connected (directly or indirectly) by at most one sequence of trails, though some pairs of billabongs may not be connected at all (thus, $$$M \\leq N - 1$$$ ). Each trail takes a certain number of days for Serpent to travel along it: this number may be different for each trail.\nSerpent's friend, Kangaroo, wishes to make $$$N - M - 1$$$ new trails, so that it is possible for Serpent to travel between any pair of billabongs. Kangaroo can create trails between any pair of billabongs, and every trail that Kangaroo creates will take $$$L$$$ days for Serpent to travel along it.\nAdditionally, Kangaroo wants to make Serpent's travels as fast as possible. Kangaroo will build the new trails so that the longest travel time between any two billabongs is as small as possible. Help Kangaroo and Serpent determine the longest travel time between any two billabongs, after Kangaroo has built the new trails in this way.\nYou should submit a file implementing the function $$$travelTime()$$$, as follows:\nint travelTime(int N, int M, int L, int A[], int B[], int T[]);\nThis function should calculate the greatest travel time (measured in days) between any pair of billabongs, assuming that Kangaroo has added $$$N - M - 1$$$ trails in such a way that all billabongs are connected and this greatest travel time is as small as possible.\nParameters:\n$$$N$$$: The number of billabongs.\n$$$M$$$: The number of trails that already exist.\n$$$L$$$: The time in days that it takes Serpent to travel along a new trail.\n$$$A$$$, $$$B$$$ and $$$T$$$: Arrays of length $$$M$$$ that specify the endpoints and travel time of each preexisting trail, so that the $$$i^{th}$$$ trail joins billabongs $$$A[i-1]$$$ and $$$B[i - 1]$$$, and takes $$$T[i-1]$$$ days to travel in either direction.\nReturns:\nThe greatest travel time between any pair of billabongs, as described above.\nInput\nThe grader reads input in following format:\nline $$$1$$$: $$$N\\ M\\ L$$$\nlines $$$2, \\dots, M + 1$$$ : $$$A[i]\\ B[i]\\ T[i]$$$\nScoring\nFull constraints:\n$$$1 \\leq N \\leq 100,000$$$\n$$$0 \\leq M \\leq N - 1$$$\n$$$0 \\leq A[i], B[i] \\leq N - 1$$$\n$$$1 \\leq T[i] \\leq 10,000$$$\n$$$1 \\leq L \\leq 10,000$$$\nSubtask\nPoints\nAdditional Input Constraints\n1\n14\n$$$M = N - 2$$$, and there are precisely one or two preexisting trails leading from each billabong. In other words, there are two sets of connected billabongs, and in each set the trails form an unbranching path.\n2\n10\n$$$M = N - 2$$$ and $$$N \\leq 100$$$\n3\n23\n$$$M = N - 2$$$\n4\n18\nThere is at most one preexisting trail leading from each billabong.\n5\n12\n$$$N \\leq 3,000$$$\n6\n23\n(None)\nExample\nNote\nConsider the first example.\nIn the picture above there are $$$N = 12$$$ billabongs and $$$M = 8$$$ trails. Suppose that $$$L = 2$$$ , so that any new trail will require Serpent $$$2$$$ days to travel. Then Kangaroo could build three new trails:\nbetween billabongs $$$1$$$ and $$$2$$$;\nbetween billabongs $$$1$$$ and $$$6$$$;\nbetween billabongs $$$4$$$ and $$$10$$$.\nThe picture above shows the final set of trails. The longest travel time is $$$18$$$ days, between billabongs $$$0$$$ and $$$11$$$. This is the smallest result possible—no matter how Kangaroo builds the trails, there will be some pair of billabongs that requires Serpent to travel for $$$18$$$ days or more.\nYour submission should\n#include \"dreaming.h\"\n."
    },
    "original": "This story takes place a long time ago, when the world was new and the IOI had not yet been dreamt.\nSerpent lives in a land which has $$$N$$$ billabongs (water holes), numbered $$$0, \\dots, N - 1$$$. There are $$$M$$$ bidirectional trails, joining pairs of billabongs, which Serpent can travel along. Each pair of billabongs is connected (directly or indirectly) by at most one sequence of trails, though some pairs of billabongs may not be connected at all (thus, $$$M \\leq N - 1$$$ ). Each trail takes a certain number of days for Serpent to travel along it: this number may be different for each trail.\nSerpent's friend, Kangaroo, wishes to make $$$N - M - 1$$$ new trails, so that it is possible for Serpent to travel between any pair of billabongs. Kangaroo can create trails between any pair of billabongs, and every trail that Kangaroo creates will take $$$L$$$ days for Serpent to travel along it.\nAdditionally, Kangaroo wants to make Serpent's travels as fast as possible. Kangaroo will build the new trails so that the longest travel time between any two billabongs is as small as possible. Help Kangaroo and Serpent determine the longest travel time between any two billabongs, after Kangaroo has built the new trails in this way.\nYou should submit a file implementing the function $$$travelTime()$$$, as follows:\nint travelTime(int N, int M, int L, int A[], int B[], int T[]);\nThis function should calculate the greatest travel time (measured in days) between any pair of billabongs, assuming that Kangaroo has added $$$N - M - 1$$$ trails in such a way that all billabongs are connected and this greatest travel time is as small as possible.\nParameters:\n$$$N$$$: The number of billabongs.\n$$$M$$$: The number of trails that already exist.\n$$$L$$$: The time in days that it takes Serpent to travel along a new trail.\n$$$A$$$, $$$B$$$ and $$$T$$$: Arrays of length $$$M$$$ that specify the endpoints and travel time of each preexisting trail, so that the $$$i^{th}$$$ trail joins billabongs $$$A[i-1]$$$ and $$$B[i - 1]$$$, and takes $$$T[i-1]$$$ days to travel in either direction.\nReturns:\nThe greatest travel time between any pair of billabongs, as described above.\nInput\nThe grader reads input in following format:\nline $$$1$$$: $$$N\\ M\\ L$$$\nlines $$$2, \\dots, M + 1$$$ : $$$A[i]\\ B[i]\\ T[i]$$$\nScoring\nFull constraints:\n$$$1 \\leq N \\leq 100,000$$$\n$$$0 \\leq M \\leq N - 1$$$\n$$$0 \\leq A[i], B[i] \\leq N - 1$$$\n$$$1 \\leq T[i] \\leq 10,000$$$\n$$$1 \\leq L \\leq 10,000$$$\nSubtask\nPoints\nAdditional Input Constraints\n1\n14\n$$$M = N - 2$$$, and there are precisely one or two preexisting trails leading from each billabong. In other words, there are two sets of connected billabongs, and in each set the trails form an unbranching path.\n2\n10\n$$$M = N - 2$$$ and $$$N \\leq 100$$$\n3\n23\n$$$M = N - 2$$$\n4\n18\nThere is at most one preexisting trail leading from each billabong.\n5\n12\n$$$N \\leq 3,000$$$\n6\n23\n(None)\nExample\nNote\nConsider the first example.\nIn the picture above there are $$$N = 12$$$ billabongs and $$$M = 8$$$ trails. Suppose that $$$L = 2$$$ , so that any new trail will require Serpent $$$2$$$ days to travel. Then Kangaroo could build three new trails:\nbetween billabongs $$$1$$$ and $$$2$$$;\nbetween billabongs $$$1$$$ and $$$6$$$;\nbetween billabongs $$$4$$$ and $$$10$$$.\nThe picture above shows the final set of trails. The longest travel time is $$$18$$$ days, between billabongs $$$0$$$ and $$$11$$$. This is the smallest result possible—no matter how Kangaroo builds the trails, there will be some pair of billabongs that requires Serpent to travel for $$$18$$$ days or more.\nYour submission should\n#include \"dreaming.h\"\n.",
    "_meta": {
      "index": 37,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/A",
      "uuid": "ps_22ab6858217bd5a5a4be3ad86d4c136f7828213a"
    }
  },
  {
    "planning_view": {
      "title": "B. Wall",
      "task": "Simulate k wall operations (add/remove bricks) on n columns with ranges",
      "given": [
        "Wall has n columns, initially empty",
        "k phases of adding or removing bricks",
        "Each phase has: type, range [left,right], height h"
      ],
      "goal": "Compute final number of bricks in each column after all k phases",
      "key_rules": [
        "ADD phases only affect columns BELOW target height",
        "REMOVE phases only affect columns ABOVE target height",
        "Operations applied sequentially in given order",
        "Height parameters ≤ 100,000"
      ],
      "target": {
        "1": {
          "points": 8,
          "req": "n ≤ 10,000; k ≤ 5,000"
        },
        "2": {
          "points": 24,
          "req": "n ≤ 100,000; k ≤ 500,000; all ADD phases before all REMOVE phases"
        },
        "3": {
          "points": 29,
          "req": "n ≤ 100,000; k ≤ 500,000"
        },
        "4": {
          "points": 39,
          "req": "n ≤ 2,000,000; k ≤ 500,000"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Wall",
      "contest": "IOI 2014 day 1",
      "one_line": "Simulate k wall operations (add/remove bricks) on n columns with ranges",
      "given": [
        "Wall has n columns, initially empty",
        "k phases of adding or removing bricks",
        "Each phase has: type, range [left,right], height h"
      ],
      "goal": "Compute final number of bricks in each column after all k phases",
      "mechanism": "ADD: set columns in range below h to exactly h; REMOVE: set columns in range above h to exactly h",
      "success_condition": "finalHeight[i] must contain correct brick count for each column i",
      "constraints": {
        "critical": [
          "ADD phases only affect columns BELOW target height",
          "REMOVE phases only affect columns ABOVE target height",
          "Operations applied sequentially in given order",
          "Height parameters ≤ 100,000"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "n ≤ 10,000; k ≤ 5,000"
          },
          "2": {
            "points": 24,
            "req": "n ≤ 100,000; k ≤ 500,000; all ADD phases before all REMOVE phases"
          },
          "3": {
            "points": 29,
            "req": "n ≤ 100,000; k ≤ 500,000"
          },
          "4": {
            "points": 39,
            "req": "n ≤ 2,000,000; k ≤ 500,000"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Wall",
        "contest": "IOI 2014 day 1",
        "one_line": "Simulate k wall operations (add/remove bricks) on n columns with ranges"
      },
      "problem": {
        "given": [
          "Wall has n columns, initially empty",
          "k phases of adding or removing bricks",
          "Each phase has: type, range [left,right], height h"
        ],
        "goal": "Compute final number of bricks in each column after all k phases",
        "mechanism": "ADD: set columns in range below h to exactly h; REMOVE: set columns in range above h to exactly h",
        "success_condition": "finalHeight[i] must contain correct brick count for each column i"
      },
      "constraints": {
        "critical": [
          "ADD phases only affect columns BELOW target height",
          "REMOVE phases only affect columns ABOVE target height",
          "Operations applied sequentially in given order",
          "Height parameters ≤ 100,000"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "n ≤ 10,000; k ≤ 5,000"
          },
          "2": {
            "points": 24,
            "req": "n ≤ 100,000; k ≤ 500,000; all ADD phases before all REMOVE phases"
          },
          "3": {
            "points": 29,
            "req": "n ≤ 100,000; k ≤ 500,000"
          },
          "4": {
            "points": 39,
            "req": "n ≤ 2,000,000; k ≤ 500,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "void buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[])",
        "available_api": {
          "buildWall": {
            "signature": "void buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[])",
            "params": "n: columns count; k: phases count; op: phase types (1=add,2=remove); left/right: range arrays; height: target heights",
            "returns": "void",
            "side_effect": "Writes results to finalHeight[] array"
          }
        },
        "requirements": [
          "Columns are 0-indexed (0 to n-1)",
          "Phases are 0-indexed (0 to k-1)",
          "Must populate finalHeight[] with results",
          "All arrays provided, just implement logic"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "10 3\n1 3 4 91220\n1 5 9 48623\n2 3 5 39412",
          "output": "0\n0\n0\n39412\n39412\n39412\n48623\n48623\n48623\n48623"
        }
      ],
      "original_statement": "Jian-Jia is building a wall by stacking bricks of the same size together. This wall consists of columns $$$n$$$ of bricks, which are numbered $$$0$$$ to $$$n - 1$$$ from left to right. The columns may have different heights. The height of a column is the number of bricks in it.\nJian-Jia builds the wall as follows. Initially there are no bricks in any column. Then, Jian-Jia goes through $$$k$$$ phases of\nadding\nor\nremoving\nbricks. The building process completes when all $$$k$$$ phases are finished. In each phase Jian-Jia is given a range of consecutive brick columns and a height $$$h$$$, and he does the following procedure:\nIn an\nadding\nphase, Jian-Jia adds bricks to those columns in the given range that have less than $$$h$$$ bricks, so that they have exactly $$$h$$$ bricks. He does nothing on the columns having $$$h$$$ or more bricks.\nIn a\nremoving\nphase, Jian-Jia removes bricks from those columns in the given range that have more than $$$h$$$ bricks, so that they have exactly $$$h$$$ bricks. He does nothing on the columns having $$$h$$$ bricks or less.\nYour task is to determine the finalshape of the wall.\nTask\nGiven the description of the $$$k$$$ phases, please calculate the number of bricks in each column after all phases are finished. You need to implement the function\nbuildWall\n.\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[])\n$$$n$$$: the number of columns of the wall.\n$$$k$$$: the number of phases.\n$$$op$$$: array of length $$$k$$$; $$$op[i]$$$ is the type of phase $$$i$$$: $$$1$$$ for an adding phase and $$$2$$$ for a removing phase, for $$$0 \\le i \\le k - 1$$$.\n$$$left$$$ and $$$right$$$: arrays of length $$$k$$$; the range of columns in phase $$$i$$$ starts with column $$$left[i]$$$ and ends with column $$$right[i]$$$ (including both endpoints $$$left[i]$$$ and $$$right[i]$$$), for $$$0 \\le i \\le k - 1$$$. You will always have $$$left[i] \\le right[i]$$$.\n$$$height$$$: array of length $$$k$$$; $$$height[i]$$$ is the height parameter of phase $$$i$$$, for $$$0 \\le i \\le k - 1$$$.\n$$$finalHeight$$$: array of length $$$n$$$; you should return your results by placing the final number of bricks in column $$$i$$$ into $$$finalHeight[i]$$$, for $$$0 \\le i \\le n - 1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$k$$$\nline $$$2 + i (0 \\le i \\le k - 1)$$$: $$$op[i]$$$, $$$left[i]$$$, $$$right[i]$$$, $$$height[i]$$$\nOutput\nThe sample grader prints the following output:\nlines $$$1 + i (0 \\le i \\le n - 1)$$$: $$$finalHeight[i]$$$\nScoring\nFor allsubtasks the height parameters of all phases are nonnegative integers less or equal to $$$100\\,000$$$\nSubtask\nPoints\n$$$n$$$\n$$$k$$$\nnote\n1\n8\n$$$1 \\le n \\le 10\\,000$$$\n$$$1 \\le k \\le 5\\,000$$$\nno additional limits\n2\n24\n$$$1 \\le n \\le 100\\,000$$$\n$$$1 \\le k \\le 500\\,000$$$\nall adding phases are before all removing phases\n3\n29\n$$$1 \\le n \\le 100\\,000$$$\n$$$1 \\le k \\le 500\\,000$$$\nno additional limits\n4\n39\n$$$1 \\le n \\le 2\\,000\\,000$$$\n$$$1 \\le k \\le 500\\,000$$$\nno additional limits\nExamples\nNote\nWe assume that there are $$$10$$$ brick columns and 6 wall building phases. All ranges in the following table are inclusive. Diagrams of the wall after each phase are shown below.\nPhase\nType\nRange\nHeight\n0\nadd\ncolumns 1 to 8\n4\n1\nremove\ncolumns 4 to 9\n1\n2\nremove\ncolumns 3 to 6\n5\n3\nadd\ncolumns 0 to 5\n3\n4\nadd\ncolumn 2\n5\n5\nremove\ncolumns 6 to 7\n0\nSince all columns are initially empty, after phase 0 each of the columns 1 to 8 will have 4 bricks. Columns 0 and 9 remain empty. In phase 1, the bricks are removed from columns 4 to 8 until each of them has 1 brick, and column 9 remains empty. Columns 0 to 3, which are out of the given range, remain unchanged. Phase 2 makes no change since columns 3 to 6 do not have more than 5 bricks. After phase 3 the numbers of bricks in columns 0, 4, and 5 increase to 3. There are 5 bricks in column 2 after phase 4. Phase 5 removes all bricks from columns 6 and 7."
    },
    "original": "Jian-Jia is building a wall by stacking bricks of the same size together. This wall consists of columns $$$n$$$ of bricks, which are numbered $$$0$$$ to $$$n - 1$$$ from left to right. The columns may have different heights. The height of a column is the number of bricks in it.\nJian-Jia builds the wall as follows. Initially there are no bricks in any column. Then, Jian-Jia goes through $$$k$$$ phases of\nadding\nor\nremoving\nbricks. The building process completes when all $$$k$$$ phases are finished. In each phase Jian-Jia is given a range of consecutive brick columns and a height $$$h$$$, and he does the following procedure:\nIn an\nadding\nphase, Jian-Jia adds bricks to those columns in the given range that have less than $$$h$$$ bricks, so that they have exactly $$$h$$$ bricks. He does nothing on the columns having $$$h$$$ or more bricks.\nIn a\nremoving\nphase, Jian-Jia removes bricks from those columns in the given range that have more than $$$h$$$ bricks, so that they have exactly $$$h$$$ bricks. He does nothing on the columns having $$$h$$$ bricks or less.\nYour task is to determine the finalshape of the wall.\nTask\nGiven the description of the $$$k$$$ phases, please calculate the number of bricks in each column after all phases are finished. You need to implement the function\nbuildWall\n.\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[])\n$$$n$$$: the number of columns of the wall.\n$$$k$$$: the number of phases.\n$$$op$$$: array of length $$$k$$$; $$$op[i]$$$ is the type of phase $$$i$$$: $$$1$$$ for an adding phase and $$$2$$$ for a removing phase, for $$$0 \\le i \\le k - 1$$$.\n$$$left$$$ and $$$right$$$: arrays of length $$$k$$$; the range of columns in phase $$$i$$$ starts with column $$$left[i]$$$ and ends with column $$$right[i]$$$ (including both endpoints $$$left[i]$$$ and $$$right[i]$$$), for $$$0 \\le i \\le k - 1$$$. You will always have $$$left[i] \\le right[i]$$$.\n$$$height$$$: array of length $$$k$$$; $$$height[i]$$$ is the height parameter of phase $$$i$$$, for $$$0 \\le i \\le k - 1$$$.\n$$$finalHeight$$$: array of length $$$n$$$; you should return your results by placing the final number of bricks in column $$$i$$$ into $$$finalHeight[i]$$$, for $$$0 \\le i \\le n - 1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$k$$$\nline $$$2 + i (0 \\le i \\le k - 1)$$$: $$$op[i]$$$, $$$left[i]$$$, $$$right[i]$$$, $$$height[i]$$$\nOutput\nThe sample grader prints the following output:\nlines $$$1 + i (0 \\le i \\le n - 1)$$$: $$$finalHeight[i]$$$\nScoring\nFor allsubtasks the height parameters of all phases are nonnegative integers less or equal to $$$100\\,000$$$\nSubtask\nPoints\n$$$n$$$\n$$$k$$$\nnote\n1\n8\n$$$1 \\le n \\le 10\\,000$$$\n$$$1 \\le k \\le 5\\,000$$$\nno additional limits\n2\n24\n$$$1 \\le n \\le 100\\,000$$$\n$$$1 \\le k \\le 500\\,000$$$\nall adding phases are before all removing phases\n3\n29\n$$$1 \\le n \\le 100\\,000$$$\n$$$1 \\le k \\le 500\\,000$$$\nno additional limits\n4\n39\n$$$1 \\le n \\le 2\\,000\\,000$$$\n$$$1 \\le k \\le 500\\,000$$$\nno additional limits\nExamples\nNote\nWe assume that there are $$$10$$$ brick columns and 6 wall building phases. All ranges in the following table are inclusive. Diagrams of the wall after each phase are shown below.\nPhase\nType\nRange\nHeight\n0\nadd\ncolumns 1 to 8\n4\n1\nremove\ncolumns 4 to 9\n1\n2\nremove\ncolumns 3 to 6\n5\n3\nadd\ncolumns 0 to 5\n3\n4\nadd\ncolumn 2\n5\n5\nremove\ncolumns 6 to 7\n0\nSince all columns are initially empty, after phase 0 each of the columns 1 to 8 will have 4 bricks. Columns 0 and 9 remain empty. In phase 1, the bricks are removed from columns 4 to 8 until each of them has 1 brick, and column 9 remains empty. Columns 0 to 3, which are out of the given range, remain unchanged. Phase 2 makes no change since columns 3 to 6 do not have more than 5 bricks. After phase 3 the numbers of bricks in columns 0, 4, and 5 increase to 3. There are 5 bricks in column 2 after phase 4. Phase 5 removes all bricks from columns 6 and 7.",
    "_meta": {
      "index": 38,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/B",
      "uuid": "ps_a86aff0f41da980a0ae3a0e94aa20348d9262ff6"
    }
  },
  {
    "planning_view": {
      "title": "D. Ideal city",
      "task": "Compute sum of Manhattan distances between all pairs of N blocks in an ideal city grid",
      "given": [
        "N blocks on infinite grid with coordinates (X[i], Y[i])",
        "Blocks form ideal city: no holes in connectivity",
        "Coordinates satisfy 1 ≤ X[i], Y[i] ≤ 2^31-2"
      ],
      "goal": "Calculate sum of shortest path distances between all block pairs (i < j)",
      "key_rules": [
        "City is ideal: all blocks connected with no holes",
        "Cannot traverse empty cells - must follow block connectivity",
        "Distances are Manhattan distances through connected blocks",
        "N can be up to 100,000"
      ],
      "target": {
        "1": {
          "points": 11,
          "req": "N ≤ 200"
        },
        "2": {
          "points": 21,
          "req": "N ≤ 2,000"
        },
        "3": {
          "points": 23,
          "req": "N ≤ 100,000, with consecutive blocks in rows/columns"
        },
        "4": {
          "points": 45,
          "req": "N ≤ 100,000"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Ideal city",
      "contest": "IOI 2012 day 2",
      "one_line": "Compute sum of Manhattan distances between all pairs of N blocks in an ideal city grid",
      "given": [
        "N blocks on infinite grid with coordinates (X[i], Y[i])",
        "Blocks form ideal city: no holes in connectivity",
        "Coordinates satisfy 1 ≤ X[i], Y[i] ≤ 2^31-2"
      ],
      "goal": "Calculate sum of shortest path distances between all block pairs (i < j)",
      "mechanism": "Blocks connected via adjacent cells; distance = minimum hops through connected blocks",
      "success_condition": "Return Σ d(v_i, v_j) for all i < j, modulo 1,000,000,000",
      "constraints": {
        "critical": [
          "City is ideal: all blocks connected with no holes",
          "Cannot traverse empty cells - must follow block connectivity",
          "Distances are Manhattan distances through connected blocks",
          "N can be up to 100,000"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "N ≤ 200"
          },
          "2": {
            "points": 21,
            "req": "N ≤ 2,000"
          },
          "3": {
            "points": 23,
            "req": "N ≤ 100,000, with consecutive blocks in rows/columns"
          },
          "4": {
            "points": 45,
            "req": "N ≤ 100,000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Ideal city",
        "contest": "IOI 2012 day 2",
        "one_line": "Compute sum of Manhattan distances between all pairs of N blocks in an ideal city grid"
      },
      "problem": {
        "given": [
          "N blocks on infinite grid with coordinates (X[i], Y[i])",
          "Blocks form ideal city: no holes in connectivity",
          "Coordinates satisfy 1 ≤ X[i], Y[i] ≤ 2^31-2"
        ],
        "goal": "Calculate sum of shortest path distances between all block pairs (i < j)",
        "mechanism": "Blocks connected via adjacent cells; distance = minimum hops through connected blocks",
        "success_condition": "Return Σ d(v_i, v_j) for all i < j, modulo 1,000,000,000"
      },
      "constraints": {
        "critical": [
          "City is ideal: all blocks connected with no holes",
          "Cannot traverse empty cells - must follow block connectivity",
          "Distances are Manhattan distances through connected blocks",
          "N can be up to 100,000"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "N ≤ 200"
          },
          "2": {
            "points": 21,
            "req": "N ≤ 2,000"
          },
          "3": {
            "points": 23,
            "req": "N ≤ 100,000, with consecutive blocks in rows/columns"
          },
          "4": {
            "points": 45,
            "req": "N ≤ 100,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int DistanceSum(int N, int *X, int *Y)",
        "available_api": {},
        "requirements": [
          "Return value modulo 1,000,000,000",
          "Coordinates in range [1, 2^31-2]",
          "Input arrays X and Y of size N",
          "Zero-based indexing: blocks 0 to N-1"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "11\n2 5\n2 6\n3 3\n3 6\n4 3\n4 4\n4 5\n4 6\n5 3\n5 4\n5 6",
          "output": "174"
        }
      ],
      "original_statement": "Leonardo, like many other Italian scientists and artists of his age, was extremely interested in city planning and urban design. He aimed to model an ideal city: comfortable, spacious and rational in its usage of resources, far away from the narrow, claustrophobic cities of the Middle Ages.\nThe ideal city\nThe city is made of $$$N$$$ blocks placed on an infinite grid of cells. Each cell is identified by a pair of coordinates (row, column). Given a cell $$$(i, j)$$$, the adjacent cells are: $$$(i - 1, j)$$$, $$$(i + 1, j)$$$, $$$(i, j - 1)$$$, and $$$(i, j + 1)$$$. Each block, when placed onto the grid, covers exactly one of the cells. A block can be placed onto the cell $$$(i, j)$$$ if and only if $$$1 \\le i, j \\le 2^{31} - 2$$$. We will use the coordinates of the cells to also refer to the blocks on top of them. Two blocks are adjacent if they are placed in adjacent cells. In an ideal city, all of its blocks are connected in such a way that there are no \"holes\" inside its border, that is, the cells must satisfy both conditions below.\nFor any two empty cells, there exists at least one sequence of adjacent empty cells connecting them.\nFor any two non-empty cells, there exists at least one sequence of adjacent non-empty cells connecting them.\nExample 1\nNone of the configurations of blocks below represent an ideal city: the first two on the left do not satisfy the first condition, the third one does not satisfy the second condition, and the fourth one does not satisfy either of the conditions.\nDistance\nWhen traversing the city, a hop indicates going from one block to an adjacent one. Empty cells cannot be traversed. Let $$$v_0, v_1, \\dots, v_N$$$ be the coordinates of the N blocks placed on the grid. For any two distinct blocks at coordinates $$$v_i$$$ and $$$v_j$$$, their distance $$$d(v_i, v_j)$$$ is the smallest number of hops that are required to go from one of these blocks to the other one.\nExample 2\nThe configuration below represents an ideal city made of $$$N = 11$$$ blocks.\n$$$v_0$$$\n$$$=$$$\n$$$(2,5)$$$\n$$$v_1$$$\n$$$=$$$\n$$$(2,6)$$$\n$$$v_2$$$\n$$$=$$$\n$$$(3,3)$$$\n$$$v_3$$$\n$$$=$$$\n$$$(3,6)$$$\n$$$v_4$$$\n$$$=$$$\n$$$(4,3)$$$\n$$$v_5$$$\n$$$=$$$\n$$$(4,4)$$$\n$$$v_6$$$\n$$$=$$$\n$$$(4,5)$$$\n$$$v_7$$$\n$$$=$$$\n$$$(4,6)$$$\n$$$v_8$$$\n$$$=$$$\n$$$(5,3)$$$\n$$$v_9$$$\n$$$=$$$\n$$$(5,4)$$$\n$$$v_{10}$$$\n$$$=$$$\n$$$(5,6)$$$\nFor example, $$$d(v_1, v_3) = 1$$$; $$$d(v_1, v_8) = 6$$$; and $$$d(v_9, v_{10}) = 4$$$.\nStatement\nYour task is to, given an ideal city, write a program to compute the sum of all pairwise distances between blocks $$$v_i$$$ and $$$v_j$$$ for which $$$i < j$$$. Formally, your program should compute the value of the following sum:\n$$$\\sum d(v_i, v_j)$$$; where $$$0 \\le i < j \\le N-1$$$\nSpecifically, you have to implement a routine\nDistanceSum(N, X, Y)\nthat, given $$$N$$$ and two arrays $$$X$$$ and $$$Y$$$ that describe the city, calculates the formula above. Both $$$X$$$ and $$$Y$$$ are of size $$$N$$$; block $$$i$$$ is at coordinates $$$(X[i], Y[i])$$$ for $$$0 \\le i \\le N - 1$$$, and $$$1 \\le X[i], Y[i] \\le 2^{31} - 2$$$. Since the result may be too big to be represented using 32 bits, you should report it modulo $$$1\\,000\\,000\\,000$$$ (one billion). In Example 2, there are $$$\\frac{11 × 10}{2} = 55$$$ pairs of blocks. The sum of all the pairwise distances is $$$174$$$.\nImplementation details\nYou have to submit exactly one file, called\ncity.c\n,\ncity.cpp\nor\ncity.pas\n. This file must implement the subprogram described above using the following signatures.\nThis subprogram must behave as described above. Of course you are free to implement other subprograms for its internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nSample grader\nThe sample grader provided with the task environment will expect input in the following format:\nline 1: $$$N$$$;\nlines 2, ..., N + 1: $$$X[i]$$$, $$$Y[i]$$$.\nScoring\nSubtask\nPoints\nConditions\n1\n11\n$$$N \\le 200$$$\n2\n21\n$$$N \\le 2\\,000$$$\n3\n23\n$$$N \\le 100\\,000$$$\n$$$*$$$\n4\n45\n$$$N \\le 100\\,000$$$\n$$$*$$$\nAdditionally, the following two conditions hold for the 3-rd subtask:\ngiven any two non-empty cells $$$i$$$ and $$$j$$$ such that $$$X[i] = X[j]$$$, every cell between them is non-empty too;\ngiven any two non-empty cells $$$i$$$ and $$$j$$$ such that $$$Y[i] = Y[j]$$$, every cell between them is non-empty too.\nExample"
    },
    "original": "Leonardo, like many other Italian scientists and artists of his age, was extremely interested in city planning and urban design. He aimed to model an ideal city: comfortable, spacious and rational in its usage of resources, far away from the narrow, claustrophobic cities of the Middle Ages.\nThe ideal city\nThe city is made of $$$N$$$ blocks placed on an infinite grid of cells. Each cell is identified by a pair of coordinates (row, column). Given a cell $$$(i, j)$$$, the adjacent cells are: $$$(i - 1, j)$$$, $$$(i + 1, j)$$$, $$$(i, j - 1)$$$, and $$$(i, j + 1)$$$. Each block, when placed onto the grid, covers exactly one of the cells. A block can be placed onto the cell $$$(i, j)$$$ if and only if $$$1 \\le i, j \\le 2^{31} - 2$$$. We will use the coordinates of the cells to also refer to the blocks on top of them. Two blocks are adjacent if they are placed in adjacent cells. In an ideal city, all of its blocks are connected in such a way that there are no \"holes\" inside its border, that is, the cells must satisfy both conditions below.\nFor any two empty cells, there exists at least one sequence of adjacent empty cells connecting them.\nFor any two non-empty cells, there exists at least one sequence of adjacent non-empty cells connecting them.\nExample 1\nNone of the configurations of blocks below represent an ideal city: the first two on the left do not satisfy the first condition, the third one does not satisfy the second condition, and the fourth one does not satisfy either of the conditions.\nDistance\nWhen traversing the city, a hop indicates going from one block to an adjacent one. Empty cells cannot be traversed. Let $$$v_0, v_1, \\dots, v_N$$$ be the coordinates of the N blocks placed on the grid. For any two distinct blocks at coordinates $$$v_i$$$ and $$$v_j$$$, their distance $$$d(v_i, v_j)$$$ is the smallest number of hops that are required to go from one of these blocks to the other one.\nExample 2\nThe configuration below represents an ideal city made of $$$N = 11$$$ blocks.\n$$$v_0$$$\n$$$=$$$\n$$$(2,5)$$$\n$$$v_1$$$\n$$$=$$$\n$$$(2,6)$$$\n$$$v_2$$$\n$$$=$$$\n$$$(3,3)$$$\n$$$v_3$$$\n$$$=$$$\n$$$(3,6)$$$\n$$$v_4$$$\n$$$=$$$\n$$$(4,3)$$$\n$$$v_5$$$\n$$$=$$$\n$$$(4,4)$$$\n$$$v_6$$$\n$$$=$$$\n$$$(4,5)$$$\n$$$v_7$$$\n$$$=$$$\n$$$(4,6)$$$\n$$$v_8$$$\n$$$=$$$\n$$$(5,3)$$$\n$$$v_9$$$\n$$$=$$$\n$$$(5,4)$$$\n$$$v_{10}$$$\n$$$=$$$\n$$$(5,6)$$$\nFor example, $$$d(v_1, v_3) = 1$$$; $$$d(v_1, v_8) = 6$$$; and $$$d(v_9, v_{10}) = 4$$$.\nStatement\nYour task is to, given an ideal city, write a program to compute the sum of all pairwise distances between blocks $$$v_i$$$ and $$$v_j$$$ for which $$$i < j$$$. Formally, your program should compute the value of the following sum:\n$$$\\sum d(v_i, v_j)$$$; where $$$0 \\le i < j \\le N-1$$$\nSpecifically, you have to implement a routine\nDistanceSum(N, X, Y)\nthat, given $$$N$$$ and two arrays $$$X$$$ and $$$Y$$$ that describe the city, calculates the formula above. Both $$$X$$$ and $$$Y$$$ are of size $$$N$$$; block $$$i$$$ is at coordinates $$$(X[i], Y[i])$$$ for $$$0 \\le i \\le N - 1$$$, and $$$1 \\le X[i], Y[i] \\le 2^{31} - 2$$$. Since the result may be too big to be represented using 32 bits, you should report it modulo $$$1\\,000\\,000\\,000$$$ (one billion). In Example 2, there are $$$\\frac{11 × 10}{2} = 55$$$ pairs of blocks. The sum of all the pairwise distances is $$$174$$$.\nImplementation details\nYou have to submit exactly one file, called\ncity.c\n,\ncity.cpp\nor\ncity.pas\n. This file must implement the subprogram described above using the following signatures.\nThis subprogram must behave as described above. Of course you are free to implement other subprograms for its internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nSample grader\nThe sample grader provided with the task environment will expect input in the following format:\nline 1: $$$N$$$;\nlines 2, ..., N + 1: $$$X[i]$$$, $$$Y[i]$$$.\nScoring\nSubtask\nPoints\nConditions\n1\n11\n$$$N \\le 200$$$\n2\n21\n$$$N \\le 2\\,000$$$\n3\n23\n$$$N \\le 100\\,000$$$\n$$$*$$$\n4\n45\n$$$N \\le 100\\,000$$$\n$$$*$$$\nAdditionally, the following two conditions hold for the 3-rd subtask:\ngiven any two non-empty cells $$$i$$$ and $$$j$$$ such that $$$X[i] = X[j]$$$, every cell between them is non-empty too;\ngiven any two non-empty cells $$$i$$$ and $$$j$$$ such that $$$Y[i] = Y[j]$$$, every cell between them is non-empty too.\nExample",
    "_meta": {
      "index": 39,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/D",
      "uuid": "ps_b49ab1593bc516599c39a48ec50ceca8072ace48"
    }
  },
  {
    "planning_view": {
      "title": "F. Aliens",
      "task": "Cover n points with ≤k diagonal-aligned squares minimizing total photographed cells",
      "given": [
        "m×m grid with n points of interest",
        "Points located at (r_i, c_i) coordinates",
        "Satellite can take ≤k photos",
        "Photos must be squares with corners on main diagonal"
      ],
      "goal": "Find minimum number of cells photographed while covering all points",
      "key_rules": [
        "Squares must have opposite corners on main diagonal (from (0,0) to (m-1,m-1))",
        "Each cell is either fully inside or outside photographed area",
        "Data for each cell transmitted only once even if photographed multiple times",
        "k ≤ n (maximum photos ≤ number of points)"
      ],
      "target": {
        "1": {
          "points": 4,
          "req": "n ≤ 50, m ≤ 100, k = n"
        },
        "2": {
          "points": 12,
          "req": "n ≤ 500, m ≤ 1000, all points on diagonal (r_i = c_i)"
        },
        "3": {
          "points": 9,
          "req": "n ≤ 500, m ≤ 1000"
        },
        "4": {
          "points": 16,
          "req": "n ≤ 4000, m ≤ 1000000"
        },
        "5": {
          "points": 19,
          "req": "n ≤ 50000, k ≤ 100, m ≤ 1000000"
        },
        "6": {
          "points": 40,
          "req": "n ≤ 100000, m ≤ 1000000"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Aliens",
      "contest": "IOI 2016 day 2",
      "one_line": "Cover n points with ≤k diagonal-aligned squares minimizing total photographed cells",
      "given": [
        "m×m grid with n points of interest",
        "Points located at (r_i, c_i) coordinates",
        "Satellite can take ≤k photos",
        "Photos must be squares with corners on main diagonal"
      ],
      "goal": "Find minimum number of cells photographed while covering all points",
      "mechanism": "Select up to k squares (diagonal-aligned) whose union covers all points; count total distinct cells photographed",
      "success_condition": "All points covered by at least one square; minimize |union of all squares|",
      "constraints": {
        "critical": [
          "Squares must have opposite corners on main diagonal (from (0,0) to (m-1,m-1))",
          "Each cell is either fully inside or outside photographed area",
          "Data for each cell transmitted only once even if photographed multiple times",
          "k ≤ n (maximum photos ≤ number of points)"
        ],
        "subtasks": {
          "1": {
            "points": 4,
            "req": "n ≤ 50, m ≤ 100, k = n"
          },
          "2": {
            "points": 12,
            "req": "n ≤ 500, m ≤ 1000, all points on diagonal (r_i = c_i)"
          },
          "3": {
            "points": 9,
            "req": "n ≤ 500, m ≤ 1000"
          },
          "4": {
            "points": 16,
            "req": "n ≤ 4000, m ≤ 1000000"
          },
          "5": {
            "points": 19,
            "req": "n ≤ 50000, k ≤ 100, m ≤ 1000000"
          },
          "6": {
            "points": 40,
            "req": "n ≤ 100000, m ≤ 1000000"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Aliens",
        "contest": "IOI 2016 day 2",
        "one_line": "Cover n points with ≤k diagonal-aligned squares minimizing total photographed cells"
      },
      "problem": {
        "given": [
          "m×m grid with n points of interest",
          "Points located at (r_i, c_i) coordinates",
          "Satellite can take ≤k photos",
          "Photos must be squares with corners on main diagonal"
        ],
        "goal": "Find minimum number of cells photographed while covering all points",
        "mechanism": "Select up to k squares (diagonal-aligned) whose union covers all points; count total distinct cells photographed",
        "success_condition": "All points covered by at least one square; minimize |union of all squares|"
      },
      "constraints": {
        "critical": [
          "Squares must have opposite corners on main diagonal (from (0,0) to (m-1,m-1))",
          "Each cell is either fully inside or outside photographed area",
          "Data for each cell transmitted only once even if photographed multiple times",
          "k ≤ n (maximum photos ≤ number of points)"
        ],
        "subtasks": {
          "1": {
            "points": 4,
            "req": "n ≤ 50, m ≤ 100, k = n"
          },
          "2": {
            "points": 12,
            "req": "n ≤ 500, m ≤ 1000, all points on diagonal (r_i = c_i)"
          },
          "3": {
            "points": 9,
            "req": "n ≤ 500, m ≤ 1000"
          },
          "4": {
            "points": 16,
            "req": "n ≤ 4000, m ≤ 1000000"
          },
          "5": {
            "points": 19,
            "req": "n ≤ 50000, k ≤ 100, m ≤ 1000000"
          },
          "6": {
            "points": 40,
            "req": "n ≤ 100000, m ≤ 1000000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 take_photos(int n, int m, int k, int[] r, int[] c)",
        "available_api": {},
        "requirements": [
          "Return int64 (long long in C++)",
          "Input arrays r and c are 0-indexed",
          "Grid coordinates range: 0 to m-1",
          "Must use provided template files"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "5 7 2\n0 3\n4 4\n4 6\n4 5\n4 6",
          "output": "25"
        }
      ],
      "original_statement": "Our satellite has just discovered an alien civilization on a remote planet. We have already obtained a low-resolution photo of a square area of the planet. The photo shows many signs of intelligent life. Our experts have identified $$$n$$$ points of interest in the photo. The points are numbered from $$$0$$$ to $$$n - 1$$$. We now want to take high-resolution photos that contain all of those $$$n$$$ points.\nInternally, the satellite has divided the area of the low-resolution photo into an $$$m$$$ by $$$m$$$ grid of unit square cells. Both rows and columns of the grid are consecutively numbered from $$$0$$$ to $$$m - 1$$$ (from the top and left, respectively). We use $$$(s, t)$$$ to denote the cell in row $$$s$$$ and column $$$t$$$. The point number $$$i$$$ is located in the cell $$$(r_i, c_i)$$$. Each cell may contain an arbitrary number of these points.\nOur satellite is on a stable orbit that passes directly over the\nmain\ndiagonal of the grid. The main diagonal is the line segment that connects the top left and the bottom right corner of the grid. The satellite can take a high-resolution photo of any area that satisfies the following constraints:\nthe shape of the area is a square,\ntwo opposite corners of the square both lie on the main diagonal of the grid,\neach cell of the grid is either completely inside or completely outside the photographed area.\nThe satellite is able to take at most $$$k$$$ high-resolution photos.\nOnce the satellite is done taking photos, it will transmit the high-resolution photo of each photographed cell to our home base (regardless of whether that cell contains some points of interest). The data for each photographed cell will only be transmitted\nonce\n, even if the cell was photographed several times.\nThus, we have to choose at most $$$k$$$ square areas that will be photographed, assuring that:\neach cell containing at least one point of interest is photographed at least once, and\nthe number of cells that are photographed at least once is minimized.\nYour task is to find the smallest possible total number of photographed cells.\nImplementation details\nYou should implement the following function (method):\nint64 take_photos(int n, int m, int k, int[] r, int[] c)\nn\n: the number of points of interest,\nm\n: the number of rows (and also columns) in the grid,\nk\n: the maximum number of photos the satellite can take,\nr\nand\nc\n: two arrays of length $$$n$$$ describing the coordinates of the grid cells that contain points of interest. For $$$0 \\le i \\le n - 1$$$, the $$$i$$$-th point of interest is located in the cell $$$(r[i], c[i])$$$,\nthe function should return the smallest possible total number of cells that are photographed at least once (given that the photos must cover all points of interest).\nPlease use the provided template files for details of implementation in your programming language.\nInput\nThe sample grader reads the input in the following format:\nline 1: integers $$$n$$$, $$$m$$$ and $$$k$$$,\nline $$$2 + i$$$ $$$(0 \\le i \\le n - 1)$$$: integers $$$r_i$$$ and $$$c_i$$$.\nOutput\nOne integer— the answer to the problem.\nScoring\nFor all subtasks, $$$1 \\le k \\le n$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n4\n$$$1 \\le n \\le 50$$$, $$$1 \\le m \\le 100$$$, $$$k = n$$$\n2\n12\n$$$1 \\le n \\le 500$$$, $$$1 \\le m \\le 1\\,000$$$, for all $$$i$$$ such that $$$0 \\le i \\le n - 1$$$, $$$r_i = c_i$$$\n3\n9\n$$$1 \\le n \\le 500$$$, $$$1 \\le m \\le 1\\,000$$$\n4\n16\n$$$1 \\le n \\le 4\\,000$$$, $$$1 \\le m \\le 1\\,000\\,000$$$\n5\n19\n$$$1 \\le n \\le 50\\,000$$$, $$$1 \\le k \\le 100$$$, $$$1 \\le m \\le 1\\,000\\,000$$$\n6\n40\n$$$1 \\le n \\le 100\\,000$$$, $$$1 \\le m \\le 1\\,000\\,000$$$\nExamples\nNote\nExample 1\ntake_photos(5, 7, 2, [0, 4, 4, 4, 4], [3, 4, 6, 5, 6])\nIn this example we have a $$$7 \\times 7$$$ grid with $$$5$$$ points of interest. The points of interest are located in four different cells: $$$(0, 3)$$$, $$$(4, 4)$$$, $$$(4, 5)$$$ and $$$(4, 6)$$$. You may take at most $$$2$$$ high-resolution photos.\nOne way to capture all five points of interest is to make two photos: a photo of the $$$6 \\times 6$$$ square containing the cells $$$(0, 0)$$$ and $$$(5, 5)$$$, and a photo of the $$$3 \\times 3$$$ square containing the cells $$$(4, 4)$$$ and $$$(6, 6)$$$. If the satellite takes these two photos, it will transmit the data about $$$41$$$ cells. This amount is not optimal.\nThe optimal solution uses one photo to capture the $$$4 \\times 4$$$ square containing cells $$$(0, 0)$$$ and $$$(3, 3)$$$ and another photo to capture the $$$3 \\times 3$$$ square containing cells $$$(4, 4)$$$ and $$$(6, 6)$$$. This results in only $$$25$$$ photographed cells, which is optimal, so 'take_photos' should return $$$25$$$.\nNote that it is sufficient to photograph the cell $$$(4, 6)$$$ once, even though it contains two points of interest.\nThis example is shown in the figures below. The leftmost figure shows the grid that corresponds to this example. The middle figure shows the suboptimal solution in which $$$41$$$ cells were photographed. The rightmost figure shows the optimal solution.\nExample 2\ntake_photos(2, 6, 2, [1, 4], [4, 1])\nHere we have $$$2$$$ points of interest located symmetrically: in the cells $$$(1, 4)$$$ and $$$(4, 1)$$$. Any valid photo that contains one of them contains the other one as well. Therefore, it is sufficient to use a single photo.\nThe figures below show this example and its optimal solution. In this solution the satellite captures a single photo of $$$16$$$ cells."
    },
    "original": "Our satellite has just discovered an alien civilization on a remote planet. We have already obtained a low-resolution photo of a square area of the planet. The photo shows many signs of intelligent life. Our experts have identified $$$n$$$ points of interest in the photo. The points are numbered from $$$0$$$ to $$$n - 1$$$. We now want to take high-resolution photos that contain all of those $$$n$$$ points.\nInternally, the satellite has divided the area of the low-resolution photo into an $$$m$$$ by $$$m$$$ grid of unit square cells. Both rows and columns of the grid are consecutively numbered from $$$0$$$ to $$$m - 1$$$ (from the top and left, respectively). We use $$$(s, t)$$$ to denote the cell in row $$$s$$$ and column $$$t$$$. The point number $$$i$$$ is located in the cell $$$(r_i, c_i)$$$. Each cell may contain an arbitrary number of these points.\nOur satellite is on a stable orbit that passes directly over the\nmain\ndiagonal of the grid. The main diagonal is the line segment that connects the top left and the bottom right corner of the grid. The satellite can take a high-resolution photo of any area that satisfies the following constraints:\nthe shape of the area is a square,\ntwo opposite corners of the square both lie on the main diagonal of the grid,\neach cell of the grid is either completely inside or completely outside the photographed area.\nThe satellite is able to take at most $$$k$$$ high-resolution photos.\nOnce the satellite is done taking photos, it will transmit the high-resolution photo of each photographed cell to our home base (regardless of whether that cell contains some points of interest). The data for each photographed cell will only be transmitted\nonce\n, even if the cell was photographed several times.\nThus, we have to choose at most $$$k$$$ square areas that will be photographed, assuring that:\neach cell containing at least one point of interest is photographed at least once, and\nthe number of cells that are photographed at least once is minimized.\nYour task is to find the smallest possible total number of photographed cells.\nImplementation details\nYou should implement the following function (method):\nint64 take_photos(int n, int m, int k, int[] r, int[] c)\nn\n: the number of points of interest,\nm\n: the number of rows (and also columns) in the grid,\nk\n: the maximum number of photos the satellite can take,\nr\nand\nc\n: two arrays of length $$$n$$$ describing the coordinates of the grid cells that contain points of interest. For $$$0 \\le i \\le n - 1$$$, the $$$i$$$-th point of interest is located in the cell $$$(r[i], c[i])$$$,\nthe function should return the smallest possible total number of cells that are photographed at least once (given that the photos must cover all points of interest).\nPlease use the provided template files for details of implementation in your programming language.\nInput\nThe sample grader reads the input in the following format:\nline 1: integers $$$n$$$, $$$m$$$ and $$$k$$$,\nline $$$2 + i$$$ $$$(0 \\le i \\le n - 1)$$$: integers $$$r_i$$$ and $$$c_i$$$.\nOutput\nOne integer— the answer to the problem.\nScoring\nFor all subtasks, $$$1 \\le k \\le n$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n4\n$$$1 \\le n \\le 50$$$, $$$1 \\le m \\le 100$$$, $$$k = n$$$\n2\n12\n$$$1 \\le n \\le 500$$$, $$$1 \\le m \\le 1\\,000$$$, for all $$$i$$$ such that $$$0 \\le i \\le n - 1$$$, $$$r_i = c_i$$$\n3\n9\n$$$1 \\le n \\le 500$$$, $$$1 \\le m \\le 1\\,000$$$\n4\n16\n$$$1 \\le n \\le 4\\,000$$$, $$$1 \\le m \\le 1\\,000\\,000$$$\n5\n19\n$$$1 \\le n \\le 50\\,000$$$, $$$1 \\le k \\le 100$$$, $$$1 \\le m \\le 1\\,000\\,000$$$\n6\n40\n$$$1 \\le n \\le 100\\,000$$$, $$$1 \\le m \\le 1\\,000\\,000$$$\nExamples\nNote\nExample 1\ntake_photos(5, 7, 2, [0, 4, 4, 4, 4], [3, 4, 6, 5, 6])\nIn this example we have a $$$7 \\times 7$$$ grid with $$$5$$$ points of interest. The points of interest are located in four different cells: $$$(0, 3)$$$, $$$(4, 4)$$$, $$$(4, 5)$$$ and $$$(4, 6)$$$. You may take at most $$$2$$$ high-resolution photos.\nOne way to capture all five points of interest is to make two photos: a photo of the $$$6 \\times 6$$$ square containing the cells $$$(0, 0)$$$ and $$$(5, 5)$$$, and a photo of the $$$3 \\times 3$$$ square containing the cells $$$(4, 4)$$$ and $$$(6, 6)$$$. If the satellite takes these two photos, it will transmit the data about $$$41$$$ cells. This amount is not optimal.\nThe optimal solution uses one photo to capture the $$$4 \\times 4$$$ square containing cells $$$(0, 0)$$$ and $$$(3, 3)$$$ and another photo to capture the $$$3 \\times 3$$$ square containing cells $$$(4, 4)$$$ and $$$(6, 6)$$$. This results in only $$$25$$$ photographed cells, which is optimal, so 'take_photos' should return $$$25$$$.\nNote that it is sufficient to photograph the cell $$$(4, 6)$$$ once, even though it contains two points of interest.\nThis example is shown in the figures below. The leftmost figure shows the grid that corresponds to this example. The middle figure shows the suboptimal solution in which $$$41$$$ cells were photographed. The rightmost figure shows the optimal solution.\nExample 2\ntake_photos(2, 6, 2, [1, 4], [4, 1])\nHere we have $$$2$$$ points of interest located symmetrically: in the cells $$$(1, 4)$$$ and $$$(4, 1)$$$. Any valid photo that contains one of them contains the other one as well. Therefore, it is sufficient to use a single photo.\nThe figures below show this example and its optimal solution. In this solution the satellite captures a single photo of $$$16$$$ cells.",
    "_meta": {
      "index": 40,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/F",
      "uuid": "ps_71f34a79c97a37f1fd5dce896c309a9bea1472cb"
    }
  },
  {
    "planning_view": {
      "title": "A. Distributing Candies",
      "task": "Simulate q range updates with capacity constraints on n boxes in ≤4s",
      "given": [
        "n boxes numbered 0 to n-1, initially empty",
        "Each box i has capacity c[i]",
        "q days with operations (l, r, v) on index ranges"
      ],
      "goal": "Determine final candy count in each box after all q operations",
      "key_rules": [
        "Updates are applied sequentially day by day",
        "Additions stop when box reaches capacity",
        "Removals stop when box becomes empty",
        "Updates affect contiguous range l to r inclusive"
      ],
      "target": {
        "1": {
          "points": 3,
          "req": "n, q ≤ 2000"
        },
        "2": {
          "points": 8,
          "req": "All v[j] > 0 (only additions)"
        },
        "3": {
          "points": 27,
          "req": "All capacities equal"
        },
        "4": {
          "points": 29,
          "req": "All operations on entire range (l=0, r=n-1)"
        },
        "5": {
          "points": 33,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Distributing Candies",
      "contest": "IOI 2021 day 1",
      "one_line": "Simulate q range updates with capacity constraints on n boxes in ≤4s",
      "given": [
        "n boxes numbered 0 to n-1, initially empty",
        "Each box i has capacity c[i]",
        "q days with operations (l, r, v) on index ranges"
      ],
      "goal": "Determine final candy count in each box after all q operations",
      "mechanism": "For each day, apply v>0: add min(v, remaining capacity) or v<0: remove min(-v, current candies) to boxes l..r",
      "success_condition": "Return array s where s[i] = final candy count for box i",
      "constraints": {
        "critical": [
          "Updates are applied sequentially day by day",
          "Additions stop when box reaches capacity",
          "Removals stop when box becomes empty",
          "Updates affect contiguous range l to r inclusive"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "n, q ≤ 2000"
          },
          "2": {
            "points": 8,
            "req": "All v[j] > 0 (only additions)"
          },
          "3": {
            "points": 27,
            "req": "All capacities equal"
          },
          "4": {
            "points": 29,
            "req": "All operations on entire range (l=0, r=n-1)"
          },
          "5": {
            "points": 33,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "4 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Distributing Candies",
        "contest": "IOI 2021 day 1",
        "one_line": "Simulate q range updates with capacity constraints on n boxes in ≤4s"
      },
      "problem": {
        "given": [
          "n boxes numbered 0 to n-1, initially empty",
          "Each box i has capacity c[i]",
          "q days with operations (l, r, v) on index ranges"
        ],
        "goal": "Determine final candy count in each box after all q operations",
        "mechanism": "For each day, apply v>0: add min(v, remaining capacity) or v<0: remove min(-v, current candies) to boxes l..r",
        "success_condition": "Return array s where s[i] = final candy count for box i"
      },
      "constraints": {
        "critical": [
          "Updates are applied sequentially day by day",
          "Additions stop when box reaches capacity",
          "Removals stop when box becomes empty",
          "Updates affect contiguous range l to r inclusive"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "n, q ≤ 2000"
          },
          "2": {
            "points": 8,
            "req": "All v[j] > 0 (only additions)"
          },
          "3": {
            "points": 27,
            "req": "All capacities equal"
          },
          "4": {
            "points": 29,
            "req": "All operations on entire range (l=0, r=n-1)"
          },
          "5": {
            "points": 33,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] distribute_candies(int[] c, int[] l, int[] r, int[] v)",
        "available_api": {
          "distribute_candies": {
            "signature": "int[] distribute_candies(int[] c, int[] l, int[] r, int[] v)",
            "params": "c: box capacities, l/r: operation ranges, v: operation values",
            "returns": "Array of final candy counts per box",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Boxes are 0-indexed (0 to n-1)",
          "Return array must match input c length",
          "Must handle large values (up to 10^9)"
        ]
      },
      "limits": {
        "time": "4 seconds",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "3\n10 15 13\n2\n0 2 20\n0 1 -11",
          "output": "0 4 13"
        }
      ],
      "original_statement": "Aunty Khong is preparing $$$n$$$ boxes of candies for students from a nearby school. The boxes are numbered from $$$0$$$ to $$$n-1$$$ and are initially empty. Box $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) has a capacity of $$$c[i]$$$ candies.\nAunty Khong spends $$$q$$$ days preparing the boxes. On day $$$j$$$ ($$$0 \\leq j \\leq q-1$$$), she performs an action specified by three integers $$$l[j]$$$, $$$r[j]$$$ and $$$v[j]$$$ where $$$0 \\leq l[j] \\leq r[j] \\leq n-1$$$ and $$$v[j] \\neq 0$$$. For each box $$$k$$$ satisfying $$$l[j] \\leq k \\leq r[j]$$$:\nIf $$$v[j] > 0$$$, Aunty Khong adds candies to box $$$k$$$, one by one, until she has added exactly $$$v[j]$$$ candies or the box becomes full. In other words, if the box had $$$p$$$ candies before the action, it will have $$$\\min(c[k],p+v[j])$$$ candies after the action.\nIf $$$v[j] < 0$$$, Aunty Khong removes candies from box $$$k$$$, one by one, until she has removed exactly $$$-v[j]$$$ candies or the box becomes empty. In other words, if the box had $$$p$$$ candies before the action, it will have $$$\\max(0,p+v[j])$$$ candies after the action.\nYour task is to determine the number of candies in each box after the $$$q$$$ days.\nImplementation Details\nYou should implement the following procedure:\nint[] distribute_candies(int[] c, int[] l, int[] r, int[] v)\n$$$c$$$: an array of length $$$n$$$. For $$$0 \\leq i \\leq n-1$$$, $$$c[i]$$$ denotes the capacity of box $$$i$$$.\n$$$l$$$, $$$r$$$ and $$$v$$$: three arrays of length $$$q$$$. On day $$$j$$$, for $$$0 \\leq j \\leq q-1$$$, Aunty Khong performs an action specified by integers $$$l[j]$$$, $$$r[j]$$$ and $$$v[j]$$$, as described above.\nThis procedure should return an array of length $$$n$$$. Denote the array by $$$s$$$. For $$$0 \\leq i \\leq n-1$$$, $$$s[i]$$$ should be the number of candies in box $$$i$$$ after the $$$q$$$ days.\nInput\nThe sample grader reads in the input in the following format:\nline $$$1$$$: $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$)\nline $$$2$$$: $$$c[0]\\ c[1]\\ldots \\ c[n-1]$$$ ($$$1 \\leq c[i] \\leq 10^9$$$)\nline $$$3$$$: $$$q$$$ ($$$1 \\leq q \\leq 200\\,000$$$)\nline $$$4+j$$$ ($$$0\\leq j \\leq q-1$$$): $$$l[j]\\ r[j]\\ v[j]$$$ ($$$0 \\leq l[j] \\leq r[j] \\leq n-1$$$, $$$-10^9\\leq v[j] \\leq 10^9, v[j] \\neq 0$$$)\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1$$$: $$$s[0]\\ s[1]\\ldots \\ s[n-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$n, q \\leq 2000$$$\n2\n8\n$$$v[j] > 0$$$ (for all $$$0 \\leq j \\leq q-1$$$)\n3\n27\n$$$c[0] = c[1] = \\ldots = c[n-1]$$$\n4\n29\n$$$l[j] = 0$$$ and $$$r[j] = n-1$$$ (for all $$$0 \\leq j \\leq q-1$$$)\n5\n33\nNo additional constraints\nExample\nNote\nExample 1\nConsider the following call:\ndistribute_candies([10, 15, 13], [0, 0], [2, 1], [20, -11])\nThis means that box $$$0$$$ has a capacity of $$$10$$$ candies, box $$$1$$$ has a capacity of $$$15$$$ candies, and box $$$2$$$ has a capacity of $$$13$$$ candies.\nAt the end of day $$$0$$$, box $$$0$$$ has $$$\\min(c[0], 0+v[0]) = 10$$$ candies, box $$$1$$$ has $$$\\min(c[1], 0+v[0])=15$$$ candies and box $$$2$$$ has $$$\\min(c[2], 0+v[0])=13$$$ candies.\nAt the end of day $$$1$$$, box $$$0$$$ has $$$\\max(0, 10+v[1]) = 0$$$ candies, box $$$1$$$ has $$$\\max(0, 15+v[1]) = 4$$$ candies. Since $$$2 > r[1]$$$, there is no change in the number of candies in box $$$2$$$. The number of candies at the end of each day are summarized below:\nDay\nBox $$$0$$$\nBox $$$1$$$\nBox $$$2$$$\n$$$0$$$\n$$$10$$$\n$$$15$$$\n$$$13$$$\n$$$1$$$\n$$$0$$$\n$$$4$$$\n$$$13$$$\nAs such, the procedure should return $$$[0, 4, 13]$$$"
    },
    "original": "Aunty Khong is preparing $$$n$$$ boxes of candies for students from a nearby school. The boxes are numbered from $$$0$$$ to $$$n-1$$$ and are initially empty. Box $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) has a capacity of $$$c[i]$$$ candies.\nAunty Khong spends $$$q$$$ days preparing the boxes. On day $$$j$$$ ($$$0 \\leq j \\leq q-1$$$), she performs an action specified by three integers $$$l[j]$$$, $$$r[j]$$$ and $$$v[j]$$$ where $$$0 \\leq l[j] \\leq r[j] \\leq n-1$$$ and $$$v[j] \\neq 0$$$. For each box $$$k$$$ satisfying $$$l[j] \\leq k \\leq r[j]$$$:\nIf $$$v[j] > 0$$$, Aunty Khong adds candies to box $$$k$$$, one by one, until she has added exactly $$$v[j]$$$ candies or the box becomes full. In other words, if the box had $$$p$$$ candies before the action, it will have $$$\\min(c[k],p+v[j])$$$ candies after the action.\nIf $$$v[j] < 0$$$, Aunty Khong removes candies from box $$$k$$$, one by one, until she has removed exactly $$$-v[j]$$$ candies or the box becomes empty. In other words, if the box had $$$p$$$ candies before the action, it will have $$$\\max(0,p+v[j])$$$ candies after the action.\nYour task is to determine the number of candies in each box after the $$$q$$$ days.\nImplementation Details\nYou should implement the following procedure:\nint[] distribute_candies(int[] c, int[] l, int[] r, int[] v)\n$$$c$$$: an array of length $$$n$$$. For $$$0 \\leq i \\leq n-1$$$, $$$c[i]$$$ denotes the capacity of box $$$i$$$.\n$$$l$$$, $$$r$$$ and $$$v$$$: three arrays of length $$$q$$$. On day $$$j$$$, for $$$0 \\leq j \\leq q-1$$$, Aunty Khong performs an action specified by integers $$$l[j]$$$, $$$r[j]$$$ and $$$v[j]$$$, as described above.\nThis procedure should return an array of length $$$n$$$. Denote the array by $$$s$$$. For $$$0 \\leq i \\leq n-1$$$, $$$s[i]$$$ should be the number of candies in box $$$i$$$ after the $$$q$$$ days.\nInput\nThe sample grader reads in the input in the following format:\nline $$$1$$$: $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$)\nline $$$2$$$: $$$c[0]\\ c[1]\\ldots \\ c[n-1]$$$ ($$$1 \\leq c[i] \\leq 10^9$$$)\nline $$$3$$$: $$$q$$$ ($$$1 \\leq q \\leq 200\\,000$$$)\nline $$$4+j$$$ ($$$0\\leq j \\leq q-1$$$): $$$l[j]\\ r[j]\\ v[j]$$$ ($$$0 \\leq l[j] \\leq r[j] \\leq n-1$$$, $$$-10^9\\leq v[j] \\leq 10^9, v[j] \\neq 0$$$)\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1$$$: $$$s[0]\\ s[1]\\ldots \\ s[n-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$n, q \\leq 2000$$$\n2\n8\n$$$v[j] > 0$$$ (for all $$$0 \\leq j \\leq q-1$$$)\n3\n27\n$$$c[0] = c[1] = \\ldots = c[n-1]$$$\n4\n29\n$$$l[j] = 0$$$ and $$$r[j] = n-1$$$ (for all $$$0 \\leq j \\leq q-1$$$)\n5\n33\nNo additional constraints\nExample\nNote\nExample 1\nConsider the following call:\ndistribute_candies([10, 15, 13], [0, 0], [2, 1], [20, -11])\nThis means that box $$$0$$$ has a capacity of $$$10$$$ candies, box $$$1$$$ has a capacity of $$$15$$$ candies, and box $$$2$$$ has a capacity of $$$13$$$ candies.\nAt the end of day $$$0$$$, box $$$0$$$ has $$$\\min(c[0], 0+v[0]) = 10$$$ candies, box $$$1$$$ has $$$\\min(c[1], 0+v[0])=15$$$ candies and box $$$2$$$ has $$$\\min(c[2], 0+v[0])=13$$$ candies.\nAt the end of day $$$1$$$, box $$$0$$$ has $$$\\max(0, 10+v[1]) = 0$$$ candies, box $$$1$$$ has $$$\\max(0, 15+v[1]) = 4$$$ candies. Since $$$2 > r[1]$$$, there is no change in the number of candies in box $$$2$$$. The number of candies at the end of each day are summarized below:\nDay\nBox $$$0$$$\nBox $$$1$$$\nBox $$$2$$$\n$$$0$$$\n$$$10$$$\n$$$15$$$\n$$$13$$$\n$$$1$$$\n$$$0$$$\n$$$4$$$\n$$$13$$$\nAs such, the procedure should return $$$[0, 4, 13]$$$",
    "_meta": {
      "index": 41,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/A",
      "uuid": "ps_e2bc1c83136e46e243179ca16d27efa6bc8a5280"
    }
  },
  {
    "planning_view": {
      "title": "B. Split the Attractions",
      "task": "Partition n connected attractions into sets of sizes a,b,c with ≥2 sets connected",
      "given": [
        "n attractions connected by m roads forming connected graph",
        "Desired set sizes a, b, c with a+b+c=n",
        "Graph is simple and connected"
      ],
      "goal": "Partition attractions into sets A,B,C of sizes a,b,c with ≥2 sets connected",
      "key_rules": [
        "Set is connected if all attractions in set are reachable using only roads within set",
        "At least two out of three sets must be connected",
        "Graph is connected and simple (no multiple edges)"
      ],
      "target": {
        "1": {
          "points": 7,
          "req": "Each attraction has degree ≤ 2"
        },
        "2": {
          "points": 11,
          "req": "a = 1"
        },
        "3": {
          "points": 22,
          "req": "m = n-1 (tree)"
        },
        "4": {
          "points": 24,
          "req": "n ≤ 2500, m ≤ 5000"
        },
        "5": {
          "points": 36,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Split the Attractions",
      "contest": "IOI 2019 day 1",
      "one_line": "Partition n connected attractions into sets of sizes a,b,c with ≥2 sets connected",
      "given": [
        "n attractions connected by m roads forming connected graph",
        "Desired set sizes a, b, c with a+b+c=n",
        "Graph is simple and connected"
      ],
      "goal": "Partition attractions into sets A,B,C of sizes a,b,c with ≥2 sets connected",
      "mechanism": "A connected set allows travel between any two attractions using only roads within that set",
      "success_condition": "Return assignment labels (1=A,2=B,3=C) or all zeros if no valid partition exists",
      "constraints": {
        "critical": [
          "Set is connected if all attractions in set are reachable using only roads within set",
          "At least two out of three sets must be connected",
          "Graph is connected and simple (no multiple edges)"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "Each attraction has degree ≤ 2"
          },
          "2": {
            "points": 11,
            "req": "a = 1"
          },
          "3": {
            "points": 22,
            "req": "m = n-1 (tree)"
          },
          "4": {
            "points": 24,
            "req": "n ≤ 2500, m ≤ 5000"
          },
          "5": {
            "points": 36,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Split the Attractions",
        "contest": "IOI 2019 day 1",
        "one_line": "Partition n connected attractions into sets of sizes a,b,c with ≥2 sets connected"
      },
      "problem": {
        "given": [
          "n attractions connected by m roads forming connected graph",
          "Desired set sizes a, b, c with a+b+c=n",
          "Graph is simple and connected"
        ],
        "goal": "Partition attractions into sets A,B,C of sizes a,b,c with ≥2 sets connected",
        "mechanism": "A connected set allows travel between any two attractions using only roads within that set",
        "success_condition": "Return assignment labels (1=A,2=B,3=C) or all zeros if no valid partition exists"
      },
      "constraints": {
        "critical": [
          "Set is connected if all attractions in set are reachable using only roads within set",
          "At least two out of three sets must be connected",
          "Graph is connected and simple (no multiple edges)"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "Each attraction has degree ≤ 2"
          },
          "2": {
            "points": 11,
            "req": "a = 1"
          },
          "3": {
            "points": 22,
            "req": "m = n-1 (tree)"
          },
          "4": {
            "points": 24,
            "req": "n ≤ 2500, m ≤ 5000"
          },
          "5": {
            "points": 36,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] find_split(int n, int a, int b, int c, int[] p, int[] q)",
        "available_api": {},
        "requirements": [
          "Return array of length n with values 1,2,3 for set assignment",
          "Return all zeros if no valid partition exists",
          "Attractions are 0-indexed from 0 to n-1",
          "Roads arrays p and q contain endpoints for each road"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "9 10\n4 2 3\n0 1\n0 2\n0 3\n0 4\n0 6\n0 8\n1 7\n3 7\n4 5\n5 6",
          "output": "3 2 3 1 3 1 1 2 1"
        }
      ],
      "original_statement": "There are $$$n$$$ attractions in Baku, numbered from $$$0$$$ to $$$n-1$$$. There are also $$$m$$$ two-way roads, numbered from $$$0$$$ to $$$m-1$$$. Each road connects two different attractions. It is possible to travel between any pair of attractions through the roads.\\nFatima is planning to visit all of the attractions in three days. She already decided that she wants to visit $$$a$$$ attractions on the first day, $$$b$$$ attractions on the second day, and $$$c$$$ attractions on the third day. Therefore, she is going to partition the $$$n$$$ attractions into three sets $$$A$$$, $$$B$$$, and $$$C$$$ of sizes $$$a$$$, $$$b$$$, and $$$c$$$, respectively. Each attraction will belong to exactly one set, so $$$a + b + c = n$$$.\\nFatima would like to find the sets $$$A$$$, $$$B$$$, and $$$C$$$, so that\\nat least two\\nout of the three sets are\\nconnected\\n. A set $$$S$$$ of attractions is called connected if it is possible to travel between any pair of attractions in $$$S$$$ by using the roads and without passing through any attraction not in $$$S$$$. A partition of attractions into sets $$$A$$$, $$$B$$$, and $$$C$$$ is called\\nvalid\\nif it satisfies the conditions described above.\\nHelp Fatima find a valid partition of the attractions (given $$$a$$$, $$$b$$$, and $$$c$$$), or determine that no valid partition exists. If there are multiple valid partitions, you may find any of them.\\nImplementation details\\nYou should implement the following procedure:\\nint[] find_split(int n, int a, int b, int c, int[] p, int[] q)\\n$$$n$$$: the number of attractions.\\n$$$a$$$, $$$b$$$, and $$$c$$$: the desired sizes of sets $$$A$$$, $$$B$$$, and $$$C$$$.\\n$$$p$$$ and $$$q$$$: arrays of length $$$m$$$, containing the endpoints of the roads. For each $$$i$$$ ($$$0 \\leq i \\leq m-1$$$), $$$p[i]$$$ and $$$q[i]$$$ are the two attractions connected by road $$$i$$$.\\nThis procedure should return an array of length $$$n$$$. Denote the array by $$$s$$$. If there is no valid partition, $$$s$$$ should contain $$$n$$$ zeros. Otherwise, for $$$0 \\leq i \\leq n-1$$$, $$$s[i]$$$ should be one of $$$1$$$, $$$2$$$, or $$$3$$$ to denote that attraction $$$i$$$ is assigned to set $$$A$$$, $$$B$$$, or $$$C$$$, respectively.\\nInput\\nThe sample grader reads the input in the following format:\\nline 1: $$$n$$$ $$$m$$$ ($$$3 \\leq n \\leq 100\\,000$$$, $$$2 \\leq m \\leq 200\\,000$$$)\\nline 2: $$$a$$$ $$$b$$$ $$$c$$$ ($$$1 \\leq a, b, c \\leq n$$$, $$$a+b+c = n$$$)\\nline $$$3+i$$$ (for $$$0 \\leq i \\leq m-1$$$): $$$p[i]$$$ $$$q[i]$$$ ($$$0 \\leq p[i], q[i] \\leq n-1$$$ and $$$p[i] \\neq q[i]$$$ for $$$0 \\leq i \\leq m - 1$$$)\\nThere is at most one road between each pair of attractions.\\nIt is possible to travel between any pair of attractions through the roads.\\nOutput\\nThe sample grader prints a single line containing the array returned by\\nfind_split\\n.\\nScoring\\nSubtask\\nPoints\\nAdditional Input Constraints\\n1\\n7\\nEach attraction is an endpoint of at most two roads.\\n2\\n11\\n$$$a = 1$$$\\n3\\n22\\n$$$m = n-1$$$\\n4\\n24\\n$$$n \\leq 2500, m \\leq 5000$$$\\n5\\n36\\nno additional constraints\\nExamples\\nNote\\nExample 1\\nConsider the following call:\\nfind_split(9, 4, 2, 3, [0, 0, 0, 0, 0, 0, 1, 3, 4, 5],\\n[1, 2, 3, 4, 6, 8, 7, 7, 5, 6])\\nA possible correct solution is $$$[1, 1, 3, 1, 2, 2, 3, 1, 3]$$$. This solution describes the following partition: $$$A=\\{0, 1, 3, 7\\}$$$, $$$B=\\{4, 5\\}$$$, and $$$C=\\{2, 6, 8\\}$$$. The sets $$$A$$$ and $$$B$$$ are connected.\\nExample 2\\nConsider the following call:\\nfind_split(6, 2, 2, 2, [0, 0, 0, 0, 0], [1, 2, 3, 4, 5])\\nNo valid partition exists. Therefore, the only correct answer is $$$[0, 0, 0, 0, 0, 0]$$$."
    },
    "original": "There are $$$n$$$ attractions in Baku, numbered from $$$0$$$ to $$$n-1$$$. There are also $$$m$$$ two-way roads, numbered from $$$0$$$ to $$$m-1$$$. Each road connects two different attractions. It is possible to travel between any pair of attractions through the roads.\\nFatima is planning to visit all of the attractions in three days. She already decided that she wants to visit $$$a$$$ attractions on the first day, $$$b$$$ attractions on the second day, and $$$c$$$ attractions on the third day. Therefore, she is going to partition the $$$n$$$ attractions into three sets $$$A$$$, $$$B$$$, and $$$C$$$ of sizes $$$a$$$, $$$b$$$, and $$$c$$$, respectively. Each attraction will belong to exactly one set, so $$$a + b + c = n$$$.\\nFatima would like to find the sets $$$A$$$, $$$B$$$, and $$$C$$$, so that\\nat least two\\nout of the three sets are\\nconnected\\n. A set $$$S$$$ of attractions is called connected if it is possible to travel between any pair of attractions in $$$S$$$ by using the roads and without passing through any attraction not in $$$S$$$. A partition of attractions into sets $$$A$$$, $$$B$$$, and $$$C$$$ is called\\nvalid\\nif it satisfies the conditions described above.\\nHelp Fatima find a valid partition of the attractions (given $$$a$$$, $$$b$$$, and $$$c$$$), or determine that no valid partition exists. If there are multiple valid partitions, you may find any of them.\\nImplementation details\\nYou should implement the following procedure:\\nint[] find_split(int n, int a, int b, int c, int[] p, int[] q)\\n$$$n$$$: the number of attractions.\\n$$$a$$$, $$$b$$$, and $$$c$$$: the desired sizes of sets $$$A$$$, $$$B$$$, and $$$C$$$.\\n$$$p$$$ and $$$q$$$: arrays of length $$$m$$$, containing the endpoints of the roads. For each $$$i$$$ ($$$0 \\leq i \\leq m-1$$$), $$$p[i]$$$ and $$$q[i]$$$ are the two attractions connected by road $$$i$$$.\\nThis procedure should return an array of length $$$n$$$. Denote the array by $$$s$$$. If there is no valid partition, $$$s$$$ should contain $$$n$$$ zeros. Otherwise, for $$$0 \\leq i \\leq n-1$$$, $$$s[i]$$$ should be one of $$$1$$$, $$$2$$$, or $$$3$$$ to denote that attraction $$$i$$$ is assigned to set $$$A$$$, $$$B$$$, or $$$C$$$, respectively.\\nInput\\nThe sample grader reads the input in the following format:\\nline 1: $$$n$$$ $$$m$$$ ($$$3 \\leq n \\leq 100\\,000$$$, $$$2 \\leq m \\leq 200\\,000$$$)\\nline 2: $$$a$$$ $$$b$$$ $$$c$$$ ($$$1 \\leq a, b, c \\leq n$$$, $$$a+b+c = n$$$)\\nline $$$3+i$$$ (for $$$0 \\leq i \\leq m-1$$$): $$$p[i]$$$ $$$q[i]$$$ ($$$0 \\leq p[i], q[i] \\leq n-1$$$ and $$$p[i] \\neq q[i]$$$ for $$$0 \\leq i \\leq m - 1$$$)\\nThere is at most one road between each pair of attractions.\\nIt is possible to travel between any pair of attractions through the roads.\\nOutput\\nThe sample grader prints a single line containing the array returned by\\nfind_split\\n.\\nScoring\\nSubtask\\nPoints\\nAdditional Input Constraints\\n1\\n7\\nEach attraction is an endpoint of at most two roads.\\n2\\n11\\n$$$a = 1$$$\\n3\\n22\\n$$$m = n-1$$$\\n4\\n24\\n$$$n \\leq 2500, m \\leq 5000$$$\\n5\\n36\\nno additional constraints\\nExamples\\nNote\\nExample 1\\nConsider the following call:\\nfind_split(9, 4, 2, 3, [0, 0, 0, 0, 0, 0, 1, 3, 4, 5],\\n[1, 2, 3, 4, 6, 8, 7, 7, 5, 6])\\nA possible correct solution is $$$[1, 1, 3, 1, 2, 2, 3, 1, 3]$$$. This solution describes the following partition: $$$A=\\{0, 1, 3, 7\\}$$$, $$$B=\\{4, 5\\}$$$, and $$$C=\\{2, 6, 8\\}$$$. The sets $$$A$$$ and $$$B$$$ are connected.\\nExample 2\\nConsider the following call:\\nfind_split(6, 2, 2, 2, [0, 0, 0, 0, 0], [1, 2, 3, 4, 5])\\nNo valid partition exists. Therefore, the only correct answer is $$$[0, 0, 0, 0, 0, 0]$$$.",
    "_meta": {
      "index": 42,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/B",
      "uuid": "ps_fa8383d9bba56d4eff9b104240bda47c25890f8a"
    }
  },
  {
    "planning_view": {
      "title": "D. Cave",
      "task": "Find correct switch positions and door connections using ≤70000 tryCombination() calls",
      "given": [
        "N doors and N switches (0 to N-1)",
        "Each switch controls exactly one door",
        "Switches have correct up/down positions",
        "Doors open only if connected switch is in correct position"
      ],
      "goal": "Determine correct switch positions and door-switch connections",
      "key_rules": [
        "Maximum 70000 calls to tryCombination()",
        "Can only see first closed door, not beyond",
        "Switch positions: 0=up, 1=down",
        "Doors checked in order 0 to N-1"
      ],
      "target": {
        "1": {
          "points": 12,
          "req": "Switch i connects to door i (find positions only)"
        },
        "2": {
          "points": 13,
          "req": "All correct positions are 0 (find connections only)"
        },
        "3": {
          "points": 21,
          "req": "N ≤ 100"
        },
        "4": {
          "points": 30,
          "req": "N ≤ 2000"
        },
        "5": {
          "points": 24,
          "req": "N ≤ 5000, no other restrictions"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Cave",
      "contest": "IOI 2013 day 2",
      "one_line": "Find correct switch positions and door connections using ≤70000 tryCombination() calls",
      "given": [
        "N doors and N switches (0 to N-1)",
        "Each switch controls exactly one door",
        "Switches have correct up/down positions",
        "Doors open only if connected switch is in correct position"
      ],
      "goal": "Determine correct switch positions and door-switch connections",
      "mechanism": "tryCombination(S) tests switch positions, returns first closed door index or -1 if all open",
      "success_condition": "Call answer(S, D) with correct switch positions S and door connections D",
      "constraints": {
        "critical": [
          "Maximum 70000 calls to tryCombination()",
          "Can only see first closed door, not beyond",
          "Switch positions: 0=up, 1=down",
          "Doors checked in order 0 to N-1"
        ],
        "subtasks": {
          "1": {
            "points": 12,
            "req": "Switch i connects to door i (find positions only)"
          },
          "2": {
            "points": 13,
            "req": "All correct positions are 0 (find connections only)"
          },
          "3": {
            "points": 21,
            "req": "N ≤ 100"
          },
          "4": {
            "points": 30,
            "req": "N ≤ 2000"
          },
          "5": {
            "points": 24,
            "req": "N ≤ 5000, no other restrictions"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "32 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Cave",
        "contest": "IOI 2013 day 2",
        "one_line": "Find correct switch positions and door connections using ≤70000 tryCombination() calls"
      },
      "problem": {
        "given": [
          "N doors and N switches (0 to N-1)",
          "Each switch controls exactly one door",
          "Switches have correct up/down positions",
          "Doors open only if connected switch is in correct position"
        ],
        "goal": "Determine correct switch positions and door-switch connections",
        "mechanism": "tryCombination(S) tests switch positions, returns first closed door index or -1 if all open",
        "success_condition": "Call answer(S, D) with correct switch positions S and door connections D"
      },
      "constraints": {
        "critical": [
          "Maximum 70000 calls to tryCombination()",
          "Can only see first closed door, not beyond",
          "Switch positions: 0=up, 1=down",
          "Doors checked in order 0 to N-1"
        ],
        "subtasks": {
          "1": {
            "points": 12,
            "req": "Switch i connects to door i (find positions only)"
          },
          "2": {
            "points": 13,
            "req": "All correct positions are 0 (find connections only)"
          },
          "3": {
            "points": 21,
            "req": "N ≤ 100"
          },
          "4": {
            "points": 30,
            "req": "N ≤ 2000"
          },
          "5": {
            "points": 24,
            "req": "N ≤ 5000, no other restrictions"
          }
        }
      },
      "implementation": {
        "function_to_write": "void exploreCave(int N)",
        "available_api": {
          "tryCombination": {
            "signature": "int tryCombination(int S[])",
            "params": "S: array of length N, S[i] is 0 (up) or 1 (down) for switch i",
            "returns": "First closed door index, or -1 if all doors open",
            "side_effect": "Tests the switch combination, runs in O(N) time"
          },
          "answer": {
            "signature": "void answer(int S[], int D[])",
            "params": "S: correct switch positions, D: door connections (D[i] = door for switch i)",
            "returns": "None (exits program)",
            "side_effect": "Submits final answer and terminates"
          }
        },
        "requirements": [
          "Must implement exploreCave(int N)",
          "Arrays S and D must be of length N",
          "Switch positions: 0=up, 1=down",
          "Door connections: D[i] = door number (0 to N-1) for switch i"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "32 megabytes"
      },
      "samples": [],
      "original_statement": "While lost on the long walk from the college to the UQ Centre, you have stumbled across the entrance to a secret cave system running deep under the university. The entrance is blocked by a security system consisting of $$$N$$$ consecutive doors, each door behind the previous; and N switches, with each switch connected to a different door.\nThe doors are numbered $$$0, 1, \\dots, N - 1$$$ in order, with door $$$0$$$ being closest to you. The switches are also numbered $$$0, 1, \\dots, N - 1$$$, though you do not know which switch is connected to which door.\nThe switches are all located at the entrance to the cave. Each switch can either be in an\nup\nor\ndown\nposition. Only one of these positions is correct for each switch. If a switch is in the correct position then the door it is connected to will be open, and if the switch is in the incorrect position then the door it is connected to will be closed. The correct position may be different for different switches, and you do not know which positions are the correct ones.\nYou would like to understand this security system. To do this, you can set the switches to any combination, and then walk into the cave to see which is the first closed door. Doors are not transparent: once you encounter the first closed door, you cannot see any of the doors behind it.\nYou have time to try $$$70\\,000$$$ combinations of switches, but no more. Your task is to determine the correct position for each switch, and also which door each switch is connected to.\nYou should submit a file that implements the procedure\nexploreCave()\n. This may call the grader function\ntryCombination()\nup to $$$70\\,000$$$ times, and must finish by calling the grader procedure\nanswer()\n. These functions and procedures are described below.\nGrader Function\ntryCombination()\n:\nint tryCombination(int S[]);\nThe grader will provide this function. It allows you to try a combination of switches, and then enter the cave to determine the first closed door. If all doors are open, the function will return $$$-1$$$. This function runs in $$$O(N)$$$ time; that is, the running time is at worst proportional to $$$N$$$.\nThis function may be called at most $$$70\\,000$$$ times.\nParameters:\n$$$S$$$: An array of length $$$N$$$, indicating the position of each switch. The element $$$S[i]$$$ corresponds to switch $$$i$$$. A value of $$$0$$$ indicates that the switch is up, and a value of $$$1$$$ indicates that the switch is down.\nReturns\n: The number of the first door that is closed, or $$$-1$$$ if all doors are open.\nGrader Procedure\nanswer()\n:\nvoid answer(int S[], int D[]);\nCall this procedure when you have identified the combination of switches to open all doors, and the door to which each switch is connected.\nParameters:\n$$$S$$$: An array of length $$$N$$$, indicating the correct position of each switch. The format matches that of the function\ntryCombination()\ndescribed above.\n$$$D$$$: An array of length $$$N$$$, indicating the door each switch is connected to. Specifically, element $$$D[i]$$$ should contain the door number that switch $$$i$$$ is connected to.\nReturns\n: This procedure does not return, but will cause the program to exit.\nYour Procedure\nexploreCave()\n:\nvoid exploreCave(int N);\nYour submission must implement this procedure.\nThis function should use the grader routine\ntryCombination()\nto determine the correct position for each switch and the door each switch is connected to, and must call\nanswer()\nonce it has determined this information.\nParameters:\n$$$N$$$: The number of switches and doors in the cave.\nInput\nThe sample grader reads input in the following format:\nline $$$1$$$: $$$N$$\nline $$$2$$$: $$$S[0]\\ S[1]\\dots S[N - 1]$$$\nline $$$3$$$: $$$D[0]\\ D[1]\\dots D[N - 1]$$$\nHere $$$N$$$ is the number of doors and switches, $$$S[i]$$$ is the correct position for switch $$$i$$$, nd $$$D[i]$$$ is the door that switch $$$i$$$ is connected to.\nScoring\nFull constraints: $$$1 \\leq N \\leq 5\\,000$$$\nSubtask\nPoints\nAdditional Input Constraints\n1\n12\nFor each $$$i$$$, switch $$$i$$$ is connected to door $$$i$$$. Your task is simply to determine the correct combination.\n2\n13\nThe correct combination will always be $$$[0,0,0, \\dots ,0]$$$. Your task is simply to determine which switch connects to which door.\n3\n21\n$$$N \\leq 100$$$\n4\n30\n$$$N \\leq 2\\,000$$$\n5\n24\n(\nNone\n)\nExample\nNote\nSuppose the doors and switches are arranged as in the picture above:\nFunction Call\nReturns\nExplanation\ntryCombination([1, 0, 1, 1])\n$$$1$$$\nThis corresponds to the picture. Switches $$$0$$$, $$$2$$$ and $$$3$$$ are down, while switch $$$1$$$ is up. The function returns $$$1$$$, indicating that door $$$1$$$ is the first door from the left that is closed.\ntryCombination([0, 1, 1, 0])\n3\nDoors $$$0$$$, $$$1$$$ and $$$2$$$ are all opened, while door $$$3$$$ is closed.\ntryCombination([1, 1, 1, 0])\n$$$-1$$$\nMoving switch $$$0$$$ down causes all doors to be opened, indicated by the return value of $$$-1$$$.\nanswer([1, 1, 1, 0],[3, 1, 0, 2])\n(Program exits)\nWe guess that the correct combination is $$$[1,1, 1,0]$$$, and that switches $$$0$$$, $$$1$$$, $$$2$$$ and $$$3$$$ connect to doors $$$3$$$, $$$1$$$, $$$0$$$ and $$$2$$$ respectively."
    },
    "original": "While lost on the long walk from the college to the UQ Centre, you have stumbled across the entrance to a secret cave system running deep under the university. The entrance is blocked by a security system consisting of $$$N$$$ consecutive doors, each door behind the previous; and N switches, with each switch connected to a different door.\nThe doors are numbered $$$0, 1, \\dots, N - 1$$$ in order, with door $$$0$$$ being closest to you. The switches are also numbered $$$0, 1, \\dots, N - 1$$$, though you do not know which switch is connected to which door.\nThe switches are all located at the entrance to the cave. Each switch can either be in an\nup\nor\ndown\nposition. Only one of these positions is correct for each switch. If a switch is in the correct position then the door it is connected to will be open, and if the switch is in the incorrect position then the door it is connected to will be closed. The correct position may be different for different switches, and you do not know which positions are the correct ones.\nYou would like to understand this security system. To do this, you can set the switches to any combination, and then walk into the cave to see which is the first closed door. Doors are not transparent: once you encounter the first closed door, you cannot see any of the doors behind it.\nYou have time to try $$$70\\,000$$$ combinations of switches, but no more. Your task is to determine the correct position for each switch, and also which door each switch is connected to.\nYou should submit a file that implements the procedure\nexploreCave()\n. This may call the grader function\ntryCombination()\nup to $$$70\\,000$$$ times, and must finish by calling the grader procedure\nanswer()\n. These functions and procedures are described below.\nGrader Function\ntryCombination()\n:\nint tryCombination(int S[]);\nThe grader will provide this function. It allows you to try a combination of switches, and then enter the cave to determine the first closed door. If all doors are open, the function will return $$$-1$$$. This function runs in $$$O(N)$$$ time; that is, the running time is at worst proportional to $$$N$$$.\nThis function may be called at most $$$70\\,000$$$ times.\nParameters:\n$$$S$$$: An array of length $$$N$$$, indicating the position of each switch. The element $$$S[i]$$$ corresponds to switch $$$i$$$. A value of $$$0$$$ indicates that the switch is up, and a value of $$$1$$$ indicates that the switch is down.\nReturns\n: The number of the first door that is closed, or $$$-1$$$ if all doors are open.\nGrader Procedure\nanswer()\n:\nvoid answer(int S[], int D[]);\nCall this procedure when you have identified the combination of switches to open all doors, and the door to which each switch is connected.\nParameters:\n$$$S$$$: An array of length $$$N$$$, indicating the correct position of each switch. The format matches that of the function\ntryCombination()\ndescribed above.\n$$$D$$$: An array of length $$$N$$$, indicating the door each switch is connected to. Specifically, element $$$D[i]$$$ should contain the door number that switch $$$i$$$ is connected to.\nReturns\n: This procedure does not return, but will cause the program to exit.\nYour Procedure\nexploreCave()\n:\nvoid exploreCave(int N);\nYour submission must implement this procedure.\nThis function should use the grader routine\ntryCombination()\nto determine the correct position for each switch and the door each switch is connected to, and must call\nanswer()\nonce it has determined this information.\nParameters:\n$$$N$$$: The number of switches and doors in the cave.\nInput\nThe sample grader reads input in the following format:\nline $$$1$$$: $$$N$$\nline $$$2$$$: $$$S[0]\\ S[1]\\dots S[N - 1]$$$\nline $$$3$$$: $$$D[0]\\ D[1]\\dots D[N - 1]$$$\nHere $$$N$$$ is the number of doors and switches, $$$S[i]$$$ is the correct position for switch $$$i$$$, nd $$$D[i]$$$ is the door that switch $$$i$$$ is connected to.\nScoring\nFull constraints: $$$1 \\leq N \\leq 5\\,000$$$\nSubtask\nPoints\nAdditional Input Constraints\n1\n12\nFor each $$$i$$$, switch $$$i$$$ is connected to door $$$i$$$. Your task is simply to determine the correct combination.\n2\n13\nThe correct combination will always be $$$[0,0,0, \\dots ,0]$$$. Your task is simply to determine which switch connects to which door.\n3\n21\n$$$N \\leq 100$$$\n4\n30\n$$$N \\leq 2\\,000$$$\n5\n24\n(\nNone\n)\nExample\nNote\nSuppose the doors and switches are arranged as in the picture above:\nFunction Call\nReturns\nExplanation\ntryCombination([1, 0, 1, 1])\n$$$1$$$\nThis corresponds to the picture. Switches $$$0$$$, $$$2$$$ and $$$3$$$ are down, while switch $$$1$$$ is up. The function returns $$$1$$$, indicating that door $$$1$$$ is the first door from the left that is closed.\ntryCombination([0, 1, 1, 0])\n3\nDoors $$$0$$$, $$$1$$$ and $$$2$$$ are all opened, while door $$$3$$$ is closed.\ntryCombination([1, 1, 1, 0])\n$$$-1$$$\nMoving switch $$$0$$$ down causes all doors to be opened, indicated by the return value of $$$-1$$$.\nanswer([1, 1, 1, 0],[3, 1, 0, 2])\n(Program exits)\nWe guess that the correct combination is $$$[1,1, 1,0]$$$, and that switches $$$0$$$, $$$1$$$, $$$2$$$ and $$$3$$$ connect to doors $$$3$$$, $$$1$$$, $$$0$$$ and $$$2$$$ respectively.",
    "_meta": {
      "index": 43,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/D",
      "uuid": "ps_65dbc744b6a96c350e262822474700f71937238d"
    }
  },
  {
    "planning_view": {
      "title": "D. Crocodile's Underground City",
      "task": "Find minimal escape time T where crocodile blocks 1 corridor per chamber",
      "given": [
        "N chambers connected by M bidirectional corridors",
        "K exit chambers where escape is possible",
        "Crocodile can block 1 corridor adjacent to current chamber",
        "Benjamas starts at chamber 0"
      ],
      "goal": "Find smallest T such that a good escape plan guarantees reaching an exit in ≤T time",
      "key_rules": [
        "Crocodile blocks exactly 1 corridor when Benjamas reaches a chamber",
        "Corridors cannot be blocked while Benjamas is traversing them",
        "Each non-exit chamber has ≥2 outgoing corridors",
        "Escape plan must guarantee success regardless of crocodile's blocking choices"
      ],
      "target": {
        "1": {
          "points": 46,
          "req": "N≤1000, M=N-1, tree structure with exits as leaves"
        },
        "2": {
          "points": 43,
          "req": "N≤1000, M≤100,000"
        },
        "3": {
          "points": 11,
          "req": "N≤100,000, M≤1,000,000"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Crocodile's Underground City",
      "contest": "IOI 2011 day 2",
      "one_line": "Find minimal escape time T where crocodile blocks 1 corridor per chamber",
      "given": [
        "N chambers connected by M bidirectional corridors",
        "K exit chambers where escape is possible",
        "Crocodile can block 1 corridor adjacent to current chamber",
        "Benjamas starts at chamber 0"
      ],
      "goal": "Find smallest T such that a good escape plan guarantees reaching an exit in ≤T time",
      "mechanism": "At each chamber: crocodile blocks 1 corridor, Benjamas chooses unblocked corridor to follow",
      "success_condition": "Good escape plan guarantees reaching exit chamber in finite time despite crocodile's blocking",
      "constraints": {
        "critical": [
          "Crocodile blocks exactly 1 corridor when Benjamas reaches a chamber",
          "Corridors cannot be blocked while Benjamas is traversing them",
          "Each non-exit chamber has ≥2 outgoing corridors",
          "Escape plan must guarantee success regardless of crocodile's blocking choices"
        ],
        "subtasks": {
          "1": {
            "points": 46,
            "req": "N≤1000, M=N-1, tree structure with exits as leaves"
          },
          "2": {
            "points": 43,
            "req": "N≤1000, M≤100,000"
          },
          "3": {
            "points": 11,
            "req": "N≤100,000, M≤1,000,000"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Crocodile's Underground City",
        "contest": "IOI 2011 day 2",
        "one_line": "Find minimal escape time T where crocodile blocks 1 corridor per chamber"
      },
      "problem": {
        "given": [
          "N chambers connected by M bidirectional corridors",
          "K exit chambers where escape is possible",
          "Crocodile can block 1 corridor adjacent to current chamber",
          "Benjamas starts at chamber 0"
        ],
        "goal": "Find smallest T such that a good escape plan guarantees reaching an exit in ≤T time",
        "mechanism": "At each chamber: crocodile blocks 1 corridor, Benjamas chooses unblocked corridor to follow",
        "success_condition": "Good escape plan guarantees reaching exit chamber in finite time despite crocodile's blocking"
      },
      "constraints": {
        "critical": [
          "Crocodile blocks exactly 1 corridor when Benjamas reaches a chamber",
          "Corridors cannot be blocked while Benjamas is traversing them",
          "Each non-exit chamber has ≥2 outgoing corridors",
          "Escape plan must guarantee success regardless of crocodile's blocking choices"
        ],
        "subtasks": {
          "1": {
            "points": 46,
            "req": "N≤1000, M=N-1, tree structure with exits as leaves"
          },
          "2": {
            "points": 43,
            "req": "N≤1000, M≤100,000"
          },
          "3": {
            "points": 11,
            "req": "N≤100,000, M≤1,000,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "travel_plan(N, M, R, L, K, P)",
        "available_api": {},
        "requirements": [
          "Return smallest T for which good escape plan exists",
          "Chambers numbered 0 to N-1",
          "Corridors numbered 0 to M-1",
          "R[i][0] and R[i][1] are chamber endpoints",
          "L[i] is corridor traversal time (1≤L[i]≤10^9)"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "5 4 3\n0 1 2\n0 2 3\n3 2 1\n2 4 4\n1 3 4",
          "output": "7"
        }
      ],
      "original_statement": "Archaeologist Benjamas is running for her life after investigating the mysterious Crocodile's Underground City. The city has $$$N$$$ chambers. There are $$$M$$$ bidirectional corridors, each connecting a different pair of distinct chambers. Running through different corridors may require different amounts of time. Only $$$K$$$ of the $$$N$$$ chambers are exit chambers that allow her to escape. Benjamas starts in chamber $$$0$$$. She wants to reach an exit chamber as quickly as possible.\nThe Crocodile gatekeeper wants to prevent Benjamas from escaping. From his den, he controls secret doors that can block any\nsingle\ncorridor. That is, whenever he blocks a new corridor, the previously blocked one has to be reopened.\nBenjamas's situation can be described as follows: Each time she tries to leave a chamber, the Crocodile gatekeeper may choose to block one of the corridors adjacent to it. Benjamas then chooses and follows one of the unblocked corridors to the next chamber. Once Benjamas enters a corridor, the Crocodile gatekeeper may not block it until Benjamas reaches the other end. Once she enters the next chamber, the gatekeeper may again choose to block one of the outgoing corridors (possibly the corridor that Benjamas just followed), and so on.\nShe would like to have a simple escape plan in advance. More precisely, she would like to have a set of instructions that tell her what to do when she gets to a chamber. Let $$$A$$$ be one of the chambers. If $$$A$$$ is an exit chamber, no instructions are needed–obviously, she can escape the city. Otherwise, the instruction for chamber $$$A$$$ should have one of the following forms:\n\"If you ever reach chamber $$$A$$$, take the corridor leading to chamber $$$B$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$C$$$.\"\n\"Don't bother about chamber $$$A$$$; according to this escape plan you cannot possibly reach it.\"\nNote that in some cases (for example, if your plan directs Benjamas to run in a cycle) the gatekeeper may be able to prevent Benjamas from reaching an exit. An escape plan is\ngood\nif Benjamas is guaranteed to reach an exit chamber after a finite amount of time, regardless of what the gatekeeper does. For a good escape plan, let $$$T$$$ be the smallest time such that after time $$$T$$$, Benjamas is\nguaranteed\nto reach an exit. In that case, we say that the\ngood escape plan takes time\n$$$T$$$.\nYour task is to write a procedure\ntravel_plan(N,M,R,L,K,P)\nthat takes the following parameters:\n$$$N$$$— the number of chambers. The chambers are numbered $$$0$$$ through $$$N-1$$$.\n$$$M$$$— the number of corridors. The corridors are numbered $$$0$$$ through $$$M-1$$$.\n$$$R$$$— a two-dimensional array of integers representing the corridors. For $$$0 \\le i < M$$$, corridor $$$i$$$ connects two distinct chambers $$$R[i][0]$$$ and $$$R[i][1]$$$. No two corridors join the same pair of chambers.\n$$$L$$$— a one-dimensional array of integers containing the times needed to traverse the corridors. For $$$0 \\le i < M$$$, the value $$$1 \\le L[i] \\le 1\\,000\\,000\\,000$$$ is the time Benjamas needs to runthrough the $$$i$$$ corridor.\n$$$K$$$— the number of exit chambers. You may assume that $$$1 \\le K \\le N$$$.\n$$$P$$$— a one-dimensional array of integers with $$$K$$$ distinct entries describing the exit chambers. For $$$0 \\le i < K$$$, the value $$$P[i]$$$ is the number of the $$$i$$$ exit chamber. Chamber $$$0$$$ will never be one of the exit chambers.\nYour procedure must return the smallest time $$$T$$$ for which there exists a good escape plan that takes time $$$T$$$.\nYou may assume that each non-exit chamber will have at least two corridors leaving it. You may also assume that in each test case there is a good escape plan for which $$$T \\le 1\\,000\\,000\\,000$$$.\nInput\nGrader reads input in following format:\nLine $$$1$$$: $$$N$$$, $$$M$$$, and $$$K$$$.\nLines $$$2$$$ to $$$M+1$$$: For $$$0 \\le i < M$$$, line $$$i+2$$$ contains $$$R[i][0]$$$, $$$R[i][1]$$$, and $$$L[i]$$$, separated by a space.\nLine $$$M+2$$$: a list of $$$K$$$ integers $$$P[0], P[1],\\ldots, P[K-1]$$$, separated by a space.\nLine $$$M+3$$$: the expected solution.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\nAdditional Input Constraints\n1\n46\n$$$3 \\le N \\le 1 000$$$\n$$$M = N-1$$$\nEvery exit chamber is connected to exactly one other chamber. Any other chamber is connected directly to three or more other chambers.\n2\n43\n$$$3 \\le N \\le 1 000$$$\n$$$2 \\le M \\le 100\\,000$$$\n—\n3\n11\n$$$3 \\le N \\le 100\\,000$$$\n$$$2 \\le M \\le 1\\,000\\,000$$$\n—\nExamples\nNote\nConsider the first example. Chambers are shown as circles, and corridors connecting them are shown as lines. Exit chambers are shown as thick-bordered circles. Benjamas starts at chamber $$$0$$$ (marked by a triangle). An optimal escape plan is the following one:\nIf you ever reach chamber $$$0$$$, take the corridor leading to chamber $$$1$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$2$$$.\nIf you ever reach chamber $$$2$$$, take the corridor leading to chamber $$$3$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$4$$$.\nIn the worst case, Benjamas will reach an exit chamber in $$$7$$$ units of time. Hence,\ntravel_plan\nshould return $$$7$$$.\nHere is an optimal escape plan:\nIf you ever reach chamber $$$0$$$, take the corridor leading to chamber $$$3$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$2$$$.\nIf you ever reach chamber $$$2$$$, take the corridor leading to chamber $$$3$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$1$$$.\nDon't bother about chamber $$$4$$$; according to this escape plan you cannot possibly reach it.\nBenjamas will reach one of the exit chambers no later than after $$$14$$$ units of time. Therefore,\ntravel_plan\nshould return $$$14$$$."
    },
    "original": "Archaeologist Benjamas is running for her life after investigating the mysterious Crocodile's Underground City. The city has $$$N$$$ chambers. There are $$$M$$$ bidirectional corridors, each connecting a different pair of distinct chambers. Running through different corridors may require different amounts of time. Only $$$K$$$ of the $$$N$$$ chambers are exit chambers that allow her to escape. Benjamas starts in chamber $$$0$$$. She wants to reach an exit chamber as quickly as possible.\nThe Crocodile gatekeeper wants to prevent Benjamas from escaping. From his den, he controls secret doors that can block any\nsingle\ncorridor. That is, whenever he blocks a new corridor, the previously blocked one has to be reopened.\nBenjamas's situation can be described as follows: Each time she tries to leave a chamber, the Crocodile gatekeeper may choose to block one of the corridors adjacent to it. Benjamas then chooses and follows one of the unblocked corridors to the next chamber. Once Benjamas enters a corridor, the Crocodile gatekeeper may not block it until Benjamas reaches the other end. Once she enters the next chamber, the gatekeeper may again choose to block one of the outgoing corridors (possibly the corridor that Benjamas just followed), and so on.\nShe would like to have a simple escape plan in advance. More precisely, she would like to have a set of instructions that tell her what to do when she gets to a chamber. Let $$$A$$$ be one of the chambers. If $$$A$$$ is an exit chamber, no instructions are needed–obviously, she can escape the city. Otherwise, the instruction for chamber $$$A$$$ should have one of the following forms:\n\"If you ever reach chamber $$$A$$$, take the corridor leading to chamber $$$B$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$C$$$.\"\n\"Don't bother about chamber $$$A$$$; according to this escape plan you cannot possibly reach it.\"\nNote that in some cases (for example, if your plan directs Benjamas to run in a cycle) the gatekeeper may be able to prevent Benjamas from reaching an exit. An escape plan is\ngood\nif Benjamas is guaranteed to reach an exit chamber after a finite amount of time, regardless of what the gatekeeper does. For a good escape plan, let $$$T$$$ be the smallest time such that after time $$$T$$$, Benjamas is\nguaranteed\nto reach an exit. In that case, we say that the\ngood escape plan takes time\n$$$T$$$.\nYour task is to write a procedure\ntravel_plan(N,M,R,L,K,P)\nthat takes the following parameters:\n$$$N$$$— the number of chambers. The chambers are numbered $$$0$$$ through $$$N-1$$$.\n$$$M$$$— the number of corridors. The corridors are numbered $$$0$$$ through $$$M-1$$$.\n$$$R$$$— a two-dimensional array of integers representing the corridors. For $$$0 \\le i < M$$$, corridor $$$i$$$ connects two distinct chambers $$$R[i][0]$$$ and $$$R[i][1]$$$. No two corridors join the same pair of chambers.\n$$$L$$$— a one-dimensional array of integers containing the times needed to traverse the corridors. For $$$0 \\le i < M$$$, the value $$$1 \\le L[i] \\le 1\\,000\\,000\\,000$$$ is the time Benjamas needs to runthrough the $$$i$$$ corridor.\n$$$K$$$— the number of exit chambers. You may assume that $$$1 \\le K \\le N$$$.\n$$$P$$$— a one-dimensional array of integers with $$$K$$$ distinct entries describing the exit chambers. For $$$0 \\le i < K$$$, the value $$$P[i]$$$ is the number of the $$$i$$$ exit chamber. Chamber $$$0$$$ will never be one of the exit chambers.\nYour procedure must return the smallest time $$$T$$$ for which there exists a good escape plan that takes time $$$T$$$.\nYou may assume that each non-exit chamber will have at least two corridors leaving it. You may also assume that in each test case there is a good escape plan for which $$$T \\le 1\\,000\\,000\\,000$$$.\nInput\nGrader reads input in following format:\nLine $$$1$$$: $$$N$$$, $$$M$$$, and $$$K$$$.\nLines $$$2$$$ to $$$M+1$$$: For $$$0 \\le i < M$$$, line $$$i+2$$$ contains $$$R[i][0]$$$, $$$R[i][1]$$$, and $$$L[i]$$$, separated by a space.\nLine $$$M+2$$$: a list of $$$K$$$ integers $$$P[0], P[1],\\ldots, P[K-1]$$$, separated by a space.\nLine $$$M+3$$$: the expected solution.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\nAdditional Input Constraints\n1\n46\n$$$3 \\le N \\le 1 000$$$\n$$$M = N-1$$$\nEvery exit chamber is connected to exactly one other chamber. Any other chamber is connected directly to three or more other chambers.\n2\n43\n$$$3 \\le N \\le 1 000$$$\n$$$2 \\le M \\le 100\\,000$$$\n—\n3\n11\n$$$3 \\le N \\le 100\\,000$$$\n$$$2 \\le M \\le 1\\,000\\,000$$$\n—\nExamples\nNote\nConsider the first example. Chambers are shown as circles, and corridors connecting them are shown as lines. Exit chambers are shown as thick-bordered circles. Benjamas starts at chamber $$$0$$$ (marked by a triangle). An optimal escape plan is the following one:\nIf you ever reach chamber $$$0$$$, take the corridor leading to chamber $$$1$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$2$$$.\nIf you ever reach chamber $$$2$$$, take the corridor leading to chamber $$$3$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$4$$$.\nIn the worst case, Benjamas will reach an exit chamber in $$$7$$$ units of time. Hence,\ntravel_plan\nshould return $$$7$$$.\nHere is an optimal escape plan:\nIf you ever reach chamber $$$0$$$, take the corridor leading to chamber $$$3$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$2$$$.\nIf you ever reach chamber $$$2$$$, take the corridor leading to chamber $$$3$$$. However, if that corridor is blocked, then take the corridor leading to chamber $$$1$$$.\nDon't bother about chamber $$$4$$$; according to this escape plan you cannot possibly reach it.\nBenjamas will reach one of the exit chambers no later than after $$$14$$$ units of time. Therefore,\ntravel_plan\nshould return $$$14$$$.",
    "_meta": {
      "index": 44,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/D",
      "uuid": "ps_990b7e05d980d7627b6027dc771b273de87dd70e"
    }
  },
  {
    "planning_view": {
      "title": "D. Paint By Numbers",
      "task": "Determine forced black/white cells among all solutions satisfying given black block constraints",
      "given": [
        "Row of n cells (0..n-1) partially filled with X (black), _ (white), or . (unknown)",
        "Sequence c of k integers representing lengths of consecutive black blocks",
        "At least one valid solution exists"
      ],
      "goal": "Mark cells as always-X, always-_, or ambiguous",
      "key_rules": [
        "Black cells form exactly k consecutive blocks",
        "Block lengths must match given sequence c exactly",
        "Pre-colored cells must be respected in all solutions"
      ],
      "target": {
        "1": {
          "points": 7,
          "req": "n ≤ 20, k = 1, empty puzzle (only '.' characters)"
        },
        "2": {
          "points": 3,
          "req": "n ≤ 20, empty puzzle (only '.' characters)"
        },
        "3": {
          "points": 22,
          "req": "n ≤ 100, empty puzzle (only '.' characters)"
        },
        "4": {
          "points": 27,
          "req": "n ≤ 100, only '.' and '_' (information only about white cells)"
        },
        "5": {
          "points": 21,
          "req": "n ≤ 100"
        },
        "6": {
          "points": 10,
          "req": "n ≤ 5,000, k ≤ 100"
        },
        "7": {
          "points": 10,
          "req": "n ≤ 200,000, k ≤ 100"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Paint By Numbers",
      "contest": "IOI 2016 day 2",
      "one_line": "Determine forced black/white cells among all solutions satisfying given black block constraints",
      "given": [
        "Row of n cells (0..n-1) partially filled with X (black), _ (white), or . (unknown)",
        "Sequence c of k integers representing lengths of consecutive black blocks",
        "At least one valid solution exists"
      ],
      "goal": "Mark cells as always-X, always-_, or ambiguous",
      "mechanism": "Valid solutions must have exactly k consecutive black blocks with lengths matching c, while respecting pre-colored cells",
      "success_condition": "Output string with X/ _/? for definitely black/white/ambiguous cells",
      "constraints": {
        "critical": [
          "Black cells form exactly k consecutive blocks",
          "Block lengths must match given sequence c exactly",
          "Pre-colored cells must be respected in all solutions"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "n ≤ 20, k = 1, empty puzzle (only '.' characters)"
          },
          "2": {
            "points": 3,
            "req": "n ≤ 20, empty puzzle (only '.' characters)"
          },
          "3": {
            "points": 22,
            "req": "n ≤ 100, empty puzzle (only '.' characters)"
          },
          "4": {
            "points": 27,
            "req": "n ≤ 100, only '.' and '_' (information only about white cells)"
          },
          "5": {
            "points": 21,
            "req": "n ≤ 100"
          },
          "6": {
            "points": 10,
            "req": "n ≤ 5,000, k ≤ 100"
          },
          "7": {
            "points": 10,
            "req": "n ≤ 200,000, k ≤ 100"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Paint By Numbers",
        "contest": "IOI 2016 day 2",
        "one_line": "Determine forced black/white cells among all solutions satisfying given black block constraints"
      },
      "problem": {
        "given": [
          "Row of n cells (0..n-1) partially filled with X (black), _ (white), or . (unknown)",
          "Sequence c of k integers representing lengths of consecutive black blocks",
          "At least one valid solution exists"
        ],
        "goal": "Mark cells as always-X, always-_, or ambiguous",
        "mechanism": "Valid solutions must have exactly k consecutive black blocks with lengths matching c, while respecting pre-colored cells",
        "success_condition": "Output string with X/ _/? for definitely black/white/ambiguous cells"
      },
      "constraints": {
        "critical": [
          "Black cells form exactly k consecutive blocks",
          "Block lengths must match given sequence c exactly",
          "Pre-colored cells must be respected in all solutions"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "n ≤ 20, k = 1, empty puzzle (only '.' characters)"
          },
          "2": {
            "points": 3,
            "req": "n ≤ 20, empty puzzle (only '.' characters)"
          },
          "3": {
            "points": 22,
            "req": "n ≤ 100, empty puzzle (only '.' characters)"
          },
          "4": {
            "points": 27,
            "req": "n ≤ 100, only '.' and '_' (information only about white cells)"
          },
          "5": {
            "points": 21,
            "req": "n ≤ 100"
          },
          "6": {
            "points": 10,
            "req": "n ≤ 5,000, k ≤ 100"
          },
          "7": {
            "points": 10,
            "req": "n ≤ 200,000, k ≤ 100"
          }
        }
      },
      "implementation": {
        "function_to_write": "string solve_puzzle(string s, int[] c)",
        "available_api": {
          "solve_puzzle": {
            "signature": "string solve_puzzle(string s, int[] c)",
            "params": "s: string of length n with characters 'X', '_', '.'; c: array of k integers (clues)",
            "returns": "string of length n with characters 'X', '_', '?'",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Return 'X' for cells black in all solutions",
          "Return '_' for cells white in all solutions",
          "Return '?' for cells that vary across solutions",
          "Must handle n up to 200,000 efficiently"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "..........\n2 3 4",
          "output": "??X???XX??"
        }
      ],
      "original_statement": "Paint By Numbers is a well-known puzzle game. We consider a simple one-dimensional version of this puzzle. In this puzzle, the player is given a row of $$$n$$$ cells. The cells are numbered $$$0$$$ through $$$n - 1$$$ from the left to the right. The player has to paint each cell black or white. We use '\nX\n' to denote black cells and '\n_\n' to denote white cells.\nThe player is given a sequence $$$c = [c_0, \\ldots, c_{k - 1}]$$$ of $$$k$$$ positive integers: the\nclues\n. He has to paint the cells in a way such that the black cells in the row form exactly $$$k$$$ blocks of consecutive cells. Moreover, the number of black cells in the $$$i$$$-th block ($$$0$$$-based) from the left should be equal to $$$c_i$$$. For example, if the clues are $$$c = [3, 4]$$$, the solved puzzle must have exactly two blocks of consecutive black cells: one of length 3 and then another of length 4. Hence, if $$$n = 10$$$ and $$$c = [3, 4]$$$, one solution satisfying the clues is \"\n_XXX__XXXX\n\". Note that \"\nXXXX_XXX__\n\" does not satisfy the clues because the blocks of black cells are not in the correct order. Also, \"\n__XXXXXXX_\n\" does not satisfy the clues because there is a single block of black cells, not two separate blocks.\nYou are given a partially solved Paint By Numbers puzzle. That is, you know $$$n$$$ and $$$c$$$, and additionally you know that some cells must be black and some cells must be white. Your task is to deduce additional information about the cells.\nSpecifically, a\nvalid solution\nis one that satisfies the clues, and also agrees with the colors of the known cells. Your program should find cells that are painted black in every valid solution, and cells that are painted white in every valid solution.\nYou may assume that the input is such that there is at least one valid solution.\nImplementation details\nYou should implement the following function (method):\nstring solve_puzzle(string s, int[] c)\n.\ns\n: string of length $$$n$$$. For each $$$i$$$ ($$$0 \\leq i \\leq n - 1$$$) character $$$i$$$ is:\n'\nX\n', if cell $$$i$$$ must be black,\n'\n_\n', if cell $$$i$$$ must be white,\n'\n.\n', if there is no information about cell $$$i$$$.\nc\n: array of length $$$k$$$ containing clues, as defined above,\nthe function should return a string of length $$$n$$$. For each $$$i$$$ $$$(0 \\le i \\le n - 1)$$$ character $$$i$$$ of the output string should be:\n'\nX\n', if cell $$$i$$$ is black in every valid solution,\n'\n_\n', if cell $$$i$$$ is white in every valid solution,\n'\n?\n', otherwise (i.e., if there exist two valid solutions such that cell $$$i$$$ is black in one of them and white in the other one).\nThe ASCII codes of characters used in this problem are:\n'\nX\n': 88,\n'\n_\n': 95,\n'\n.\n': 46,\n'\n?\n': 63.\nPlease use the provided template files for details of implementation in your programming language.\nInput\nThe sample grader reads the input in the following format:\nline 1: string $$$s$$$,\nline 2: integer $$$k$$$ followed by $$$k$$$ integers $$$c_0, \\ldots, c_{k - 1}$$$.\nOutput\nOne string— the return value of function.\nScoring\nIn all subtasks $$$1 \\le k \\le n$$$, and $$$1\\le c_i\\le n$$$ for each $$$0 \\le i \\le k - 1$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n7\n$$$n\\leq 20$$$, $$$k = 1$$$, $$$s$$$ contains only '\n.\n' (empty puzzle)\n2\n3\n$$$n\\leq 20$$$, $$$s$$$ contains only '\n.\n3\n22\n$$$n\\leq 100$$$, $$$s$$$ contains only '\n.\n'\n4\n27\n$$$n\\leq 100$$$, $$$s$$$ contains only '\n.\n' and '\n_\n' (information only about white cells)\n5\n21\n$$$n\\leq 100$$$\n6\n10\n$$$n\\leq 5\\,000$$$, $$$k\\leq 100$$$\n7\n10\n$$$n\\leq 200\\,000$$$, $$$k\\leq 100$$$\nExamples\nNote\nExample 1\nsolve_puzzle(\"..........\", [3, 4])\nThese are all possible valid solutions of the puzzle:\n\"\nXXX_XXXX__\n\",\n\"\nXXX__XXXX_\n\",\n\"\nXXX___XXXX\n\",\n\"\n_XXX_XXXX_\n\",\n\"\n_XXX__XXXX\n\",\n\"\n__XXX_XXXX\n\".\nOne can observe that the cells with (0-based) indices 2, 6, and 7 are black in each valid solution. Each of the other cells can be, but does not have to be black. Hence, the correct answer is \"\n??X???XX??\n\".\nExample 2\nsolve_puzzle(\"........\", [3, 4])\nIn this example the entire solution is uniquely determined and the correct answer is \"\nXXX_XXXX\n\".\nExample 3\nsolve_puzzle(\"..._._....\", [3])\nIn this example we can deduce that cell 4 must be white as well— there is no way to fit three consecutive black cells between the white cells at indices 3 and 5. Hence, the correct answer is \"\n???___????\n\".\nExample 4\nsolve_puzzle(\".X........\", [3])\nThere are only two valid solutions that match the above description:\n\"\nXXX_______\n\",\n\"\n_XXX______\n\".\nThus, the correct answer is \"\n?XX?______\n\"."
    },
    "original": "Paint By Numbers is a well-known puzzle game. We consider a simple one-dimensional version of this puzzle. In this puzzle, the player is given a row of $$$n$$$ cells. The cells are numbered $$$0$$$ through $$$n - 1$$$ from the left to the right. The player has to paint each cell black or white. We use '\nX\n' to denote black cells and '\n_\n' to denote white cells.\nThe player is given a sequence $$$c = [c_0, \\ldots, c_{k - 1}]$$$ of $$$k$$$ positive integers: the\nclues\n. He has to paint the cells in a way such that the black cells in the row form exactly $$$k$$$ blocks of consecutive cells. Moreover, the number of black cells in the $$$i$$$-th block ($$$0$$$-based) from the left should be equal to $$$c_i$$$. For example, if the clues are $$$c = [3, 4]$$$, the solved puzzle must have exactly two blocks of consecutive black cells: one of length 3 and then another of length 4. Hence, if $$$n = 10$$$ and $$$c = [3, 4]$$$, one solution satisfying the clues is \"\n_XXX__XXXX\n\". Note that \"\nXXXX_XXX__\n\" does not satisfy the clues because the blocks of black cells are not in the correct order. Also, \"\n__XXXXXXX_\n\" does not satisfy the clues because there is a single block of black cells, not two separate blocks.\nYou are given a partially solved Paint By Numbers puzzle. That is, you know $$$n$$$ and $$$c$$$, and additionally you know that some cells must be black and some cells must be white. Your task is to deduce additional information about the cells.\nSpecifically, a\nvalid solution\nis one that satisfies the clues, and also agrees with the colors of the known cells. Your program should find cells that are painted black in every valid solution, and cells that are painted white in every valid solution.\nYou may assume that the input is such that there is at least one valid solution.\nImplementation details\nYou should implement the following function (method):\nstring solve_puzzle(string s, int[] c)\n.\ns\n: string of length $$$n$$$. For each $$$i$$$ ($$$0 \\leq i \\leq n - 1$$$) character $$$i$$$ is:\n'\nX\n', if cell $$$i$$$ must be black,\n'\n_\n', if cell $$$i$$$ must be white,\n'\n.\n', if there is no information about cell $$$i$$$.\nc\n: array of length $$$k$$$ containing clues, as defined above,\nthe function should return a string of length $$$n$$$. For each $$$i$$$ $$$(0 \\le i \\le n - 1)$$$ character $$$i$$$ of the output string should be:\n'\nX\n', if cell $$$i$$$ is black in every valid solution,\n'\n_\n', if cell $$$i$$$ is white in every valid solution,\n'\n?\n', otherwise (i.e., if there exist two valid solutions such that cell $$$i$$$ is black in one of them and white in the other one).\nThe ASCII codes of characters used in this problem are:\n'\nX\n': 88,\n'\n_\n': 95,\n'\n.\n': 46,\n'\n?\n': 63.\nPlease use the provided template files for details of implementation in your programming language.\nInput\nThe sample grader reads the input in the following format:\nline 1: string $$$s$$$,\nline 2: integer $$$k$$$ followed by $$$k$$$ integers $$$c_0, \\ldots, c_{k - 1}$$$.\nOutput\nOne string— the return value of function.\nScoring\nIn all subtasks $$$1 \\le k \\le n$$$, and $$$1\\le c_i\\le n$$$ for each $$$0 \\le i \\le k - 1$$$.\nSubtask\nPoints\nAdditional Input Constraints\n1\n7\n$$$n\\leq 20$$$, $$$k = 1$$$, $$$s$$$ contains only '\n.\n' (empty puzzle)\n2\n3\n$$$n\\leq 20$$$, $$$s$$$ contains only '\n.\n3\n22\n$$$n\\leq 100$$$, $$$s$$$ contains only '\n.\n'\n4\n27\n$$$n\\leq 100$$$, $$$s$$$ contains only '\n.\n' and '\n_\n' (information only about white cells)\n5\n21\n$$$n\\leq 100$$$\n6\n10\n$$$n\\leq 5\\,000$$$, $$$k\\leq 100$$$\n7\n10\n$$$n\\leq 200\\,000$$$, $$$k\\leq 100$$$\nExamples\nNote\nExample 1\nsolve_puzzle(\"..........\", [3, 4])\nThese are all possible valid solutions of the puzzle:\n\"\nXXX_XXXX__\n\",\n\"\nXXX__XXXX_\n\",\n\"\nXXX___XXXX\n\",\n\"\n_XXX_XXXX_\n\",\n\"\n_XXX__XXXX\n\",\n\"\n__XXX_XXXX\n\".\nOne can observe that the cells with (0-based) indices 2, 6, and 7 are black in each valid solution. Each of the other cells can be, but does not have to be black. Hence, the correct answer is \"\n??X???XX??\n\".\nExample 2\nsolve_puzzle(\"........\", [3, 4])\nIn this example the entire solution is uniquely determined and the correct answer is \"\nXXX_XXXX\n\".\nExample 3\nsolve_puzzle(\"..._._....\", [3])\nIn this example we can deduce that cell 4 must be white as well— there is no way to fit three consecutive black cells between the white cells at indices 3 and 5. Hence, the correct answer is \"\n???___????\n\".\nExample 4\nsolve_puzzle(\".X........\", [3])\nThere are only two valid solutions that match the above description:\n\"\nXXX_______\n\",\n\"\n_XXX______\n\".\nThus, the correct answer is \"\n?XX?______\n\".",
    "_meta": {
      "index": 45,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/D",
      "uuid": "ps_fbc05c3e4d297245f9085845c30866a6b303bcd3"
    }
  },
  {
    "planning_view": {
      "title": "F. Meetings",
      "task": "Minimize meeting cost for range queries on mountain heights (N, Q ≤ 750,000)",
      "given": [
        "N mountains in a row with heights H_i",
        "Q meetings with ranges [L_j, R_j]",
        "Each meeting requires choosing meeting place x in [L_j, R_j]"
      ],
      "goal": "For each meeting, find the minimum possible total cost",
      "key_rules": [
        "Meeting place x must be within [L_j, R_j]",
        "Cost includes all mountains from L_j to R_j",
        "Heights are positive integers up to 10^9",
        "All meetings are independent"
      ],
      "target": {
        "1": {
          "points": 4,
          "req": "N ≤ 3,000, Q ≤ 10"
        },
        "2": {
          "points": 15,
          "req": "N ≤ 5,000, Q ≤ 5,000"
        },
        "3": {
          "points": 17,
          "req": "N ≤ 100,000, Q ≤ 100,000, H_i ≤ 2"
        },
        "4": {
          "points": 24,
          "req": "N ≤ 100,000, Q ≤ 100,000, H_i ≤ 20"
        },
        "5": {
          "points": 40,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Meetings",
      "contest": "IOI 2018 day 2",
      "one_line": "Minimize meeting cost for range queries on mountain heights (N, Q ≤ 750,000)",
      "given": [
        "N mountains in a row with heights H_i",
        "Q meetings with ranges [L_j, R_j]",
        "Each meeting requires choosing meeting place x in [L_j, R_j]"
      ],
      "goal": "For each meeting, find the minimum possible total cost",
      "mechanism": "Cost for participant from mountain y is max height between x and y; total cost is sum over all participants",
      "success_condition": "Return array C where C[j] is the minimum cost for meeting j",
      "constraints": {
        "critical": [
          "Meeting place x must be within [L_j, R_j]",
          "Cost includes all mountains from L_j to R_j",
          "Heights are positive integers up to 10^9",
          "All meetings are independent"
        ],
        "subtasks": {
          "1": {
            "points": 4,
            "req": "N ≤ 3,000, Q ≤ 10"
          },
          "2": {
            "points": 15,
            "req": "N ≤ 5,000, Q ≤ 5,000"
          },
          "3": {
            "points": 17,
            "req": "N ≤ 100,000, Q ≤ 100,000, H_i ≤ 2"
          },
          "4": {
            "points": 24,
            "req": "N ≤ 100,000, Q ≤ 100,000, H_i ≤ 20"
          },
          "5": {
            "points": 40,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "7 seconds",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Meetings",
        "contest": "IOI 2018 day 2",
        "one_line": "Minimize meeting cost for range queries on mountain heights (N, Q ≤ 750,000)"
      },
      "problem": {
        "given": [
          "N mountains in a row with heights H_i",
          "Q meetings with ranges [L_j, R_j]",
          "Each meeting requires choosing meeting place x in [L_j, R_j]"
        ],
        "goal": "For each meeting, find the minimum possible total cost",
        "mechanism": "Cost for participant from mountain y is max height between x and y; total cost is sum over all participants",
        "success_condition": "Return array C where C[j] is the minimum cost for meeting j"
      },
      "constraints": {
        "critical": [
          "Meeting place x must be within [L_j, R_j]",
          "Cost includes all mountains from L_j to R_j",
          "Heights are positive integers up to 10^9",
          "All meetings are independent"
        ],
        "subtasks": {
          "1": {
            "points": 4,
            "req": "N ≤ 3,000, Q ≤ 10"
          },
          "2": {
            "points": 15,
            "req": "N ≤ 5,000, Q ≤ 5,000"
          },
          "3": {
            "points": 17,
            "req": "N ≤ 100,000, Q ≤ 100,000, H_i ≤ 2"
          },
          "4": {
            "points": 24,
            "req": "N ≤ 100,000, Q ≤ 100,000, H_i ≤ 20"
          },
          "5": {
            "points": 40,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64[] minimum_costs(int[] H, int[] L, int[] R)",
        "available_api": {
          "minimum_costs": {
            "signature": "int64[] minimum_costs(int[] H, int[] L, int[] R)",
            "params": "H: array of length N with mountain heights, L: array of length Q with left endpoints, R: array of length Q with right endpoints",
            "returns": "array of length Q with minimum costs for each meeting",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Use 64-bit integers for cost calculations",
          "Arrays are 0-indexed",
          "Must handle up to N=750,000 and Q=750,000"
        ]
      },
      "limits": {
        "time": "7 seconds",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "4 2\n2 4 3 5\n0 2\n1 3",
          "output": "10\n12"
        }
      ],
      "original_statement": "There are $$$N$$$ mountains lying in a horizontal row, numbered from $$$0$$$ through $$$N-1$$$ from left to right. The height of the mountain $$$i$$$ is $$$H_i$$$ ($$$0\\le i\\le N-1$$$). Exactly one person lives on the top of each mountain.\nYou are going to hold $$$Q$$$ meetings, numbered from $$$0$$$ through $$$Q-1$$$. The meeting $$$j$$$ ($$$0 \\le j \\le Q-1$$$) will be attended by all the people living on the mountains from $$$L_j$$$ to $$$R_j$$$, inclusive ($$$0\\le L_j \\le R_j \\le N-1$$$). For this meeting, you must select a mountain $$$x$$$ as the meeting place ($$$L_j \\le x \\le R_j$$$). The cost of this meeting, based on your selection, is then calculated as follows:\nThe cost of the participant from each mountain $$$y$$$ ($$$L_j \\le y \\le R_j$$$) is the maximum height of the mountains between the mountains $$$x$$$ and $$$y$$$, inclusive. In particular, the cost of the participant from the mountain $$$x$$$ is $$$H_x$$$, the height of the mountain $$$x$$$.\nThe cost of the meeting is the sum of the costs of all participants.\nFor each meeting, you want to find the minimum possible cost of holding it.\nNote that all participants go back to their own mountains after each meeting; so the cost of a meeting is not influenced by the previous meetings.\nImplementation details\nYou should implement the following function:\nint64[] minimum_costs(int[] H, int[] L, int[] R)\n$$$H$$$: an array of length $$$N$$$, representing the heights of the mountains\n$$$L$$$ and $$$R$$$: arrays of length $$$Q$$$, representing the range of the participants in the meetings.\nThis function should return an array $$$C$$$ of length $$$Q$$$. The value of $$$C_j$$$ ($$$0\\le j\\le Q-1$$$) must be the minimum possible cost of holding the meeting $$$j$$$.\nNote that the values of $$$N$$$ and $$$Q$$$ are the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N\\ Q$$$ ($$$1\\le N \\le 750\\,000$$$, $$$1\\le Q \\le 750\\,000$$$)\nline $$$2$$$: $$$H_0\\ H_1\\ldots H_{N-1}$$$ ($$$1\\le H_i \\le 10^9$$$)\nline $$$3 + j$$$ ($$$0\\le j\\le Q-1$$$): $$$L_j\\ R_j$$$ ($$$0 \\le L_j \\le R_j \\le N -1$$$, $$$(L_j, R_j) \\ne (L_k, R_k) (0\\le j < k \\le Q-1)$$$\nOutput\nThe sample grader prints the return value of\nminimum_costs\nin the following format:\nline $$$1 + j$$$ ($$$0 \\le j \\le Q-1$$$): $$$C_j$$$\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$Q$$$\n$$$H_i$$$\n1\n4\n$$$N \\le 3\\,000$$$\n$$$Q\\le 10$$$\n—\n2\n15\n$$$N \\le 5\\,000$$$\n$$$Q\\le 5\\,000$$$\n—\n3\n17\n$$$N \\le 100\\,000$$$\n$$$Q\\le 100\\,000$$$\n$$$H_i \\le 2$$$\n4\n24\n$$$N \\le 100\\,000$$$\n$$$Q\\le 100\\,000$$$\n$$$H_i \\le 20$$$\n5\n40\n—\n—\n—\nExamples\nNote\nExample\nLet $$$N=4$$$, $$$H=[2,4,3,5]$$$, $$$Q=2$$$, and $$$R=[2,3]$$$.\nThe grader calls\nminimum_costs([2, 4, 3, 5], [0, 1], [2, 3])\n.\nThe meeting $$$j=0$$$ has $$$L_j=0$$$ and $$$R_j=2$$$, so will be attended by the people living on the mountains $$$0$$$, $$$1$$$, and $$$2$$$. If the mountain $$$0$$$ is chosen as the meeting place, the cost of the meeting $$$0$$$ is calculated as follows:\nThe cost of the participant from the mountain $$$0$$$ is $$$\\max(H_0)=2$$$.\nThe cost of the participant from the mountain $$$1$$$ is $$$\\max(H_0, H_1)=4$$$.\nThe cost of the participant from the mountain $$$2$$$ is $$$\\max(H_0, H_1, H_2)=4$$$.\nTherefore, the cost of the meeting $$$0$$$ is $$$2 + 4 + 4 = 10$$$.\nIt is impossible to hold the meeting $$$0$$$ at a lower cost, so the minimum cost of the meeting $$$0$$$ is $$$10$$$.\nThe meeting $$$j=1$$$ has $$$L_j = 1$$$ and $$$R_j=3$$$, so will be attended by the people living on the mountains $$$1$$$, $$$2$$$, and $$$3$$$. If the mountain $$$2$$$ is chosen as the meeting place, the cost of the meeting $$$1$$$ is calculated as follows:\nThe cost of the participant from the mountain $$$1$$$ is $$$\\max(H_1, H_2)=4$$$.\nThe cost of the participant from the mountain $$$2$$$ is $$$\\max(H_2)=3$$$.\nThe cost of the participant from the mountain $$$3$$$ is $$$\\max(H_2, H_3)=5$$$.\nTherefore, the cost of the meeting $$$1$$$ is $$$4 + 3 + 5 = 12$$$.\nIt is impossible to hold the meeting $$$1$$$ at a lower cost, so the minimum cost of the meeting $$$1$$$ is $$$12$$$.\nThe files sample-01-in.txt and sample-01-out.txt in the zipped attachment package correspond to this example. Other sample inputs/outputs are also available in the package."
    },
    "original": "There are $$$N$$$ mountains lying in a horizontal row, numbered from $$$0$$$ through $$$N-1$$$ from left to right. The height of the mountain $$$i$$$ is $$$H_i$$$ ($$$0\\le i\\le N-1$$$). Exactly one person lives on the top of each mountain.\nYou are going to hold $$$Q$$$ meetings, numbered from $$$0$$$ through $$$Q-1$$$. The meeting $$$j$$$ ($$$0 \\le j \\le Q-1$$$) will be attended by all the people living on the mountains from $$$L_j$$$ to $$$R_j$$$, inclusive ($$$0\\le L_j \\le R_j \\le N-1$$$). For this meeting, you must select a mountain $$$x$$$ as the meeting place ($$$L_j \\le x \\le R_j$$$). The cost of this meeting, based on your selection, is then calculated as follows:\nThe cost of the participant from each mountain $$$y$$$ ($$$L_j \\le y \\le R_j$$$) is the maximum height of the mountains between the mountains $$$x$$$ and $$$y$$$, inclusive. In particular, the cost of the participant from the mountain $$$x$$$ is $$$H_x$$$, the height of the mountain $$$x$$$.\nThe cost of the meeting is the sum of the costs of all participants.\nFor each meeting, you want to find the minimum possible cost of holding it.\nNote that all participants go back to their own mountains after each meeting; so the cost of a meeting is not influenced by the previous meetings.\nImplementation details\nYou should implement the following function:\nint64[] minimum_costs(int[] H, int[] L, int[] R)\n$$$H$$$: an array of length $$$N$$$, representing the heights of the mountains\n$$$L$$$ and $$$R$$$: arrays of length $$$Q$$$, representing the range of the participants in the meetings.\nThis function should return an array $$$C$$$ of length $$$Q$$$. The value of $$$C_j$$$ ($$$0\\le j\\le Q-1$$$) must be the minimum possible cost of holding the meeting $$$j$$$.\nNote that the values of $$$N$$$ and $$$Q$$$ are the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N\\ Q$$$ ($$$1\\le N \\le 750\\,000$$$, $$$1\\le Q \\le 750\\,000$$$)\nline $$$2$$$: $$$H_0\\ H_1\\ldots H_{N-1}$$$ ($$$1\\le H_i \\le 10^9$$$)\nline $$$3 + j$$$ ($$$0\\le j\\le Q-1$$$): $$$L_j\\ R_j$$$ ($$$0 \\le L_j \\le R_j \\le N -1$$$, $$$(L_j, R_j) \\ne (L_k, R_k) (0\\le j < k \\le Q-1)$$$\nOutput\nThe sample grader prints the return value of\nminimum_costs\nin the following format:\nline $$$1 + j$$$ ($$$0 \\le j \\le Q-1$$$): $$$C_j$$$\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$Q$$$\n$$$H_i$$$\n1\n4\n$$$N \\le 3\\,000$$$\n$$$Q\\le 10$$$\n—\n2\n15\n$$$N \\le 5\\,000$$$\n$$$Q\\le 5\\,000$$$\n—\n3\n17\n$$$N \\le 100\\,000$$$\n$$$Q\\le 100\\,000$$$\n$$$H_i \\le 2$$$\n4\n24\n$$$N \\le 100\\,000$$$\n$$$Q\\le 100\\,000$$$\n$$$H_i \\le 20$$$\n5\n40\n—\n—\n—\nExamples\nNote\nExample\nLet $$$N=4$$$, $$$H=[2,4,3,5]$$$, $$$Q=2$$$, and $$$R=[2,3]$$$.\nThe grader calls\nminimum_costs([2, 4, 3, 5], [0, 1], [2, 3])\n.\nThe meeting $$$j=0$$$ has $$$L_j=0$$$ and $$$R_j=2$$$, so will be attended by the people living on the mountains $$$0$$$, $$$1$$$, and $$$2$$$. If the mountain $$$0$$$ is chosen as the meeting place, the cost of the meeting $$$0$$$ is calculated as follows:\nThe cost of the participant from the mountain $$$0$$$ is $$$\\max(H_0)=2$$$.\nThe cost of the participant from the mountain $$$1$$$ is $$$\\max(H_0, H_1)=4$$$.\nThe cost of the participant from the mountain $$$2$$$ is $$$\\max(H_0, H_1, H_2)=4$$$.\nTherefore, the cost of the meeting $$$0$$$ is $$$2 + 4 + 4 = 10$$$.\nIt is impossible to hold the meeting $$$0$$$ at a lower cost, so the minimum cost of the meeting $$$0$$$ is $$$10$$$.\nThe meeting $$$j=1$$$ has $$$L_j = 1$$$ and $$$R_j=3$$$, so will be attended by the people living on the mountains $$$1$$$, $$$2$$$, and $$$3$$$. If the mountain $$$2$$$ is chosen as the meeting place, the cost of the meeting $$$1$$$ is calculated as follows:\nThe cost of the participant from the mountain $$$1$$$ is $$$\\max(H_1, H_2)=4$$$.\nThe cost of the participant from the mountain $$$2$$$ is $$$\\max(H_2)=3$$$.\nThe cost of the participant from the mountain $$$3$$$ is $$$\\max(H_2, H_3)=5$$$.\nTherefore, the cost of the meeting $$$1$$$ is $$$4 + 3 + 5 = 12$$$.\nIt is impossible to hold the meeting $$$1$$$ at a lower cost, so the minimum cost of the meeting $$$1$$$ is $$$12$$$.\nThe files sample-01-in.txt and sample-01-out.txt in the zipped attachment package correspond to this example. Other sample inputs/outputs are also available in the package.",
    "_meta": {
      "index": 46,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/F",
      "uuid": "ps_c8eef2f0f80900dc4e482aade55b77082130e7fd"
    }
  },
  {
    "planning_view": {
      "title": "C. Ricehub",
      "task": "Place hub along road to maximize rice transport within budget B",
      "given": [
        "R rice fields along a straight road (coordinates 1 to L)",
        "Fields sorted by coordinate, multiple fields can share same coordinate",
        "Each field produces 1 truckload of rice",
        "Transport cost = distance from field to hub",
        "Budget B for total transportation cost"
      ],
      "goal": "Find hub location that maximizes rice transported within budget B",
      "key_rules": [
        "Hub must be at integer coordinate between 1 and L",
        "All R fields sorted by coordinate X[i]",
        "Total transport cost ≤ B"
      ],
      "target": {
        "1": {
          "points": 17,
          "req": "R ≤ 100, L ≤ 100, B ≤ 10,000, no duplicate coordinates"
        },
        "2": {
          "points": 25,
          "req": "R ≤ 500, L ≤ 10,000, B ≤ 1,000,000"
        },
        "3": {
          "points": 26,
          "req": "R ≤ 5,000, L ≤ 1,000,000, B ≤ 2×10^9"
        },
        "4": {
          "points": 32,
          "req": "R ≤ 100,000, L ≤ 10^9, B ≤ 2×10^15"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Ricehub",
      "contest": "IOI 2011 day 1",
      "one_line": "Place hub along road to maximize rice transport within budget B",
      "given": [
        "R rice fields along a straight road (coordinates 1 to L)",
        "Fields sorted by coordinate, multiple fields can share same coordinate",
        "Each field produces 1 truckload of rice",
        "Transport cost = distance from field to hub",
        "Budget B for total transportation cost"
      ],
      "goal": "Find hub location that maximizes rice transported within budget B",
      "mechanism": "Choose integer hub coordinate; calculate total transport cost as sum of distances from selected fields to hub",
      "success_condition": "Maximize number of fields whose rice can be transported to hub without exceeding budget",
      "constraints": {
        "critical": [
          "Hub must be at integer coordinate between 1 and L",
          "All R fields sorted by coordinate X[i]",
          "Total transport cost ≤ B"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "R ≤ 100, L ≤ 100, B ≤ 10,000, no duplicate coordinates"
          },
          "2": {
            "points": 25,
            "req": "R ≤ 500, L ≤ 10,000, B ≤ 1,000,000"
          },
          "3": {
            "points": 26,
            "req": "R ≤ 5,000, L ≤ 1,000,000, B ≤ 2×10^9"
          },
          "4": {
            "points": 32,
            "req": "R ≤ 100,000, L ≤ 10^9, B ≤ 2×10^15"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Ricehub",
        "contest": "IOI 2011 day 1",
        "one_line": "Place hub along road to maximize rice transport within budget B"
      },
      "problem": {
        "given": [
          "R rice fields along a straight road (coordinates 1 to L)",
          "Fields sorted by coordinate, multiple fields can share same coordinate",
          "Each field produces 1 truckload of rice",
          "Transport cost = distance from field to hub",
          "Budget B for total transportation cost"
        ],
        "goal": "Find hub location that maximizes rice transported within budget B",
        "mechanism": "Choose integer hub coordinate; calculate total transport cost as sum of distances from selected fields to hub",
        "success_condition": "Maximize number of fields whose rice can be transported to hub without exceeding budget"
      },
      "constraints": {
        "critical": [
          "Hub must be at integer coordinate between 1 and L",
          "All R fields sorted by coordinate X[i]",
          "Total transport cost ≤ B"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "R ≤ 100, L ≤ 100, B ≤ 10,000, no duplicate coordinates"
          },
          "2": {
            "points": 25,
            "req": "R ≤ 500, L ≤ 10,000, B ≤ 1,000,000"
          },
          "3": {
            "points": 26,
            "req": "R ≤ 5,000, L ≤ 1,000,000, B ≤ 2×10^9"
          },
          "4": {
            "points": 32,
            "req": "R ≤ 100,000, L ≤ 10^9, B ≤ 2×10^15"
          }
        }
      },
      "implementation": {
        "function_to_write": "int besthub(int R, int L, int X[], long long B)",
        "available_api": {},
        "requirements": [
          "Use 64-bit integers for budget calculations",
          "X array is 0-indexed with R elements",
          "Array X is pre-sorted in non-decreasing order",
          "Return maximum number of truckloads possible"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "5 20 6\n1\n2\n10\n12\n14",
          "output": "3",
          "explanation": "Hub at 10-14 can collect from 3 fields costing ≤6"
        }
      ],
      "original_statement": "In the countryside, you can find a long straight road known as the Rice Way. Along this road there are $$$R$$$ rice fields. Each field is located at an integer coordinate between $$$1$$$ and $$$L$$$, inclusive. The rice fields will be presented in non-decreasing order of their coordinates. Formally, for $$$0 \\le i < R$$$, rice field $$$i$$$ is at coordinate $$$X[i]$$$. You may assume that $$$1 \\le X[0] \\le \\ldots \\le X[R-1] \\le L$$$.\nPlease note that multiple rice fields may share the same coordinate.\nWe plan to construct a single rice hub as a common place to store as much of the harvest as possible. As with the rice fields, the hub has to be at an integer coordinate between $$$1$$$ and $$$L$$$, inclusive.\nThe rice hub can be at any location, including one that already contains one or more rice fields. Each rice field produces exactly $$$1$$$ truckload of rice every harvest season. To transport the rice to the hub, the city has to hire a truck driver. The driver charges $$$1$$$ Baht to transport a truckload of rice per unit of distance towards the hub. In other words, the cost of transporting rice from a given field to the rice hub is numerically equal to the difference between their coordinates.\nUnfortunately, our budget for this season is tight: we may only spend at most $$$B$$$ Baht on transportation. Your task is to help us strategically place the hub to gather as much rice as possible.\nWrite a procedure\nbesthub(R,L,X,B)\nthat takes the following parameters:\n$$$R$$$— the number of rice fields. The fields are numbered $$$0$$$ through $$$R-1$$$.\n$$$L$$$— the maximum coordinate.\n$$$X$$$— a one-dimensional array of integers sorted from smallest to largest. For each $$$i$$$ $$$0 \\le i < R$$$, field $$$i$$$ is located at $$$X[i]$$$.\n$$$B$$$— the budget.\nYour procedure must find an optimal location of the hub and return the maximum number of truckloads of rice that can be transported to the hub within the budget. Note that the total cost of transporting the rice can be very large. The budget is given as a 64-bit integer, and we recommend that you use 64-bit integers in your computation. In C/C++, use the type long long.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$R$$$, $$$L$$$, and $$$B$$$.\nLines $$$2$$$ to $$$R+1$$$: locations of rice fields; i.e., line $$$i+2$$$ contains $$$X[i]$$$, for $$$0 \\le i < R$$$.\nScoring\nSubtask\nPoints\n$$$R$$$\n$$$L$$$\n$$$B$$$\nAdditional Input Constraints\n1\n17\n$$$1 \\le R \\le 100$$$\n$$$1 \\le L \\le 100$$$\n$$$0 \\le B \\le 10\\,000$$$\nNo two rice fields share the same coordinate (only for this subtask).\n2\n25\n$$$1 \\le R \\le 500$$$\n$$$1 \\le L \\le 10\\,000$$$\n$$$0 \\le B \\le 1\\,000\\,000$$$\n—\n3\n26\n$$$1 \\le R \\le 5\\,000$$$\n$$$1 \\le L \\le 1\\,000\\,000$$$\n$$$0 \\le B \\le 2 \\cdot 10^9$$$\n—\n4\n32\n$$$1 \\le R \\le 100\\,000$$$\n$$$1 \\le L \\le 10^9$$$\n$$$0 \\le B \\le 2 \\cdot 10^{15}$$$\n—\nExample\nNote\nFor this case, there are multiple optimal locations for the hub: you can place it anywhere between locations $$$10$$$ and $$$14$$$, inclusive. The figure above shows one of these optimal locations. You will then be able to transport rice from fields at coordinates $$$10$$$, $$$12$$$, and $$$14$$$. For any optimal hub location, the total cost of this transportation will be at most $$$6$$$ Baht. Clearly, no hub location will allow us to gather rice from more than three fields, hence this solution is optimal and\nbesthub\nshould return $$$3$$$."
    },
    "original": "In the countryside, you can find a long straight road known as the Rice Way. Along this road there are $$$R$$$ rice fields. Each field is located at an integer coordinate between $$$1$$$ and $$$L$$$, inclusive. The rice fields will be presented in non-decreasing order of their coordinates. Formally, for $$$0 \\le i < R$$$, rice field $$$i$$$ is at coordinate $$$X[i]$$$. You may assume that $$$1 \\le X[0] \\le \\ldots \\le X[R-1] \\le L$$$.\nPlease note that multiple rice fields may share the same coordinate.\nWe plan to construct a single rice hub as a common place to store as much of the harvest as possible. As with the rice fields, the hub has to be at an integer coordinate between $$$1$$$ and $$$L$$$, inclusive.\nThe rice hub can be at any location, including one that already contains one or more rice fields. Each rice field produces exactly $$$1$$$ truckload of rice every harvest season. To transport the rice to the hub, the city has to hire a truck driver. The driver charges $$$1$$$ Baht to transport a truckload of rice per unit of distance towards the hub. In other words, the cost of transporting rice from a given field to the rice hub is numerically equal to the difference between their coordinates.\nUnfortunately, our budget for this season is tight: we may only spend at most $$$B$$$ Baht on transportation. Your task is to help us strategically place the hub to gather as much rice as possible.\nWrite a procedure\nbesthub(R,L,X,B)\nthat takes the following parameters:\n$$$R$$$— the number of rice fields. The fields are numbered $$$0$$$ through $$$R-1$$$.\n$$$L$$$— the maximum coordinate.\n$$$X$$$— a one-dimensional array of integers sorted from smallest to largest. For each $$$i$$$ $$$0 \\le i < R$$$, field $$$i$$$ is located at $$$X[i]$$$.\n$$$B$$$— the budget.\nYour procedure must find an optimal location of the hub and return the maximum number of truckloads of rice that can be transported to the hub within the budget. Note that the total cost of transporting the rice can be very large. The budget is given as a 64-bit integer, and we recommend that you use 64-bit integers in your computation. In C/C++, use the type long long.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$R$$$, $$$L$$$, and $$$B$$$.\nLines $$$2$$$ to $$$R+1$$$: locations of rice fields; i.e., line $$$i+2$$$ contains $$$X[i]$$$, for $$$0 \\le i < R$$$.\nScoring\nSubtask\nPoints\n$$$R$$$\n$$$L$$$\n$$$B$$$\nAdditional Input Constraints\n1\n17\n$$$1 \\le R \\le 100$$$\n$$$1 \\le L \\le 100$$$\n$$$0 \\le B \\le 10\\,000$$$\nNo two rice fields share the same coordinate (only for this subtask).\n2\n25\n$$$1 \\le R \\le 500$$$\n$$$1 \\le L \\le 10\\,000$$$\n$$$0 \\le B \\le 1\\,000\\,000$$$\n—\n3\n26\n$$$1 \\le R \\le 5\\,000$$$\n$$$1 \\le L \\le 1\\,000\\,000$$$\n$$$0 \\le B \\le 2 \\cdot 10^9$$$\n—\n4\n32\n$$$1 \\le R \\le 100\\,000$$$\n$$$1 \\le L \\le 10^9$$$\n$$$0 \\le B \\le 2 \\cdot 10^{15}$$$\n—\nExample\nNote\nFor this case, there are multiple optimal locations for the hub: you can place it anywhere between locations $$$10$$$ and $$$14$$$, inclusive. The figure above shows one of these optimal locations. You will then be able to transport rice from fields at coordinates $$$10$$$, $$$12$$$, and $$$14$$$. For any optimal hub location, the total cost of this transportation will be at most $$$6$$$ Baht. Clearly, no hub location will allow us to gather rice from more than three fields, hence this solution is optimal and\nbesthub\nshould return $$$3$$$.",
    "_meta": {
      "index": 47,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/C",
      "uuid": "ps_354465314359b21def54f4d2420d04828a529c25"
    }
  },
  {
    "planning_view": {
      "title": "E. Counting Mushrooms",
      "task": "Count species A mushrooms in ≤100,000 total machine inputs",
      "given": [
        "n mushrooms labeled 0 to n-1",
        "Mushroom 0 is species A",
        "Species B looks identical to A",
        "Machine counts adjacent different-species pairs"
      ],
      "goal": "Determine how many mushrooms are species A",
      "key_rules": [
        "Machine use limited to 20,000 calls",
        "Total mushrooms placed across all calls ≤100,000",
        "Each call must use 2+ distinct mushrooms",
        "Grader may be adaptive (answers consistent with prior calls)"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "20,000 ≥ Q > 10,010 calls"
        },
        "2": {
          "points": 25,
          "req": "10,010 ≥ Q > 904 calls"
        },
        "3": {
          "points": "100·226/Q",
          "req": "904 ≥ Q > 226 calls"
        },
        "4": {
          "points": 100,
          "req": "Q ≤ 226 calls"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Counting Mushrooms",
      "contest": "IOI 2020 day 2",
      "one_line": "Count species A mushrooms in ≤100,000 total machine inputs",
      "given": [
        "n mushrooms labeled 0 to n-1",
        "Mushroom 0 is species A",
        "Species B looks identical to A",
        "Machine counts adjacent different-species pairs"
      ],
      "goal": "Determine how many mushrooms are species A",
      "mechanism": "Call use_machine(x) with mushroom sequence; returns count of adjacent different-species pairs",
      "success_condition": "Return correct count of species A mushrooms",
      "constraints": {
        "critical": [
          "Machine use limited to 20,000 calls",
          "Total mushrooms placed across all calls ≤100,000",
          "Each call must use 2+ distinct mushrooms",
          "Grader may be adaptive (answers consistent with prior calls)"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "20,000 ≥ Q > 10,010 calls"
          },
          "2": {
            "points": 25,
            "req": "10,010 ≥ Q > 904 calls"
          },
          "3": {
            "points": "100·226/Q",
            "req": "904 ≥ Q > 226 calls"
          },
          "4": {
            "points": 100,
            "req": "Q ≤ 226 calls"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Counting Mushrooms",
        "contest": "IOI 2020 day 2",
        "one_line": "Count species A mushrooms in ≤100,000 total machine inputs"
      },
      "problem": {
        "given": [
          "n mushrooms labeled 0 to n-1",
          "Mushroom 0 is species A",
          "Species B looks identical to A",
          "Machine counts adjacent different-species pairs"
        ],
        "goal": "Determine how many mushrooms are species A",
        "mechanism": "Call use_machine(x) with mushroom sequence; returns count of adjacent different-species pairs",
        "success_condition": "Return correct count of species A mushrooms"
      },
      "constraints": {
        "critical": [
          "Machine use limited to 20,000 calls",
          "Total mushrooms placed across all calls ≤100,000",
          "Each call must use 2+ distinct mushrooms",
          "Grader may be adaptive (answers consistent with prior calls)"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "20,000 ≥ Q > 10,010 calls"
          },
          "2": {
            "points": 25,
            "req": "10,010 ≥ Q > 904 calls"
          },
          "3": {
            "points": "100·226/Q",
            "req": "904 ≥ Q > 226 calls"
          },
          "4": {
            "points": 100,
            "req": "Q ≤ 226 calls"
          }
        }
      },
      "implementation": {
        "function_to_write": "int count_mushrooms(int n)",
        "available_api": {
          "use_machine": {
            "signature": "int use_machine(int[] x)",
            "params": "x: array of 2+ distinct mushroom IDs (0 to n-1)",
            "returns": "Number of adjacent mushroom pairs with different species",
            "side_effect": "Contributes to total mushroom and call limits"
          }
        },
        "requirements": [
          "Mushroom IDs are 0-indexed (0 to n-1)",
          "Each call must use distinct mushroom IDs",
          "Array x length must be between 2 and n inclusive"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "Andrew the mushroom expert is investigating mushrooms native to Singapore.\nAs part of his research, Andrew collected $$$n$$$ mushrooms labelled $$$0$$$ to $$$n-1$$$. Each mushroom is of one of two species, which are called A and B.\nAndrew knows that\nmushroom $$$0$$$ belongs to species A\n, but as the two species look the same, he does not know the species of mushrooms $$$1$$$ to $$$n-1$$$.\nFortunately, Andrew has a machine in his lab that can help with this. To use this machine, one should place two or more mushrooms in a row inside the machine (in any order) and turn the machine on. Then, the machine calculates the number of\nadjacent\npairs of mushrooms that are of different species. For example, if you place mushrooms of species $$$[A, B, B, A]$$$ (in that order) into the machine, the result will be $$$2$$$.\nHowever, as operating the machine is very expensive, the machine can be used for a limited number of times. In addition, the total number of mushrooms placed in the machine across all its uses cannot exceed $$$100\\,000$$$. Use this machine to help Andrew count the number of mushrooms of species A collected.\nImplementation details\nYou should implement the following procedure:\nint count_mushrooms(int n)\n$$$n$$$: number of mushrooms collected by Andrew.\nThis procedure is called exactly once, and should return the number of mushrooms of species A.\nThe above procedure can make calls to the following procedure:\nint use_machine(int[] x)\n$$$x$$$: an array of length between $$$2$$$ and $$$n$$$ inclusive, describing the labels of the mushrooms placed in the machine, in order.\nThe elements of $$$x$$$ must be\ndistinct\nintegers from $$$0$$$ to $$$n-1$$$ inclusive.\nLet $$$d$$$ be the length of array $$$x$$$. Then, the procedure returns the number of different indices $$$j$$$, such that $$$0 \\leq j \\leq d-2$$$ and mushrooms $$$x[j]$$$ and $$$x[j+1]$$$ are of different species.\nThis procedure can be called at most $$$20\\,000$$$ times.\nThe total length of $$$x$$$ passed to the procedure\nuse_machine\namong all its invocations cannot exceed $$$100\\,000$$$.\nInput\nThe sample grader reads an array $$$s$$$ of integers giving the mushroom species. For all $$$0 \\leq i \\leq n-1$$$, $$$s[i] = 0$$$ means the species of mushroom $$$i$$$ is A, whereas $$$s[i] = 1$$$ means the species of mushroom $$$i$$$ is B. The sample grader reads input in the following format:\nline $$$1$$$: $$$n$$$ ($$$2 \\leq n \\leq 20\\,000$$$)\nline $$$2$$$: $$$s[0]\\ s[1] \\ldots s[n-1]$$$\nOutput\nThe output of sample grader is in the following format:\nline $$$1$$$: the return value of\ncount_mushrooms\n.\nline $$$2$$$: the number of calls to\nuse_machine\n.\nNote that the sample grader is not adaptive.\nInteraction\nIn some test cases the behavior of the grader is adaptive. This means that in these test cases the grader does not have a fixed sequence of mushroom species. Instead, the answers given by the grader may depend on the prior calls to\nuse_machine\n. Though, it is guaranteed that the grader answers in such a way that after each interaction there is at least one sequence of mushroom species consistent with all the answers given so far.\nScoring\nIf in any of the test cases, the calls to the procedure\nuse_machine\ndo not conform to the rules mentioned above, or the return value of\ncount_mushrooms\nis incorrect, the score of your solution will be $$$0$$$. Otherwise, let $$$Q$$$ be the maximum number of calls to the procedure\nuse_machine\namong all test cases. Then, the score will be calculated according to the following table:\nCondition\nScore\n$$$20\\,000 \\textless Q$$$\n0\n$$$10\\,010 \\textless Q \\le 20\\,000$$$\n10\n$$$904 \\textless Q \\le 10\\,010$$$\n25\n$$$226 \\textless Q \\le 904$$$\n$$$100 \\cdot \\frac{226}{Q}$$$\n$$$Q \\le 226$$$\n100\nNote\nExample 1\nConsider a scenario in which there are $$$3$$$ mushrooms of species $$$[A, B, B]$$$, in order. The procedure\ncount_mushrooms\nis called in the following way:\ncount_mushrooms(3)\nThis procedure may call\nuse_machine([0, 1, 2])\n, which (in this scenario) returns $$$1$$$.\nIt may then call\nuse_machine([2, 1])\n, which returns $$$0$$$.\nAt this point, there is sufficient information to conclude that there is only $$$1$$$ mushroom of species A. So, the procedure\ncount_mushrooms\nshould return $$$1$$$.\nExample 2\nConsider a case in which there are $$$4$$$ mushrooms with species $$$[A, B, A, A]$$$, in order. The procedure\ncount_mushrooms\nis called as below:\ncount_mushrooms(4)\nThis procedure may call\nuse_machine([0, 2, 1, 3])\n, which returns $$$2$$$.\nIt may then call\nuse_machine([1, 2])\n, which returns $$$1$$$.\nAt this point, there is sufficient information to conclude that there are $$$3$$$ mushrooms of species A. Therefore, the procedure\ncount_mushrooms\nshould return $$$3$$$."
    },
    "original": "Andrew the mushroom expert is investigating mushrooms native to Singapore.\nAs part of his research, Andrew collected $$$n$$$ mushrooms labelled $$$0$$$ to $$$n-1$$$. Each mushroom is of one of two species, which are called A and B.\nAndrew knows that\nmushroom $$$0$$$ belongs to species A\n, but as the two species look the same, he does not know the species of mushrooms $$$1$$$ to $$$n-1$$$.\nFortunately, Andrew has a machine in his lab that can help with this. To use this machine, one should place two or more mushrooms in a row inside the machine (in any order) and turn the machine on. Then, the machine calculates the number of\nadjacent\npairs of mushrooms that are of different species. For example, if you place mushrooms of species $$$[A, B, B, A]$$$ (in that order) into the machine, the result will be $$$2$$$.\nHowever, as operating the machine is very expensive, the machine can be used for a limited number of times. In addition, the total number of mushrooms placed in the machine across all its uses cannot exceed $$$100\\,000$$$. Use this machine to help Andrew count the number of mushrooms of species A collected.\nImplementation details\nYou should implement the following procedure:\nint count_mushrooms(int n)\n$$$n$$$: number of mushrooms collected by Andrew.\nThis procedure is called exactly once, and should return the number of mushrooms of species A.\nThe above procedure can make calls to the following procedure:\nint use_machine(int[] x)\n$$$x$$$: an array of length between $$$2$$$ and $$$n$$$ inclusive, describing the labels of the mushrooms placed in the machine, in order.\nThe elements of $$$x$$$ must be\ndistinct\nintegers from $$$0$$$ to $$$n-1$$$ inclusive.\nLet $$$d$$$ be the length of array $$$x$$$. Then, the procedure returns the number of different indices $$$j$$$, such that $$$0 \\leq j \\leq d-2$$$ and mushrooms $$$x[j]$$$ and $$$x[j+1]$$$ are of different species.\nThis procedure can be called at most $$$20\\,000$$$ times.\nThe total length of $$$x$$$ passed to the procedure\nuse_machine\namong all its invocations cannot exceed $$$100\\,000$$$.\nInput\nThe sample grader reads an array $$$s$$$ of integers giving the mushroom species. For all $$$0 \\leq i \\leq n-1$$$, $$$s[i] = 0$$$ means the species of mushroom $$$i$$$ is A, whereas $$$s[i] = 1$$$ means the species of mushroom $$$i$$$ is B. The sample grader reads input in the following format:\nline $$$1$$$: $$$n$$$ ($$$2 \\leq n \\leq 20\\,000$$$)\nline $$$2$$$: $$$s[0]\\ s[1] \\ldots s[n-1]$$$\nOutput\nThe output of sample grader is in the following format:\nline $$$1$$$: the return value of\ncount_mushrooms\n.\nline $$$2$$$: the number of calls to\nuse_machine\n.\nNote that the sample grader is not adaptive.\nInteraction\nIn some test cases the behavior of the grader is adaptive. This means that in these test cases the grader does not have a fixed sequence of mushroom species. Instead, the answers given by the grader may depend on the prior calls to\nuse_machine\n. Though, it is guaranteed that the grader answers in such a way that after each interaction there is at least one sequence of mushroom species consistent with all the answers given so far.\nScoring\nIf in any of the test cases, the calls to the procedure\nuse_machine\ndo not conform to the rules mentioned above, or the return value of\ncount_mushrooms\nis incorrect, the score of your solution will be $$$0$$$. Otherwise, let $$$Q$$$ be the maximum number of calls to the procedure\nuse_machine\namong all test cases. Then, the score will be calculated according to the following table:\nCondition\nScore\n$$$20\\,000 \\textless Q$$$\n0\n$$$10\\,010 \\textless Q \\le 20\\,000$$$\n10\n$$$904 \\textless Q \\le 10\\,010$$$\n25\n$$$226 \\textless Q \\le 904$$$\n$$$100 \\cdot \\frac{226}{Q}$$$\n$$$Q \\le 226$$$\n100\nNote\nExample 1\nConsider a scenario in which there are $$$3$$$ mushrooms of species $$$[A, B, B]$$$, in order. The procedure\ncount_mushrooms\nis called in the following way:\ncount_mushrooms(3)\nThis procedure may call\nuse_machine([0, 1, 2])\n, which (in this scenario) returns $$$1$$$.\nIt may then call\nuse_machine([2, 1])\n, which returns $$$0$$$.\nAt this point, there is sufficient information to conclude that there is only $$$1$$$ mushroom of species A. So, the procedure\ncount_mushrooms\nshould return $$$1$$$.\nExample 2\nConsider a case in which there are $$$4$$$ mushrooms with species $$$[A, B, A, A]$$$, in order. The procedure\ncount_mushrooms\nis called as below:\ncount_mushrooms(4)\nThis procedure may call\nuse_machine([0, 2, 1, 3])\n, which returns $$$2$$$.\nIt may then call\nuse_machine([1, 2])\n, which returns $$$1$$$.\nAt this point, there is sufficient information to conclude that there are $$$3$$$ mushrooms of species A. Therefore, the procedure\ncount_mushrooms\nshould return $$$3$$$.",
    "_meta": {
      "index": 48,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/E",
      "uuid": "ps_bf794a38070407744d404d62d82082869cd5b579"
    }
  },
  {
    "planning_view": {
      "title": "C. Teams",
      "task": "Assign students to teams of required sizes respecting their size preferences over Q days",
      "given": [
        "N students with min/max team size preferences (A[i], B[i])",
        "Q days with M projects of required team sizes",
        "Each student can be in at most one team per day"
      ],
      "goal": "For each day, determine if all required teams can be formed",
      "key_rules": [
        "1 ≤ N ≤ 500,000",
        "1 ≤ Q ≤ 200,000",
        "Sum of all M values in can() calls ≤ 200,000",
        "1 ≤ A[i] ≤ B[i] ≤ N",
        "1 ≤ M ≤ N, 1 ≤ K[i] ≤ N"
      ],
      "target": {
        "1": {
          "points": 21,
          "req": "N ≤ 100, Q ≤ 100"
        },
        "2": {
          "points": 13,
          "req": "N ≤ 100,000, Q = 1"
        },
        "3": {
          "points": 43,
          "req": "N ≤ 100,000, Q ≤ 100,000, S ≤ 100,000"
        },
        "4": {
          "points": 23,
          "req": "N ≤ 500,000, Q ≤ 200,000, S ≤ 200,000"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Teams",
      "contest": "IOI 2015 day 1",
      "one_line": "Assign students to teams of required sizes respecting their size preferences over Q days",
      "given": [
        "N students with min/max team size preferences (A[i], B[i])",
        "Q days with M projects of required team sizes",
        "Each student can be in at most one team per day"
      ],
      "goal": "For each day, determine if all required teams can be formed",
      "mechanism": "Students have team size range constraints; each day has projects with required team sizes; students can be assigned to at most one team",
      "success_condition": "Return 1 if all teams can be formed respecting constraints, 0 otherwise",
      "constraints": {
        "critical": [
          "1 ≤ N ≤ 500,000",
          "1 ≤ Q ≤ 200,000",
          "Sum of all M values in can() calls ≤ 200,000",
          "1 ≤ A[i] ≤ B[i] ≤ N",
          "1 ≤ M ≤ N, 1 ≤ K[i] ≤ N"
        ],
        "subtasks": {
          "1": {
            "points": 21,
            "req": "N ≤ 100, Q ≤ 100"
          },
          "2": {
            "points": 13,
            "req": "N ≤ 100,000, Q = 1"
          },
          "3": {
            "points": 43,
            "req": "N ≤ 100,000, Q ≤ 100,000, S ≤ 100,000"
          },
          "4": {
            "points": 23,
            "req": "N ≤ 500,000, Q ≤ 200,000, S ≤ 200,000"
          }
        }
      },
      "limits": {
        "time": "4 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Teams",
        "contest": "IOI 2015 day 1",
        "one_line": "Assign students to teams of required sizes respecting their size preferences over Q days"
      },
      "problem": {
        "given": [
          "N students with min/max team size preferences (A[i], B[i])",
          "Q days with M projects of required team sizes",
          "Each student can be in at most one team per day"
        ],
        "goal": "For each day, determine if all required teams can be formed",
        "mechanism": "Students have team size range constraints; each day has projects with required team sizes; students can be assigned to at most one team",
        "success_condition": "Return 1 if all teams can be formed respecting constraints, 0 otherwise"
      },
      "constraints": {
        "critical": [
          "1 ≤ N ≤ 500,000",
          "1 ≤ Q ≤ 200,000",
          "Sum of all M values in can() calls ≤ 200,000",
          "1 ≤ A[i] ≤ B[i] ≤ N",
          "1 ≤ M ≤ N, 1 ≤ K[i] ≤ N"
        ],
        "subtasks": {
          "1": {
            "points": 21,
            "req": "N ≤ 100, Q ≤ 100"
          },
          "2": {
            "points": 13,
            "req": "N ≤ 100,000, Q = 1"
          },
          "3": {
            "points": 43,
            "req": "N ≤ 100,000, Q ≤ 100,000, S ≤ 100,000"
          },
          "4": {
            "points": 23,
            "req": "N ≤ 500,000, Q ≤ 200,000, S ≤ 200,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "void init(int N, int A[], int B[]) and int can(int M, int K[])",
        "available_api": {
          "init": {
            "signature": "void init(int N, int A[], int B[])",
            "params": "N: number of students; A: array[N] of min team sizes; B: array[N] of max team sizes",
            "returns": "void",
            "side_effect": "Initializes data structures for subsequent can() calls"
          },
          "can": {
            "signature": "int can(int M, int K[])",
            "params": "M: number of projects; K: array[M] of required team sizes",
            "returns": "1 if teams can be formed, 0 otherwise",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Must implement both functions",
          "Grader calls init() once first, then can() Q times",
          "Array indices 0..N-1 for students",
          "K array has length M"
        ]
      },
      "limits": {
        "time": "4 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "4\n2 4\n1 2\n2 3\n2 3\n2\n2 1 3\n2 1 1",
          "output": "1\n0"
        }
      ],
      "original_statement": "There is a class of $$$N$$$ students, numbered $$$0$$$ through $$$N - 1$$$. Every day the teacher of the class has some projects for the students. Each project has to be completed by a team of students within the same day. The projects may have various difficulty. For each project, the teacher knows the exact size of a team that should work on it.\nDifferent students may prefer different team sizes. More precisely, student $$$i$$$ can only be assigned to a team of size between $$$A[i]$$$ and $$$B[i]$$$ inclusive. On each day, a student may be assigned to at most one team. Some students might not be assigned to any teams. Each team will work on a single project.\nThe teacher has already chosen the projects for each of the next $$$Q$$$ days. For each of these days, determine whether it is possible to assign students to teams so that there is one team working on each project.\nYou are given the description of all students: $$$N$$$, $$$A$$$, and $$$B$$$, as well as a sequence of $$$Q$$$ questions— one about each day. Each question consists of the number $$$M$$$ of projects on that day and a sequence $$$K$$$ of length $$$M$$$ containing the required team sizes. For each question, your program must return whether it is possible to form all the teams. You need to implement the functions\ninit\nand\ncan\n:\nvoid init(int N, int A[], int B[])\n— The grader will call this function first and exactly once.\n$$$N$$$: the number of students.\n$$$A$$$: an array of length $$$N$$$: $$$A[i]$$$ is the minimum team size for student $$$i$$$.\n$$$B$$$: an array of length $$$N$$$: $$$B[i]$$$ is the maximum team size for student $$$i$$$\nThe function has no return value.\nYou may assume that $$$1 \\le A[i] \\le B[i] \\le N$$$ for each $$$i = 0, \\ldots, N - 1$$$\nint can(int M, int K[])\n— After calling\ninit\nonce, the grader will call this function $$$Q$$$ times in a row, once for each day.\n$$$M$$$: the number of projects for this day.\n$$$K$$$: an array of length $$$M$$$ containing the required team size for each of these projects.\nThe function should return $$$1$$$ if it is possible to form all the required teams and $$$0$$$ otherwise.\nYou may assume that $$$1 \\le M \\le N$$$, and that for each $$$i = 0, \\ldots, M - 1$$$ we have $$$1 \\le K[i] \\le N$$$. Note that the sum of all $$$K[i]$$$ may exceed $$$N$$$.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$\nlines $$$2, \\ldots,N + 1$$$: $$$A[i]\\ B[i]$$$\nline $$$N + 2$$$: $$$Q$$$\nlines $$$N + 3, \\ldots, N + Q + 2$$$: $$$M\\ K[0]\\ K[1]\\ \\ldots\\ K[M - 1]$$$\nOutput\nFor each question, the sample grader prints the return value of\ncan\n.\nScoring\nLet us denote $$$S$$$ by the sum of values of $$$M$$$ in all calls to\ncan(M, K)\n.\nSubtask\nPoints\n$$$N$$$\n$$$Q$$$\nAdditional constraints\n1\n21\n$$$1 \\le N \\le 100$$$\n$$$1 \\le Q \\le 100$$$\nNone\n2\n13\n$$$1 \\le N \\le 100\\,000$$$\n$$$Q = 1$$$\nNone\n3\n43\n$$$1 \\le N \\le 100\\,000$$$\n$$$1 \\le Q \\le 100\\,000$$$\n$$$S \\le 100\\,000$$$\n4\n23\n$$$1 \\le N \\le 500\\,000$$$\n$$$1 \\le Q \\le 200\\,000$$$\n$$$S \\le 200\\,000$$$\nExamples\nNote\nConsider the first example.\nThe students' constraints on team sizes are given in the table below:\nStudent\n0\n1\n2\n3\n$$$A$$$\n1\n2\n2\n2\n$$$B$$$\n2\n3\n3\n4\nThere are $$$Q = 2$$$ days.\nOn the first day there are $$$M = 2$$$ projects. The required team sizes are $$$K[0] = 1$$$ and $$$K[1] = 3$$$. These two teams can be formed by assigning student $$$0$$$ to a team of size $$$1$$$ and the remaining three students to a team of size $$$3$$$.\nOn the second day there are $$$M = 2$$$ projects again, but this time the required team sizes are $$$K[0] = 1$$$ and $$$K[1] = 1$$$. In this case it is not possible to form the teams, as there is only one student who can be in a team of size $$$1$$$."
    },
    "original": "There is a class of $$$N$$$ students, numbered $$$0$$$ through $$$N - 1$$$. Every day the teacher of the class has some projects for the students. Each project has to be completed by a team of students within the same day. The projects may have various difficulty. For each project, the teacher knows the exact size of a team that should work on it.\nDifferent students may prefer different team sizes. More precisely, student $$$i$$$ can only be assigned to a team of size between $$$A[i]$$$ and $$$B[i]$$$ inclusive. On each day, a student may be assigned to at most one team. Some students might not be assigned to any teams. Each team will work on a single project.\nThe teacher has already chosen the projects for each of the next $$$Q$$$ days. For each of these days, determine whether it is possible to assign students to teams so that there is one team working on each project.\nYou are given the description of all students: $$$N$$$, $$$A$$$, and $$$B$$$, as well as a sequence of $$$Q$$$ questions— one about each day. Each question consists of the number $$$M$$$ of projects on that day and a sequence $$$K$$$ of length $$$M$$$ containing the required team sizes. For each question, your program must return whether it is possible to form all the teams. You need to implement the functions\ninit\nand\ncan\n:\nvoid init(int N, int A[], int B[])\n— The grader will call this function first and exactly once.\n$$$N$$$: the number of students.\n$$$A$$$: an array of length $$$N$$$: $$$A[i]$$$ is the minimum team size for student $$$i$$$.\n$$$B$$$: an array of length $$$N$$$: $$$B[i]$$$ is the maximum team size for student $$$i$$$\nThe function has no return value.\nYou may assume that $$$1 \\le A[i] \\le B[i] \\le N$$$ for each $$$i = 0, \\ldots, N - 1$$$\nint can(int M, int K[])\n— After calling\ninit\nonce, the grader will call this function $$$Q$$$ times in a row, once for each day.\n$$$M$$$: the number of projects for this day.\n$$$K$$$: an array of length $$$M$$$ containing the required team size for each of these projects.\nThe function should return $$$1$$$ if it is possible to form all the required teams and $$$0$$$ otherwise.\nYou may assume that $$$1 \\le M \\le N$$$, and that for each $$$i = 0, \\ldots, M - 1$$$ we have $$$1 \\le K[i] \\le N$$$. Note that the sum of all $$$K[i]$$$ may exceed $$$N$$$.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$\nlines $$$2, \\ldots,N + 1$$$: $$$A[i]\\ B[i]$$$\nline $$$N + 2$$$: $$$Q$$$\nlines $$$N + 3, \\ldots, N + Q + 2$$$: $$$M\\ K[0]\\ K[1]\\ \\ldots\\ K[M - 1]$$$\nOutput\nFor each question, the sample grader prints the return value of\ncan\n.\nScoring\nLet us denote $$$S$$$ by the sum of values of $$$M$$$ in all calls to\ncan(M, K)\n.\nSubtask\nPoints\n$$$N$$$\n$$$Q$$$\nAdditional constraints\n1\n21\n$$$1 \\le N \\le 100$$$\n$$$1 \\le Q \\le 100$$$\nNone\n2\n13\n$$$1 \\le N \\le 100\\,000$$$\n$$$Q = 1$$$\nNone\n3\n43\n$$$1 \\le N \\le 100\\,000$$$\n$$$1 \\le Q \\le 100\\,000$$$\n$$$S \\le 100\\,000$$$\n4\n23\n$$$1 \\le N \\le 500\\,000$$$\n$$$1 \\le Q \\le 200\\,000$$$\n$$$S \\le 200\\,000$$$\nExamples\nNote\nConsider the first example.\nThe students' constraints on team sizes are given in the table below:\nStudent\n0\n1\n2\n3\n$$$A$$$\n1\n2\n2\n2\n$$$B$$$\n2\n3\n3\n4\nThere are $$$Q = 2$$$ days.\nOn the first day there are $$$M = 2$$$ projects. The required team sizes are $$$K[0] = 1$$$ and $$$K[1] = 3$$$. These two teams can be formed by assigning student $$$0$$$ to a team of size $$$1$$$ and the remaining three students to a team of size $$$3$$$.\nOn the second day there are $$$M = 2$$$ projects again, but this time the required team sizes are $$$K[0] = 1$$$ and $$$K[1] = 1$$$. In this case it is not possible to form the teams, as there is only one student who can be in a team of size $$$1$$$.",
    "_meta": {
      "index": 49,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/C",
      "uuid": "ps_a14631f24fa1b5ccb954e6a6ccca4e3e52389115"
    }
  },
  {
    "planning_view": {
      "title": "A. Nile",
      "task": "Find minimum transport cost for N artifacts given Q D values",
      "given": [
        "N artifacts with weights W, solo costs A, paired costs B",
        "B[i] < A[i] for all artifacts",
        "Can pair artifacts only if |W[p]-W[q]| ≤ D",
        "Q queries with different D values in E"
      ],
      "goal": "Answer Q queries: minimum cost to transport all artifacts for each D",
      "key_rules": [
        "Pairs only allowed when |W[p]-W[q]| ≤ current D",
        "Solo transport costs A[i], paired costs B[i] (B[i] < A[i])",
        "Paired boat cost = sum of B values for both artifacts"
      ],
      "target": {
        "1": {
          "points": 6,
          "req": "Q ≤ 5, N ≤ 2000, all W[i] = 1"
        },
        "2": {
          "points": 13,
          "req": "Q ≤ 5, W[i] = i+1 (sorted)"
        },
        "3": {
          "points": 17,
          "req": "Q ≤ 5, all A[i] = 2, B[i] = 1"
        },
        "4": {
          "points": 11,
          "req": "Q ≤ 5, N ≤ 2000"
        },
        "5": {
          "points": 20,
          "req": "Q ≤ 5"
        },
        "6": {
          "points": 15,
          "req": "All A[i] = 2, B[i] = 1"
        },
        "7": {
          "points": 18,
          "req": "No constraints, N,Q ≤ 100,000"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Nile",
      "contest": "IOI 2024 day 1",
      "one_line": "Find minimum transport cost for N artifacts given Q D values",
      "given": [
        "N artifacts with weights W, solo costs A, paired costs B",
        "B[i] < A[i] for all artifacts",
        "Can pair artifacts only if |W[p]-W[q]| ≤ D",
        "Q queries with different D values in E"
      ],
      "goal": "Answer Q queries: minimum cost to transport all artifacts for each D",
      "mechanism": "Each boat carries 1 or 2 artifacts; pairing requires weight difference ≤ D",
      "success_condition": "Return array R where R[j] = minimum cost when D = E[j]",
      "constraints": {
        "critical": [
          "Pairs only allowed when |W[p]-W[q]| ≤ current D",
          "Solo transport costs A[i], paired costs B[i] (B[i] < A[i])",
          "Paired boat cost = sum of B values for both artifacts"
        ],
        "subtasks": {
          "1": {
            "points": 6,
            "req": "Q ≤ 5, N ≤ 2000, all W[i] = 1"
          },
          "2": {
            "points": 13,
            "req": "Q ≤ 5, W[i] = i+1 (sorted)"
          },
          "3": {
            "points": 17,
            "req": "Q ≤ 5, all A[i] = 2, B[i] = 1"
          },
          "4": {
            "points": 11,
            "req": "Q ≤ 5, N ≤ 2000"
          },
          "5": {
            "points": 20,
            "req": "Q ≤ 5"
          },
          "6": {
            "points": 15,
            "req": "All A[i] = 2, B[i] = 1"
          },
          "7": {
            "points": 18,
            "req": "No constraints, N,Q ≤ 100,000"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Nile",
        "contest": "IOI 2024 day 1",
        "one_line": "Find minimum transport cost for N artifacts given Q D values"
      },
      "problem": {
        "given": [
          "N artifacts with weights W, solo costs A, paired costs B",
          "B[i] < A[i] for all artifacts",
          "Can pair artifacts only if |W[p]-W[q]| ≤ D",
          "Q queries with different D values in E"
        ],
        "goal": "Answer Q queries: minimum cost to transport all artifacts for each D",
        "mechanism": "Each boat carries 1 or 2 artifacts; pairing requires weight difference ≤ D",
        "success_condition": "Return array R where R[j] = minimum cost when D = E[j]"
      },
      "constraints": {
        "critical": [
          "Pairs only allowed when |W[p]-W[q]| ≤ current D",
          "Solo transport costs A[i], paired costs B[i] (B[i] < A[i])",
          "Paired boat cost = sum of B values for both artifacts"
        ],
        "subtasks": {
          "1": {
            "points": 6,
            "req": "Q ≤ 5, N ≤ 2000, all W[i] = 1"
          },
          "2": {
            "points": 13,
            "req": "Q ≤ 5, W[i] = i+1 (sorted)"
          },
          "3": {
            "points": 17,
            "req": "Q ≤ 5, all A[i] = 2, B[i] = 1"
          },
          "4": {
            "points": 11,
            "req": "Q ≤ 5, N ≤ 2000"
          },
          "5": {
            "points": 20,
            "req": "Q ≤ 5"
          },
          "6": {
            "points": 15,
            "req": "All A[i] = 2, B[i] = 1"
          },
          "7": {
            "points": 18,
            "req": "No constraints, N,Q ≤ 100,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "std::vector<long long> calculate_costs(std::vector<int> W, std::vector<int> A, std::vector<int> B, std::vector<int> E)",
        "available_api": {
          "calculate_costs": {
            "signature": "std::vector<long long> calculate_costs(std::vector<int> W, std::vector<int> A, std::vector<int> B, std::vector<int> E)",
            "params": "W: artifact weights, A: solo costs, B: paired costs, E: D values for queries",
            "returns": "Array R of Q elements with minimum costs",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Use long long for costs (can reach 10^18)",
          "0-indexed artifacts",
          "Return vector must match Q length exactly"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "5\n15 5 1\n12 4 2\n2 5 2\n10 6 3\n21 3 2\n3\n5\n9\n1",
          "output": "16\n11\n23"
        }
      ],
      "original_statement": "You want to transport $$$N$$$ artifacts through the Nile. The artifacts are numbered from $$$0$$$ to $$$N - 1$$$. The weight of artifact $$$i$$$ ($$$0 \\le i < N$$$) is $$$W[i]$$$.\nTo transport the artifacts, you use specialized boats. Each boat can carry\nat most two\nartifacts.\nIf you decide to put a single artifact in a boat, the artifact weight can be arbitrary.\nIf you want to put two artifacts in the same boat, you have to make sure the boat is balanced evenly. Specifically, you can send artifacts $$$p$$$ and $$$q$$$ ($$$0 \\le p < q < N$$$) in the same boat only if the absolute difference between their weights is at most $$$D$$$, that is $$$|W[p] - W[q]| \\le D$$$.\nTo transport an artifact, you have to pay a cost that depends on the number of artifacts carried in the same boat. The cost of transporting artifact $$$i$$$ ($$$0 \\le i < N$$$) is:\n$$$A[i]$$$, if you put the artifact in its own boat, or\n$$$B[i]$$$, if you put it in a boat together with some other artifact.\nNote that in the latter case, you have to pay for both artifacts in the boat. Specifically, if you decide to send artifacts $$$p$$$ and $$$q$$$ ($$$0 \\le p < q < N$$$) in the same boat, you need to pay $$$B[p] + B[q]$$$.\nSending an artifact in a boat by itself is always more expensive than sending it with some other artifact sharing the boat with it, so $$$B[i] < A[i]$$$ for all $$$i$$$ such that $$$0 \\le i < N$$$.\nUnfortunately, the river is very unpredictable and the value of $$$D$$$ changes often. Your task is to answer $$$Q$$$ questions numbered from $$$0$$$ to $$$Q - 1$$$. The questions are described by an array $$$E$$$ of length $$$Q$$$. The answer to question $$$j$$$ ($$$0 \\le j < Q$$$) is the minimum total cost of transporting all $$$N$$$ artifacts, when the value of $$$D$$$ is equal to $$$E[j]$$$.\nImplementation Details\nYou should implement the following procedure.\nstd::vector<long long> calculate_costs(\nstd::vector<int> W, std::vector<int> A,\nstd::vector<int> B, std::vector<int> E)\n$$$W$$$, $$$A$$$, $$$B$$$: arrays of integers of length $$$N$$$, describing the weights of the artifacts and the costs of transporting them.\n$$$E$$$: an array of integers of length $$$Q$$$ describing the value of $$$D$$$ for each question.\nThis procedure should return an array $$$R$$$ of $$$Q$$$ integers containing the minimum total cost of transporting the artifacts, where $$$R[j]$$$ gives the cost when the value of $$$D$$$ is $$$E[j]$$$ (for each $$$j$$$ suchthat $$$0 \\le j < Q$$$).\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\le N \\le 100\\; 000$$$)\nline $$$2 + j$$$ ($$$0 \\le j \\le N - 1$$$): $$$W[0]\\; A[0]\\; B[0]$$$ ($$$1 \\le W[j] \\le 10^9$$$, $$$1 \\le B[j] < A[j] \\le 10^9$$$)\nline $$$N + 2$$$: $$$Q$$$ ($$$1 \\le Q \\le 100\\; 000$$$)\nline $$$N + 3 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$E[j]$$$ ($$$1 \\le E[j] \\le 10^9$$$)\nOutput\nThe sample grader prints $$$S$$$ lines, in the following format:\nline $$$1 + i$$$ ($$$0 \\le i \\le S - 1$$$): $$$R[i]$$$\nHere, $$$S$$$ is the length of the array $$$R$$$ returned by\ncalculate_costs\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n6\n$$$Q\\le 5$$$; $$$N \\le 2000$$$; $$$W[i]=1$$$ for each $$$i$$$ such that $$$0 \\le i < N$$$\n2\n13\n$$$Q\\le 5$$$; $$$W[i]=i+1$$$ for each $$$i$$$ such that $$$0\\le i < N$$$\n3\n17\n$$$Q\\le 5$$$;$$$A[i]=2$$$ and $$$B[i]=1$$$ for each $$$i$$$ such that $$$0\\le i < N$$$\n4\n11\n$$$Q\\le 5$$$; $$$N \\le 2000$$$\n5\n20\n$$$Q\\le 5$$$\n6\n15\n$$$A[i]=2$$$ and $$$B[i]=1$$$ for each $$$i$$$ such that $$$0\\le i < N$$$\n7\n18\nNo additional constraints.\nExample\nNote\nConsider the following call.\ncalculate_costs([15, 12, 2, 10, 21],\n[5, 4, 5, 6, 3],\n[1, 2, 2, 3, 2],\n[5, 9, 1])\nIn this example we have $$$N = 5$$$ artifacts and $$$Q = 3$$$ questions. In the first question, $$$D = 5$$$. You can send artifacts $$$0$$$ and $$$3$$$ in one boat (since $$$|15 - 10| \\le 5$$$) and the remaining artifacts in separate boats. This yields the minimum cost of transporting all the artifacts, which is $$$1 + 4 + 5 + 3 + 3 = 16$$$.\nIn the second question, $$$D = 9$$$. You can send artifacts $$$0$$$ and $$$1$$$ in one boat (since $$$|15 - 12| \\le 9$$$) and send artifacts $$$2$$$ and $$$3$$$ in one boat (since $$$|2 - 10| \\le 9$$$). The remaining artifact can be sent in a separate boat. This yields the minimum cost of transporting all the artifacts, which is $$$1 + 2 + 2 + 3 + 3 = 11$$$.\nIn the final question, $$$D = 1$$$. You need to send each artifact in its own boat. This yields the minimum cost of transporting all the artifacts, which is $$$5 + 4 + 5 + 6 + 3 = 23$$$. Hence, this procedure should return $$$[16,\\; 11,\\; 23]$$$."
    },
    "original": "You want to transport $$$N$$$ artifacts through the Nile. The artifacts are numbered from $$$0$$$ to $$$N - 1$$$. The weight of artifact $$$i$$$ ($$$0 \\le i < N$$$) is $$$W[i]$$$.\nTo transport the artifacts, you use specialized boats. Each boat can carry\nat most two\nartifacts.\nIf you decide to put a single artifact in a boat, the artifact weight can be arbitrary.\nIf you want to put two artifacts in the same boat, you have to make sure the boat is balanced evenly. Specifically, you can send artifacts $$$p$$$ and $$$q$$$ ($$$0 \\le p < q < N$$$) in the same boat only if the absolute difference between their weights is at most $$$D$$$, that is $$$|W[p] - W[q]| \\le D$$$.\nTo transport an artifact, you have to pay a cost that depends on the number of artifacts carried in the same boat. The cost of transporting artifact $$$i$$$ ($$$0 \\le i < N$$$) is:\n$$$A[i]$$$, if you put the artifact in its own boat, or\n$$$B[i]$$$, if you put it in a boat together with some other artifact.\nNote that in the latter case, you have to pay for both artifacts in the boat. Specifically, if you decide to send artifacts $$$p$$$ and $$$q$$$ ($$$0 \\le p < q < N$$$) in the same boat, you need to pay $$$B[p] + B[q]$$$.\nSending an artifact in a boat by itself is always more expensive than sending it with some other artifact sharing the boat with it, so $$$B[i] < A[i]$$$ for all $$$i$$$ such that $$$0 \\le i < N$$$.\nUnfortunately, the river is very unpredictable and the value of $$$D$$$ changes often. Your task is to answer $$$Q$$$ questions numbered from $$$0$$$ to $$$Q - 1$$$. The questions are described by an array $$$E$$$ of length $$$Q$$$. The answer to question $$$j$$$ ($$$0 \\le j < Q$$$) is the minimum total cost of transporting all $$$N$$$ artifacts, when the value of $$$D$$$ is equal to $$$E[j]$$$.\nImplementation Details\nYou should implement the following procedure.\nstd::vector<long long> calculate_costs(\nstd::vector<int> W, std::vector<int> A,\nstd::vector<int> B, std::vector<int> E)\n$$$W$$$, $$$A$$$, $$$B$$$: arrays of integers of length $$$N$$$, describing the weights of the artifacts and the costs of transporting them.\n$$$E$$$: an array of integers of length $$$Q$$$ describing the value of $$$D$$$ for each question.\nThis procedure should return an array $$$R$$$ of $$$Q$$$ integers containing the minimum total cost of transporting the artifacts, where $$$R[j]$$$ gives the cost when the value of $$$D$$$ is $$$E[j]$$$ (for each $$$j$$$ suchthat $$$0 \\le j < Q$$$).\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\le N \\le 100\\; 000$$$)\nline $$$2 + j$$$ ($$$0 \\le j \\le N - 1$$$): $$$W[0]\\; A[0]\\; B[0]$$$ ($$$1 \\le W[j] \\le 10^9$$$, $$$1 \\le B[j] < A[j] \\le 10^9$$$)\nline $$$N + 2$$$: $$$Q$$$ ($$$1 \\le Q \\le 100\\; 000$$$)\nline $$$N + 3 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$E[j]$$$ ($$$1 \\le E[j] \\le 10^9$$$)\nOutput\nThe sample grader prints $$$S$$$ lines, in the following format:\nline $$$1 + i$$$ ($$$0 \\le i \\le S - 1$$$): $$$R[i]$$$\nHere, $$$S$$$ is the length of the array $$$R$$$ returned by\ncalculate_costs\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n6\n$$$Q\\le 5$$$; $$$N \\le 2000$$$; $$$W[i]=1$$$ for each $$$i$$$ such that $$$0 \\le i < N$$$\n2\n13\n$$$Q\\le 5$$$; $$$W[i]=i+1$$$ for each $$$i$$$ such that $$$0\\le i < N$$$\n3\n17\n$$$Q\\le 5$$$;$$$A[i]=2$$$ and $$$B[i]=1$$$ for each $$$i$$$ such that $$$0\\le i < N$$$\n4\n11\n$$$Q\\le 5$$$; $$$N \\le 2000$$$\n5\n20\n$$$Q\\le 5$$$\n6\n15\n$$$A[i]=2$$$ and $$$B[i]=1$$$ for each $$$i$$$ such that $$$0\\le i < N$$$\n7\n18\nNo additional constraints.\nExample\nNote\nConsider the following call.\ncalculate_costs([15, 12, 2, 10, 21],\n[5, 4, 5, 6, 3],\n[1, 2, 2, 3, 2],\n[5, 9, 1])\nIn this example we have $$$N = 5$$$ artifacts and $$$Q = 3$$$ questions. In the first question, $$$D = 5$$$. You can send artifacts $$$0$$$ and $$$3$$$ in one boat (since $$$|15 - 10| \\le 5$$$) and the remaining artifacts in separate boats. This yields the minimum cost of transporting all the artifacts, which is $$$1 + 4 + 5 + 3 + 3 = 16$$$.\nIn the second question, $$$D = 9$$$. You can send artifacts $$$0$$$ and $$$1$$$ in one boat (since $$$|15 - 12| \\le 9$$$) and send artifacts $$$2$$$ and $$$3$$$ in one boat (since $$$|2 - 10| \\le 9$$$). The remaining artifact can be sent in a separate boat. This yields the minimum cost of transporting all the artifacts, which is $$$1 + 2 + 2 + 3 + 3 = 11$$$.\nIn the final question, $$$D = 1$$$. You need to send each artifact in its own boat. This yields the minimum cost of transporting all the artifacts, which is $$$5 + 4 + 5 + 6 + 3 = 23$$$. Hence, this procedure should return $$$[16,\\; 11,\\; 23]$$$.",
    "_meta": {
      "index": 50,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/A",
      "uuid": "ps_85a08a4de768623895e0d6230d9b0d96dc38d9d2"
    }
  },
  {
    "planning_view": {
      "title": "B. Parachute rings",
      "task": "Count critical rings in a dynamic graph adding edges, where removal leaves only chains",
      "given": [
        "N disjoint rings numbered 0 to N-1",
        "Initially no connections between rings",
        "Links are added incrementally"
      ],
      "goal": "After each Link operation, count rings whose removal leaves only chains (no cycles except trivial)",
      "key_rules": [
        "Ring is critical if its removal makes graph a set of chains (each component is a simple path)",
        "Original graph can have cycles and high-degree nodes",
        "Links are added incrementally, never removed"
      ],
      "target": {
        "1": {
          "points": 20,
          "req": "N ≤ 5000, CountCritical called once at end, ≤5000 Link calls"
        },
        "2": {
          "points": 17,
          "req": "N ≤ 1e6, CountCritical once at end, ≤1e6 Link calls"
        },
        "3": {
          "points": 18,
          "req": "N ≤ 20000, ≤100 CountCritical calls, ≤10000 Link calls"
        },
        "4": {
          "points": 14,
          "req": "N ≤ 100000, total operations ≤100000"
        },
        "5": {
          "points": 31,
          "req": "N ≤ 1e6, total operations ≤1e6"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Parachute rings",
      "contest": "IOI 2012 day 1",
      "one_line": "Count critical rings in a dynamic graph adding edges, where removal leaves only chains",
      "given": [
        "N disjoint rings numbered 0 to N-1",
        "Initially no connections between rings",
        "Links are added incrementally"
      ],
      "goal": "After each Link operation, count rings whose removal leaves only chains (no cycles except trivial)",
      "mechanism": "Graph evolves by adding edges between rings; critical ring removal makes graph acyclic (only chains remain)",
      "success_condition": "Ring is critical if its removal results in graph consisting only of disjoint chains (paths with degree ≤ 2)",
      "constraints": {
        "critical": [
          "Ring is critical if its removal makes graph a set of chains (each component is a simple path)",
          "Original graph can have cycles and high-degree nodes",
          "Links are added incrementally, never removed"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "N ≤ 5000, CountCritical called once at end, ≤5000 Link calls"
          },
          "2": {
            "points": 17,
            "req": "N ≤ 1e6, CountCritical once at end, ≤1e6 Link calls"
          },
          "3": {
            "points": 18,
            "req": "N ≤ 20000, ≤100 CountCritical calls, ≤10000 Link calls"
          },
          "4": {
            "points": 14,
            "req": "N ≤ 100000, total operations ≤100000"
          },
          "5": {
            "points": 31,
            "req": "N ≤ 1e6, total operations ≤1e6"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Parachute rings",
        "contest": "IOI 2012 day 1",
        "one_line": "Count critical rings in a dynamic graph adding edges, where removal leaves only chains"
      },
      "problem": {
        "given": [
          "N disjoint rings numbered 0 to N-1",
          "Initially no connections between rings",
          "Links are added incrementally"
        ],
        "goal": "After each Link operation, count rings whose removal leaves only chains (no cycles except trivial)",
        "mechanism": "Graph evolves by adding edges between rings; critical ring removal makes graph acyclic (only chains remain)",
        "success_condition": "Ring is critical if its removal results in graph consisting only of disjoint chains (paths with degree ≤ 2)"
      },
      "constraints": {
        "critical": [
          "Ring is critical if its removal makes graph a set of chains (each component is a simple path)",
          "Original graph can have cycles and high-degree nodes",
          "Links are added incrementally, never removed"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "N ≤ 5000, CountCritical called once at end, ≤5000 Link calls"
          },
          "2": {
            "points": 17,
            "req": "N ≤ 1e6, CountCritical once at end, ≤1e6 Link calls"
          },
          "3": {
            "points": 18,
            "req": "N ≤ 20000, ≤100 CountCritical calls, ≤10000 Link calls"
          },
          "4": {
            "points": 14,
            "req": "N ≤ 100000, total operations ≤100000"
          },
          "5": {
            "points": 31,
            "req": "N ≤ 1e6, total operations ≤1e6"
          }
        }
      },
      "implementation": {
        "function_to_write": "void Init(int N); void Link(int A, int B); int CountCritical();",
        "available_api": {
          "Init": {
            "signature": "void Init(int N)",
            "params": "N: number of rings (0 to N-1)",
            "returns": "void",
            "side_effect": "Initializes N disjoint rings with no connections"
          },
          "Link": {
            "signature": "void Link(int A, int B)",
            "params": "A, B: distinct ring indices to connect",
            "returns": "void",
            "side_effect": "Adds edge between rings A and B"
          },
          "CountCritical": {
            "signature": "int CountCritical()",
            "params": "none",
            "returns": "Number of critical rings in current configuration",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Rings are 0-indexed",
          "No standard I/O",
          "Implement exact function signatures",
          "Handle incremental edge additions"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "7 13\n-1\n1 2\n-1\n0 5\n-1\n2 0\n-1\n3 2\n-1\n3 5\n-1\n4 3\n-1",
          "output": "7\n7\n7\n7\n4\n3\n2"
        }
      ],
      "original_statement": "An early and quite sophisticated version of what we now call a parachute is described in Leonardo's Codex Atlanticus (ca. 1485). Leonardo's parachute consisted of a sealed linen cloth held open by a pyramid-shaped wooden structure.\nLinked rings\nSkydiver Adrian Nicholas tested Leonardo's design more than 500 years later. For this, a modern lightweight structure tied Leonardo's parachute to the human body. We want to use linked rings, which also provide hooks for the sealed linen cloth. Each ring is made of flexible and strong material. Rings can be easily linked together as every ring can be opened and re-closed. A special configuration of linked rings is the chain. A chain is a sequence of rings in which each ring is only connected to its (at most two) neighbours, as illustrated below. This sequence must have a start and an end (rings that are connected to at most one other ring each). Specifically, a single ring is also a chain.\nOther configurations are clearly possible, since a ring can be linked to three or more other rings. We say that a ring is critical if after opening and removing it, all remaining rings form a set of chains (or there are no other rings left). In other words, there can be nothing but chains left.\nExample\nConsider the seven rings in the next figure, numbered from $$$0$$$ to $$$6$$$. There are two critical rings. One critical ring is $$$2$$$: after its removal, the remaining rings form chains $$$[1]$$$, $$$[0, 5, 3, 4]$$$ and $$$[6]$$$. The other critical ring is $$$3$$$: after its removal, the remaining rings form chains $$$[1, 2, 0, 5]$$$, $$$[4]$$$ and $$$[6]$$$. If we remove any other ring, we do not obtain a set of disjoint chains. For example, after removing ring $$$5$$$: although we have that $$$[6]$$$ is a chain, the linked rings $$$0, 1, 2, 3$$$ and $$$4$$$ do not form a chain.\nStatement\nYour task is to count the number of critical rings in a given configuration that will be communicated to your program.\nAt the beginning, there are a certain number of disjoint rings. After that, rings are linked together. At any given time, you can be asked to return the number of critical rings in the current configuration. Specifically, you have to implement three routines.\nInit(N)\n— it is called exactly once at the beginning to communicate that there are $$$N$$$ disjoint rings numbered from $$$0$$$ to $$$N - 1$$$ (inclusive) in the initial configuration.\nLink(A, B)\n— the two rings numbered $$$A$$$ and $$$B$$$ get linked together. It is guaranteed that $$$A$$$ and $$$B$$$ are different and not already linked directly; apart from this, there are no additional conditions on $$$A$$$ and $$$B$$$, in particular no conditions arising from physical constraints. Clearly,\nLink(A, B)\nand\nLink(B, A)\nare equivalent.\nCountCritical()\n— return the number of critical rings for the current configuration of linked rings.\nYou have to submit exactly one file, called\nrings.c\n,\nrings.cpp\nor\nrings.pas\n. This file implements the subprograms described above using the following signatures.\nC/C++ programs:\nvoid Init(int N);\nvoid Link(int A, int B);\nint CountCritical();\nPascal programs:\nprocedure Init(N : LongInt);\nprocedure Link(A, B : LongInt);\nfunction CountCritical() : LongInt;\nThese subprograms must behave as described above. Of course you are free to implement other subprograms for their internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nSample grader\nThe sample grader reads the input in the following format:\nline 1: $$$N$$$, $$$L$$$;\nlines 2, ..., L + 1:\n$$$-1$$$ to invoke\nCountCritical\n;\n$$$A$$$, $$$B$$$ parameters to invoke\nLink\nwith $$$A$$$ and $$$B$$$ as parameters.\nThe sample grader will print all results from\nCountCritical\n.\nScoring\nSubtask 1 [20 points]\n$$$N \\le 5\\,000$$$.\nThe function\nCountCritical\nis called only once, after all the other calls; the function\nLink\nis called at most $$$5\\,000$$$ times.\nSubtask 2 [17 points]\n$$$N \\le 1\\,000\\,000$$$.\nThe function\nCountCritical\nis called only once, after all the other calls; the function\nLink\nis called at most $$$1\\,000\\,000$$$ times.\nSubtask 3 [18 points]\n$$$N \\le 20\\,000$$$.\nThe function\nCountCritical\nis called at most $$$100$$$ times; the function\nLink\nis called at most $$$10\\,000$$$ times.\nSubtask 4 [14 points]\n$$$N \\le 100\\,000$$$.\nThe functions\nCountCritical\nand\nLink\nare called, in total, at most $$$100\\,000$$$ times.\nSubtask 5 [31 points]\n$$$N \\le 1\\,000\\,000$$$.\nThe functions\nCountCritical\nand\nLink\nare called, in total, at most $$$1\\,000\\,000$$$ times.\nExample\nNote\nConsider our figure with $$$N = 7$$$ rings and suppose that they are initially unlinked. We show a possible sequence of calls, where after the last call we obtain the situation depicted in our figure.\nCall\nReturns\nInit(7)\nCountCritical()\n7\nLink(1, 2)\nCountCritical()\n7\nLink(0, 5)\nCountCritical()\n7\nLink(2, 0)\nCountCritical()\n7\nLink(3, 2)\nCountCritical()\n4\nLink(3, 5)\nCountCritical()\n3\nLink(4, 3)\nCountCritical()\n2"
    },
    "original": "An early and quite sophisticated version of what we now call a parachute is described in Leonardo's Codex Atlanticus (ca. 1485). Leonardo's parachute consisted of a sealed linen cloth held open by a pyramid-shaped wooden structure.\nLinked rings\nSkydiver Adrian Nicholas tested Leonardo's design more than 500 years later. For this, a modern lightweight structure tied Leonardo's parachute to the human body. We want to use linked rings, which also provide hooks for the sealed linen cloth. Each ring is made of flexible and strong material. Rings can be easily linked together as every ring can be opened and re-closed. A special configuration of linked rings is the chain. A chain is a sequence of rings in which each ring is only connected to its (at most two) neighbours, as illustrated below. This sequence must have a start and an end (rings that are connected to at most one other ring each). Specifically, a single ring is also a chain.\nOther configurations are clearly possible, since a ring can be linked to three or more other rings. We say that a ring is critical if after opening and removing it, all remaining rings form a set of chains (or there are no other rings left). In other words, there can be nothing but chains left.\nExample\nConsider the seven rings in the next figure, numbered from $$$0$$$ to $$$6$$$. There are two critical rings. One critical ring is $$$2$$$: after its removal, the remaining rings form chains $$$[1]$$$, $$$[0, 5, 3, 4]$$$ and $$$[6]$$$. The other critical ring is $$$3$$$: after its removal, the remaining rings form chains $$$[1, 2, 0, 5]$$$, $$$[4]$$$ and $$$[6]$$$. If we remove any other ring, we do not obtain a set of disjoint chains. For example, after removing ring $$$5$$$: although we have that $$$[6]$$$ is a chain, the linked rings $$$0, 1, 2, 3$$$ and $$$4$$$ do not form a chain.\nStatement\nYour task is to count the number of critical rings in a given configuration that will be communicated to your program.\nAt the beginning, there are a certain number of disjoint rings. After that, rings are linked together. At any given time, you can be asked to return the number of critical rings in the current configuration. Specifically, you have to implement three routines.\nInit(N)\n— it is called exactly once at the beginning to communicate that there are $$$N$$$ disjoint rings numbered from $$$0$$$ to $$$N - 1$$$ (inclusive) in the initial configuration.\nLink(A, B)\n— the two rings numbered $$$A$$$ and $$$B$$$ get linked together. It is guaranteed that $$$A$$$ and $$$B$$$ are different and not already linked directly; apart from this, there are no additional conditions on $$$A$$$ and $$$B$$$, in particular no conditions arising from physical constraints. Clearly,\nLink(A, B)\nand\nLink(B, A)\nare equivalent.\nCountCritical()\n— return the number of critical rings for the current configuration of linked rings.\nYou have to submit exactly one file, called\nrings.c\n,\nrings.cpp\nor\nrings.pas\n. This file implements the subprograms described above using the following signatures.\nC/C++ programs:\nvoid Init(int N);\nvoid Link(int A, int B);\nint CountCritical();\nPascal programs:\nprocedure Init(N : LongInt);\nprocedure Link(A, B : LongInt);\nfunction CountCritical() : LongInt;\nThese subprograms must behave as described above. Of course you are free to implement other subprograms for their internal use. Your submissions must not interact in any way with standard input/output, nor with any other file.\nSample grader\nThe sample grader reads the input in the following format:\nline 1: $$$N$$$, $$$L$$$;\nlines 2, ..., L + 1:\n$$$-1$$$ to invoke\nCountCritical\n;\n$$$A$$$, $$$B$$$ parameters to invoke\nLink\nwith $$$A$$$ and $$$B$$$ as parameters.\nThe sample grader will print all results from\nCountCritical\n.\nScoring\nSubtask 1 [20 points]\n$$$N \\le 5\\,000$$$.\nThe function\nCountCritical\nis called only once, after all the other calls; the function\nLink\nis called at most $$$5\\,000$$$ times.\nSubtask 2 [17 points]\n$$$N \\le 1\\,000\\,000$$$.\nThe function\nCountCritical\nis called only once, after all the other calls; the function\nLink\nis called at most $$$1\\,000\\,000$$$ times.\nSubtask 3 [18 points]\n$$$N \\le 20\\,000$$$.\nThe function\nCountCritical\nis called at most $$$100$$$ times; the function\nLink\nis called at most $$$10\\,000$$$ times.\nSubtask 4 [14 points]\n$$$N \\le 100\\,000$$$.\nThe functions\nCountCritical\nand\nLink\nare called, in total, at most $$$100\\,000$$$ times.\nSubtask 5 [31 points]\n$$$N \\le 1\\,000\\,000$$$.\nThe functions\nCountCritical\nand\nLink\nare called, in total, at most $$$1\\,000\\,000$$$ times.\nExample\nNote\nConsider our figure with $$$N = 7$$$ rings and suppose that they are initially unlinked. We show a possible sequence of calls, where after the last call we obtain the situation depicted in our figure.\nCall\nReturns\nInit(7)\nCountCritical()\n7\nLink(1, 2)\nCountCritical()\n7\nLink(0, 5)\nCountCritical()\n7\nLink(2, 0)\nCountCritical()\n7\nLink(3, 2)\nCountCritical()\n4\nLink(3, 5)\nCountCritical()\n3\nLink(4, 3)\nCountCritical()\n2",
    "_meta": {
      "index": 51,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/B",
      "uuid": "ps_66400e72b9f6618cbb09139fc400079602de0ad9"
    }
  },
  {
    "planning_view": {
      "title": "A. Detecting Molecules",
      "task": "Find subset of molecules with total weight in [l,u] using given constraint u-l≥w_max-w_min",
      "given": [
        "n molecules with integer weights w[0..n-1]",
        "Detection range [l,u] where u-l ≥ max(w)-min(w)",
        "Weights are positive integers"
      ],
      "goal": "Find any subset with total weight between l and u, or determine none exists",
      "key_rules": [
        "u-l ≥ max(w) - min(w) (critical mathematical property)",
        "Subset must use distinct molecules (no repetition)",
        "If molecules can reach both ≤l and ≥u, solution must exist"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "n≤100, w_i≤100, u,l≤1000, all weights equal"
        },
        "2": {
          "points": 10,
          "req": "n≤100, w_i,u,l≤1000, max(w)-min(w)≤1"
        },
        "3": {
          "points": 12,
          "req": "n≤100, w_i,u,l≤1000"
        },
        "4": {
          "points": 15,
          "req": "n≤10,000, w_i,u,l≤10,000"
        },
        "5": {
          "points": 23,
          "req": "n≤10,000, w_i,u,l≤500,000"
        },
        "6": {
          "points": 31,
          "req": "n≤200,000, w_i,u,l≤2^31-1"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Detecting Molecules",
      "contest": "IOI 2016 day 1",
      "one_line": "Find subset of molecules with total weight in [l,u] using given constraint u-l≥w_max-w_min",
      "given": [
        "n molecules with integer weights w[0..n-1]",
        "Detection range [l,u] where u-l ≥ max(w)-min(w)",
        "Weights are positive integers"
      ],
      "goal": "Find any subset with total weight between l and u, or determine none exists",
      "mechanism": "Machine detects molecules if any subset has total weight within [l,u]; key constraint guarantees solution exists if molecules can reach both bounds",
      "success_condition": "Return indices of any subset with ∑w_i ∈ [l,u], or empty array if impossible",
      "constraints": {
        "critical": [
          "u-l ≥ max(w) - min(w) (critical mathematical property)",
          "Subset must use distinct molecules (no repetition)",
          "If molecules can reach both ≤l and ≥u, solution must exist"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "n≤100, w_i≤100, u,l≤1000, all weights equal"
          },
          "2": {
            "points": 10,
            "req": "n≤100, w_i,u,l≤1000, max(w)-min(w)≤1"
          },
          "3": {
            "points": 12,
            "req": "n≤100, w_i,u,l≤1000"
          },
          "4": {
            "points": 15,
            "req": "n≤10,000, w_i,u,l≤10,000"
          },
          "5": {
            "points": 23,
            "req": "n≤10,000, w_i,u,l≤500,000"
          },
          "6": {
            "points": 31,
            "req": "n≤200,000, w_i,u,l≤2^31-1"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Detecting Molecules",
        "contest": "IOI 2016 day 1",
        "one_line": "Find subset of molecules with total weight in [l,u] using given constraint u-l≥w_max-w_min"
      },
      "problem": {
        "given": [
          "n molecules with integer weights w[0..n-1]",
          "Detection range [l,u] where u-l ≥ max(w)-min(w)",
          "Weights are positive integers"
        ],
        "goal": "Find any subset with total weight between l and u, or determine none exists",
        "mechanism": "Machine detects molecules if any subset has total weight within [l,u]; key constraint guarantees solution exists if molecules can reach both bounds",
        "success_condition": "Return indices of any subset with ∑w_i ∈ [l,u], or empty array if impossible"
      },
      "constraints": {
        "critical": [
          "u-l ≥ max(w) - min(w) (critical mathematical property)",
          "Subset must use distinct molecules (no repetition)",
          "If molecules can reach both ≤l and ≥u, solution must exist"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "n≤100, w_i≤100, u,l≤1000, all weights equal"
          },
          "2": {
            "points": 10,
            "req": "n≤100, w_i,u,l≤1000, max(w)-min(w)≤1"
          },
          "3": {
            "points": 12,
            "req": "n≤100, w_i,u,l≤1000"
          },
          "4": {
            "points": 15,
            "req": "n≤10,000, w_i,u,l≤10,000"
          },
          "5": {
            "points": 23,
            "req": "n≤10,000, w_i,u,l≤500,000"
          },
          "6": {
            "points": 31,
            "req": "n≤200,000, w_i,u,l≤2^31-1"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] find_subset(int l, int u, int[] w)",
        "available_api": {
          "find_subset": {
            "signature": "int[] find_subset(int l, int u, int[] w)",
            "params": "l: lower bound, u: upper bound, w: array of molecule weights",
            "returns": "Array of indices (0-indexed) forming valid subset, or empty array",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Return empty array if no solution exists",
          "Indices can be in any order",
          "Any valid subset is acceptable",
          "Must handle worst-case n=200,000 with large weights"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "4 15 17\n6 8 8 7",
          "output": "2\n2 1"
        }
      ],
      "original_statement": "Petr is working for a company that has built a machine for detecting molecules. Each molecule has a positive integer weight. The machine has a\ndetection range\n$$$[l, u]$$$, where $$$l$$$ and $$$u$$$ are positive integers. The machine can detect a set of molecules if and only if this set contains a subset of the molecules with total weight belonging to the machine's detection range.\nFormally, consider $$$n$$$ molecules with weights $$$w_0, \\ldots, w_{n - 1}$$$. The detection is successful if there is a set of distinct indices $$$I = {i_1, \\ldots , i_m}$$$ such that $$$l \\le w_{i_1} + \\ldots + w_{i_m} \\le u$$$.\nDue to specifics of the machine, the gap between $$$l$$$ and $$$u$$$ is guaranteed to be greater than or equal to the weight gap between the heaviest and the lightest molecule. Formally, $$$u - l \\ge w_{max} - w_{min}$$$, where $$$w_{max}=\\max(w_0, \\ldots, w_{n - 1})$$$ and $$$w_{min}=\\min(w_0, \\ldots, w_{n - 1})$$$.\nYour task is to write a program which either finds any one subset of molecules with total weight within the detection range, or determines that there is no such subset.\nImplementation details\nYou should implement one function (method):\nint[] find_subset(int l, int u, int[] w)\nl\nand\nu\n: the endpoints of the detection range,\nw\n: weights of the molecules.\nif the required subset exists, the function should return an array of indices of molecules that form any one such subset. If there are several correct answers, return any of them.\nif the required subset does not exist, the function should return an empty array.\nYour program may write the indices into the returned array in any order.\nPlease use the provided template files for details of implementation in your programming language.\nThe sample grader reads the input in the following format:\nInput\nline 1: integers $$$n$$$, $$$l$$$, $$$u$$$.\nline 2: $$$n$$$ integers: $$$w_0, \\ldots , w_{n - 1}$$$.\nOutput\nIf the required subset exists, the function should return an array of indices of molecules that form any one such subset. If there are several correct answers, return any of them.\nIf the required subset does not exist, the function should return an empty array.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$1 \\le n \\le 100$$$, $$$1 \\le w_i \\le 100$$$, $$$1 \\le u, l \\le 1000$$$, all $$$w_i$$$ are equal\n2\n10\n$$$1 \\le n \\le 100$$$, $$$1 \\le w_i, u, l \\le 1000$$$ and $$$\\max(w_0, \\ldots, w_{n - 1}) - \\min(w_0, \\ldots, w_{n - 1}) \\le 1$$$\n3\n12\n$$$1 \\le n \\le 100$$$ and $$$1 \\le w_i,u,l \\le 1000$$$\n4\n15\n$$$1 \\le n \\le 10\\,000$$$ and $$$1 \\le w_i,u,l \\le 10\\,000$$$\n5\n23\n$$$1 \\le n \\le 10\\,000$$$ and $$$1 \\le w_i,u,l \\le 500\\,000$$$\n6\n31\n$$$1 \\le n \\le 200\\,000$$$ and $$$1 \\le w_i,u,l \\le 2^{31} - 1$$$\nExamples\nNote\nExample 1\nfind_subset(15, 17, [6, 8, 8, 7])\nIn this example we have four molecules with weights 6, 8, 8 and 7. The machine can detect subsets of molecules with total weight between 15 and 17, inclusive. Note, that $$$17-15\\geq 8-6$$$. The total weight of molecules 1 and 3 is $$$w_1 + w_3 = 8 + 7 = 15$$$, so the function can return\n[1, 3]\n. Other possible correct answers are\n[1, 2]\n($$$w_1 + w_2 = 8 + 8 = 16$$$) and\n[2, 3]\n($$$w_2 + w_3 = 8 + 7 = 15$$$).\nExample 2\nfind_subset(14, 15, [5, 5, 6, 6])\nIn this example we have four molecules with weights 5, 5, 6 and 6, and we are looking for a subset of them with total weight between 14 and 15, inclusive. Again, note that $$$15 - 14 \\geq 6 - 5$$$. There is no subset of molecules with total weight between $$$14$$$ and $$$15$$$ so the function should return an empty array.\nExample 3\nfind_subset(10, 20, [15, 17, 16, 18])\nIn this example we have four molecules with weights 15, 17, 16 and 18, and we are looking for a subset of them with total weight between 10 and 20, inclusive. Again, note that $$$20 - 10 \\geq 18 - 15$$$. Any subset consisting of exactly one element has total weight between $$$10$$$ and $$$20$$$, so the possible correct answers are:\n[0]\n,\n[1]\n,\n[2]\nand\n[3]\n."
    },
    "original": "Petr is working for a company that has built a machine for detecting molecules. Each molecule has a positive integer weight. The machine has a\ndetection range\n$$$[l, u]$$$, where $$$l$$$ and $$$u$$$ are positive integers. The machine can detect a set of molecules if and only if this set contains a subset of the molecules with total weight belonging to the machine's detection range.\nFormally, consider $$$n$$$ molecules with weights $$$w_0, \\ldots, w_{n - 1}$$$. The detection is successful if there is a set of distinct indices $$$I = {i_1, \\ldots , i_m}$$$ such that $$$l \\le w_{i_1} + \\ldots + w_{i_m} \\le u$$$.\nDue to specifics of the machine, the gap between $$$l$$$ and $$$u$$$ is guaranteed to be greater than or equal to the weight gap between the heaviest and the lightest molecule. Formally, $$$u - l \\ge w_{max} - w_{min}$$$, where $$$w_{max}=\\max(w_0, \\ldots, w_{n - 1})$$$ and $$$w_{min}=\\min(w_0, \\ldots, w_{n - 1})$$$.\nYour task is to write a program which either finds any one subset of molecules with total weight within the detection range, or determines that there is no such subset.\nImplementation details\nYou should implement one function (method):\nint[] find_subset(int l, int u, int[] w)\nl\nand\nu\n: the endpoints of the detection range,\nw\n: weights of the molecules.\nif the required subset exists, the function should return an array of indices of molecules that form any one such subset. If there are several correct answers, return any of them.\nif the required subset does not exist, the function should return an empty array.\nYour program may write the indices into the returned array in any order.\nPlease use the provided template files for details of implementation in your programming language.\nThe sample grader reads the input in the following format:\nInput\nline 1: integers $$$n$$$, $$$l$$$, $$$u$$$.\nline 2: $$$n$$$ integers: $$$w_0, \\ldots , w_{n - 1}$$$.\nOutput\nIf the required subset exists, the function should return an array of indices of molecules that form any one such subset. If there are several correct answers, return any of them.\nIf the required subset does not exist, the function should return an empty array.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$1 \\le n \\le 100$$$, $$$1 \\le w_i \\le 100$$$, $$$1 \\le u, l \\le 1000$$$, all $$$w_i$$$ are equal\n2\n10\n$$$1 \\le n \\le 100$$$, $$$1 \\le w_i, u, l \\le 1000$$$ and $$$\\max(w_0, \\ldots, w_{n - 1}) - \\min(w_0, \\ldots, w_{n - 1}) \\le 1$$$\n3\n12\n$$$1 \\le n \\le 100$$$ and $$$1 \\le w_i,u,l \\le 1000$$$\n4\n15\n$$$1 \\le n \\le 10\\,000$$$ and $$$1 \\le w_i,u,l \\le 10\\,000$$$\n5\n23\n$$$1 \\le n \\le 10\\,000$$$ and $$$1 \\le w_i,u,l \\le 500\\,000$$$\n6\n31\n$$$1 \\le n \\le 200\\,000$$$ and $$$1 \\le w_i,u,l \\le 2^{31} - 1$$$\nExamples\nNote\nExample 1\nfind_subset(15, 17, [6, 8, 8, 7])\nIn this example we have four molecules with weights 6, 8, 8 and 7. The machine can detect subsets of molecules with total weight between 15 and 17, inclusive. Note, that $$$17-15\\geq 8-6$$$. The total weight of molecules 1 and 3 is $$$w_1 + w_3 = 8 + 7 = 15$$$, so the function can return\n[1, 3]\n. Other possible correct answers are\n[1, 2]\n($$$w_1 + w_2 = 8 + 8 = 16$$$) and\n[2, 3]\n($$$w_2 + w_3 = 8 + 7 = 15$$$).\nExample 2\nfind_subset(14, 15, [5, 5, 6, 6])\nIn this example we have four molecules with weights 5, 5, 6 and 6, and we are looking for a subset of them with total weight between 14 and 15, inclusive. Again, note that $$$15 - 14 \\geq 6 - 5$$$. There is no subset of molecules with total weight between $$$14$$$ and $$$15$$$ so the function should return an empty array.\nExample 3\nfind_subset(10, 20, [15, 17, 16, 18])\nIn this example we have four molecules with weights 15, 17, 16 and 18, and we are looking for a subset of them with total weight between 10 and 20, inclusive. Again, note that $$$20 - 10 \\geq 18 - 15$$$. Any subset consisting of exactly one element has total weight between $$$10$$$ and $$$20$$$, so the possible correct answers are:\n[0]\n,\n[1]\n,\n[2]\nand\n[3]\n.",
    "_meta": {
      "index": 52,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/A",
      "uuid": "ps_c5ea06c0a37ad8591eb81b31256bfd06839dbc86"
    }
  },
  {
    "planning_view": {
      "title": "C. Game",
      "task": "Answer connectivity queries to prevent early graph determination in ≤n(n-1)/2 rounds",
      "given": [
        "n cities numbered 0 to n-1",
        "Mei-Yu asks about every pair exactly once in unknown order",
        "Jian-Jia invents flight network as game progresses"
      ],
      "goal": "Prevent Mei-Yu from determining graph connectivity before all queries are asked",
      "key_rules": [
        "Answers must be consistent with some simple graph",
        "Must answer immediately without knowing future queries",
        "Queries come in arbitrary order (adversarial)"
      ],
      "target": {
        "1": {
          "points": 15,
          "req": "n = 4"
        },
        "2": {
          "points": 27,
          "req": "4 ≤ n ≤ 80"
        },
        "3": {
          "points": 58,
          "req": "4 ≤ n ≤ 1500"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Game",
      "contest": "IOI 2014 day 1",
      "one_line": "Answer connectivity queries to prevent early graph determination in ≤n(n-1)/2 rounds",
      "given": [
        "n cities numbered 0 to n-1",
        "Mei-Yu asks about every pair exactly once in unknown order",
        "Jian-Jia invents flight network as game progresses"
      ],
      "goal": "Prevent Mei-Yu from determining graph connectivity before all queries are asked",
      "mechanism": "Answer each hasEdge(u,v) immediately; Mei-Yu wins if she can prove connectivity/disconnectivity early",
      "success_condition": "Jian-Jia wins if Mei-Yu needs all n(n-1)/2 queries to determine connectivity",
      "constraints": {
        "critical": [
          "Answers must be consistent with some simple graph",
          "Must answer immediately without knowing future queries",
          "Queries come in arbitrary order (adversarial)"
        ],
        "subtasks": {
          "1": {
            "points": 15,
            "req": "n = 4"
          },
          "2": {
            "points": 27,
            "req": "4 ≤ n ≤ 80"
          },
          "3": {
            "points": 58,
            "req": "4 ≤ n ≤ 1500"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Game",
        "contest": "IOI 2014 day 1",
        "one_line": "Answer connectivity queries to prevent early graph determination in ≤n(n-1)/2 rounds"
      },
      "problem": {
        "given": [
          "n cities numbered 0 to n-1",
          "Mei-Yu asks about every pair exactly once in unknown order",
          "Jian-Jia invents flight network as game progresses"
        ],
        "goal": "Prevent Mei-Yu from determining graph connectivity before all queries are asked",
        "mechanism": "Answer each hasEdge(u,v) immediately; Mei-Yu wins if she can prove connectivity/disconnectivity early",
        "success_condition": "Jian-Jia wins if Mei-Yu needs all n(n-1)/2 queries to determine connectivity"
      },
      "constraints": {
        "critical": [
          "Answers must be consistent with some simple graph",
          "Must answer immediately without knowing future queries",
          "Queries come in arbitrary order (adversarial)"
        ],
        "subtasks": {
          "1": {
            "points": 15,
            "req": "n = 4"
          },
          "2": {
            "points": 27,
            "req": "4 ≤ n ≤ 80"
          },
          "3": {
            "points": 58,
            "req": "4 ≤ n ≤ 1500"
          }
        }
      },
      "implementation": {
        "function_to_write": "int hasEdge(int u, int v)",
        "available_api": {
          "initialize": {
            "signature": "void initialize(int n)",
            "params": "n: number of cities",
            "returns": "none",
            "side_effect": "Called once at beginning to set up data structures"
          },
          "hasEdge": {
            "signature": "int hasEdge(int u, int v)",
            "params": "u, v: city indices (0 to n-1)",
            "returns": "1 if direct flight exists, 0 otherwise",
            "side_effect": "None; must answer immediately and consistently"
          }
        },
        "requirements": [
          "Cities are 0-indexed",
          "Must handle adversarial query order",
          "Answers must maintain graph consistency",
          "No global variables between test cases"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "4\n0 1\n3 0\n1 2\n0 2\n3 1\n2 3",
          "output": "100101"
        }
      ],
      "original_statement": "Jian-Jia is a young boy who loves playing games. When he is asked a question, he prefers playing games rather than answering directly. Jian-Jia met his friend Mei-Yu and told her about the flight network in Taiwan. There are $$$n$$$ cities in Taiwan (numbered $$$0, \\ldots, n - 1$$$), some of which are connected by flights. Each flight connects two cities and can be taken in both directions.\nMei-Yu asked Jian-Jia whether it is possible to go between any two cities by plane (either directly or indirectly). Jian-Jia did not want to reveal the answer, but instead suggested to play a game. Mei-Yu can ask him questions of the form \"Are cities $$$x$$$ and $$$y$$$\ndirectly\nconnected with a flight?\", and Jian-Jia will answer such questions immediately. Mei-Yu will ask about every pair of cities exactly once, giving $$$r = \\frac{n(n - 1)}{2}$$$ questions in total. Mei-Yu wins the game if, after obtaining the answers to the first $$$i$$$ questions for some $$$i < r$$$, she can infer whether or not it is possible to travel between every pair of cities by flights (either directly or indirectly). Otherwise, that is, if she needs all $$$r$$$ questions, then the winner is Jian-Jia.\nIn order for the game to be more fun for Jian-Jia, the friends agreed that he may forget about the real Taiwanese flight network, and invent the network as the game progresses, choosing his answers based on Mei-Yu's previous questions. Your task is to help Jian-Jia win the game, by deciding how he should answer the questions\nTask\nPlease write a program that helps Jian-Jia win the game. Note that neither Mei-Yu nor Jian-Jia knows the strategy of each other. Mei-Yu can ask about pairs of cities in any order, and Jian-Jia must answer them immediately without knowing the future questions. You need to implement the following two functions.\nvoid initialize(int n)\n— We will call your\ninitialize\nfirst. The parameter $$$n$$$ is the number of cities.\nint hasEdge(int u, int v)\n— Then we will call\nhasEdge\nfor $$$r = \\frac{n(n - 1)}{2}$$$ times. These calls represent Mei-Yu's questions, in the order that she asks them. You must answer whether there is a direct flight between cities $$$u$$$ and $$$v$$$. Specifically, the return value should be $$$1$$$ if there is a direct flight, or $$$0$$$ otherwise.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$\nthe following $$$r$$$ lines: each line contains two integers $$$u$$$ and $$$v$$$ that describe a question regarding cities $$$u$$$ and $$$v$$$.\nOutput\nFor each request the sample grader will return\n1\nif\nhasEdge\nreturn $$$1$$$ for and\n0\notherwise.\nScoring\nEach subtask consists of several games. You will only get points for a subtask if your program wins all of the games for Jian-Jia.\nSubtask\nPoints\n$$$n$$$\n1\n15\n$$$n = 4$$$\n2\n27\n$$$4 \\le n \\le 80$$$\n3\n58\n$$$4 \\le n \\le 1500$$$\nExamples\nNote\nWe explain the game rules with three examples. Each example has $$$n = 4$$$ cities and $$$r = 6$$$ rounds of question and answer.\nIn the first example (the following table), Jian-Jia\nloses\nbecause after round 4, Mei-Yu knows for certain that one can travel between any two cities by flights, no matter how Jian-Jia answers questions 5 or 6.\nRound\nQuestion\nAnswer\n1\n0, 1\nyes\n2\n3, 0\nyes\n3\n1, 2\nno\n4\n0, 2\nyes\n—\n—\n—\n5\n3, 1\nno\n6\n2, 3\nno\nIn the next example Mei-Yu can prove after round 3 that no matter how Jian-Jia answers questions 4, 5, or 6, one\ncannot\ntravel between cities 0 and 1 by flights, so Jian-Jia loses again.\nRound\nQuestion\nAnswer\n1\n0, 3\nno\n2\n2, 0\nno\n3\n0, 1\nno\n—\n—\n—\n4\n1, 2\nyes\n5\n1, 3\nyes\n6\n2, 3\nyes\nIn the final example Mei-Yu cannot determine whether one can travel between any two cities by flights until allsix questions are answered, so Jian-Jia\nwins\nthe game. Specifically, because Jian-Jia answered yes to the last question (in the following table), then it is possible to travel between any pair of cities. However, if Jian-Jia had answered no to the last question instead then it would be impossible.\nRound\nQuestion\nAnswer\n1\n0, 3\nno\n2\n1, 0\nyes\n3\n0, 2\nno\n4\n3, 1\nyes\n5\n1, 2\nno\n6\n2, 3\nyes"
    },
    "original": "Jian-Jia is a young boy who loves playing games. When he is asked a question, he prefers playing games rather than answering directly. Jian-Jia met his friend Mei-Yu and told her about the flight network in Taiwan. There are $$$n$$$ cities in Taiwan (numbered $$$0, \\ldots, n - 1$$$), some of which are connected by flights. Each flight connects two cities and can be taken in both directions.\nMei-Yu asked Jian-Jia whether it is possible to go between any two cities by plane (either directly or indirectly). Jian-Jia did not want to reveal the answer, but instead suggested to play a game. Mei-Yu can ask him questions of the form \"Are cities $$$x$$$ and $$$y$$$\ndirectly\nconnected with a flight?\", and Jian-Jia will answer such questions immediately. Mei-Yu will ask about every pair of cities exactly once, giving $$$r = \\frac{n(n - 1)}{2}$$$ questions in total. Mei-Yu wins the game if, after obtaining the answers to the first $$$i$$$ questions for some $$$i < r$$$, she can infer whether or not it is possible to travel between every pair of cities by flights (either directly or indirectly). Otherwise, that is, if she needs all $$$r$$$ questions, then the winner is Jian-Jia.\nIn order for the game to be more fun for Jian-Jia, the friends agreed that he may forget about the real Taiwanese flight network, and invent the network as the game progresses, choosing his answers based on Mei-Yu's previous questions. Your task is to help Jian-Jia win the game, by deciding how he should answer the questions\nTask\nPlease write a program that helps Jian-Jia win the game. Note that neither Mei-Yu nor Jian-Jia knows the strategy of each other. Mei-Yu can ask about pairs of cities in any order, and Jian-Jia must answer them immediately without knowing the future questions. You need to implement the following two functions.\nvoid initialize(int n)\n— We will call your\ninitialize\nfirst. The parameter $$$n$$$ is the number of cities.\nint hasEdge(int u, int v)\n— Then we will call\nhasEdge\nfor $$$r = \\frac{n(n - 1)}{2}$$$ times. These calls represent Mei-Yu's questions, in the order that she asks them. You must answer whether there is a direct flight between cities $$$u$$$ and $$$v$$$. Specifically, the return value should be $$$1$$$ if there is a direct flight, or $$$0$$$ otherwise.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$\nthe following $$$r$$$ lines: each line contains two integers $$$u$$$ and $$$v$$$ that describe a question regarding cities $$$u$$$ and $$$v$$$.\nOutput\nFor each request the sample grader will return\n1\nif\nhasEdge\nreturn $$$1$$$ for and\n0\notherwise.\nScoring\nEach subtask consists of several games. You will only get points for a subtask if your program wins all of the games for Jian-Jia.\nSubtask\nPoints\n$$$n$$$\n1\n15\n$$$n = 4$$$\n2\n27\n$$$4 \\le n \\le 80$$$\n3\n58\n$$$4 \\le n \\le 1500$$$\nExamples\nNote\nWe explain the game rules with three examples. Each example has $$$n = 4$$$ cities and $$$r = 6$$$ rounds of question and answer.\nIn the first example (the following table), Jian-Jia\nloses\nbecause after round 4, Mei-Yu knows for certain that one can travel between any two cities by flights, no matter how Jian-Jia answers questions 5 or 6.\nRound\nQuestion\nAnswer\n1\n0, 1\nyes\n2\n3, 0\nyes\n3\n1, 2\nno\n4\n0, 2\nyes\n—\n—\n—\n5\n3, 1\nno\n6\n2, 3\nno\nIn the next example Mei-Yu can prove after round 3 that no matter how Jian-Jia answers questions 4, 5, or 6, one\ncannot\ntravel between cities 0 and 1 by flights, so Jian-Jia loses again.\nRound\nQuestion\nAnswer\n1\n0, 3\nno\n2\n2, 0\nno\n3\n0, 1\nno\n—\n—\n—\n4\n1, 2\nyes\n5\n1, 3\nyes\n6\n2, 3\nyes\nIn the final example Mei-Yu cannot determine whether one can travel between any two cities by flights until allsix questions are answered, so Jian-Jia\nwins\nthe game. Specifically, because Jian-Jia answered yes to the last question (in the following table), then it is possible to travel between any pair of cities. However, if Jian-Jia had answered no to the last question instead then it would be impossible.\nRound\nQuestion\nAnswer\n1\n0, 3\nno\n2\n1, 0\nyes\n3\n0, 2\nno\n4\n3, 1\nyes\n5\n1, 2\nno\n6\n2, 3\nyes",
    "_meta": {
      "index": 53,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/C",
      "uuid": "ps_09884a23693f4f6a21dd86c749cce480c24aa521"
    }
  },
  {
    "planning_view": {
      "title": "A. Catfish Farm",
      "task": "Place piers in columns to catch maximum-weight catfish avoiding their cells",
      "given": [
        "N×N grid pond with M catfish at distinct cells",
        "Each catfish has weight W[i] at position (X[i], Y[i])",
        "Can build pier in each column (from row 0 to k-1) or none"
      ],
      "goal": "Maximize total weight of catchable catfish",
      "key_rules": [
        "Pier covers cells (c,0) to (c,k-1) for chosen length k",
        "Catfish caught if (X-1,Y) or (X+1,Y) has pier AND (X,Y) has no pier",
        "Must choose pier length (0 to N) for each column independently"
      ],
      "target": {
        "1": {
          "points": 3,
          "req": "All X[i] are even"
        },
        "2": {
          "points": 6,
          "req": "All X[i] ≤ 1"
        },
        "3": {
          "points": 9,
          "req": "All Y[i] = 0"
        },
        "4": {
          "points": 14,
          "req": "N ≤ 300, Y[i] ≤ 8"
        },
        "5": {
          "points": 21,
          "req": "N ≤ 300"
        },
        "6": {
          "points": 17,
          "req": "N ≤ 3000"
        },
        "7": {
          "points": 14,
          "req": "At most 2 catfish per column"
        },
        "8": {
          "points": 16,
          "req": "No constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Catfish Farm",
      "contest": "IOI 2022 day 1",
      "one_line": "Place piers in columns to catch maximum-weight catfish avoiding their cells",
      "given": [
        "N×N grid pond with M catfish at distinct cells",
        "Each catfish has weight W[i] at position (X[i], Y[i])",
        "Can build pier in each column (from row 0 to k-1) or none"
      ],
      "goal": "Maximize total weight of catchable catfish",
      "mechanism": "Catfish is catchable if has pier in adjacent column (west/east) and no pier in its own cell",
      "success_condition": "Maximum possible sum of weights of catchable catfish",
      "constraints": {
        "critical": [
          "Pier covers cells (c,0) to (c,k-1) for chosen length k",
          "Catfish caught if (X-1,Y) or (X+1,Y) has pier AND (X,Y) has no pier",
          "Must choose pier length (0 to N) for each column independently"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "All X[i] are even"
          },
          "2": {
            "points": 6,
            "req": "All X[i] ≤ 1"
          },
          "3": {
            "points": 9,
            "req": "All Y[i] = 0"
          },
          "4": {
            "points": 14,
            "req": "N ≤ 300, Y[i] ≤ 8"
          },
          "5": {
            "points": 21,
            "req": "N ≤ 300"
          },
          "6": {
            "points": 17,
            "req": "N ≤ 3000"
          },
          "7": {
            "points": 14,
            "req": "At most 2 catfish per column"
          },
          "8": {
            "points": 16,
            "req": "No constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Catfish Farm",
        "contest": "IOI 2022 day 1",
        "one_line": "Place piers in columns to catch maximum-weight catfish avoiding their cells"
      },
      "problem": {
        "given": [
          "N×N grid pond with M catfish at distinct cells",
          "Each catfish has weight W[i] at position (X[i], Y[i])",
          "Can build pier in each column (from row 0 to k-1) or none"
        ],
        "goal": "Maximize total weight of catchable catfish",
        "mechanism": "Catfish is catchable if has pier in adjacent column (west/east) and no pier in its own cell",
        "success_condition": "Maximum possible sum of weights of catchable catfish"
      },
      "constraints": {
        "critical": [
          "Pier covers cells (c,0) to (c,k-1) for chosen length k",
          "Catfish caught if (X-1,Y) or (X+1,Y) has pier AND (X,Y) has no pier",
          "Must choose pier length (0 to N) for each column independently"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "All X[i] are even"
          },
          "2": {
            "points": 6,
            "req": "All X[i] ≤ 1"
          },
          "3": {
            "points": 9,
            "req": "All Y[i] = 0"
          },
          "4": {
            "points": 14,
            "req": "N ≤ 300, Y[i] ≤ 8"
          },
          "5": {
            "points": 21,
            "req": "N ≤ 300"
          },
          "6": {
            "points": 17,
            "req": "N ≤ 3000"
          },
          "7": {
            "points": 14,
            "req": "At most 2 catfish per column"
          },
          "8": {
            "points": 16,
            "req": "No constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 max_weights(int N, int M, int[] X, int[] Y, int[] W)",
        "available_api": {},
        "requirements": [
          "Columns and rows 0-indexed (0 to N-1)",
          "Return int64 (long long in C++)",
          "No main() function",
          "Called exactly once"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "5 4\n0 2 5\n1 1 2\n4 4 1\n3 3 3",
          "output": "8"
        }
      ],
      "original_statement": "Bu Dengklek owns a catfish farm. The catfish farm is a pond consisting of a $$$N \\times N$$$ grid of cells. Each cell is a square of the same size. The columns of the grid are numbered from $$$0$$$ to $$$N - 1$$$ from west to east and the rows are numbered from $$$0$$$ to $$$N - 1$$$ from south to north. We refer to the cell located at column $$$c$$$ and row $$$r$$$ of the grid ($$$0 \\le c \\le N - 1$$$, $$$0 \\le r \\le N - 1$$$) as cell $$$(c, r)$$$.\nIn the pond, there are $$$M$$$ catfish, numbered from $$$0$$$ to $$$M - 1$$$, located at\ndistinct\ncells. For each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$, catfish $$$i$$$ is located at cell $$$(X[i], Y[i])$$$, and weighs $$$W[i]$$$ grams.\nBu Dengklek wants to build some piers to catch the catfish. A pier in column $$$c$$$ of length $$$k$$$ (for any $$$0 \\le c \\le N - 1$$$ and $$$1 \\le k \\le N$$$) is a rectangle extending from row $$$0$$$ to row $$$k - 1$$$, covering cells $$$(c, 0), (c, 1), \\ldots, (c, k - 1)$$$. For each column, Bu Dengklek can choose either to build a pier of some length of her choice or to not build a pier.\nCatfish $$$i$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$) can be caught if there is a pier directly to the west or east of it, and there is no pier covering its cell; that is, if\nat least one\nof the cells $$$(X[i] - 1, Y[i])$$$ or $$$(X[i] + 1, Y[i])$$$ is covered by a pier, and\nthere is no pier covering cell $$$(X[i], Y[i])$$$.\nFor example, consider a pond of size $$$N = 5$$$ with $$$M = 4$$$ catfish:\nCatfish $$$0$$$ is located at cell $$$(0, 2)$$$ and weighs $$$5$$$ grams.\nCatfish $$$1$$$ is located at cell $$$(1, 1)$$$ and weighs $$$2$$$ grams.\nCatfish $$$2$$$ is located at cell $$$(4, 4)$$$ and weighs $$$1$$$ gram.\nCatfish $$$3$$$ is located at cell $$$(3, 3)$$$ and weighs $$$3$$$ grams.\nOne way Bu Dengklek can build the piers is as follows:\nBefore the piers are built\nAfter the piers are built\nThe number at a cell denotes the weight of the catfish located at the cell. The shaded cells are covered by piers. In this case, catfish $$$0$$$ (at cell $$$(0, 2)$$$) and catfish $$$3$$$ (at cell $$$(3, 3)$$$) can be caught. Catfish $$$1$$$ (at cell $$$(1, 1)$$$) cannot be caught, as there is a pier covering its location, while catfish $$$2$$$ (at cell $$$(4, 4)$$$) can not be caught as there is no pier directly to the west nor east of it.\nBu Dengklek would like to build piers so that the total weight of catfish she can catch is as large as possible. Your task is to find the maximum total weight of catfish that Bu Dengklek can catch after building piers.\nImplementation Details\nYou should implement the following procedure:\nint64 max_weights(int N, int M, int[] X, int[] Y, int[] W)\n$$$N$$$: the size of the pond.\n$$$M$$$: the number of catfish.\n$$$X$$$, $$$Y$$$: arrays of length $$$M$$$ describing catfish locations.\n$$$W$$$: array of length $$$M$$$ describing catfish weights.\nThis procedure should return an integer representing the maximum total weight of catfish that Bu Dengklek can catch after building piers.\nThis procedure is called exactly once.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$2 \\le N \\le 100\\;000$$$, $$$1 \\le M \\le 300\\;000$$$)\nline $$$2 + i$$$ ($$$0 \\le i \\le M - 1$$$): $$$X[i] \\; Y[i] \\; W[i]$$$ ($$$0 \\le X[i] \\le N - 1$$$, $$$0 \\le Y[i] \\le N - 1$$$, $$$1 \\le W[i] \\le 10^9$$$)\nNo two catfish share the same cell. In other words, $$$X[i] \\neq X[j]$$$ or $$$Y[i] \\neq Y[j]$$$ (for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i \\textless j \\le M - 1$$$).\nOutput\nThe sample grader prints your answer in the following format:\nline $$$1$$$: the return value of\nmax_weights\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$X[i]$$$ is even (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n2\n6\n$$$X[i] \\le 1$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n3\n9\n$$$Y[i] = 0$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n4\n14\n$$$N \\le 300$$$, $$$Y[i] \\le 8$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n5\n21\n$$$N \\le 300$$$\n6\n17\n$$$N \\le 3000$$$\n7\n14\nThere are at most $$$2$$$ catfish in each column.\n8\n16\nNo additional constraints\nExample\nNote\nConsider the following call:\nmax_weights(5, 4, [0, 1, 4, 3], [2, 1, 4, 3], [5, 2, 1, 3])\nThis example is illustrated in the task description above.\nAfter building piers as described, Bu Dengklek can catch catfish $$$0$$$ and $$$3$$$, whose total weight is $$$5 + 3 = 8$$$ grams. As there is no way to build piers to catch catfish with a total weight of more than $$$8$$$ grams, the procedure should return $$$8$$$."
    },
    "original": "Bu Dengklek owns a catfish farm. The catfish farm is a pond consisting of a $$$N \\times N$$$ grid of cells. Each cell is a square of the same size. The columns of the grid are numbered from $$$0$$$ to $$$N - 1$$$ from west to east and the rows are numbered from $$$0$$$ to $$$N - 1$$$ from south to north. We refer to the cell located at column $$$c$$$ and row $$$r$$$ of the grid ($$$0 \\le c \\le N - 1$$$, $$$0 \\le r \\le N - 1$$$) as cell $$$(c, r)$$$.\nIn the pond, there are $$$M$$$ catfish, numbered from $$$0$$$ to $$$M - 1$$$, located at\ndistinct\ncells. For each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$, catfish $$$i$$$ is located at cell $$$(X[i], Y[i])$$$, and weighs $$$W[i]$$$ grams.\nBu Dengklek wants to build some piers to catch the catfish. A pier in column $$$c$$$ of length $$$k$$$ (for any $$$0 \\le c \\le N - 1$$$ and $$$1 \\le k \\le N$$$) is a rectangle extending from row $$$0$$$ to row $$$k - 1$$$, covering cells $$$(c, 0), (c, 1), \\ldots, (c, k - 1)$$$. For each column, Bu Dengklek can choose either to build a pier of some length of her choice or to not build a pier.\nCatfish $$$i$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$) can be caught if there is a pier directly to the west or east of it, and there is no pier covering its cell; that is, if\nat least one\nof the cells $$$(X[i] - 1, Y[i])$$$ or $$$(X[i] + 1, Y[i])$$$ is covered by a pier, and\nthere is no pier covering cell $$$(X[i], Y[i])$$$.\nFor example, consider a pond of size $$$N = 5$$$ with $$$M = 4$$$ catfish:\nCatfish $$$0$$$ is located at cell $$$(0, 2)$$$ and weighs $$$5$$$ grams.\nCatfish $$$1$$$ is located at cell $$$(1, 1)$$$ and weighs $$$2$$$ grams.\nCatfish $$$2$$$ is located at cell $$$(4, 4)$$$ and weighs $$$1$$$ gram.\nCatfish $$$3$$$ is located at cell $$$(3, 3)$$$ and weighs $$$3$$$ grams.\nOne way Bu Dengklek can build the piers is as follows:\nBefore the piers are built\nAfter the piers are built\nThe number at a cell denotes the weight of the catfish located at the cell. The shaded cells are covered by piers. In this case, catfish $$$0$$$ (at cell $$$(0, 2)$$$) and catfish $$$3$$$ (at cell $$$(3, 3)$$$) can be caught. Catfish $$$1$$$ (at cell $$$(1, 1)$$$) cannot be caught, as there is a pier covering its location, while catfish $$$2$$$ (at cell $$$(4, 4)$$$) can not be caught as there is no pier directly to the west nor east of it.\nBu Dengklek would like to build piers so that the total weight of catfish she can catch is as large as possible. Your task is to find the maximum total weight of catfish that Bu Dengklek can catch after building piers.\nImplementation Details\nYou should implement the following procedure:\nint64 max_weights(int N, int M, int[] X, int[] Y, int[] W)\n$$$N$$$: the size of the pond.\n$$$M$$$: the number of catfish.\n$$$X$$$, $$$Y$$$: arrays of length $$$M$$$ describing catfish locations.\n$$$W$$$: array of length $$$M$$$ describing catfish weights.\nThis procedure should return an integer representing the maximum total weight of catfish that Bu Dengklek can catch after building piers.\nThis procedure is called exactly once.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$2 \\le N \\le 100\\;000$$$, $$$1 \\le M \\le 300\\;000$$$)\nline $$$2 + i$$$ ($$$0 \\le i \\le M - 1$$$): $$$X[i] \\; Y[i] \\; W[i]$$$ ($$$0 \\le X[i] \\le N - 1$$$, $$$0 \\le Y[i] \\le N - 1$$$, $$$1 \\le W[i] \\le 10^9$$$)\nNo two catfish share the same cell. In other words, $$$X[i] \\neq X[j]$$$ or $$$Y[i] \\neq Y[j]$$$ (for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i \\textless j \\le M - 1$$$).\nOutput\nThe sample grader prints your answer in the following format:\nline $$$1$$$: the return value of\nmax_weights\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$X[i]$$$ is even (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n2\n6\n$$$X[i] \\le 1$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n3\n9\n$$$Y[i] = 0$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n4\n14\n$$$N \\le 300$$$, $$$Y[i] \\le 8$$$ (for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$)\n5\n21\n$$$N \\le 300$$$\n6\n17\n$$$N \\le 3000$$$\n7\n14\nThere are at most $$$2$$$ catfish in each column.\n8\n16\nNo additional constraints\nExample\nNote\nConsider the following call:\nmax_weights(5, 4, [0, 1, 4, 3], [2, 1, 4, 3], [5, 2, 1, 3])\nThis example is illustrated in the task description above.\nAfter building piers as described, Bu Dengklek can catch catfish $$$0$$$ and $$$3$$$, whose total weight is $$$5 + 3 = 8$$$ grams. As there is no way to build piers to catch catfish with a total weight of more than $$$8$$$ grams, the procedure should return $$$8$$$.",
    "_meta": {
      "index": 54,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/A",
      "uuid": "ps_fe973a5f5cf9aa7ea95cd9bbb8aabc8a3eed2b6e"
    }
  },
  {
    "planning_view": {
      "title": "A. Boxes",
      "task": "Deliver N souvenirs to teams on circle of length L, carrying ≤K at once, minimizing time and returning to start.",
      "given": [
        "Circle divided into L sections (0 to L-1)",
        "N teams at given sections",
        "Start at section 0 with all N souvenirs",
        "Aman can carry ≤K souvenirs at once"
      ],
      "goal": "Find minimum time to deliver all souvenirs and return to section 0",
      "key_rules": [
        "Circle wraps around: sections 0 and L-1 are adjacent",
        "Can only pick up souvenirs at section 0",
        "Must return to section 0 after final delivery",
        "Movement time depends only on distance traveled, not souvenirs carried"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "K = 1, N ≤ 1000"
        },
        "2": {
          "points": 10,
          "req": "K = N, N ≤ 1000"
        },
        "3": {
          "points": 15,
          "req": "N ≤ 10, K ≤ N"
        },
        "4": {
          "points": 15,
          "req": "N ≤ 1000, K ≤ N"
        },
        "5": {
          "points": 20,
          "req": "N ≤ 1e6, K ≤ 3000"
        },
        "6": {
          "points": 30,
          "req": "N ≤ 1e7, K ≤ N"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Boxes",
      "contest": "IOI 2015 day 1",
      "one_line": "Deliver N souvenirs to teams on circle of length L, carrying ≤K at once, minimizing time and returning to start.",
      "given": [
        "Circle divided into L sections (0 to L-1)",
        "N teams at given sections",
        "Start at section 0 with all N souvenirs",
        "Aman can carry ≤K souvenirs at once"
      ],
      "goal": "Find minimum time to deliver all souvenirs and return to section 0",
      "mechanism": "Move between adjacent sections (1 second per move), pick up souvenirs at section 0, drop off at team locations instantly",
      "success_condition": "Each of N teams receives exactly 1 souvenir, Aman returns to section 0",
      "constraints": {
        "critical": [
          "Circle wraps around: sections 0 and L-1 are adjacent",
          "Can only pick up souvenirs at section 0",
          "Must return to section 0 after final delivery",
          "Movement time depends only on distance traveled, not souvenirs carried"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "K = 1, N ≤ 1000"
          },
          "2": {
            "points": 10,
            "req": "K = N, N ≤ 1000"
          },
          "3": {
            "points": 15,
            "req": "N ≤ 10, K ≤ N"
          },
          "4": {
            "points": 15,
            "req": "N ≤ 1000, K ≤ N"
          },
          "5": {
            "points": 20,
            "req": "N ≤ 1e6, K ≤ 3000"
          },
          "6": {
            "points": 30,
            "req": "N ≤ 1e7, K ≤ N"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Boxes",
        "contest": "IOI 2015 day 1",
        "one_line": "Deliver N souvenirs to teams on circle of length L, carrying ≤K at once, minimizing time and returning to start."
      },
      "problem": {
        "given": [
          "Circle divided into L sections (0 to L-1)",
          "N teams at given sections",
          "Start at section 0 with all N souvenirs",
          "Aman can carry ≤K souvenirs at once"
        ],
        "goal": "Find minimum time to deliver all souvenirs and return to section 0",
        "mechanism": "Move between adjacent sections (1 second per move), pick up souvenirs at section 0, drop off at team locations instantly",
        "success_condition": "Each of N teams receives exactly 1 souvenir, Aman returns to section 0"
      },
      "constraints": {
        "critical": [
          "Circle wraps around: sections 0 and L-1 are adjacent",
          "Can only pick up souvenirs at section 0",
          "Must return to section 0 after final delivery",
          "Movement time depends only on distance traveled, not souvenirs carried"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "K = 1, N ≤ 1000"
          },
          "2": {
            "points": 10,
            "req": "K = N, N ≤ 1000"
          },
          "3": {
            "points": 15,
            "req": "N ≤ 10, K ≤ N"
          },
          "4": {
            "points": 15,
            "req": "N ≤ 1000, K ≤ N"
          },
          "5": {
            "points": 20,
            "req": "N ≤ 1e6, K ≤ 3000"
          },
          "6": {
            "points": 30,
            "req": "N ≤ 1e7, K ≤ N"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 delivery(int N, int K, int L, int positions[])",
        "available_api": {
          "delivery": {
            "signature": "int64 delivery(int N, int K, int L, int positions[])",
            "params": "N: number of teams, K: carrying capacity, L: circle size, positions[]: sorted team positions",
            "returns": "Minimum seconds to deliver all souvenirs and return to start",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Positions array is non-decreasing",
          "Return type is int64 for large results",
          "L can be up to 1e9, N up to 1e7"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "3 2 100\n10 47 60",
          "output": "120"
        }
      ],
      "original_statement": "The last act of the IOI 2015 opening ceremony is in progress. During the opening ceremony, each team was supposed to receive a box with a souvenir from the host. However, all volunteers are so fascinated by the ceremony that they completely forgot about the souvenirs. The only person who remembers about the souvenirs is Aman. He is an enthusiastic volunteer and he wants the IOI to be perfect, so he wants to deliver all the souvenirs in the least amount of time.\nThe venue of the opening ceremony is a circle divided into $$$L$$$ identical sections. The sections around the circle are numbered consecutively from $$$0$$$ to $$$L - 1$$$. That is, for $$$0 \\le i \\le L - 2$$$, sections $$$i$$$ and $$$i + 1$$$ are adjacent, and also sections $$$0$$$ and $$$L - 1$$$ are adjacent. There are $$$N$$$ teams at the venue. Each team is sitting in one of the sections. Each section may contain arbitrarily many teams.\nThere are $$$N$$$ identical souvenirs. Initially, both Aman and all of the souvenirs are in section $$$0$$$. Aman should give one souvenir to each team, and after delivering the last souvenir he must return to section $$$0$$$. Note that some teams may be sitting in section $$$0$$$.\nAt any moment, Aman can only carry at most $$$K$$$ souvenirs. Aman must pick up souvenirs in section $$$0$$$, and this takes him no time. Each souvenir must be carried until it is delivered to one of the teams. Whenever Aman carries one or more souvenirs and reaches a section with a team that has not received a souvenir yet, he may give that team one of the souvenirs he carries. This also happens instantly. The only thing that takes time is movement. Aman can move around the circular venue in both directions. Moving to an adjacent section (either clockwise or counterclockwise) takes him exactly one second, regardless of how many souvenirs he carries.\nYour task is to find the smallest number of seconds Aman needs to deliver all souvenirs and then return to his initial position.\nYou are given $$$N$$$, $$$K$$$, $$$L$$$, and the positions of all teams. Compute the smallest number of seconds Aman needs to deliver all the souvenirs and to return to section $$$0$$$. You need to implement the function $$$delivery$$$:\n$$$int64\\ delivery(int\\ N, int\\ K, int\\ L, int\\ positions[])$$$ — This function will be called by the grader exactly once.\n$$$N$$$: the number of teams.\n$$$K$$$: the maximum number of souvenirs Aman can carry at the same\ntime.\n$$$L$$$: the number of sections in the venue of the opening ceremony.\n$$$positions$$$: an array of length $$$N$$$. $$$positions[0], \\ldots, positions[N - 1]$$$ give the section number of all teams. The elements of $$$positions$$$ are in non-decreasing order.\nThe function should return the smallest number of seconds in which Aman can complete his task.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N\\ K\\ L$$$\nline $$$2$$$: $$$positions[0] \\ldots positions[N - 1]$$$\nOutput\nThe sample grader prints the return value of\ndelivery\n.\nScoring\nsubtask\npoints\n$$$N$$$\n$$$K$$$\n$$$L$$$\n1\n10\n$$$1 \\le N \\le 1000$$$\n$$$K = 1$$$\n$$$1 \\le L \\le 10^9$$$\n2\n10\n$$$1 \\le N \\le 1000$$$\n$$$K = N$$$\n$$$1 \\le L \\le 10^9$$$\n3\n15\n$$$1 \\le N \\le 10$$$\n$$$1 \\le K \\le N$$$\n$$$1 \\le L \\le 10^9$$$\n4\n15\n$$$1 \\le N \\le 1000$$$\n$$$1 \\le K \\le N$$$\n$$$1 \\le L \\le 10^9$$$\n5\n20\n$$$1 \\le N \\le 10^6$$$\n$$$1\\le K \\le 3000$$$\n$$$1 \\le L \\le 10^9$$$\n6\n30\n$$$1 \\le N \\le 10^7$$$\n$$$1 \\le K \\le N$$$\n$$$1 \\le L \\le 10^9$$$\nExample\nNote\nIn the example we have $$$N = 3$$$ teams, Aman's carrying capacity is $$$K = 2$$$, and the number of sections is $$$L = 8$$$. The teams are located in sections $$$1$$$, $$$2$$$, and $$$5$$$.\nOne of the optimal solutions is shown in the picture above. In his first trip Aman takes two souvenirs, delivers one to the team in section $$$2$$$, then the other to the team in section $$$5$$$, and finally he returns to section $$$0$$$. This trip takes $$$8$$$ seconds. In his second trip Aman brings the remaining souvenir to the team in section $$$1$$$ and then returns to section $$$0$$$. He needs another $$$2$$$ seconds to do this. Thus, the total time is $$$10$$$ seconds."
    },
    "original": "The last act of the IOI 2015 opening ceremony is in progress. During the opening ceremony, each team was supposed to receive a box with a souvenir from the host. However, all volunteers are so fascinated by the ceremony that they completely forgot about the souvenirs. The only person who remembers about the souvenirs is Aman. He is an enthusiastic volunteer and he wants the IOI to be perfect, so he wants to deliver all the souvenirs in the least amount of time.\nThe venue of the opening ceremony is a circle divided into $$$L$$$ identical sections. The sections around the circle are numbered consecutively from $$$0$$$ to $$$L - 1$$$. That is, for $$$0 \\le i \\le L - 2$$$, sections $$$i$$$ and $$$i + 1$$$ are adjacent, and also sections $$$0$$$ and $$$L - 1$$$ are adjacent. There are $$$N$$$ teams at the venue. Each team is sitting in one of the sections. Each section may contain arbitrarily many teams.\nThere are $$$N$$$ identical souvenirs. Initially, both Aman and all of the souvenirs are in section $$$0$$$. Aman should give one souvenir to each team, and after delivering the last souvenir he must return to section $$$0$$$. Note that some teams may be sitting in section $$$0$$$.\nAt any moment, Aman can only carry at most $$$K$$$ souvenirs. Aman must pick up souvenirs in section $$$0$$$, and this takes him no time. Each souvenir must be carried until it is delivered to one of the teams. Whenever Aman carries one or more souvenirs and reaches a section with a team that has not received a souvenir yet, he may give that team one of the souvenirs he carries. This also happens instantly. The only thing that takes time is movement. Aman can move around the circular venue in both directions. Moving to an adjacent section (either clockwise or counterclockwise) takes him exactly one second, regardless of how many souvenirs he carries.\nYour task is to find the smallest number of seconds Aman needs to deliver all souvenirs and then return to his initial position.\nYou are given $$$N$$$, $$$K$$$, $$$L$$$, and the positions of all teams. Compute the smallest number of seconds Aman needs to deliver all the souvenirs and to return to section $$$0$$$. You need to implement the function $$$delivery$$$:\n$$$int64\\ delivery(int\\ N, int\\ K, int\\ L, int\\ positions[])$$$ — This function will be called by the grader exactly once.\n$$$N$$$: the number of teams.\n$$$K$$$: the maximum number of souvenirs Aman can carry at the same\ntime.\n$$$L$$$: the number of sections in the venue of the opening ceremony.\n$$$positions$$$: an array of length $$$N$$$. $$$positions[0], \\ldots, positions[N - 1]$$$ give the section number of all teams. The elements of $$$positions$$$ are in non-decreasing order.\nThe function should return the smallest number of seconds in which Aman can complete his task.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N\\ K\\ L$$$\nline $$$2$$$: $$$positions[0] \\ldots positions[N - 1]$$$\nOutput\nThe sample grader prints the return value of\ndelivery\n.\nScoring\nsubtask\npoints\n$$$N$$$\n$$$K$$$\n$$$L$$$\n1\n10\n$$$1 \\le N \\le 1000$$$\n$$$K = 1$$$\n$$$1 \\le L \\le 10^9$$$\n2\n10\n$$$1 \\le N \\le 1000$$$\n$$$K = N$$$\n$$$1 \\le L \\le 10^9$$$\n3\n15\n$$$1 \\le N \\le 10$$$\n$$$1 \\le K \\le N$$$\n$$$1 \\le L \\le 10^9$$$\n4\n15\n$$$1 \\le N \\le 1000$$$\n$$$1 \\le K \\le N$$$\n$$$1 \\le L \\le 10^9$$$\n5\n20\n$$$1 \\le N \\le 10^6$$$\n$$$1\\le K \\le 3000$$$\n$$$1 \\le L \\le 10^9$$$\n6\n30\n$$$1 \\le N \\le 10^7$$$\n$$$1 \\le K \\le N$$$\n$$$1 \\le L \\le 10^9$$$\nExample\nNote\nIn the example we have $$$N = 3$$$ teams, Aman's carrying capacity is $$$K = 2$$$, and the number of sections is $$$L = 8$$$. The teams are located in sections $$$1$$$, $$$2$$$, and $$$5$$$.\nOne of the optimal solutions is shown in the picture above. In his first trip Aman takes two souvenirs, delivers one to the team in section $$$2$$$, then the other to the team in section $$$5$$$, and finally he returns to section $$$0$$$. This trip takes $$$8$$$ seconds. In his second trip Aman brings the remaining souvenir to the team in section $$$1$$$ and then returns to section $$$0$$$. He needs another $$$2$$$ seconds to do this. Thus, the total time is $$$10$$$ seconds.",
    "_meta": {
      "index": 55,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/A",
      "uuid": "ps_1484f759c0eb6f66e64f83fcdb2358282a37730f"
    }
  },
  {
    "planning_view": {
      "title": "Pebbling odometer - subtask 1",
      "task": "Move to cell (0,0) if x≤y else (0,1) using ≤100 program size and ≤1000 steps",
      "given": [
        "256x256 grid with border at edges",
        "Start at (0,0) facing north",
        "x pebbles in (0,0), y in (0,1), others empty",
        "Max 15 pebbles per cell"
      ],
      "goal": "Position odometer in correct cell based on pebble count comparison",
      "key_rules": [
        "Program size ≤ 100 (commands, excluding labels/comments)",
        "Execution length ≤ 1000 steps",
        "Cells can hold max 15 pebbles",
        "Start facing north at (0,0)",
        "Only specified cells have pebbles initially"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "End at correct cell (pebble counts don't matter)"
        }
      }
    },
    "algorithm_view": {
      "title": "Pebbling odometer - subtask 1",
      "contest": "IOI 2012 day 1",
      "one_line": "Move to cell (0,0) if x≤y else (0,1) using ≤100 program size and ≤1000 steps",
      "given": [
        "256x256 grid with border at edges",
        "Start at (0,0) facing north",
        "x pebbles in (0,0), y in (0,1), others empty",
        "Max 15 pebbles per cell"
      ],
      "goal": "Position odometer in correct cell based on pebble count comparison",
      "mechanism": "Odometer program uses commands: move, turn, get/put pebbles, conditional jumps based on borders/pebbles",
      "success_condition": "End at (0,0) if x≤y, (0,1) if x>y",
      "constraints": {
        "critical": [
          "Program size ≤ 100 (commands, excluding labels/comments)",
          "Execution length ≤ 1000 steps",
          "Cells can hold max 15 pebbles",
          "Start facing north at (0,0)",
          "Only specified cells have pebbles initially"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "End at correct cell (pebble counts don't matter)"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "Pebbling odometer - subtask 1",
        "contest": "IOI 2012 day 1",
        "one_line": "Move to cell (0,0) if x≤y else (0,1) using ≤100 program size and ≤1000 steps"
      },
      "problem": {
        "given": [
          "256x256 grid with border at edges",
          "Start at (0,0) facing north",
          "x pebbles in (0,0), y in (0,1), others empty",
          "Max 15 pebbles per cell"
        ],
        "goal": "Position odometer in correct cell based on pebble count comparison",
        "mechanism": "Odometer program uses commands: move, turn, get/put pebbles, conditional jumps based on borders/pebbles",
        "success_condition": "End at (0,0) if x≤y, (0,1) if x>y"
      },
      "constraints": {
        "critical": [
          "Program size ≤ 100 (commands, excluding labels/comments)",
          "Execution length ≤ 1000 steps",
          "Cells can hold max 15 pebbles",
          "Start facing north at (0,0)",
          "Only specified cells have pebbles initially"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "End at correct cell (pebble counts don't matter)"
          }
        }
      },
      "implementation": {
        "function_to_write": "Odometer program file",
        "available_api": {
          "left": {
            "signature": "left",
            "params": "none",
            "returns": "none",
            "side_effect": "Turn 90° counter-clockwise in place"
          },
          "right": {
            "signature": "right",
            "params": "none",
            "returns": "none",
            "side_effect": "Turn 90° clockwise in place"
          },
          "move": {
            "signature": "move",
            "params": "none",
            "returns": "none",
            "side_effect": "Move forward one cell if possible"
          },
          "get": {
            "signature": "get",
            "params": "none",
            "returns": "none",
            "side_effect": "Remove one pebble from current cell if available"
          },
          "put": {
            "signature": "put",
            "params": "none",
            "returns": "none",
            "side_effect": "Add one pebble to current cell if <15 pebbles"
          },
          "jump": {
            "signature": "jump L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Jump to label L unconditionally"
          },
          "border": {
            "signature": "border L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Jump to L if at border facing edge"
          },
          "pebble": {
            "signature": "pebble L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Jump to L if current cell has ≥1 pebble"
          }
        },
        "requirements": [
          "Submit as odometer language program file",
          "Maximum file size: 5 MiB",
          "Use # for comments, labels with :",
          "Commands executed sequentially unless jumped"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$."
    },
    "original": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$.",
    "_meta": {
      "index": 56,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A1",
      "uuid": "ps_f50799b1ba1ca947d7b3f8d77c9effe8e3886c05"
    }
  },
  {
    "planning_view": {
      "title": "E. Dungeons Game",
      "task": "Simulate hero's dungeon traversal with strength gains for ≤50k queries",
      "given": [
        "n opponents in dungeons 0 to n-1",
        "Each opponent i has strength s[i] and loss gain p[i]",
        "Win moves to w[i], lose moves to l[i]",
        "Game ends when hero enters dungeon n"
      ],
      "goal": "Compute final strength after all confrontations for each (start, strength) simulation",
      "key_rules": [
        "Game always ends after finite steps",
        "Opponents remain in place after confrontation",
        "w[i] > i (win always progresses forward)",
        "l[i] can be any dungeon (0 to n)"
      ],
      "target": {
        "1": {
          "points": 11,
          "req": "n ≤ 50,000, q ≤ 100, s[i],p[i] ≤ 10,000"
        },
        "2": {
          "points": 26,
          "req": "s[i] = p[i] for all i"
        },
        "3": {
          "points": 13,
          "req": "n ≤ 50,000, all s[i] equal"
        },
        "4": {
          "points": 12,
          "req": "n ≤ 50,000, ≤5 distinct s[i] values"
        },
        "5": {
          "points": 27,
          "req": "n ≤ 50,000"
        },
        "6": {
          "points": 11,
          "req": "n ≤ 400,000, q ≤ 50,000"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Dungeons Game",
      "contest": "IOI 2021 day 2",
      "one_line": "Simulate hero's dungeon traversal with strength gains for ≤50k queries",
      "given": [
        "n opponents in dungeons 0 to n-1",
        "Each opponent i has strength s[i] and loss gain p[i]",
        "Win moves to w[i], lose moves to l[i]",
        "Game ends when hero enters dungeon n"
      ],
      "goal": "Compute final strength after all confrontations for each (start, strength) simulation",
      "mechanism": "Hero confronts opponent i: if strength ≥ s[i], win → gain s[i], move to w[i]; else lose → gain p[i], move to l[i]",
      "success_condition": "Return hero's strength when dungeon n is reached",
      "constraints": {
        "critical": [
          "Game always ends after finite steps",
          "Opponents remain in place after confrontation",
          "w[i] > i (win always progresses forward)",
          "l[i] can be any dungeon (0 to n)"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "n ≤ 50,000, q ≤ 100, s[i],p[i] ≤ 10,000"
          },
          "2": {
            "points": 26,
            "req": "s[i] = p[i] for all i"
          },
          "3": {
            "points": 13,
            "req": "n ≤ 50,000, all s[i] equal"
          },
          "4": {
            "points": 12,
            "req": "n ≤ 50,000, ≤5 distinct s[i] values"
          },
          "5": {
            "points": 27,
            "req": "n ≤ 50,000"
          },
          "6": {
            "points": 11,
            "req": "n ≤ 400,000, q ≤ 50,000"
          }
        }
      },
      "limits": {
        "time": "8 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Dungeons Game",
        "contest": "IOI 2021 day 2",
        "one_line": "Simulate hero's dungeon traversal with strength gains for ≤50k queries"
      },
      "problem": {
        "given": [
          "n opponents in dungeons 0 to n-1",
          "Each opponent i has strength s[i] and loss gain p[i]",
          "Win moves to w[i], lose moves to l[i]",
          "Game ends when hero enters dungeon n"
        ],
        "goal": "Compute final strength after all confrontations for each (start, strength) simulation",
        "mechanism": "Hero confronts opponent i: if strength ≥ s[i], win → gain s[i], move to w[i]; else lose → gain p[i], move to l[i]",
        "success_condition": "Return hero's strength when dungeon n is reached"
      },
      "constraints": {
        "critical": [
          "Game always ends after finite steps",
          "Opponents remain in place after confrontation",
          "w[i] > i (win always progresses forward)",
          "l[i] can be any dungeon (0 to n)"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "n ≤ 50,000, q ≤ 100, s[i],p[i] ≤ 10,000"
          },
          "2": {
            "points": 26,
            "req": "s[i] = p[i] for all i"
          },
          "3": {
            "points": 13,
            "req": "n ≤ 50,000, all s[i] equal"
          },
          "4": {
            "points": 12,
            "req": "n ≤ 50,000, ≤5 distinct s[i] values"
          },
          "5": {
            "points": 27,
            "req": "n ≤ 50,000"
          },
          "6": {
            "points": 11,
            "req": "n ≤ 400,000, q ≤ 50,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 simulate(int x, int z)",
        "available_api": {
          "init": {
            "signature": "void init(int n, int[] s, int[] p, int[] w, int[] l)",
            "params": "n: number of opponents; s,p,w,l: arrays of length n with opponent properties",
            "returns": "void",
            "side_effect": "Initializes game state for subsequent simulate calls"
          },
          "simulate": {
            "signature": "int64 simulate(int x, int z)",
            "params": "x: starting dungeon (0 ≤ x ≤ n-1), z: starting strength",
            "returns": "Hero's final strength when reaching dungeon n",
            "side_effect": "None"
          }
        },
        "requirements": [
          "init called once before any simulate calls",
          "simulate called exactly q times",
          "Return type is int64 (64-bit integer)",
          "Arrays are 0-indexed"
        ]
      },
      "limits": {
        "time": "8 seconds",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "3 2\n2 6 9\n3 1 2\n2 2 3\n1 0 1\n0 1\n2 3",
          "output": "24\n25"
        }
      ],
      "original_statement": "Robert is designing a new computer game. The game involves one hero, $$$n$$$ opponents and $$$n+1$$$ dungeons. The opponents are numbered from $$$0$$$ to $$$n-1$$$ and the dungeons are numbered from $$$0$$$ to $$$n$$$. Opponent $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) is located in dungeon $$$i$$$ and has strength $$$s[i]$$$. There is no opponent in dungeon $$$n$$$.\nThe hero starts off entering dungeon $$$x$$$, with strength $$$z$$$. Every time the hero enters any dungeon $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), they confront opponent $$$i$$$, and one of the following occurs:\nIf the hero's strength is greater than or equal to the opponent's strength $$$s[i]$$$, the hero wins. This causes the hero's strength to\nincrease\nby $$$s[i]$$$ ($$$s[i] \\geq 1$$$). In this case the hero enters dungeon $$$w[i]$$$ next ($$$w[i] > i$$$).\nOtherwise, the hero loses. This causes the hero's strength to\nincrease\nby $$$p[i]$$$ ($$$p[i] \\geq 1$$$). In this case the hero enters dungeon $$$l[i]$$$ next.\nNote $$$p[i]$$$ may be less than, equal to, or greater than $$$s[i]$$$. Also, $$$l[i]$$$ may be less than, equal to, or greater than $$$i$$$. Regardless of the outcome of the confrontation, the opponent remains in dungeon $$$i$$$ and maintains strength $$$s[i]$$$.\nThe game ends when the hero enters dungeon $$$n$$$. One can show that the game ends after a finite number of confrontations, regardless of the hero's starting dungeon and strength.\nRobert asked you to test his game by running $$$q$$$ simulations. For each simulation, Robert defines a starting dungeon $$$x$$$ and starting strength $$$z$$$. Your task is to find out, for each simulation, the hero's strength when the game ends.\nImplementation details\nYou should implement the following procedures:\nvoid init(int n, int[] s, int[] p, int[] w, int[] l)\n$$$n$$$: number of opponents.\n$$$s$$$, $$$p$$$, $$$w$$$, $$$l$$$: arrays of length $$$n$$$. For $$$0 \\leq i \\leq n-1$$$:\n$$$s[i]$$$ is the strength of the opponent $$$i$$$. It is also the strength gained by the hero after winning against opponent $$$i$$$.\n$$$p[i]$$$ is the strength gained by the hero after losing against opponent $$$i$$$.\n$$$w[i]$$$ is the dungeon the hero enters after winning against opponent $$$i$$$.\n$$$l[i]$$$ is the dungeon the hero enters after losing against opponent $$$i$$$.\nThis procedure is called exactly once, before any calls to\nsimulate\n(see below)\nint64 simulate(int x, int z)\n$$$x$$$: the dungeon the hero enters first.\n$$$z$$$: the hero's starting strength.\nThis procedure should return the hero's strength when the game ends, assuming the hero starts the game by entering dungeon $$$x$$$, having strength $$$z$$$.\nThe procedure is called exactly $$$q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ q$$$ ($$$1 \\leq n \\leq 400\\,000$$$, $$$1 \\leq q \\leq 50\\,000$$$)\nline $$$2$$$: $$$s[0]\\ s[1]\\ldots \\ s[n-1]$$$ ($$$1 \\leq s[i] \\leq 10^{7}$$$)\nline $$$3$$$: $$$p[0]\\ p[1]\\ldots \\ p[n-1]$$$ ($$$1 \\leq p[i] \\leq 10^{7}$$$)\nline $$$4$$$: $$$w[0]\\ w[1]\\ldots \\ w[n-1]$$$ ($$$i < w[i] \\leq n$$$)\nline $$$5$$$: $$$l[0]\\ l[1]\\ldots \\ l[n-1]$$$ ($$$0 \\leq l[i] \\leq n$$$)\nline $$$6 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): $$$x\\ z$$$ ($$$0 \\leq x \\leq n-1$$$, $$$1 \\leq z \\leq 10^{7}$$$) for the $$$i$$$-th call to\nsimulate\n.\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + i$$$ ($$$0 \\leq i \\leq q - 1$$$) : the return value of the $$$i$$$-th call to\nsimulate\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$n \\leq 50\\,000$$$, $$$q \\leq 100$$$, $$$s[i], p[i] \\leq 10\\,000$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n2\n26\n$$$s[i] = p[i]$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n3\n13\n$$$n \\leq 50\\,000$$$, all opponents have the same strength, in other words, $$$s[i]=s[j]$$$ for all $$$0 \\leq i,j \\leq n-1$$$.\n4\n12\n$$$n \\leq 50\\,000$$$, there are at most $$$5$$$ distinct values among all values of $$$s[i]$$$.\n5\n27\n$$$n \\leq 50\\,000$$$\n6\n11\nNo additional constraints.\nExample\nNote\nExample\nConsider the following call:\ninit(3, [2, 6, 9], [3, 1, 2], [2, 2, 3], [1, 0, 1])\nThe diagram above illustrates this call. Each square shows a dungeon. For dungeons $$$0$$$, $$$1$$$ and $$$2$$$, the values $$$s[i]$$$ and $$$p[i]$$$ are indicated inside the squares. Magenta arrows indicate where the hero moves after winning a confrontation, while black arrows indicate where the hero moves after losing.\nLet's say the grader calls\nsimulate(0, 1)\n.\nThe game proceeds as follows:\nDungeon\nHero's strength before confrontation\nResult\n$$$0$$$\n$$$1$$$\nLose\n$$$1$$$\n$$$4$$$\nLose\n$$$0$$$\n$$$5$$$\nWin\n$$$2$$$\n$$$7$$$\nLose\n$$$1$$$\n$$$9$$$\nWin\n$$$2$$$\n$$$15$$$\nWin\n$$$3$$$\n$$$24$$$\nGame ends\nAs such, the procedure should return $$$24$$$.\nLet's say the grader calls\nsimulate(2, 3)\n.\nThe game proceeds as follows:\nDungeon\nHero's strength before confrontation\nResult\n$$$2$$$\n$$$3$$$\nLose\n$$$1$$$\n$$$5$$$\nLose\n$$$0$$$\n$$$6$$$\nWin\n$$$2$$$\n$$$8$$$\nLose\n$$$1$$$\n$$$10$$$\nWin\n$$$2$$$\n$$$16$$$\nWin\n$$$3$$$\n$$$25$$$\nGame ends\nAs such, the procedure should return $$$25$$$."
    },
    "original": "Robert is designing a new computer game. The game involves one hero, $$$n$$$ opponents and $$$n+1$$$ dungeons. The opponents are numbered from $$$0$$$ to $$$n-1$$$ and the dungeons are numbered from $$$0$$$ to $$$n$$$. Opponent $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) is located in dungeon $$$i$$$ and has strength $$$s[i]$$$. There is no opponent in dungeon $$$n$$$.\nThe hero starts off entering dungeon $$$x$$$, with strength $$$z$$$. Every time the hero enters any dungeon $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), they confront opponent $$$i$$$, and one of the following occurs:\nIf the hero's strength is greater than or equal to the opponent's strength $$$s[i]$$$, the hero wins. This causes the hero's strength to\nincrease\nby $$$s[i]$$$ ($$$s[i] \\geq 1$$$). In this case the hero enters dungeon $$$w[i]$$$ next ($$$w[i] > i$$$).\nOtherwise, the hero loses. This causes the hero's strength to\nincrease\nby $$$p[i]$$$ ($$$p[i] \\geq 1$$$). In this case the hero enters dungeon $$$l[i]$$$ next.\nNote $$$p[i]$$$ may be less than, equal to, or greater than $$$s[i]$$$. Also, $$$l[i]$$$ may be less than, equal to, or greater than $$$i$$$. Regardless of the outcome of the confrontation, the opponent remains in dungeon $$$i$$$ and maintains strength $$$s[i]$$$.\nThe game ends when the hero enters dungeon $$$n$$$. One can show that the game ends after a finite number of confrontations, regardless of the hero's starting dungeon and strength.\nRobert asked you to test his game by running $$$q$$$ simulations. For each simulation, Robert defines a starting dungeon $$$x$$$ and starting strength $$$z$$$. Your task is to find out, for each simulation, the hero's strength when the game ends.\nImplementation details\nYou should implement the following procedures:\nvoid init(int n, int[] s, int[] p, int[] w, int[] l)\n$$$n$$$: number of opponents.\n$$$s$$$, $$$p$$$, $$$w$$$, $$$l$$$: arrays of length $$$n$$$. For $$$0 \\leq i \\leq n-1$$$:\n$$$s[i]$$$ is the strength of the opponent $$$i$$$. It is also the strength gained by the hero after winning against opponent $$$i$$$.\n$$$p[i]$$$ is the strength gained by the hero after losing against opponent $$$i$$$.\n$$$w[i]$$$ is the dungeon the hero enters after winning against opponent $$$i$$$.\n$$$l[i]$$$ is the dungeon the hero enters after losing against opponent $$$i$$$.\nThis procedure is called exactly once, before any calls to\nsimulate\n(see below)\nint64 simulate(int x, int z)\n$$$x$$$: the dungeon the hero enters first.\n$$$z$$$: the hero's starting strength.\nThis procedure should return the hero's strength when the game ends, assuming the hero starts the game by entering dungeon $$$x$$$, having strength $$$z$$$.\nThe procedure is called exactly $$$q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ q$$$ ($$$1 \\leq n \\leq 400\\,000$$$, $$$1 \\leq q \\leq 50\\,000$$$)\nline $$$2$$$: $$$s[0]\\ s[1]\\ldots \\ s[n-1]$$$ ($$$1 \\leq s[i] \\leq 10^{7}$$$)\nline $$$3$$$: $$$p[0]\\ p[1]\\ldots \\ p[n-1]$$$ ($$$1 \\leq p[i] \\leq 10^{7}$$$)\nline $$$4$$$: $$$w[0]\\ w[1]\\ldots \\ w[n-1]$$$ ($$$i < w[i] \\leq n$$$)\nline $$$5$$$: $$$l[0]\\ l[1]\\ldots \\ l[n-1]$$$ ($$$0 \\leq l[i] \\leq n$$$)\nline $$$6 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): $$$x\\ z$$$ ($$$0 \\leq x \\leq n-1$$$, $$$1 \\leq z \\leq 10^{7}$$$) for the $$$i$$$-th call to\nsimulate\n.\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + i$$$ ($$$0 \\leq i \\leq q - 1$$$) : the return value of the $$$i$$$-th call to\nsimulate\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$n \\leq 50\\,000$$$, $$$q \\leq 100$$$, $$$s[i], p[i] \\leq 10\\,000$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n2\n26\n$$$s[i] = p[i]$$$ (for all $$$0 \\leq i \\leq n-1$$$)\n3\n13\n$$$n \\leq 50\\,000$$$, all opponents have the same strength, in other words, $$$s[i]=s[j]$$$ for all $$$0 \\leq i,j \\leq n-1$$$.\n4\n12\n$$$n \\leq 50\\,000$$$, there are at most $$$5$$$ distinct values among all values of $$$s[i]$$$.\n5\n27\n$$$n \\leq 50\\,000$$$\n6\n11\nNo additional constraints.\nExample\nNote\nExample\nConsider the following call:\ninit(3, [2, 6, 9], [3, 1, 2], [2, 2, 3], [1, 0, 1])\nThe diagram above illustrates this call. Each square shows a dungeon. For dungeons $$$0$$$, $$$1$$$ and $$$2$$$, the values $$$s[i]$$$ and $$$p[i]$$$ are indicated inside the squares. Magenta arrows indicate where the hero moves after winning a confrontation, while black arrows indicate where the hero moves after losing.\nLet's say the grader calls\nsimulate(0, 1)\n.\nThe game proceeds as follows:\nDungeon\nHero's strength before confrontation\nResult\n$$$0$$$\n$$$1$$$\nLose\n$$$1$$$\n$$$4$$$\nLose\n$$$0$$$\n$$$5$$$\nWin\n$$$2$$$\n$$$7$$$\nLose\n$$$1$$$\n$$$9$$$\nWin\n$$$2$$$\n$$$15$$$\nWin\n$$$3$$$\n$$$24$$$\nGame ends\nAs such, the procedure should return $$$24$$$.\nLet's say the grader calls\nsimulate(2, 3)\n.\nThe game proceeds as follows:\nDungeon\nHero's strength before confrontation\nResult\n$$$2$$$\n$$$3$$$\nLose\n$$$1$$$\n$$$5$$$\nLose\n$$$0$$$\n$$$6$$$\nWin\n$$$2$$$\n$$$8$$$\nLose\n$$$1$$$\n$$$10$$$\nWin\n$$$2$$$\n$$$16$$$\nWin\n$$$3$$$\n$$$25$$$\nGame ends\nAs such, the procedure should return $$$25$$$.",
    "_meta": {
      "index": 57,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/E",
      "uuid": "ps_760488ff47e02a2d5fe0fb570f6515a764ab9729"
    }
  },
  {
    "planning_view": {
      "title": "F. Sky Walking",
      "task": "Find shortest path between building bottoms using skywalks and buildings in 2D plane",
      "given": [
        "n buildings at positions x[i] with heights h[i]",
        "m skywalks between buildings l[j] and r[j] at height y[j]",
        "Start at bottom of building s, end at bottom of building g"
      ],
      "goal": "Find shortest path length from building s to building g using buildings and skywalks",
      "key_rules": [
        "Can only walk on buildings and skywalks, not on the ground (y=0)",
        "Skywalks never share interior points (only endpoints may coincide)",
        "Buildings are in strictly increasing x-coordinate order",
        "Skywalk height y[j] ≤ minimum of h[l[j]] and h[r[j]]"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "n, m ≤ 50"
        },
        "2": {
          "points": 14,
          "req": "Each skywalk intersects at most 10 buildings"
        },
        "3": {
          "points": 15,
          "req": "s=0, g=n-1, all buildings have same height"
        },
        "4": {
          "points": 18,
          "req": "s=0, g=n-1"
        },
        "5": {
          "points": 43,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Sky Walking",
      "contest": "IOI 2019 day 2",
      "one_line": "Find shortest path between building bottoms using skywalks and buildings in 2D plane",
      "given": [
        "n buildings at positions x[i] with heights h[i]",
        "m skywalks between buildings l[j] and r[j] at height y[j]",
        "Start at bottom of building s, end at bottom of building g"
      ],
      "goal": "Find shortest path length from building s to building g using buildings and skywalks",
      "mechanism": "Buildings are vertical segments, skywalks are horizontal segments at height y[j] between buildings",
      "success_condition": "Return minimal path length if path exists, else -1",
      "constraints": {
        "critical": [
          "Can only walk on buildings and skywalks, not on the ground (y=0)",
          "Skywalks never share interior points (only endpoints may coincide)",
          "Buildings are in strictly increasing x-coordinate order",
          "Skywalk height y[j] ≤ minimum of h[l[j]] and h[r[j]]"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "n, m ≤ 50"
          },
          "2": {
            "points": 14,
            "req": "Each skywalk intersects at most 10 buildings"
          },
          "3": {
            "points": 15,
            "req": "s=0, g=n-1, all buildings have same height"
          },
          "4": {
            "points": 18,
            "req": "s=0, g=n-1"
          },
          "5": {
            "points": 43,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Sky Walking",
        "contest": "IOI 2019 day 2",
        "one_line": "Find shortest path between building bottoms using skywalks and buildings in 2D plane"
      },
      "problem": {
        "given": [
          "n buildings at positions x[i] with heights h[i]",
          "m skywalks between buildings l[j] and r[j] at height y[j]",
          "Start at bottom of building s, end at bottom of building g"
        ],
        "goal": "Find shortest path length from building s to building g using buildings and skywalks",
        "mechanism": "Buildings are vertical segments, skywalks are horizontal segments at height y[j] between buildings",
        "success_condition": "Return minimal path length if path exists, else -1"
      },
      "constraints": {
        "critical": [
          "Can only walk on buildings and skywalks, not on the ground (y=0)",
          "Skywalks never share interior points (only endpoints may coincide)",
          "Buildings are in strictly increasing x-coordinate order",
          "Skywalk height y[j] ≤ minimum of h[l[j]] and h[r[j]]"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "n, m ≤ 50"
          },
          "2": {
            "points": 14,
            "req": "Each skywalk intersects at most 10 buildings"
          },
          "3": {
            "points": 15,
            "req": "s=0, g=n-1, all buildings have same height"
          },
          "4": {
            "points": 18,
            "req": "s=0, g=n-1"
          },
          "5": {
            "points": 43,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 min_distance(int[] x, int[] h, int[] l, int[] r, int[] y, int s, int g)",
        "available_api": {},
        "requirements": [
          "Return -1 if no path exists",
          "Use int64 for return value to avoid overflow"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "7 7\n0 8\n3 7\n5 9\n7 7\n10 6\n12 6\n14 9\n0 1 1\n0 2 6\n0 6 8\n2 3 1\n2 6 7\n3 4 2\n4 6 5\n1 5",
          "output": "27"
        }
      ],
      "original_statement": "Kenan drew a plan of the buildings and skywalks along one side of the main avenue of Baku. There are $$$n$$$ buildings numbered from $$$0$$$ to $$$n-1$$$ and $$$m$$$ skywalks numbered from $$$0$$$ to $$$m-1$$$. The plan is drawn on a two-dimensional plane, where the buildings and skywalks are vertical and horizontal segments respectively.\nThe bottom of building $$$i$$$ $$$(0 \\leq i \\leq n-1)$$$ is located at point $$$(x[i], 0)$$$ and the building has height $$$h[i]$$$. Hence, it is a segment connecting the points $$$(x[i], 0)$$$ and $$$(x[i], h[i])$$$.\nSkywalk $$$j$$$ $$$(0 \\leq j \\leq m-1)$$$ has endpoints at buildings numbered $$$l[j]$$$ and $$$r[j]$$$ and has a positive $$$y$$$-coordinate $$$y[j]$$$. Hence, it is a segment connecting the points $$$(x[l[j]], y[j])$$$ and $$$(x[r[j]], y[j])$$$.\nA skywalk and a building\nintersect\nif they share a common point. Hence, a skywalk intersects two buildings at its two endpoints, and may also intersect other buildings in between.\nKenan would like to find the length of the shortest path from the bottom of building $$$s$$$ to the bottom of building $$$g$$$, assuming that one can only walk along the buildings and skywalks, or determine that no such path exists. Note that it is not allowed to walk on the ground, i.e. along the horizontal line with $$$y$$$-coordinate $$$0$$$.\nOne can walk from a skywalk into a building or vice versa at any intersection. If the endpoints of two skywalks are at the same point, one can walk from one skywalk to the other.\nYour task is to help Kenan answer his question.\nImplementation details\nYou should implement the following procedure. It will be called by the grader once for each test case.\nint64 min_distance(int[] x, int[] h, int[] l, int[] r, int[] y, int s, int g)\n$$$x$$$ and $$$h$$$: integer arrays of length $$$n$$$\n$$$l$$$, $$$r$$$, and $$$y$$$: integer arrays of length $$$m$$$\n$$$s$$$ and $$$g$$$: two integers\nThis procedure should return the length of the shortest path between the bottom of building $$$s$$$ and the bottom of building $$$g$$$, if such path exists. Otherwise, it should return $$$-1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$m$$$ ($$$1 \\leq n, m \\leq 100\\,000$$$)\nline $$$2 + i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$x[i]$$$ $$$h[i]$$$ ($$$0 \\leq x[0] < x[1] < \\ldots < x[n - 1] \\leq 10^9$$$ $$$1 \\leq h[i] \\leq 10^9$$$)\nline $$$n + 2 + j$$$ ($$$0 \\leq j \\leq m - 1$$$): $$$l[j]$$$ $$$r[j]$$$ $$$y[j]$$$ ($$$0 \\leq l[j] < r[j] \\leq n-1$$$ $$$1 \\leq y[j] \\leq \\min(h[l[j]], h[r[j]])$$$)\nline $$$n + m + 2$$$: $$$s$$$ $$$g$$$ ($$$0 \\leq s, g \\leq n - 1$$$, $$$s \\neq g$$$)\nNo two skywalks have a common point, except maybe on their endpoints.\nOutput\nThe sample grader prints a single line containing the return value of\nmin_distance\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$n, m \\leq 50$$$\n2\n14\nEach skywalk intersects at most 10 buildings.\n3\n15\n$$$s=0$$$, $$$g=n-1$$$, and all buildings have the same height.\n4\n18\n$$$s=0$$$, $$$g=n-1$$$\n5\n43\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nmin_distance([0, 3, 5, 7, 10, 12, 14],\n[8, 7, 9, 7, 6, 6, 9],\n[0, 0, 0, 2, 2, 3, 4],\n[1, 2, 6, 3, 6, 4, 6],\n[1, 6, 8, 1, 7, 2, 5],\n1, 5)\nThe correct answer is $$$27$$$.\nThe figure below corresponds to\nExample 1\n:\nExample 2\nmin_distance([0, 4, 5, 6, 9],\n[6, 6, 6, 6, 6],\n[3, 1, 0],\n[4, 3, 2],\n[1, 3, 6],\n0, 4)\nThe correct answer is $$$21$$$."
    },
    "original": "Kenan drew a plan of the buildings and skywalks along one side of the main avenue of Baku. There are $$$n$$$ buildings numbered from $$$0$$$ to $$$n-1$$$ and $$$m$$$ skywalks numbered from $$$0$$$ to $$$m-1$$$. The plan is drawn on a two-dimensional plane, where the buildings and skywalks are vertical and horizontal segments respectively.\nThe bottom of building $$$i$$$ $$$(0 \\leq i \\leq n-1)$$$ is located at point $$$(x[i], 0)$$$ and the building has height $$$h[i]$$$. Hence, it is a segment connecting the points $$$(x[i], 0)$$$ and $$$(x[i], h[i])$$$.\nSkywalk $$$j$$$ $$$(0 \\leq j \\leq m-1)$$$ has endpoints at buildings numbered $$$l[j]$$$ and $$$r[j]$$$ and has a positive $$$y$$$-coordinate $$$y[j]$$$. Hence, it is a segment connecting the points $$$(x[l[j]], y[j])$$$ and $$$(x[r[j]], y[j])$$$.\nA skywalk and a building\nintersect\nif they share a common point. Hence, a skywalk intersects two buildings at its two endpoints, and may also intersect other buildings in between.\nKenan would like to find the length of the shortest path from the bottom of building $$$s$$$ to the bottom of building $$$g$$$, assuming that one can only walk along the buildings and skywalks, or determine that no such path exists. Note that it is not allowed to walk on the ground, i.e. along the horizontal line with $$$y$$$-coordinate $$$0$$$.\nOne can walk from a skywalk into a building or vice versa at any intersection. If the endpoints of two skywalks are at the same point, one can walk from one skywalk to the other.\nYour task is to help Kenan answer his question.\nImplementation details\nYou should implement the following procedure. It will be called by the grader once for each test case.\nint64 min_distance(int[] x, int[] h, int[] l, int[] r, int[] y, int s, int g)\n$$$x$$$ and $$$h$$$: integer arrays of length $$$n$$$\n$$$l$$$, $$$r$$$, and $$$y$$$: integer arrays of length $$$m$$$\n$$$s$$$ and $$$g$$$: two integers\nThis procedure should return the length of the shortest path between the bottom of building $$$s$$$ and the bottom of building $$$g$$$, if such path exists. Otherwise, it should return $$$-1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$m$$$ ($$$1 \\leq n, m \\leq 100\\,000$$$)\nline $$$2 + i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$x[i]$$$ $$$h[i]$$$ ($$$0 \\leq x[0] < x[1] < \\ldots < x[n - 1] \\leq 10^9$$$ $$$1 \\leq h[i] \\leq 10^9$$$)\nline $$$n + 2 + j$$$ ($$$0 \\leq j \\leq m - 1$$$): $$$l[j]$$$ $$$r[j]$$$ $$$y[j]$$$ ($$$0 \\leq l[j] < r[j] \\leq n-1$$$ $$$1 \\leq y[j] \\leq \\min(h[l[j]], h[r[j]])$$$)\nline $$$n + m + 2$$$: $$$s$$$ $$$g$$$ ($$$0 \\leq s, g \\leq n - 1$$$, $$$s \\neq g$$$)\nNo two skywalks have a common point, except maybe on their endpoints.\nOutput\nThe sample grader prints a single line containing the return value of\nmin_distance\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$n, m \\leq 50$$$\n2\n14\nEach skywalk intersects at most 10 buildings.\n3\n15\n$$$s=0$$$, $$$g=n-1$$$, and all buildings have the same height.\n4\n18\n$$$s=0$$$, $$$g=n-1$$$\n5\n43\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nmin_distance([0, 3, 5, 7, 10, 12, 14],\n[8, 7, 9, 7, 6, 6, 9],\n[0, 0, 0, 2, 2, 3, 4],\n[1, 2, 6, 3, 6, 4, 6],\n[1, 6, 8, 1, 7, 2, 5],\n1, 5)\nThe correct answer is $$$27$$$.\nThe figure below corresponds to\nExample 1\n:\nExample 2\nmin_distance([0, 4, 5, 6, 9],\n[6, 6, 6, 6, 6],\n[3, 1, 0],\n[4, 3, 2],\n[1, 3, 6],\n0, 4)\nThe correct answer is $$$21$$$.",
    "_meta": {
      "index": 58,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/F",
      "uuid": "ps_b0e333e8cca244a587c2307646e9e121003547ac"
    }
  },
  {
    "planning_view": {
      "title": "A. Tropical Garden",
      "task": "Count routes from any fountain to P in exactly K steps using beauty-preference rules",
      "given": [
        "N fountains (0 to N-1), M trails",
        "Trails ordered by decreasing beauty (trail i more beautiful than i+1)",
        "Restaurant at fountain P",
        "Q groups with different K values"
      ],
      "goal": "Count valid routes that end at P after exactly K trail traversals",
      "key_rules": [
        "Always take most beautiful trail unless it was previous trail",
        "If no alternative when returning, must use same trail again",
        "Routes can pass through P before final step",
        "Start at any fountain"
      ],
      "target": {
        "1": {
          "points": 49,
          "req": "N ≤ 1,000, M ≤ 10,000, Q=1, K ≤ 100"
        },
        "2": {
          "points": 20,
          "req": "N,M ≤ 150,000, Q=1, K ≤ 1e9"
        },
        "3": {
          "points": 31,
          "req": "N,M ≤ 150,000, Q ≤ 2,000, K ≤ 1e9"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Tropical Garden",
      "contest": "IOI 2011 day 1",
      "one_line": "Count routes from any fountain to P in exactly K steps using beauty-preference rules",
      "given": [
        "N fountains (0 to N-1), M trails",
        "Trails ordered by decreasing beauty (trail i more beautiful than i+1)",
        "Restaurant at fountain P",
        "Q groups with different K values"
      ],
      "goal": "Count valid routes that end at P after exactly K trail traversals",
      "mechanism": "From any fountain, take most beautiful trail unless it was just used (then take second most)",
      "success_condition": "Route must follow beauty-preference rules and end at P after exactly K steps",
      "constraints": {
        "critical": [
          "Always take most beautiful trail unless it was previous trail",
          "If no alternative when returning, must use same trail again",
          "Routes can pass through P before final step",
          "Start at any fountain"
        ],
        "subtasks": {
          "1": {
            "points": 49,
            "req": "N ≤ 1,000, M ≤ 10,000, Q=1, K ≤ 100"
          },
          "2": {
            "points": 20,
            "req": "N,M ≤ 150,000, Q=1, K ≤ 1e9"
          },
          "3": {
            "points": 31,
            "req": "N,M ≤ 150,000, Q ≤ 2,000, K ≤ 1e9"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Tropical Garden",
        "contest": "IOI 2011 day 1",
        "one_line": "Count routes from any fountain to P in exactly K steps using beauty-preference rules"
      },
      "problem": {
        "given": [
          "N fountains (0 to N-1), M trails",
          "Trails ordered by decreasing beauty (trail i more beautiful than i+1)",
          "Restaurant at fountain P",
          "Q groups with different K values"
        ],
        "goal": "Count valid routes that end at P after exactly K trail traversals",
        "mechanism": "From any fountain, take most beautiful trail unless it was just used (then take second most)",
        "success_condition": "Route must follow beauty-preference rules and end at P after exactly K steps"
      },
      "constraints": {
        "critical": [
          "Always take most beautiful trail unless it was previous trail",
          "If no alternative when returning, must use same trail again",
          "Routes can pass through P before final step",
          "Start at any fountain"
        ],
        "subtasks": {
          "1": {
            "points": 49,
            "req": "N ≤ 1,000, M ≤ 10,000, Q=1, K ≤ 100"
          },
          "2": {
            "points": 20,
            "req": "N,M ≤ 150,000, Q=1, K ≤ 1e9"
          },
          "3": {
            "points": 31,
            "req": "N,M ≤ 150,000, Q ≤ 2,000, K ≤ 1e9"
          }
        }
      },
      "implementation": {
        "function_to_write": "void count_routes(int N, int M, int P, int R[][2], int Q, int G[])",
        "available_api": {
          "answer": {
            "signature": "void answer(int X)",
            "params": "X: number of routes for current group",
            "returns": "void",
            "side_effect": "Reports answer to grader (must call Q times)"
          }
        },
        "requirements": [
          "Must call answer(X) for each of the Q groups in order",
          "R is M×2 array where R[i] contains endpoints of trail i",
          "Trails given in decreasing beauty order (i more beautiful than i+1)",
          "Fountains 0-indexed (0 to N-1)"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "6 6 0\n1 2\n0 1\n0 3\n3 4\n4 5\n1 5\n1\n3",
          "output": "2"
        }
      ],
      "original_statement": "Botanist Somhed regularly takes groups of students to one of Thailand's largest tropical gardens. The landscape of this garden is composed of $$$N$$$ fountains (numbered $$$0, 1, \\ldots, N-1$$$) and $$$M$$$ trails. Each trail connects a different pair of distinct fountains, and can be traveled in either direction. There is at least one trail leaving each fountain. These trails feature beautiful botanical collections that Somhed would like to see. Each group can start their trip at any fountain.\nSomhed loves beautiful tropical plants. Therefore, from any fountain he and his students will take the most beautiful trail leaving that fountain, unless it is the most recent trail taken and there is an alternative. In that case, they will take the second most beautiful trail instead. Of course, if there is no alternative, they will walk back, using the same trail for the second time. Note that since Somhed is a professional botanist, no two trails are considered equally beautiful for him.\nHis students are not very interested in the plants. However, they would love to have lunch at a premium restaurant located beside fountain number $$$P$$$. Somhed knows that his students will become hungry after taking exactly $$$K$$$ trails, where $$$K$$$ could be different for each group of students.\nSomhed wonders how many different routes he could choose for each group, given that:\neach group can start at any fountain;\nthe successive trails must be chosen in the way described above; and\neach group must finish at fountain number $$$P$$$ after traversing exactly $$$K$$$ trails.\nNote that they may pass fountain number $$$P$$$ earlier on their route, although they still need to finish their route at fountain number $$$P$$$.\nGiven the information on the fountains and the trails, you have to find the answers for $$$Q$$$ groups of students; that is, $$$Q$$$ values of $$$K$$$. Write a procedure\ncount_routes(N,M,P,R,Q,G)\nthat takes the following parameters:\n$$$N$$$— the number of fountains. The fountains are numbered $$$0$$$ through $$$N-1$$$.\n$$$M$$$— the number of trails. The trails are numbered $$$0$$$ through $$$M-1$$$. The trails will be given in decreasing order of beauty: for $$$0 \\le i < M-1$$$, trail $$$i$$$ is more beautiful than trail $$$i+1$$$.\n$$$P$$$— the fountain at which the premium restaurant is located.\n$$$R$$$— a two-dimensional array representing the trails. For $$$0 \\le i < M$$$, trail $$$i$$$ connects the fountains $$$R[i][0]$$$ and $$$R[i][1]$$$. Recall that each trail joins a pair of distinct fountains, and no two trails join the same pair of fountains.\n$$$Q$$$— the number of groups of students.\n$$$G$$$— a one-dimensional array of integers containing the values of $$$K$$$. For $$$0 \\le i < Q$$$, $$$G[i]$$$ is the number of trails $$$K$$$ that the $$$i$$$-th group will take.\nFor $$$0 \\le i < Q$$$, your procedure must find the number of possible routes with exactly $$$G[i]$$$ trails that group $$$i$$$ could possibly take to reach fountain $$$P$$$. For each group $$$i$$$, your procedure should call the procedure\nanswer(X)\nto report that the number of routes is $$$X$$$. The answers must be given in the same order as the groups. If there are no valid routes, your procedure must call\nanswer(0)\n.\nInput\nGrader reads input in following format:\nLine $$$1$$$: $$$N$$$, $$$M$$$, and $$$P$$$.\nLines $$$2$$$ to $$$M+1$$$: description of the trails; i.e., line $$$i+2$$$ contains $$$R[i][0]$$$ and $$$R[i][1]$$$, separated by a space, for $$$0 \\le i < M$$$.\nLine M+2: $$$Q$$$.\nLine M+3: array $$$G$$$ as a sequence of space-separated integers.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\n$$$Q$$$\nAdditional Input Constraints\n1\n49\n$$$2 \\le N \\le 1\\,000$$$\n$$$1 \\le M \\le 10\\,000$$$\n$$$Q = 1$$$\neach element of $$$G$$$ is an integer between $$$1$$$ and $$$100$$$, inclusive.\n2\n20\n$$$2 \\le N \\le 150\\,000$$$\n$$$1 \\le M \\le 150\\,000$$$\n$$$Q = 1$$$\neach element of $$$G$$$ is an integer between $$$1$$$ and $$$1\\,000\\,000\\,000$$$, inclusive.\n3\n31\n$$$2 \\le N \\le 150\\,000$$$\n$$$1 \\le M \\le 150\\,000$$$\n$$$1 \\le Q \\le 2\\,000$$$\neach element of $$$G$$$ is an integer between $$$1$$$ and $$$1\\,000\\,000\\,000$$$, inclusive.\nExamples\nNote\nThere are only two possible valid routes in the first example that follow 3 trails: $$$1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$$$, and $$$5 \\rightarrow 4 \\rightarrow 3 \\rightarrow 0$$$. The first route starts at fountain 1. The most beautiful trail from here leads to fountain $$$2$$$. At fountain $$$2$$$, the group has no choice, they must return using the same trail. Back at fountain 1, the group will now avoid trail 0 and choose trail 1 instead. This trail does indeed bring them to the fountain $$$P=0$$$. Thus, the procedure should call\nanswer(2)\n.\nFor the first group in the second example, there is only one valid route that reaches fountain $$$2$$$ after following 3 trails: $$$1 \\rightarrow 0 \\rightarrow 1 \\rightarrow 2$$$. For the second group, there are two valid routes that reach fountain 2 after following $$$1$$$ trail: $$$3 \\rightarrow 2$$$, and $$$4 \\rightarrow 2$$$. Therefore, the correct implementation of\ncount_routes\nshould first call\nanswer(1)\nto report the answer for the first group, and then call\nanswer(2)\nto report the answer for the second group."
    },
    "original": "Botanist Somhed regularly takes groups of students to one of Thailand's largest tropical gardens. The landscape of this garden is composed of $$$N$$$ fountains (numbered $$$0, 1, \\ldots, N-1$$$) and $$$M$$$ trails. Each trail connects a different pair of distinct fountains, and can be traveled in either direction. There is at least one trail leaving each fountain. These trails feature beautiful botanical collections that Somhed would like to see. Each group can start their trip at any fountain.\nSomhed loves beautiful tropical plants. Therefore, from any fountain he and his students will take the most beautiful trail leaving that fountain, unless it is the most recent trail taken and there is an alternative. In that case, they will take the second most beautiful trail instead. Of course, if there is no alternative, they will walk back, using the same trail for the second time. Note that since Somhed is a professional botanist, no two trails are considered equally beautiful for him.\nHis students are not very interested in the plants. However, they would love to have lunch at a premium restaurant located beside fountain number $$$P$$$. Somhed knows that his students will become hungry after taking exactly $$$K$$$ trails, where $$$K$$$ could be different for each group of students.\nSomhed wonders how many different routes he could choose for each group, given that:\neach group can start at any fountain;\nthe successive trails must be chosen in the way described above; and\neach group must finish at fountain number $$$P$$$ after traversing exactly $$$K$$$ trails.\nNote that they may pass fountain number $$$P$$$ earlier on their route, although they still need to finish their route at fountain number $$$P$$$.\nGiven the information on the fountains and the trails, you have to find the answers for $$$Q$$$ groups of students; that is, $$$Q$$$ values of $$$K$$$. Write a procedure\ncount_routes(N,M,P,R,Q,G)\nthat takes the following parameters:\n$$$N$$$— the number of fountains. The fountains are numbered $$$0$$$ through $$$N-1$$$.\n$$$M$$$— the number of trails. The trails are numbered $$$0$$$ through $$$M-1$$$. The trails will be given in decreasing order of beauty: for $$$0 \\le i < M-1$$$, trail $$$i$$$ is more beautiful than trail $$$i+1$$$.\n$$$P$$$— the fountain at which the premium restaurant is located.\n$$$R$$$— a two-dimensional array representing the trails. For $$$0 \\le i < M$$$, trail $$$i$$$ connects the fountains $$$R[i][0]$$$ and $$$R[i][1]$$$. Recall that each trail joins a pair of distinct fountains, and no two trails join the same pair of fountains.\n$$$Q$$$— the number of groups of students.\n$$$G$$$— a one-dimensional array of integers containing the values of $$$K$$$. For $$$0 \\le i < Q$$$, $$$G[i]$$$ is the number of trails $$$K$$$ that the $$$i$$$-th group will take.\nFor $$$0 \\le i < Q$$$, your procedure must find the number of possible routes with exactly $$$G[i]$$$ trails that group $$$i$$$ could possibly take to reach fountain $$$P$$$. For each group $$$i$$$, your procedure should call the procedure\nanswer(X)\nto report that the number of routes is $$$X$$$. The answers must be given in the same order as the groups. If there are no valid routes, your procedure must call\nanswer(0)\n.\nInput\nGrader reads input in following format:\nLine $$$1$$$: $$$N$$$, $$$M$$$, and $$$P$$$.\nLines $$$2$$$ to $$$M+1$$$: description of the trails; i.e., line $$$i+2$$$ contains $$$R[i][0]$$$ and $$$R[i][1]$$$, separated by a space, for $$$0 \\le i < M$$$.\nLine M+2: $$$Q$$$.\nLine M+3: array $$$G$$$ as a sequence of space-separated integers.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\n$$$Q$$$\nAdditional Input Constraints\n1\n49\n$$$2 \\le N \\le 1\\,000$$$\n$$$1 \\le M \\le 10\\,000$$$\n$$$Q = 1$$$\neach element of $$$G$$$ is an integer between $$$1$$$ and $$$100$$$, inclusive.\n2\n20\n$$$2 \\le N \\le 150\\,000$$$\n$$$1 \\le M \\le 150\\,000$$$\n$$$Q = 1$$$\neach element of $$$G$$$ is an integer between $$$1$$$ and $$$1\\,000\\,000\\,000$$$, inclusive.\n3\n31\n$$$2 \\le N \\le 150\\,000$$$\n$$$1 \\le M \\le 150\\,000$$$\n$$$1 \\le Q \\le 2\\,000$$$\neach element of $$$G$$$ is an integer between $$$1$$$ and $$$1\\,000\\,000\\,000$$$, inclusive.\nExamples\nNote\nThere are only two possible valid routes in the first example that follow 3 trails: $$$1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$$$, and $$$5 \\rightarrow 4 \\rightarrow 3 \\rightarrow 0$$$. The first route starts at fountain 1. The most beautiful trail from here leads to fountain $$$2$$$. At fountain $$$2$$$, the group has no choice, they must return using the same trail. Back at fountain 1, the group will now avoid trail 0 and choose trail 1 instead. This trail does indeed bring them to the fountain $$$P=0$$$. Thus, the procedure should call\nanswer(2)\n.\nFor the first group in the second example, there is only one valid route that reaches fountain $$$2$$$ after following 3 trails: $$$1 \\rightarrow 0 \\rightarrow 1 \\rightarrow 2$$$. For the second group, there are two valid routes that reach fountain 2 after following $$$1$$$ trail: $$$3 \\rightarrow 2$$$, and $$$4 \\rightarrow 2$$$. Therefore, the correct implementation of\ncount_routes\nshould first call\nanswer(1)\nto report the answer for the first group, and then call\nanswer(2)\nto report the answer for the second group.",
    "_meta": {
      "index": 59,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/A",
      "uuid": "ps_5493ef7ee3edc2cfd103813ef08759e20c754aeb"
    }
  },
  {
    "planning_view": {
      "title": "A. Closing Time",
      "task": "Maximize cities reachable from X+Y given K sum of closing times",
      "given": [
        "N cities connected by N-1 roads (tree)",
        "Two festival cities X and Y",
        "Sum of closing times ≤ K",
        "Roads have positive integer lengths"
      ],
      "goal": "Find maximum convenience score = reachable(X) + reachable(Y)",
      "key_rules": [
        "Tree structure: unique path between any two cities",
        "Closing times sum to ≤ K (K ≤ 10^18)",
        "Reachable condition: path from a to b valid if cost to each intermediate city ≤ its closing time",
        "Cities reachable from both X and Y count twice"
      ],
      "target": {
        "1": {
          "points": 8,
          "req": "Distance(X,Y) > 2K"
        },
        "2": {
          "points": 9,
          "req": "S_N ≤ 50, linear network"
        },
        "3": {
          "points": 12,
          "req": "S_N ≤ 500, linear network"
        },
        "4": {
          "points": 14,
          "req": "S_N ≤ 3000, linear network"
        },
        "5": {
          "points": 9,
          "req": "S_N ≤ 20"
        },
        "6": {
          "points": 11,
          "req": "S_N ≤ 100"
        },
        "7": {
          "points": 10,
          "req": "S_N ≤ 500"
        },
        "8": {
          "points": 10,
          "req": "S_N ≤ 3000"
        },
        "9": {
          "points": 17,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Closing Time",
      "contest": "IOI 2023 day 1",
      "one_line": "Maximize cities reachable from X+Y given K sum of closing times",
      "given": [
        "N cities connected by N-1 roads (tree)",
        "Two festival cities X and Y",
        "Sum of closing times ≤ K",
        "Roads have positive integer lengths"
      ],
      "goal": "Find maximum convenience score = reachable(X) + reachable(Y)",
      "mechanism": "Assign closing times c[i] ≥ 0; city b reachable from a if path cost to each intermediate city ≤ its closing time",
      "success_condition": "Maximum possible sum of cities reachable from X and cities reachable from Y",
      "constraints": {
        "critical": [
          "Tree structure: unique path between any two cities",
          "Closing times sum to ≤ K (K ≤ 10^18)",
          "Reachable condition: path from a to b valid if cost to each intermediate city ≤ its closing time",
          "Cities reachable from both X and Y count twice"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "Distance(X,Y) > 2K"
          },
          "2": {
            "points": 9,
            "req": "S_N ≤ 50, linear network"
          },
          "3": {
            "points": 12,
            "req": "S_N ≤ 500, linear network"
          },
          "4": {
            "points": 14,
            "req": "S_N ≤ 3000, linear network"
          },
          "5": {
            "points": 9,
            "req": "S_N ≤ 20"
          },
          "6": {
            "points": 11,
            "req": "S_N ≤ 100"
          },
          "7": {
            "points": 10,
            "req": "S_N ≤ 500"
          },
          "8": {
            "points": 10,
            "req": "S_N ≤ 3000"
          },
          "9": {
            "points": 17,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Closing Time",
        "contest": "IOI 2023 day 1",
        "one_line": "Maximize cities reachable from X+Y given K sum of closing times"
      },
      "problem": {
        "given": [
          "N cities connected by N-1 roads (tree)",
          "Two festival cities X and Y",
          "Sum of closing times ≤ K",
          "Roads have positive integer lengths"
        ],
        "goal": "Find maximum convenience score = reachable(X) + reachable(Y)",
        "mechanism": "Assign closing times c[i] ≥ 0; city b reachable from a if path cost to each intermediate city ≤ its closing time",
        "success_condition": "Maximum possible sum of cities reachable from X and cities reachable from Y"
      },
      "constraints": {
        "critical": [
          "Tree structure: unique path between any two cities",
          "Closing times sum to ≤ K (K ≤ 10^18)",
          "Reachable condition: path from a to b valid if cost to each intermediate city ≤ its closing time",
          "Cities reachable from both X and Y count twice"
        ],
        "subtasks": {
          "1": {
            "points": 8,
            "req": "Distance(X,Y) > 2K"
          },
          "2": {
            "points": 9,
            "req": "S_N ≤ 50, linear network"
          },
          "3": {
            "points": 12,
            "req": "S_N ≤ 500, linear network"
          },
          "4": {
            "points": 14,
            "req": "S_N ≤ 3000, linear network"
          },
          "5": {
            "points": 9,
            "req": "S_N ≤ 20"
          },
          "6": {
            "points": 11,
            "req": "S_N ≤ 100"
          },
          "7": {
            "points": 10,
            "req": "S_N ≤ 500"
          },
          "8": {
            "points": 10,
            "req": "S_N ≤ 3000"
          },
          "9": {
            "points": 17,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)",
        "available_api": {
          "max_score": {
            "signature": "int max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)",
            "params": "N: number of cities; X,Y: festival cities; K: max sum of closing times; U,V,W: road descriptions",
            "returns": "Maximum convenience score",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Called multiple times per test case",
          "S_N ≤ 200,000 (sum of all N across calls)",
          "0 ≤ X < Y < N",
          "Road lengths between 1 and 10^6"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "2\n7 0 2 10\n0 1 2\n0 3 3\n1 2 4\n2 4 2\n2 5 5\n5 6 3\n4 0 3 20\n0 1 18\n1 2 1\n2 3 19",
          "output": "6\n3"
        }
      ],
      "original_statement": "Hungary is a country with $$$N$$$ cities, numbered from $$$0$$$ to $$$N - 1$$$.\nThe cities are connected by $$$N - 1$$$\nbidirectional\nroads, numbered from $$$0$$$ to $$$N - 2$$$. For each $$$j$$$ such that $$$0 \\le j \\le N - 2$$$, road $$$j$$$ connects city $$$U[j]$$$ and city $$$V[j]$$$ and has length $$$W[j]$$$, that is, it allows one to travel between the cities in $$$W[j]$$$ units of time. Each road connects two different cities, and each pair of cities is connected by at most one road.\nA\npath\nbetween two distinct cities $$$a$$$ and $$$b$$$ is a sequence $$$p_0, p_1, \\ldots, p_t$$$ of distinct cities, such that:\n$$$p_0 = a$$$,\n$$$p_t = b$$$,\nfor each $$$i$$$ ($$$0 \\le i < t$$$), there is a road connecting cities $$$p_i$$$ and $$$p_{i + 1}$$$.\nIt is possible to travel from any city to any other city by using the roads, that is, there exists a path between every two distinct cities. It can be shown that this path is unique for each pair of distinct cities.\nThe\nlength\nof a path $$$p_0, p_1, \\ldots, p_t$$$ is the sum of the lengths of the $$$t$$$ roads connecting consecutive cities along the path.\nIn Hungary, many people travel to attend the Foundation Day festivities in two major cities. Once the celebrations are over, they return to their homes. The government wants to prevent the crowd from disturbing the locals, so they plan to lock down all cities at certain times. Each city will be assigned a non-negative\nclosing time\nby the government. The government has decided that the sum of all closing times must not be more than $$$K$$$. More precisely, for every $$$i$$$ between $$$0$$$ and $$$N - 1$$$, inclusive, the closing time assigned to city $$$i$$$ is a nonnegative integer $$$c[i]$$$. The sum of all $$$c[i]$$$ must not be greater than $$$K$$$.\nConsider a city $$$a$$$ and some assignment of closing times. We say that a city $$$b$$$ is\nreachable\nfrom city $$$a$$$ if and only if either $$$b = a$$$, or the path $$$p_0, \\ldots, p_t$$$ between these two cities (so in particular $$$p_0 = a$$$ and $$$p_t = b$$$) satisfies the following conditions:\nthe length of the path $$$p_0, p_1$$$ is at most $$$c[p_1]$$$, and\nthe length of the path $$$p_0, p_1, p_2$$$ is at most $$$c[p_2]$$$, and\n$$$\\ldots$$$\nthe length of the path $$$p_0, p_1, p_2, \\ldots, p_t$$$ is at most $$$c[p_t]$$$.\nThis year, the two main festival sites are located in city $$$X$$$ and city $$$Y$$$. For each assignment of closing times, the\nconvenience score\nis defined as the sum of the following two numbers:\nThe number of cities reachable from city $$$X$$$.\nThe number of cities reachable from city $$$Y$$$.\nNote that if a city is reachable from city $$$X$$$ and reachable from city $$$Y$$$, it counts\ntwice\ntowards the convenience score.\nYour task is to compute the maximum convenience score that can be achieved by some assignment of closing times.\nImplementation Details\nYou should implement the following procedure.\nint max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)\n$$$N$$$: the number of cities.\n$$$X$$$, $$$Y$$$: the cities with main festival sites.\n$$$K$$$: the upper bound on the sum of closing times.\n$$$U$$$, $$$V$$$: arrays of length $$$N - 1$$$ describing road connections.\n$$$W$$$: array of length $$$N - 1$$$ describing road lengths.\nThis procedure should return the maximum convenience score that can be achieved by some assignment of closing times.\nThis procedure may be called\nmultiple times\nin each test case.\nInput\nLet $$$C$$$ denote the number of scenarios, that is, the number of calls to\nmax_score\n. The sample grader reads the input in the following format:\nline $$$1$$$: $$$C$$$\nThe descriptions of $$$C$$$ scenarios follow.\nThe sample grader reads the description of each scenario in the following format:\nline $$$1$$$: $$$N \\; X \\; Y \\; K (0 \\le X < Y < N, 0 \\le K \\le 10^{18})$$$\nline $$$2 + j$$$ ($$$0 \\le j \\le N - 2$$$): $$$U[j] \\; V[j] \\; W[j] (0 \\le U[j] < V[j] < N, 1 \\le W[j] \\le 10^6)$$$\nIt is possible to travel from any city to any other city by using the roads.\n$$$S_N \\le 200\\,000$$$, where $$$S_N$$$ is the sum of $$$N$$$ over all calls to\nmax_score\nin each test case.\nOutput\nThe sample grader prints a single line for each scenario, in the following format:\nline $$$1$$$: the return value of\nmax_score\nScoring\nWe say that a road network is\nlinear\nif road $$$i$$$ connects cities $$$i$$$ and $$$i + 1$$$ (for each $$$i$$$ such that $$$0 \\le i \\le N - 2$$$).\nSubtask\nPoints\nAdditional Input Constraints\n1\n8\nThe length of the path from city $$$X$$$ to city $$$Y$$$ is greater than $$$2K$$$.\n2\n9\n$$$S_N \\le 50$$$, the road network is linear.\n3\n12\n$$$S_N \\le 500$$$, the road network is linear.\n4\n14\n$$$S_N \\le 3\\,000$$$, the road network is linear.\n5\n9\n$$$S_N \\le 20$$$\n6\n11\n$$$S_N \\le 100$$$\n7\n10\n$$$S_N \\le 500$$$\n8\n10\n$$$S_N \\le 3\\,000$$$\n9\n17\nNo additional constraints.\nExample\nNote\nConsider the following call:\nmax_score(7, 0, 2, 10, [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])\nThis corresponds to the following road network:\nSuppose the closing times are assigned as follows:\nCity\n$$$0$$$\n$$$1$$$\n$$$2$$$\n$$$3$$$\n$$$4$$$\n$$$5$$$\n$$$6$$$\nClosing time\n$$$0$$$\n$$$4$$$\n$$$0$$$\n$$$3$$$\n$$$2$$$\n$$$0$$$\n$$$0$$$\nNote that the sum of all closing times is $$$9$$$, which is not more than $$$K = 10$$$. Cities $$$0$$$, $$$1$$$, and $$$3$$$ are reachable from city $$$X$$$ ($$$X = 0$$$), while cities $$$1$$$, $$$2$$$, and $$$4$$$ are reachable from city $$$Y$$$ ($$$Y = 2$$$). Therefore, the convenience score is $$$3 + 3 = 6$$$. There is no assignment of closing times with convenience score more than $$$6$$$, so the procedure should return $$$6$$$.\nAlso consider the following call:\nmax_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])\nThis corresponds to the following road network:\nSuppose the closing times are assigned as follows:\nCity\n$$$0$$$\n$$$1$$$\n$$$2$$$\n$$$3$$$\nClosing time\n$$$0$$$\n$$$1$$$\n$$$19$$$\n$$$0$$$\nCity $$$0$$$ is reachable from city $$$X$$$ ($$$X = 0$$$), while cities $$$2$$$ and $$$3$$$ are reachable from city $$$Y$$$ ($$$Y = 3$$$). Therefore, the convenience score is $$$1 + 2 = 3$$$. There is no assignment of closing times with convenience score more than $$$3$$$, so the procedure should return $$$3$$$."
    },
    "original": "Hungary is a country with $$$N$$$ cities, numbered from $$$0$$$ to $$$N - 1$$$.\nThe cities are connected by $$$N - 1$$$\nbidirectional\nroads, numbered from $$$0$$$ to $$$N - 2$$$. For each $$$j$$$ such that $$$0 \\le j \\le N - 2$$$, road $$$j$$$ connects city $$$U[j]$$$ and city $$$V[j]$$$ and has length $$$W[j]$$$, that is, it allows one to travel between the cities in $$$W[j]$$$ units of time. Each road connects two different cities, and each pair of cities is connected by at most one road.\nA\npath\nbetween two distinct cities $$$a$$$ and $$$b$$$ is a sequence $$$p_0, p_1, \\ldots, p_t$$$ of distinct cities, such that:\n$$$p_0 = a$$$,\n$$$p_t = b$$$,\nfor each $$$i$$$ ($$$0 \\le i < t$$$), there is a road connecting cities $$$p_i$$$ and $$$p_{i + 1}$$$.\nIt is possible to travel from any city to any other city by using the roads, that is, there exists a path between every two distinct cities. It can be shown that this path is unique for each pair of distinct cities.\nThe\nlength\nof a path $$$p_0, p_1, \\ldots, p_t$$$ is the sum of the lengths of the $$$t$$$ roads connecting consecutive cities along the path.\nIn Hungary, many people travel to attend the Foundation Day festivities in two major cities. Once the celebrations are over, they return to their homes. The government wants to prevent the crowd from disturbing the locals, so they plan to lock down all cities at certain times. Each city will be assigned a non-negative\nclosing time\nby the government. The government has decided that the sum of all closing times must not be more than $$$K$$$. More precisely, for every $$$i$$$ between $$$0$$$ and $$$N - 1$$$, inclusive, the closing time assigned to city $$$i$$$ is a nonnegative integer $$$c[i]$$$. The sum of all $$$c[i]$$$ must not be greater than $$$K$$$.\nConsider a city $$$a$$$ and some assignment of closing times. We say that a city $$$b$$$ is\nreachable\nfrom city $$$a$$$ if and only if either $$$b = a$$$, or the path $$$p_0, \\ldots, p_t$$$ between these two cities (so in particular $$$p_0 = a$$$ and $$$p_t = b$$$) satisfies the following conditions:\nthe length of the path $$$p_0, p_1$$$ is at most $$$c[p_1]$$$, and\nthe length of the path $$$p_0, p_1, p_2$$$ is at most $$$c[p_2]$$$, and\n$$$\\ldots$$$\nthe length of the path $$$p_0, p_1, p_2, \\ldots, p_t$$$ is at most $$$c[p_t]$$$.\nThis year, the two main festival sites are located in city $$$X$$$ and city $$$Y$$$. For each assignment of closing times, the\nconvenience score\nis defined as the sum of the following two numbers:\nThe number of cities reachable from city $$$X$$$.\nThe number of cities reachable from city $$$Y$$$.\nNote that if a city is reachable from city $$$X$$$ and reachable from city $$$Y$$$, it counts\ntwice\ntowards the convenience score.\nYour task is to compute the maximum convenience score that can be achieved by some assignment of closing times.\nImplementation Details\nYou should implement the following procedure.\nint max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)\n$$$N$$$: the number of cities.\n$$$X$$$, $$$Y$$$: the cities with main festival sites.\n$$$K$$$: the upper bound on the sum of closing times.\n$$$U$$$, $$$V$$$: arrays of length $$$N - 1$$$ describing road connections.\n$$$W$$$: array of length $$$N - 1$$$ describing road lengths.\nThis procedure should return the maximum convenience score that can be achieved by some assignment of closing times.\nThis procedure may be called\nmultiple times\nin each test case.\nInput\nLet $$$C$$$ denote the number of scenarios, that is, the number of calls to\nmax_score\n. The sample grader reads the input in the following format:\nline $$$1$$$: $$$C$$$\nThe descriptions of $$$C$$$ scenarios follow.\nThe sample grader reads the description of each scenario in the following format:\nline $$$1$$$: $$$N \\; X \\; Y \\; K (0 \\le X < Y < N, 0 \\le K \\le 10^{18})$$$\nline $$$2 + j$$$ ($$$0 \\le j \\le N - 2$$$): $$$U[j] \\; V[j] \\; W[j] (0 \\le U[j] < V[j] < N, 1 \\le W[j] \\le 10^6)$$$\nIt is possible to travel from any city to any other city by using the roads.\n$$$S_N \\le 200\\,000$$$, where $$$S_N$$$ is the sum of $$$N$$$ over all calls to\nmax_score\nin each test case.\nOutput\nThe sample grader prints a single line for each scenario, in the following format:\nline $$$1$$$: the return value of\nmax_score\nScoring\nWe say that a road network is\nlinear\nif road $$$i$$$ connects cities $$$i$$$ and $$$i + 1$$$ (for each $$$i$$$ such that $$$0 \\le i \\le N - 2$$$).\nSubtask\nPoints\nAdditional Input Constraints\n1\n8\nThe length of the path from city $$$X$$$ to city $$$Y$$$ is greater than $$$2K$$$.\n2\n9\n$$$S_N \\le 50$$$, the road network is linear.\n3\n12\n$$$S_N \\le 500$$$, the road network is linear.\n4\n14\n$$$S_N \\le 3\\,000$$$, the road network is linear.\n5\n9\n$$$S_N \\le 20$$$\n6\n11\n$$$S_N \\le 100$$$\n7\n10\n$$$S_N \\le 500$$$\n8\n10\n$$$S_N \\le 3\\,000$$$\n9\n17\nNo additional constraints.\nExample\nNote\nConsider the following call:\nmax_score(7, 0, 2, 10, [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])\nThis corresponds to the following road network:\nSuppose the closing times are assigned as follows:\nCity\n$$$0$$$\n$$$1$$$\n$$$2$$$\n$$$3$$$\n$$$4$$$\n$$$5$$$\n$$$6$$$\nClosing time\n$$$0$$$\n$$$4$$$\n$$$0$$$\n$$$3$$$\n$$$2$$$\n$$$0$$$\n$$$0$$$\nNote that the sum of all closing times is $$$9$$$, which is not more than $$$K = 10$$$. Cities $$$0$$$, $$$1$$$, and $$$3$$$ are reachable from city $$$X$$$ ($$$X = 0$$$), while cities $$$1$$$, $$$2$$$, and $$$4$$$ are reachable from city $$$Y$$$ ($$$Y = 2$$$). Therefore, the convenience score is $$$3 + 3 = 6$$$. There is no assignment of closing times with convenience score more than $$$6$$$, so the procedure should return $$$6$$$.\nAlso consider the following call:\nmax_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])\nThis corresponds to the following road network:\nSuppose the closing times are assigned as follows:\nCity\n$$$0$$$\n$$$1$$$\n$$$2$$$\n$$$3$$$\nClosing time\n$$$0$$$\n$$$1$$$\n$$$19$$$\n$$$0$$$\nCity $$$0$$$ is reachable from city $$$X$$$ ($$$X = 0$$$), while cities $$$2$$$ and $$$3$$$ are reachable from city $$$Y$$$ ($$$Y = 3$$$). Therefore, the convenience score is $$$1 + 2 = 3$$$. There is no assignment of closing times with convenience score more than $$$3$$$, so the procedure should return $$$3$$$.",
    "_meta": {
      "index": 60,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/A",
      "uuid": "ps_5a7d954e79d7948396aeea06851532a19b8cf7ba"
    }
  },
  {
    "planning_view": {
      "title": "A. Comparing Plants",
      "task": "Determine height order for plant pairs using cyclic r[i] values (n≤200,000)",
      "given": [
        "n distinct-height plants in circle (0 to n-1)",
        "r[i] = count of taller plants in next k-1 plants clockwise from i",
        "All r[i] values are provided"
      ],
      "goal": "For each query (x,y), determine if x is definitely taller/shorter than y",
      "key_rules": [
        "Plants have distinct heights in circular arrangement",
        "r[i] constraints involve consecutive plants in clockwise order",
        "At least one valid height configuration exists"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "k=2"
        },
        "2": {
          "points": 14,
          "req": "n≤5000, 2*k>n"
        },
        "3": {
          "points": 13,
          "req": "2*k>n"
        },
        "4": {
          "points": 17,
          "req": "All answers are 1 or -1 (no inconclusive)"
        },
        "5": {
          "points": 11,
          "req": "n≤300, q≤n*(n-1)/2"
        },
        "6": {
          "points": 15,
          "req": "x=0 for all queries"
        },
        "7": {
          "points": 25,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "A. Comparing Plants",
      "contest": "IOI 2020 day 1",
      "one_line": "Determine height order for plant pairs using cyclic r[i] values (n≤200,000)",
      "given": [
        "n distinct-height plants in circle (0 to n-1)",
        "r[i] = count of taller plants in next k-1 plants clockwise from i",
        "All r[i] values are provided"
      ],
      "goal": "For each query (x,y), determine if x is definitely taller/shorter than y",
      "mechanism": "Each r[i] constrains height relationships within k consecutive plants",
      "success_condition": "Return 1 if h[x]>h[y] in all consistent configurations, -1 if h[x]<h[y], 0 otherwise",
      "constraints": {
        "critical": [
          "Plants have distinct heights in circular arrangement",
          "r[i] constraints involve consecutive plants in clockwise order",
          "At least one valid height configuration exists"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "k=2"
          },
          "2": {
            "points": 14,
            "req": "n≤5000, 2*k>n"
          },
          "3": {
            "points": 13,
            "req": "2*k>n"
          },
          "4": {
            "points": 17,
            "req": "All answers are 1 or -1 (no inconclusive)"
          },
          "5": {
            "points": 11,
            "req": "n≤300, q≤n*(n-1)/2"
          },
          "6": {
            "points": 15,
            "req": "x=0 for all queries"
          },
          "7": {
            "points": 25,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "5 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A. Comparing Plants",
        "contest": "IOI 2020 day 1",
        "one_line": "Determine height order for plant pairs using cyclic r[i] values (n≤200,000)"
      },
      "problem": {
        "given": [
          "n distinct-height plants in circle (0 to n-1)",
          "r[i] = count of taller plants in next k-1 plants clockwise from i",
          "All r[i] values are provided"
        ],
        "goal": "For each query (x,y), determine if x is definitely taller/shorter than y",
        "mechanism": "Each r[i] constrains height relationships within k consecutive plants",
        "success_condition": "Return 1 if h[x]>h[y] in all consistent configurations, -1 if h[x]<h[y], 0 otherwise"
      },
      "constraints": {
        "critical": [
          "Plants have distinct heights in circular arrangement",
          "r[i] constraints involve consecutive plants in clockwise order",
          "At least one valid height configuration exists"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "k=2"
          },
          "2": {
            "points": 14,
            "req": "n≤5000, 2*k>n"
          },
          "3": {
            "points": 13,
            "req": "2*k>n"
          },
          "4": {
            "points": 17,
            "req": "All answers are 1 or -1 (no inconclusive)"
          },
          "5": {
            "points": 11,
            "req": "n≤300, q≤n*(n-1)/2"
          },
          "6": {
            "points": 15,
            "req": "x=0 for all queries"
          },
          "7": {
            "points": 25,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int compare_plants(int x, int y)",
        "available_api": {
          "init": {
            "signature": "void init(int k, int[] r)",
            "params": "k: consecutive plants considered, r: array of size n",
            "returns": "void",
            "side_effect": "Initializes data structures for future queries"
          },
          "compare_plants": {
            "signature": "int compare_plants(int x, int y)",
            "params": "x,y: plant labels to compare (0-indexed)",
            "returns": "1 if x>y, -1 if x<y, 0 if undetermined",
            "side_effect": "None"
          }
        },
        "requirements": [
          "init() called exactly once before any compare_plants() calls",
          "compare_plants() called exactly q times",
          "Plants are 0-indexed",
          "Must handle n,q ≤ 200,000 efficiently"
        ]
      },
      "limits": {
        "time": "5 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "4 3 2\n0 1 1 2\n0 2\n1 2",
          "output": "1\n-1"
        }
      ],
      "original_statement": "Hazel the botanist visited a special exhibition in the Singapore Botanical Gardens. In this exhibition, $$$n$$$ plants of\ndistinct heights\nare placed in a circle. These plants are labelled from $$$0$$$ to $$$n - 1$$$ in clockwise order, with plant $$$n-1$$$ beside plant $$$0$$$.\nFor each plant $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), Hazel compared plant $$$i$$$ to each of the next $$$k-1$$$ plants in clockwise order, and wrote down the number $$$r[i]$$$ denoting how many of these $$$k-1$$$ plants are taller than plant $$$i$$$. Thus, each value $$$r[i]$$$ depends on the relative heights of some $$$k$$$ consecutive plants.\nFor example, suppose $$$n=5$$$, $$$k=3$$$ and $$$i=3$$$. The next $$$k-1 = 2$$$ plants in clockwise order from plant $$$i = 3$$$ would be plant $$$4$$$ and plant $$$0$$$. If plant $$$4$$$ was taller than plant $$$3$$$ and plant $$$0$$$ was shorter than plant $$$3$$$, Hazel would write down $$$r[3] = 1$$$.\nYou may assume that Hazel recorded the values $$$r[i]$$$ correctly. Thus, there is at least one configuration of distinct heights of plants consistent with these values.\nYou were asked to compare the heights of $$$q$$$ pairs of plants. Sadly, you do not have access to the exhibition. Your only source of information is Hazel's notebook with the value $$$k$$$ and the sequence of values $$$r[0], \\ldots, r[n-1]$$$.\nFor each pair of different plants $$$x$$$ and $$$y$$$ that need to be compared, determine which of the three following situations occurs:\nPlant $$$x$$$ is definitely taller than plant $$$y$$$: in any configuration of distinct heights $$$h[0], \\ldots, h[n - 1]$$$ consistent with the array $$$r$$$ we have $$$h[x] > h[y]$$$.\nPlant $$$x$$$ is definitely shorter than plant $$$y$$$: in any configuration of distinct heights $$$h[0], \\ldots, h[n - 1]$$$ consistent with the array $$$r$$$ we have $$$h[x] < h[y]$$$.\nThe comparison is inconclusive: neither of the previous two cases applies.\nImplementation details\nYou should implement the following procedures:\nvoid init(int k, int[] r)\n$$$k$$$: the number of consecutive plants whose heights determine each individual value $$$r[i]$$$.\n$$$r$$$: an array of size $$$n$$$, where $$$r[i]$$$ is the number of plants taller than plant $$$i$$$ among the next $$$k-1$$$ plants in clockwise order.\nThis procedure is called exactly once, before any calls to\ncompare_plants\n.\nint compare_plants(int x, int y)\n$$$x$$$, $$$y$$$: labels of the plants to be compared.\nThis procedure should return:\n$$$1$$$ if plant $$$x$$$ is definitely taller than plant $$$y$$$,\n$$$-1$$$ if plant $$$x$$$ is definitely shorter than plant $$$y$$$,\n$$$0$$$ if the comparison is inconclusive.\nThis procedure is called exactly $$$q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ k\\ q$$$ ($$$2 \\leq k \\leq n \\leq 200\\,000$$$, $$$1 \\leq q \\leq 200\\,000$$$)\nline $$$2$$$: $$$r[0]\\ r[1]\\ldots\\ r[n-1]$$$ ($$$0 \\leq r[i] \\leq k - 1$$$ (for all $$$0 \\leq i \\leq n - 1$$$))\nline $$$3 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): $$$x\\ y$$$ ($$$0 \\leq x < y \\leq n - 1$$$) for the $$$i$$$-th call to {compare_plants}\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + i$$$ ($$$0 \\leq i \\leq q - 1)$$$: return value of the $$$i$$$-th call to\ncompare_plants\n.\nThere exists one or more configurations of\ndistinct heights\nof plants consistent with the array $$$r$$$.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$k = 2$$$\n2\n14\n$$$n \\leq 5000$$$, $$$2 \\cdot k \\textgreater n$$$\n3\n13\n$$$2\\cdot k \\textgreater n$$$\n4\n17\nThe correct answer to each call of\ncompare_plants\nis $$$1$$$ or $$$-1$$$.\n5\n11\n$$$n \\le 300, q \\le \\frac{n\\cdot (n-1)}{2}$$$\n6\n15\n$$$x=0$$$ for each call of\ncompare_plants\n.\n7\n25\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\ninit(3, [0, 1, 1, 2])\nLet's say the grader calls\ncompare_plants(0, 2)\n. Since $$$r[0] = 0$$$ we can immediately infer that plant $$$2$$$ is not taller than plant $$$0$$$. Therefore, the call should return $$$1$$$.\nLet's say the grader calls\ncompare_plants(1, 2)\nnext. For all possible configurations of heights that fit the constraints above, plant $$$1$$$ is shorter than plant $$$2$$$. Therefore, the call should return $$$-1$$$.\nExample 2\nConsider the following call:\ninit(2, [0, 1, 0, 1])\nLet's say the grader calls\ncompare_plants(0, 3)\n. Since $$$r[3] = 1$$$, we know that plant $$$0$$$ is taller than plant $$$3$$$. Therefore, the call should return $$$1$$$.\nLet's say the grader calls\ncompare_plants(1, 3)\nnext. Two configurations of heights $$$[3,1,4,2]$$$ and $$$[3,2,4,1]$$$ are both consistent with Hazel's measurements. Since plant $$$1$$$ is shorter than plant $$$3$$$ in one configuration and taller than plant $$$3$$$ in the other, this call should return $$$0$$$."
    },
    "original": "Hazel the botanist visited a special exhibition in the Singapore Botanical Gardens. In this exhibition, $$$n$$$ plants of\ndistinct heights\nare placed in a circle. These plants are labelled from $$$0$$$ to $$$n - 1$$$ in clockwise order, with plant $$$n-1$$$ beside plant $$$0$$$.\nFor each plant $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), Hazel compared plant $$$i$$$ to each of the next $$$k-1$$$ plants in clockwise order, and wrote down the number $$$r[i]$$$ denoting how many of these $$$k-1$$$ plants are taller than plant $$$i$$$. Thus, each value $$$r[i]$$$ depends on the relative heights of some $$$k$$$ consecutive plants.\nFor example, suppose $$$n=5$$$, $$$k=3$$$ and $$$i=3$$$. The next $$$k-1 = 2$$$ plants in clockwise order from plant $$$i = 3$$$ would be plant $$$4$$$ and plant $$$0$$$. If plant $$$4$$$ was taller than plant $$$3$$$ and plant $$$0$$$ was shorter than plant $$$3$$$, Hazel would write down $$$r[3] = 1$$$.\nYou may assume that Hazel recorded the values $$$r[i]$$$ correctly. Thus, there is at least one configuration of distinct heights of plants consistent with these values.\nYou were asked to compare the heights of $$$q$$$ pairs of plants. Sadly, you do not have access to the exhibition. Your only source of information is Hazel's notebook with the value $$$k$$$ and the sequence of values $$$r[0], \\ldots, r[n-1]$$$.\nFor each pair of different plants $$$x$$$ and $$$y$$$ that need to be compared, determine which of the three following situations occurs:\nPlant $$$x$$$ is definitely taller than plant $$$y$$$: in any configuration of distinct heights $$$h[0], \\ldots, h[n - 1]$$$ consistent with the array $$$r$$$ we have $$$h[x] > h[y]$$$.\nPlant $$$x$$$ is definitely shorter than plant $$$y$$$: in any configuration of distinct heights $$$h[0], \\ldots, h[n - 1]$$$ consistent with the array $$$r$$$ we have $$$h[x] < h[y]$$$.\nThe comparison is inconclusive: neither of the previous two cases applies.\nImplementation details\nYou should implement the following procedures:\nvoid init(int k, int[] r)\n$$$k$$$: the number of consecutive plants whose heights determine each individual value $$$r[i]$$$.\n$$$r$$$: an array of size $$$n$$$, where $$$r[i]$$$ is the number of plants taller than plant $$$i$$$ among the next $$$k-1$$$ plants in clockwise order.\nThis procedure is called exactly once, before any calls to\ncompare_plants\n.\nint compare_plants(int x, int y)\n$$$x$$$, $$$y$$$: labels of the plants to be compared.\nThis procedure should return:\n$$$1$$$ if plant $$$x$$$ is definitely taller than plant $$$y$$$,\n$$$-1$$$ if plant $$$x$$$ is definitely shorter than plant $$$y$$$,\n$$$0$$$ if the comparison is inconclusive.\nThis procedure is called exactly $$$q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ k\\ q$$$ ($$$2 \\leq k \\leq n \\leq 200\\,000$$$, $$$1 \\leq q \\leq 200\\,000$$$)\nline $$$2$$$: $$$r[0]\\ r[1]\\ldots\\ r[n-1]$$$ ($$$0 \\leq r[i] \\leq k - 1$$$ (for all $$$0 \\leq i \\leq n - 1$$$))\nline $$$3 + i$$$ ($$$0 \\leq i \\leq q - 1$$$): $$$x\\ y$$$ ($$$0 \\leq x < y \\leq n - 1$$$) for the $$$i$$$-th call to {compare_plants}\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + i$$$ ($$$0 \\leq i \\leq q - 1)$$$: return value of the $$$i$$$-th call to\ncompare_plants\n.\nThere exists one or more configurations of\ndistinct heights\nof plants consistent with the array $$$r$$$.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$k = 2$$$\n2\n14\n$$$n \\leq 5000$$$, $$$2 \\cdot k \\textgreater n$$$\n3\n13\n$$$2\\cdot k \\textgreater n$$$\n4\n17\nThe correct answer to each call of\ncompare_plants\nis $$$1$$$ or $$$-1$$$.\n5\n11\n$$$n \\le 300, q \\le \\frac{n\\cdot (n-1)}{2}$$$\n6\n15\n$$$x=0$$$ for each call of\ncompare_plants\n.\n7\n25\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\ninit(3, [0, 1, 1, 2])\nLet's say the grader calls\ncompare_plants(0, 2)\n. Since $$$r[0] = 0$$$ we can immediately infer that plant $$$2$$$ is not taller than plant $$$0$$$. Therefore, the call should return $$$1$$$.\nLet's say the grader calls\ncompare_plants(1, 2)\nnext. For all possible configurations of heights that fit the constraints above, plant $$$1$$$ is shorter than plant $$$2$$$. Therefore, the call should return $$$-1$$$.\nExample 2\nConsider the following call:\ninit(2, [0, 1, 0, 1])\nLet's say the grader calls\ncompare_plants(0, 3)\n. Since $$$r[3] = 1$$$, we know that plant $$$0$$$ is taller than plant $$$3$$$. Therefore, the call should return $$$1$$$.\nLet's say the grader calls\ncompare_plants(1, 3)\nnext. Two configurations of heights $$$[3,1,4,2]$$$ and $$$[3,2,4,1]$$$ are both consistent with Hazel's measurements. Since plant $$$1$$$ is shorter than plant $$$3$$$ in one configuration and taller than plant $$$3$$$ in the other, this call should return $$$0$$$.",
    "_meta": {
      "index": 61,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/A",
      "uuid": "ps_2e991543ae5a5530ebb38c1eedce6e29168b1441"
    }
  },
  {
    "planning_view": {
      "title": "C. Toy Train",
      "task": "Determine if Arezou wins starting from each station with optimal play",
      "given": [
        "n stations (0 to n-1), m one-way tracks",
        "Each station owned by Arezou (1) or Borzou (0)",
        "Some stations are charging stations",
        "Fully charged train can travel n consecutive tracks",
        "At least one track starts from each station"
      ],
      "goal": "For each starting station s, determine if Arezou can guarantee victory",
      "key_rules": [
        "Train owner sets switch when train first visits their station",
        "Switches remain fixed once set",
        "Train runs out of energy after n tracks without charging",
        "Arezou wins if cycle contains charging station"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "All tracks are self-loops or go to next station"
        },
        "2": {
          "points": 10,
          "req": "n ≤ 15"
        },
        "3": {
          "points": 11,
          "req": "Arezou owns all stations"
        },
        "4": {
          "points": 11,
          "req": "Borzou owns all stations"
        },
        "5": {
          "points": 12,
          "req": "Exactly one charging station"
        },
        "6": {
          "points": 51,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Toy Train",
      "contest": "IOI 2017 day 1",
      "one_line": "Determine if Arezou wins starting from each station with optimal play",
      "given": [
        "n stations (0 to n-1), m one-way tracks",
        "Each station owned by Arezou (1) or Borzou (0)",
        "Some stations are charging stations",
        "Fully charged train can travel n consecutive tracks",
        "At least one track starts from each station"
      ],
      "goal": "For each starting station s, determine if Arezou can guarantee victory",
      "mechanism": "At each station, owner sets switch to outgoing track; once set, switch stays fixed",
      "success_condition": "Arezou wins if train cycles through at least one charging station indefinitely",
      "constraints": {
        "critical": [
          "Train owner sets switch when train first visits their station",
          "Switches remain fixed once set",
          "Train runs out of energy after n tracks without charging",
          "Arezou wins if cycle contains charging station"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "All tracks are self-loops or go to next station"
          },
          "2": {
            "points": 10,
            "req": "n ≤ 15"
          },
          "3": {
            "points": 11,
            "req": "Arezou owns all stations"
          },
          "4": {
            "points": 11,
            "req": "Borzou owns all stations"
          },
          "5": {
            "points": 12,
            "req": "Exactly one charging station"
          },
          "6": {
            "points": 51,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Toy Train",
        "contest": "IOI 2017 day 1",
        "one_line": "Determine if Arezou wins starting from each station with optimal play"
      },
      "problem": {
        "given": [
          "n stations (0 to n-1), m one-way tracks",
          "Each station owned by Arezou (1) or Borzou (0)",
          "Some stations are charging stations",
          "Fully charged train can travel n consecutive tracks",
          "At least one track starts from each station"
        ],
        "goal": "For each starting station s, determine if Arezou can guarantee victory",
        "mechanism": "At each station, owner sets switch to outgoing track; once set, switch stays fixed",
        "success_condition": "Arezou wins if train cycles through at least one charging station indefinitely"
      },
      "constraints": {
        "critical": [
          "Train owner sets switch when train first visits their station",
          "Switches remain fixed once set",
          "Train runs out of energy after n tracks without charging",
          "Arezou wins if cycle contains charging station"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "All tracks are self-loops or go to next station"
          },
          "2": {
            "points": 10,
            "req": "n ≤ 15"
          },
          "3": {
            "points": 11,
            "req": "Arezou owns all stations"
          },
          "4": {
            "points": 11,
            "req": "Borzou owns all stations"
          },
          "5": {
            "points": 12,
            "req": "Exactly one charging station"
          },
          "6": {
            "points": 51,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] who_wins(int[] a, int[] r, int[] u, int[] v)",
        "available_api": {
          "who_wins": {
            "signature": "int[] who_wins(int[] a, int[] r, int[] u, int[] v)",
            "params": "a: ownership (1=Arezou, 0=Borzou), r: charging stations (1=charger), u/v: track endpoints",
            "returns": "Array w where w[i]=1 if Arezou wins starting from station i",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Stations are 0-indexed (0 to n-1)",
          "Each track is distinct (no duplicates)",
          "At least one charging station exists",
          "At least one track starts from each station"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "2 4\n0 1\n1 0\n0 0\n0 1\n1 0\n1 1",
          "output": "1 1"
        }
      ],
      "original_statement": "Arezou and her brother Borzou are twins. They have received an amazing toy train set for their birthday, and they used it to build a railway system with $$$n$$$ stations and $$$m$$$\none-way\ntracks. The stations are numbered from $$$0$$$ to $$$n - 1$$$. Each track starts at one station and ends at the same or a different station. There is at least one track starting at each station.\nSome stations are\ncharging stations\n. Whenever the train arrives at a charging station, it gets fully charged. A fully charged train has enough energy to travel along $$$n$$$ consecutive tracks. That is, the train runs out of energy just when it enters the $$$n + 1$$$-st track after last being charged.\nOn each station there is a switch that can be pointed to any of the tracks that start at that station. When a train is at a station, it leaves it using the track that is pointed to by the switch on that station.\nThe twins are going to play a game with their train. They have already divided all the stations between themselves: each station is either owned by Arezou or by Borzou. There is a single train. At the beginning of the game the train is at station $$$s$$$ and it is fully charged. To start the game, the owner of station $$$s$$$ points the switch on station $$$s$$$ to one of the tracks that start at station $$$s$$$. Then, they turn the train on and the train starts traveling along the tracks.\nWhenever the train enters a station for the first time, the owner of that station sets the switch on that station. Once a switch is set, it stays in the same position for the rest of the game. Thus, if a train re-enters a station it visited before, it will leave that station along the same track as before.\nSince there is a finite number of stations, the train will eventually start going along a\ncycle\n. A cycle is a sequence of\ndistinct\nstations $$$c[0], c[1], \\ldots, c[k - 1]$$$ such that the train leaves station $$$c[i]$$$ (for $$$0 \\le i < k - 1$$$) using a track going to station $$$c[i + 1]$$$, and it leaves station $$$c[k - 1]$$$ using a track going to station $$$c[0]$$$. Note that a cycle may consist of a single station (i.e., have $$$k = 1$$$) if the train leaves the station $$$c[0]$$$ using a track that goes back to $$$c[0]$$$.\nArezou wins the game if the train continues going indefinitely, and Borzou wins if the train runs out of energy. In other words, if there is at least one charging station among $$$c[0], c[1], \\ldots, c[k - 1]$$$, the train can recharge and cycle indefinitely, and Arezou wins. Otherwise, it will run out of energy (possibly after turning around the cycle several times), and Borzou wins.\nYou are given the description of the railway system. Arezou and Borzou are going to play $$$n$$$ games. In the $$$s$$$-th game, for $$$0 \\le s \\le n - 1$$$, the train will initially be at station $$$s$$$. Your task is to find, for each game, whether there is a strategy for Arezou that guarantees she wins, regardless of how Borzou plays.\nImplementation details\nYou should implement the following procedure:\nint[] who_wins(int[] a, int[] r, int[] u, int[] v)\n$$$a$$$: array of length $$$n$$$. If Arezou owns station $$$i$$$, $$$a[i] = 1$$$. Otherwise, Borzou owns station $$$i$$$ and $$$a[i] = 0$$$.\n$$$r$$$: array of length $$$n$$$. If the station $$$i$$$ is a charging station, $$$r[i] = 1$$$. Otherwise, $$$r[i] = 0$$$.\n$$$u$$$ and $$$v$$$: arrays of length $$$m$$$. For all $$$0 \\leq i \\leq m - 1$$$, there is a one-way track starting at station $$$u[i]$$$ and ending at station $$$v[i]$$$.\nThis procedure should return an array $$$w$$$ of length $$$n$$$. For each $$$0 \\leq i \\leq n-1$$$, the value of $$$w[i]$$$ should be $$$1$$$ if Arezou can win the game that starts at station $$$i$$$, regardless of how Borzou plays. Otherwise, the value of $$$w[i]$$$ should be $$$0$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$m$$$ ($$$1 \\leq n \\leq 5000$$$, $$$n \\leq m \\leq 20\\,000$$$)\nline 2: $$$a[0], a[1], \\ldots, a[n - 1]$$$\nline 3: $$$r[0], r[1], \\ldots, r[n - 1]$$$\nline $$$4 + i$$$ (for $$$0 \\le i \\le m - 1$$$): $$$u[i]$$$, $$$v[i]$$$ ($$$0 \\le u[i], v[i] \\le n - 1$$$)\nThere is at least one charging station. There is at least one track starting at each station.\nThere might be tracks that start and end at the same station (i.e., $$$u[i] = v[i]$$$).\nEach track is distinct. In other words, there are no such two indices $$$i$$$ and $$$j$$$ ($$$0 \\le i < j \\le m - 1$$$) that $$$u[i] = u[j]$$$ and $$$v[i] = v[j]$$$.\nOutput\nThe sample grader prints the return value of\nwho_wins\nin the following format:\nline 1: $$$w[0], w[1], \\ldots, w[n - 1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\nFor all $$$0 \\le i \\le m - 1$$$, either $$$v[i] = u[i]$$$ or $$$v[i] = u[i] + 1$$$\n2\n10\n$$$n \\leq 15$$$\n3\n11\nArezou owns all stations.\n4\n11\nBorzou owns all stations.\n5\n12\nThere is exactly one charging station.\n6\n51\nNo additional constraints.\nExample\nNote\nwho_wins([0, 1], [1, 0], [0, 0, 1, 1], [0, 1, 0, 1])\nThere are 2 stations. Borzou is the owner of station $$$0$$$, which is a charging station. Arezou is the owner of station $$$1$$$, which is not a charging station.\nThere are $$$4$$$ tracks $$$(0, 0), (0, 1), (1, 0)$$$, and $$$(1, 1)$$$, where $$$(i, j)$$$ denotes a one-way track from station $$$i$$$ to station $$$j$$$.\nConsider the game in which the train is initially placed at station $$$0$$$. If Borzou sets the switch on station $$$0$$$ towards the track $$$(0, 0)$$$, the train will indefinitely cycle through this track (note that station $$$0$$$ is a charging station). In this case, Arezou wins. Otherwise, if Borzou sets the switch on station $$$0$$$ towards track $$$(0, 1)$$$, Arezou can set the switch on station $$$1$$$ towards $$$(1, 0)$$$. If this happens, the train will indefinitely cycle through both stations. Again Arezou wins, since station $$$0$$$ is a charging station and the train will not stop. Hence, Arezou can win the game, regardless of what Borzou does.\nBy a similar reasoning, in the game starting at station $$$1$$$ Arezou can also win, regardless of how Borzou plays. Thus, the procedure should return $$$[1, 1]$$$."
    },
    "original": "Arezou and her brother Borzou are twins. They have received an amazing toy train set for their birthday, and they used it to build a railway system with $$$n$$$ stations and $$$m$$$\none-way\ntracks. The stations are numbered from $$$0$$$ to $$$n - 1$$$. Each track starts at one station and ends at the same or a different station. There is at least one track starting at each station.\nSome stations are\ncharging stations\n. Whenever the train arrives at a charging station, it gets fully charged. A fully charged train has enough energy to travel along $$$n$$$ consecutive tracks. That is, the train runs out of energy just when it enters the $$$n + 1$$$-st track after last being charged.\nOn each station there is a switch that can be pointed to any of the tracks that start at that station. When a train is at a station, it leaves it using the track that is pointed to by the switch on that station.\nThe twins are going to play a game with their train. They have already divided all the stations between themselves: each station is either owned by Arezou or by Borzou. There is a single train. At the beginning of the game the train is at station $$$s$$$ and it is fully charged. To start the game, the owner of station $$$s$$$ points the switch on station $$$s$$$ to one of the tracks that start at station $$$s$$$. Then, they turn the train on and the train starts traveling along the tracks.\nWhenever the train enters a station for the first time, the owner of that station sets the switch on that station. Once a switch is set, it stays in the same position for the rest of the game. Thus, if a train re-enters a station it visited before, it will leave that station along the same track as before.\nSince there is a finite number of stations, the train will eventually start going along a\ncycle\n. A cycle is a sequence of\ndistinct\nstations $$$c[0], c[1], \\ldots, c[k - 1]$$$ such that the train leaves station $$$c[i]$$$ (for $$$0 \\le i < k - 1$$$) using a track going to station $$$c[i + 1]$$$, and it leaves station $$$c[k - 1]$$$ using a track going to station $$$c[0]$$$. Note that a cycle may consist of a single station (i.e., have $$$k = 1$$$) if the train leaves the station $$$c[0]$$$ using a track that goes back to $$$c[0]$$$.\nArezou wins the game if the train continues going indefinitely, and Borzou wins if the train runs out of energy. In other words, if there is at least one charging station among $$$c[0], c[1], \\ldots, c[k - 1]$$$, the train can recharge and cycle indefinitely, and Arezou wins. Otherwise, it will run out of energy (possibly after turning around the cycle several times), and Borzou wins.\nYou are given the description of the railway system. Arezou and Borzou are going to play $$$n$$$ games. In the $$$s$$$-th game, for $$$0 \\le s \\le n - 1$$$, the train will initially be at station $$$s$$$. Your task is to find, for each game, whether there is a strategy for Arezou that guarantees she wins, regardless of how Borzou plays.\nImplementation details\nYou should implement the following procedure:\nint[] who_wins(int[] a, int[] r, int[] u, int[] v)\n$$$a$$$: array of length $$$n$$$. If Arezou owns station $$$i$$$, $$$a[i] = 1$$$. Otherwise, Borzou owns station $$$i$$$ and $$$a[i] = 0$$$.\n$$$r$$$: array of length $$$n$$$. If the station $$$i$$$ is a charging station, $$$r[i] = 1$$$. Otherwise, $$$r[i] = 0$$$.\n$$$u$$$ and $$$v$$$: arrays of length $$$m$$$. For all $$$0 \\leq i \\leq m - 1$$$, there is a one-way track starting at station $$$u[i]$$$ and ending at station $$$v[i]$$$.\nThis procedure should return an array $$$w$$$ of length $$$n$$$. For each $$$0 \\leq i \\leq n-1$$$, the value of $$$w[i]$$$ should be $$$1$$$ if Arezou can win the game that starts at station $$$i$$$, regardless of how Borzou plays. Otherwise, the value of $$$w[i]$$$ should be $$$0$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$, $$$m$$$ ($$$1 \\leq n \\leq 5000$$$, $$$n \\leq m \\leq 20\\,000$$$)\nline 2: $$$a[0], a[1], \\ldots, a[n - 1]$$$\nline 3: $$$r[0], r[1], \\ldots, r[n - 1]$$$\nline $$$4 + i$$$ (for $$$0 \\le i \\le m - 1$$$): $$$u[i]$$$, $$$v[i]$$$ ($$$0 \\le u[i], v[i] \\le n - 1$$$)\nThere is at least one charging station. There is at least one track starting at each station.\nThere might be tracks that start and end at the same station (i.e., $$$u[i] = v[i]$$$).\nEach track is distinct. In other words, there are no such two indices $$$i$$$ and $$$j$$$ ($$$0 \\le i < j \\le m - 1$$$) that $$$u[i] = u[j]$$$ and $$$v[i] = v[j]$$$.\nOutput\nThe sample grader prints the return value of\nwho_wins\nin the following format:\nline 1: $$$w[0], w[1], \\ldots, w[n - 1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\nFor all $$$0 \\le i \\le m - 1$$$, either $$$v[i] = u[i]$$$ or $$$v[i] = u[i] + 1$$$\n2\n10\n$$$n \\leq 15$$$\n3\n11\nArezou owns all stations.\n4\n11\nBorzou owns all stations.\n5\n12\nThere is exactly one charging station.\n6\n51\nNo additional constraints.\nExample\nNote\nwho_wins([0, 1], [1, 0], [0, 0, 1, 1], [0, 1, 0, 1])\nThere are 2 stations. Borzou is the owner of station $$$0$$$, which is a charging station. Arezou is the owner of station $$$1$$$, which is not a charging station.\nThere are $$$4$$$ tracks $$$(0, 0), (0, 1), (1, 0)$$$, and $$$(1, 1)$$$, where $$$(i, j)$$$ denotes a one-way track from station $$$i$$$ to station $$$j$$$.\nConsider the game in which the train is initially placed at station $$$0$$$. If Borzou sets the switch on station $$$0$$$ towards the track $$$(0, 0)$$$, the train will indefinitely cycle through this track (note that station $$$0$$$ is a charging station). In this case, Arezou wins. Otherwise, if Borzou sets the switch on station $$$0$$$ towards track $$$(0, 1)$$$, Arezou can set the switch on station $$$1$$$ towards $$$(1, 0)$$$. If this happens, the train will indefinitely cycle through both stations. Again Arezou wins, since station $$$0$$$ is a charging station and the train will not stop. Hence, Arezou can win the game, regardless of what Borzou does.\nBy a similar reasoning, in the game starting at station $$$1$$$ Arezou can also win, regardless of how Borzou plays. Thus, the procedure should return $$$[1, 1]$$$.",
    "_meta": {
      "index": 62,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/C",
      "uuid": "ps_98353c0d72e65756e262cedbfbb26c8107c29b33"
    }
  },
  {
    "planning_view": {
      "title": "C. Werewolf",
      "task": "Check if Q trips can transform in [L,R] between S,E via N cities",
      "given": [
        "N cities connected by M bidirectional roads",
        "Cities numbered 0..N-1 by increasing population",
        "Q trips from S to E with thresholds L,R"
      ],
      "goal": "Determine for each trip if valid route exists satisfying transformation constraints",
      "key_rules": [
        "Must transform exactly once during trip (human→wolf)",
        "Human form cannot visit cities 0..L-1",
        "Wolf form cannot visit cities R+1..N-1",
        "Transformation must occur in city with population ∈ [L,R]",
        "Graph is connected"
      ],
      "target": {
        "1": {
          "points": 7,
          "req": "N ≤ 100, M ≤ 200, Q ≤ 100"
        },
        "2": {
          "points": 8,
          "req": "N ≤ 3,000, M ≤ 6,000, Q ≤ 3,000"
        },
        "3": {
          "points": 34,
          "req": "Tree with degree ≤ 2 (line)"
        },
        "4": {
          "points": 51,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Werewolf",
      "contest": "IOI 2018 day 1",
      "one_line": "Check if Q trips can transform in [L,R] between S,E via N cities",
      "given": [
        "N cities connected by M bidirectional roads",
        "Cities numbered 0..N-1 by increasing population",
        "Q trips from S to E with thresholds L,R"
      ],
      "goal": "Determine for each trip if valid route exists satisfying transformation constraints",
      "mechanism": "Travel S→E, transform once from human→wolf; avoid low-population cities as human, avoid high-population cities as wolf",
      "success_condition": "Trip possible if exists route where transformation occurs in city within [L,R] range",
      "constraints": {
        "critical": [
          "Must transform exactly once during trip (human→wolf)",
          "Human form cannot visit cities 0..L-1",
          "Wolf form cannot visit cities R+1..N-1",
          "Transformation must occur in city with population ∈ [L,R]",
          "Graph is connected"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "N ≤ 100, M ≤ 200, Q ≤ 100"
          },
          "2": {
            "points": 8,
            "req": "N ≤ 3,000, M ≤ 6,000, Q ≤ 3,000"
          },
          "3": {
            "points": 34,
            "req": "Tree with degree ≤ 2 (line)"
          },
          "4": {
            "points": 51,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Werewolf",
        "contest": "IOI 2018 day 1",
        "one_line": "Check if Q trips can transform in [L,R] between S,E via N cities"
      },
      "problem": {
        "given": [
          "N cities connected by M bidirectional roads",
          "Cities numbered 0..N-1 by increasing population",
          "Q trips from S to E with thresholds L,R"
        ],
        "goal": "Determine for each trip if valid route exists satisfying transformation constraints",
        "mechanism": "Travel S→E, transform once from human→wolf; avoid low-population cities as human, avoid high-population cities as wolf",
        "success_condition": "Trip possible if exists route where transformation occurs in city within [L,R] range"
      },
      "constraints": {
        "critical": [
          "Must transform exactly once during trip (human→wolf)",
          "Human form cannot visit cities 0..L-1",
          "Wolf form cannot visit cities R+1..N-1",
          "Transformation must occur in city with population ∈ [L,R]",
          "Graph is connected"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "N ≤ 100, M ≤ 200, Q ≤ 100"
          },
          "2": {
            "points": 8,
            "req": "N ≤ 3,000, M ≤ 6,000, Q ≤ 3,000"
          },
          "3": {
            "points": 34,
            "req": "Tree with degree ≤ 2 (line)"
          },
          "4": {
            "points": 51,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] check_validity(int N, int[] X, int[] Y, int[] S, int[] E, int[] L, int[] R)",
        "available_api": {},
        "requirements": [
          "Function called exactly once per test case",
          "Return array of length Q with 1/0 for each trip",
          "Cities are 0-indexed"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "6 6 3\n5 1\n1 2\n1 3\n3 4\n3 0\n5 2\n4 2 1 2\n4 2 2 2\n5 4 3 4",
          "output": "1\n0\n0"
        }
      ],
      "original_statement": "There are cities $$$N$$$ and $$$M$$$ roads in Ibaraki Prefecture, Japan. Cities are numbered from $$$0$$$ through $$$N-1$$$ in the increasing order of their population. Each road connects a pair of distinct cities, and can be traveled in both directions. You can travel from any city to any other city by using one or more of these roads.\nYou planned $$$Q$$$ trips, numbered from $$$0$$$ through $$$Q-1$$$. The trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ is to travel from $$$S_i$$$ the city to the city $$$E_i$$$.\nYou are a werewolf. You have two forms:\nhuman form\nand\nwolf form\n. At the beginning of each trip you are in human form. At the end of each trip, you must be in wolf form. During the trip you have to\ntransform\n(change from human form to wolf form) exactly once. You can transform only when you are in some city (possibly $$$S_i$$$ or $$$E_i$$$).\nLiving as a werewolf is not easy. You must avoid low-populated cities when you are in human form, and avoid highly-populated cities when you are in wolf form. For each trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ there are two thresholds $$$L_i$$$ and $$$R_i$$$ $$$(0 \\le L_i \\le R_i \\le N-1)$$$ that indicate which cities must be avoided. More specifically, you must avoid the cities $$$0, 1, \\dots , L_i-1$$$ when you are in human form, and must avoid the cities $$$R_i+1, R_i+2, \\dots ,N-1$$$ when you are in wolf form. This means in the trip $$$i$$$, you can only transform in one of the cities $$$L_i, L_i+1, \\dots , R_i.$$$\nYour task is to determine, for each trip, whether it is possible to travel from the city $$$S_i$$$ to the city $$$E_i$$$ in a way that satisfies the aforementioned constraints. The route you take can have an arbitrary length.\nImplementation details\nYou should implement the following function:\nint[] check_validity(int N, int[] X, int[] Y, int[] S, int[] E, int[] L, int[] R)\n$$$N$$$: the number of cities.\n$$$X$$$ and $$$Y$$$: arrays of length $$$M$$$. For each $$$j$$$ $$$(0 \\le j \\le M-1)$$$, the city $$$X[j]$$$ is directly connected to the city $$$Y[j]$$$ by a road.\n$$$S, E, L,$$$ and $$$R$$$: arrays of length $$$Q$$$, representing the trips.\nNote that the values of $$$M$$$ and $$$Q$$$ are the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nThe function\ncheck_validity\nis called exactly once for each test case. This function should return an array $$$A$$$ of integers of length $$$Q$$$. The value of $$$A_i$$$ $$$(0 \\le i \\le Q-1)$$$ must be $$$1$$$ if the trip $$$i$$$ is possible while satisfying the aforementioned conditions, or $$$0$$$ otherwise.\nConstraints\n$$$2 \\le N \\le 200\\,000$$$\n$$$N-1 \\le M \\le 400\\,000$$$\n$$$1 \\le Q \\le 200\\,000$$$\nFor each $$$j : 0 \\le j \\le M-1$$$\n$$$0 \\le X_j \\le N-1$$$\n$$$0 \\le Y_j \\le N-1$$$\n$$$X_j \\neq Y_j$$$\nYou can travel from any city to any other city by using roads.\nEach pair of cities are directly connected by at most one road. In other words, $$$(X_j, Y_j) \\neq (X_k, Y_k)$$$ and $$$(Y_j, X_j) \\neq (X_k, Y_k)$$$ for all $$$j, k: 0 \\le j < k \\le M-1$$$\nFor each $$$i: 0 \\le i \\le Q-1$$$\n$$$0 \\le L_i \\le S_i \\le N-1$$$\n$$$0 \\le E_i \\le R_i \\le N-1$$$\n$$$S_i \\neq E_i$$$\n$$$L_i \\le R_i$$$\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$1$$$\n:\n$$$N$$$ $$$M$$$ $$$Q$$$\nline\n$$$2+j$$$\n:\n$$$X_j$$$ $$$Y_j$$$\n$$$0 \\le j \\le M-1$$$\nline\n$$$2+M+i$$$\n:\n$$$S_i$$$ $$$E_i$$$ $$$L_i$$$ $$$R_i$$$\n$$$0 \\le i \\le Q-1$$$\nThe sample grader prints the return value of\ncheck_validity\nin the following format:\nline\n$$$1+i$$$\n:\n$$$A_i$$$\n$$$0 \\le i \\le Q-1$$$\nScoring\nSubtasks\nSubtask\nPoints\nAdditional constraints\n$$$1$$$\n$$$7$$$\n$$$N \\le 100,$$$ $$$M \\le 200,$$$ $$$Q \\le 100$$$\n$$$2$$$\n$$$8$$$\n$$$N \\le 3\\,000,$$$ $$$M \\le 6\\,000,$$$ $$$Q \\le 3\\,000$$$\n$$$3$$$\n$$$34$$$\n$$$M=N-1$$$ and each city is incident to at most $$$2$$$ roads (the cities are connected in a line)\n$$$4$$$\n$$$51$$$\nNo\nExamples\nNote\nExample\nLet $$$N=6,$$$ $$$M=6,$$$ $$$Q=3,$$$ $$$X=[5,1,1,3,3,5],$$$ $$$Y=[1,2,3,4,0,2],$$$ $$$S=[4,4,5],$$$ $$$E=[2,2,4],$$$ $$$L=[1,2,3],$$$ and $$$R=[2,2,4].$$$\nThe grader calls\ncheck_validity(6, [5, 1, 1, 3, 3, 5], [1, 2, 3, 4, 0, 2], [4, 4, 5], [2, 2, 4], [1, 2, 3], [2, 2, 4]).\nFor the trip $$$0$$$, you can travel from the city $$$4$$$ to the city $$$2$$$ as follows:\nStart at the city $$$4$$$ (You are in human form)\nMove to the city $$$3$$$ (You are in human form)\nMove to the city $$$1$$$(You are in human form)\nTransform yourself into wolf form (You are in wolf form)\nMove to the city $$$2$$$(You are in wolf form)\nFor the trips $$$1$$$ and $$$2$$$, you cannot travel between the given cities.\nHence, your program should return $$$[1,0,0].$$$\nThe files\nsample-01-in.txt\nand\nsample-01-out.txt\nin the zipped attachment package correspond to this example. This package also contains another pair of sample input/output files."
    },
    "original": "There are cities $$$N$$$ and $$$M$$$ roads in Ibaraki Prefecture, Japan. Cities are numbered from $$$0$$$ through $$$N-1$$$ in the increasing order of their population. Each road connects a pair of distinct cities, and can be traveled in both directions. You can travel from any city to any other city by using one or more of these roads.\nYou planned $$$Q$$$ trips, numbered from $$$0$$$ through $$$Q-1$$$. The trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ is to travel from $$$S_i$$$ the city to the city $$$E_i$$$.\nYou are a werewolf. You have two forms:\nhuman form\nand\nwolf form\n. At the beginning of each trip you are in human form. At the end of each trip, you must be in wolf form. During the trip you have to\ntransform\n(change from human form to wolf form) exactly once. You can transform only when you are in some city (possibly $$$S_i$$$ or $$$E_i$$$).\nLiving as a werewolf is not easy. You must avoid low-populated cities when you are in human form, and avoid highly-populated cities when you are in wolf form. For each trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ there are two thresholds $$$L_i$$$ and $$$R_i$$$ $$$(0 \\le L_i \\le R_i \\le N-1)$$$ that indicate which cities must be avoided. More specifically, you must avoid the cities $$$0, 1, \\dots , L_i-1$$$ when you are in human form, and must avoid the cities $$$R_i+1, R_i+2, \\dots ,N-1$$$ when you are in wolf form. This means in the trip $$$i$$$, you can only transform in one of the cities $$$L_i, L_i+1, \\dots , R_i.$$$\nYour task is to determine, for each trip, whether it is possible to travel from the city $$$S_i$$$ to the city $$$E_i$$$ in a way that satisfies the aforementioned constraints. The route you take can have an arbitrary length.\nImplementation details\nYou should implement the following function:\nint[] check_validity(int N, int[] X, int[] Y, int[] S, int[] E, int[] L, int[] R)\n$$$N$$$: the number of cities.\n$$$X$$$ and $$$Y$$$: arrays of length $$$M$$$. For each $$$j$$$ $$$(0 \\le j \\le M-1)$$$, the city $$$X[j]$$$ is directly connected to the city $$$Y[j]$$$ by a road.\n$$$S, E, L,$$$ and $$$R$$$: arrays of length $$$Q$$$, representing the trips.\nNote that the values of $$$M$$$ and $$$Q$$$ are the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nThe function\ncheck_validity\nis called exactly once for each test case. This function should return an array $$$A$$$ of integers of length $$$Q$$$. The value of $$$A_i$$$ $$$(0 \\le i \\le Q-1)$$$ must be $$$1$$$ if the trip $$$i$$$ is possible while satisfying the aforementioned conditions, or $$$0$$$ otherwise.\nConstraints\n$$$2 \\le N \\le 200\\,000$$$\n$$$N-1 \\le M \\le 400\\,000$$$\n$$$1 \\le Q \\le 200\\,000$$$\nFor each $$$j : 0 \\le j \\le M-1$$$\n$$$0 \\le X_j \\le N-1$$$\n$$$0 \\le Y_j \\le N-1$$$\n$$$X_j \\neq Y_j$$$\nYou can travel from any city to any other city by using roads.\nEach pair of cities are directly connected by at most one road. In other words, $$$(X_j, Y_j) \\neq (X_k, Y_k)$$$ and $$$(Y_j, X_j) \\neq (X_k, Y_k)$$$ for all $$$j, k: 0 \\le j < k \\le M-1$$$\nFor each $$$i: 0 \\le i \\le Q-1$$$\n$$$0 \\le L_i \\le S_i \\le N-1$$$\n$$$0 \\le E_i \\le R_i \\le N-1$$$\n$$$S_i \\neq E_i$$$\n$$$L_i \\le R_i$$$\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$1$$$\n:\n$$$N$$$ $$$M$$$ $$$Q$$$\nline\n$$$2+j$$$\n:\n$$$X_j$$$ $$$Y_j$$$\n$$$0 \\le j \\le M-1$$$\nline\n$$$2+M+i$$$\n:\n$$$S_i$$$ $$$E_i$$$ $$$L_i$$$ $$$R_i$$$\n$$$0 \\le i \\le Q-1$$$\nThe sample grader prints the return value of\ncheck_validity\nin the following format:\nline\n$$$1+i$$$\n:\n$$$A_i$$$\n$$$0 \\le i \\le Q-1$$$\nScoring\nSubtasks\nSubtask\nPoints\nAdditional constraints\n$$$1$$$\n$$$7$$$\n$$$N \\le 100,$$$ $$$M \\le 200,$$$ $$$Q \\le 100$$$\n$$$2$$$\n$$$8$$$\n$$$N \\le 3\\,000,$$$ $$$M \\le 6\\,000,$$$ $$$Q \\le 3\\,000$$$\n$$$3$$$\n$$$34$$$\n$$$M=N-1$$$ and each city is incident to at most $$$2$$$ roads (the cities are connected in a line)\n$$$4$$$\n$$$51$$$\nNo\nExamples\nNote\nExample\nLet $$$N=6,$$$ $$$M=6,$$$ $$$Q=3,$$$ $$$X=[5,1,1,3,3,5],$$$ $$$Y=[1,2,3,4,0,2],$$$ $$$S=[4,4,5],$$$ $$$E=[2,2,4],$$$ $$$L=[1,2,3],$$$ and $$$R=[2,2,4].$$$\nThe grader calls\ncheck_validity(6, [5, 1, 1, 3, 3, 5], [1, 2, 3, 4, 0, 2], [4, 4, 5], [2, 2, 4], [1, 2, 3], [2, 2, 4]).\nFor the trip $$$0$$$, you can travel from the city $$$4$$$ to the city $$$2$$$ as follows:\nStart at the city $$$4$$$ (You are in human form)\nMove to the city $$$3$$$ (You are in human form)\nMove to the city $$$1$$$(You are in human form)\nTransform yourself into wolf form (You are in wolf form)\nMove to the city $$$2$$$(You are in wolf form)\nFor the trips $$$1$$$ and $$$2$$$, you cannot travel between the given cities.\nHence, your program should return $$$[1,0,0].$$$\nThe files\nsample-01-in.txt\nand\nsample-01-out.txt\nin the zipped attachment package correspond to this example. This package also contains another pair of sample input/output files.",
    "_meta": {
      "index": 63,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
      "uuid": "ps_b598c7d54571d38321f3a7f99e407bafafc3da22"
    }
  },
  {
    "planning_view": {
      "title": "C. Werewolf",
      "task": "Check if Q trips allow transforming human→wolf at city with population between L_i and R_i",
      "given": [
        "N cities numbered by population (0=smallest, N-1=largest)",
        "M bidirectional roads connecting cities",
        "Graph is connected",
        "Q trips from S_i to E_i with thresholds L_i and R_i"
      ],
      "goal": "Determine for each trip if path exists satisfying transformation constraints",
      "key_rules": [
        "Human form cannot visit cities with population < L_i",
        "Wolf form cannot visit cities with population > R_i",
        "Transformation must occur at city with population between L_i and R_i",
        "Must transform exactly once during trip",
        "Graph is connected with unique roads between cities"
      ],
      "target": {
        "1": {
          "points": 7,
          "req": "N ≤ 100, M ≤ 200, Q ≤ 100"
        },
        "2": {
          "points": 8,
          "req": "N ≤ 3,000, M ≤ 6,000, Q ≤ 3,000"
        },
        "3": {
          "points": 34,
          "req": "Tree with max degree 2 (line graph)"
        },
        "4": {
          "points": 51,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Werewolf",
      "contest": "IOI 2018 day 1",
      "one_line": "Check if Q trips allow transforming human→wolf at city with population between L_i and R_i",
      "given": [
        "N cities numbered by population (0=smallest, N-1=largest)",
        "M bidirectional roads connecting cities",
        "Graph is connected",
        "Q trips from S_i to E_i with thresholds L_i and R_i"
      ],
      "goal": "Determine for each trip if path exists satisfying transformation constraints",
      "mechanism": "Start human at S_i, transform once at city with population in [L_i,R_i], end wolf at E_i",
      "success_condition": "Valid path exists using only cities ≥L_i as human and cities ≤R_i as wolf",
      "constraints": {
        "critical": [
          "Human form cannot visit cities with population < L_i",
          "Wolf form cannot visit cities with population > R_i",
          "Transformation must occur at city with population between L_i and R_i",
          "Must transform exactly once during trip",
          "Graph is connected with unique roads between cities"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "N ≤ 100, M ≤ 200, Q ≤ 100"
          },
          "2": {
            "points": 8,
            "req": "N ≤ 3,000, M ≤ 6,000, Q ≤ 3,000"
          },
          "3": {
            "points": 34,
            "req": "Tree with max degree 2 (line graph)"
          },
          "4": {
            "points": 51,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Werewolf",
        "contest": "IOI 2018 day 1",
        "one_line": "Check if Q trips allow transforming human→wolf at city with population between L_i and R_i"
      },
      "problem": {
        "given": [
          "N cities numbered by population (0=smallest, N-1=largest)",
          "M bidirectional roads connecting cities",
          "Graph is connected",
          "Q trips from S_i to E_i with thresholds L_i and R_i"
        ],
        "goal": "Determine for each trip if path exists satisfying transformation constraints",
        "mechanism": "Start human at S_i, transform once at city with population in [L_i,R_i], end wolf at E_i",
        "success_condition": "Valid path exists using only cities ≥L_i as human and cities ≤R_i as wolf"
      },
      "constraints": {
        "critical": [
          "Human form cannot visit cities with population < L_i",
          "Wolf form cannot visit cities with population > R_i",
          "Transformation must occur at city with population between L_i and R_i",
          "Must transform exactly once during trip",
          "Graph is connected with unique roads between cities"
        ],
        "subtasks": {
          "1": {
            "points": 7,
            "req": "N ≤ 100, M ≤ 200, Q ≤ 100"
          },
          "2": {
            "points": 8,
            "req": "N ≤ 3,000, M ≤ 6,000, Q ≤ 3,000"
          },
          "3": {
            "points": 34,
            "req": "Tree with max degree 2 (line graph)"
          },
          "4": {
            "points": 51,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] check_validity(int N, int[] X, int[] Y, int[] S, int[] E, int[] L, int[] R)",
        "available_api": {},
        "requirements": [
          "Return array of Q integers (1=possible, 0=impossible)",
          "Input constraints guarantee L_i ≤ S_i and E_i ≤ R_i",
          "S_i ≠ E_i for all trips"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "6 6 3\n5 1\n1 2\n1 3\n3 4\n3 0\n5 2\n4 2 1 2\n4 2 2 2\n5 4 3 4",
          "output": "1\n0\n0"
        }
      ],
      "original_statement": "There are cities $$$N$$$ and $$$M$$$ roads in Ibaraki Prefecture, Japan. Cities are numbered from $$$0$$$ through $$$N-1$$$ in the increasing order of their population. Each road connects a pair of distinct cities, and can be traveled in both directions. You can travel from any city to any other city by using one or more of these roads.\nYou planned $$$Q$$$ trips, numbered from $$$0$$$ through $$$Q-1$$$. The trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ is to travel from $$$S_i$$$ the city to the city $$$E_i$$$.\nYou are a werewolf. You have two forms:\nhuman form\nand\nwolf form\n. At the beginning of each trip you are in human form. At the end of each trip, you must be in wolf form. During the trip you have to\ntransform\n(change from human form to wolf form) exactly once. You can transform only when you are in some city (possibly $$$S_i$$$ or $$$E_i$$$).\nLiving as a werewolf is not easy. You must avoid low-populated cities when you are in human form, and avoid highly-populated cities when you are in wolf form. For each trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ there are two thresholds $$$L_i$$$ and $$$R_i$$$ $$$(0 \\le L_i \\le R_i \\le N-1)$$$ that indicate which cities must be avoided. More specifically, you must avoid the cities $$$0, 1, \\dots , L_i-1$$$ when you are in human form, and must avoid the cities $$$R_i+1, R_i+2, \\dots ,N-1$$$ when you are in wolf form. This means in the trip $$$i$$$, you can only transform in one of the cities $$$L_i, L_i+1, \\dots , R_i.$$$\nYour task is to determine, for each trip, whether it is possible to travel from the city $$$S_i$$$ to the city $$$E_i$$$ in a way that satisfies the aforementioned constraints. The route you take can have an arbitrary length.\nImplementation details\nYou should implement the following function:\nint[] check_validity(int N, int[] X, int[] Y, int[] S, int[] E, int[] L, int[] R)\n$$$N$$$: the number of cities.\n$$$X$$$ and $$$Y$$$: arrays of length $$$M$$$. For each $$$j$$$ $$$(0 \\le j \\le M-1)$$$, the city $$$X[j]$$$ is directly connected to the city $$$Y[j]$$$ by a road.\n$$$S, E, L,$$$ and $$$R$$$: arrays of length $$$Q$$$, representing the trips.\nNote that the values of $$$M$$$ and $$$Q$$$ are the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nThe function\ncheck_validity\nis called exactly once for each test case. This function should return an array $$$A$$$ of integers of length $$$Q$$$. The value of $$$A_i$$$ $$$(0 \\le i \\le Q-1)$$$ must be $$$1$$$ if the trip $$$i$$$ is possible while satisfying the aforementioned conditions, or $$$0$$$ otherwise.\nConstraints\n$$$2 \\le N \\le 200\\,000$$$\n$$$N-1 \\le M \\le 400\\,000$$$\n$$$1 \\le Q \\le 200\\,000$$$\nFor each $$$j : 0 \\le j \\le M-1$$$\n$$$0 \\le X_j \\le N-1$$$\n$$$0 \\le Y_j \\le N-1$$$\n$$$X_j \\neq Y_j$$$\nYou can travel from any city to any other city by using roads.\nEach pair of cities are directly connected by at most one road. In other words, $$$(X_j, Y_j) \\neq (X_k, Y_k)$$$ and $$$(Y_j, X_j) \\neq (X_k, Y_k)$$$ for all $$$j, k: 0 \\le j < k \\le M-1$$$\nFor each $$$i: 0 \\le i \\le Q-1$$$\n$$$0 \\le L_i \\le S_i \\le N-1$$$\n$$$0 \\le E_i \\le R_i \\le N-1$$$\n$$$S_i \\neq E_i$$$\n$$$L_i \\le R_i$$$\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$1$$$\n:\n$$$N$$$ $$$M$$$ $$$Q$$$\nline\n$$$2+j$$$\n:\n$$$X_j$$$ $$$Y_j$$$\n$$$0 \\le j \\le M-1$$$\nline\n$$$2+M+i$$$\n:\n$$$S_i$$$ $$$E_i$$$ $$$L_i$$$ $$$R_i$$$\n$$$0 \\le i \\le Q-1$$$\nThe sample grader prints the return value of\ncheck_validity\nin the following format:\nline\n$$$1+i$$$\n:\n$$$A_i$$$\n$$$0 \\le i \\le Q-1$$$\nScoring\nSubtasks\nSubtask\nPoints\nAdditional constraints\n$$$1$$$\n$$$7$$$\n$$$N \\le 100,$$$ $$$M \\le 200,$$$ $$$Q \\le 100$$$\n$$$2$$$\n$$$8$$$\n$$$N \\le 3\\,000,$$$ $$$M \\le 6\\,000,$$$ $$$Q \\le 3\\,000$$$\n$$$3$$$\n$$$34$$$\n$$$M=N-1$$$ and each city is incident to at most $$$2$$$ roads (the cities are connected in a line)\n$$$4$$$\n$$$51$$$\nNo\nExamples\nNote\nExample\nLet $$$N=6,$$$ $$$M=6,$$$ $$$Q=3,$$$ $$$X=[5,1,1,3,3,5],$$$ $$$Y=[1,2,3,4,0,2],$$$ $$$S=[4,4,5],$$$ $$$E=[2,2,4],$$$ $$$L=[1,2,3],$$$ and $$$R=[2,2,4].$$$\nThe grader calls\ncheck_validity(6, [5, 1, 1, 3, 3, 5], [1, 2, 3, 4, 0, 2], [4, 4, 5], [2, 2, 4], [1, 2, 3], [2, 2, 4]).\nFor the trip $$$0$$$, you can travel from the city $$$4$$$ to the city $$$2$$$ as follows:\nStart at the city $$$4$$$ (You are in human form)\nMove to the city $$$3$$$ (You are in human form)\nMove to the city $$$1$$$(You are in human form)\nTransform yourself into wolf form (You are in wolf form)\nMove to the city $$$2$$$(You are in wolf form)\nFor the trips $$$1$$$ and $$$2$$$, you cannot travel between the given cities.\nHence, your program should return $$$[1,0,0].$$$\nThe files\nsample-01-in.txt\nand\nsample-01-out.txt\nin the zipped attachment package correspond to this example. This package also contains another pair of sample input/output files."
    },
    "original": "There are cities $$$N$$$ and $$$M$$$ roads in Ibaraki Prefecture, Japan. Cities are numbered from $$$0$$$ through $$$N-1$$$ in the increasing order of their population. Each road connects a pair of distinct cities, and can be traveled in both directions. You can travel from any city to any other city by using one or more of these roads.\nYou planned $$$Q$$$ trips, numbered from $$$0$$$ through $$$Q-1$$$. The trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ is to travel from $$$S_i$$$ the city to the city $$$E_i$$$.\nYou are a werewolf. You have two forms:\nhuman form\nand\nwolf form\n. At the beginning of each trip you are in human form. At the end of each trip, you must be in wolf form. During the trip you have to\ntransform\n(change from human form to wolf form) exactly once. You can transform only when you are in some city (possibly $$$S_i$$$ or $$$E_i$$$).\nLiving as a werewolf is not easy. You must avoid low-populated cities when you are in human form, and avoid highly-populated cities when you are in wolf form. For each trip $$$i$$$ $$$(0 \\le i \\le Q-1)$$$ there are two thresholds $$$L_i$$$ and $$$R_i$$$ $$$(0 \\le L_i \\le R_i \\le N-1)$$$ that indicate which cities must be avoided. More specifically, you must avoid the cities $$$0, 1, \\dots , L_i-1$$$ when you are in human form, and must avoid the cities $$$R_i+1, R_i+2, \\dots ,N-1$$$ when you are in wolf form. This means in the trip $$$i$$$, you can only transform in one of the cities $$$L_i, L_i+1, \\dots , R_i.$$$\nYour task is to determine, for each trip, whether it is possible to travel from the city $$$S_i$$$ to the city $$$E_i$$$ in a way that satisfies the aforementioned constraints. The route you take can have an arbitrary length.\nImplementation details\nYou should implement the following function:\nint[] check_validity(int N, int[] X, int[] Y, int[] S, int[] E, int[] L, int[] R)\n$$$N$$$: the number of cities.\n$$$X$$$ and $$$Y$$$: arrays of length $$$M$$$. For each $$$j$$$ $$$(0 \\le j \\le M-1)$$$, the city $$$X[j]$$$ is directly connected to the city $$$Y[j]$$$ by a road.\n$$$S, E, L,$$$ and $$$R$$$: arrays of length $$$Q$$$, representing the trips.\nNote that the values of $$$M$$$ and $$$Q$$$ are the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nThe function\ncheck_validity\nis called exactly once for each test case. This function should return an array $$$A$$$ of integers of length $$$Q$$$. The value of $$$A_i$$$ $$$(0 \\le i \\le Q-1)$$$ must be $$$1$$$ if the trip $$$i$$$ is possible while satisfying the aforementioned conditions, or $$$0$$$ otherwise.\nConstraints\n$$$2 \\le N \\le 200\\,000$$$\n$$$N-1 \\le M \\le 400\\,000$$$\n$$$1 \\le Q \\le 200\\,000$$$\nFor each $$$j : 0 \\le j \\le M-1$$$\n$$$0 \\le X_j \\le N-1$$$\n$$$0 \\le Y_j \\le N-1$$$\n$$$X_j \\neq Y_j$$$\nYou can travel from any city to any other city by using roads.\nEach pair of cities are directly connected by at most one road. In other words, $$$(X_j, Y_j) \\neq (X_k, Y_k)$$$ and $$$(Y_j, X_j) \\neq (X_k, Y_k)$$$ for all $$$j, k: 0 \\le j < k \\le M-1$$$\nFor each $$$i: 0 \\le i \\le Q-1$$$\n$$$0 \\le L_i \\le S_i \\le N-1$$$\n$$$0 \\le E_i \\le R_i \\le N-1$$$\n$$$S_i \\neq E_i$$$\n$$$L_i \\le R_i$$$\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$1$$$\n:\n$$$N$$$ $$$M$$$ $$$Q$$$\nline\n$$$2+j$$$\n:\n$$$X_j$$$ $$$Y_j$$$\n$$$0 \\le j \\le M-1$$$\nline\n$$$2+M+i$$$\n:\n$$$S_i$$$ $$$E_i$$$ $$$L_i$$$ $$$R_i$$$\n$$$0 \\le i \\le Q-1$$$\nThe sample grader prints the return value of\ncheck_validity\nin the following format:\nline\n$$$1+i$$$\n:\n$$$A_i$$$\n$$$0 \\le i \\le Q-1$$$\nScoring\nSubtasks\nSubtask\nPoints\nAdditional constraints\n$$$1$$$\n$$$7$$$\n$$$N \\le 100,$$$ $$$M \\le 200,$$$ $$$Q \\le 100$$$\n$$$2$$$\n$$$8$$$\n$$$N \\le 3\\,000,$$$ $$$M \\le 6\\,000,$$$ $$$Q \\le 3\\,000$$$\n$$$3$$$\n$$$34$$$\n$$$M=N-1$$$ and each city is incident to at most $$$2$$$ roads (the cities are connected in a line)\n$$$4$$$\n$$$51$$$\nNo\nExamples\nNote\nExample\nLet $$$N=6,$$$ $$$M=6,$$$ $$$Q=3,$$$ $$$X=[5,1,1,3,3,5],$$$ $$$Y=[1,2,3,4,0,2],$$$ $$$S=[4,4,5],$$$ $$$E=[2,2,4],$$$ $$$L=[1,2,3],$$$ and $$$R=[2,2,4].$$$\nThe grader calls\ncheck_validity(6, [5, 1, 1, 3, 3, 5], [1, 2, 3, 4, 0, 2], [4, 4, 5], [2, 2, 4], [1, 2, 3], [2, 2, 4]).\nFor the trip $$$0$$$, you can travel from the city $$$4$$$ to the city $$$2$$$ as follows:\nStart at the city $$$4$$$ (You are in human form)\nMove to the city $$$3$$$ (You are in human form)\nMove to the city $$$1$$$(You are in human form)\nTransform yourself into wolf form (You are in wolf form)\nMove to the city $$$2$$$(You are in wolf form)\nFor the trips $$$1$$$ and $$$2$$$, you cannot travel between the given cities.\nHence, your program should return $$$[1,0,0].$$$\nThe files\nsample-01-in.txt\nand\nsample-01-out.txt\nin the zipped attachment package correspond to this example. This package also contains another pair of sample input/output files.",
    "_meta": {
      "index": 63,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
      "uuid": "ps_b598c7d54571d38321f3a7f99e407bafafc3da22"
    }
  },
  {
    "planning_view": {
      "title": "E. Simurgh",
      "task": "Identify n-1 royal roads among m roads using ≤30000 queries",
      "given": [
        "n cities (0 to n-1)",
        "m bidirectional roads (0 to m-1)",
        "Unknown set of royal roads forms a spanning tree",
        "Can query grader with spanning trees"
      ],
      "goal": "Find exactly which roads are royal roads",
      "key_rules": [
        "Royal roads form a golden set (spanning tree with n-1 edges)",
        "Each query must be a valid spanning tree",
        "Maximum query limit q varies by subtask (30000 max)"
      ],
      "target": {
        "1": {
          "points": 13,
          "req": "n ≤ 7, q = 30000"
        },
        "2": {
          "points": 17,
          "req": "n ≤ 50, q = 30000"
        },
        "3": {
          "points": 21,
          "req": "n ≤ 240, q = 30000"
        },
        "4": {
          "points": 19,
          "req": "q = 12000, complete graph"
        },
        "5": {
          "points": 30,
          "req": "q = 8000"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Simurgh",
      "contest": "IOI 2017 day 2",
      "one_line": "Identify n-1 royal roads among m roads using ≤30000 queries",
      "given": [
        "n cities (0 to n-1)",
        "m bidirectional roads (0 to m-1)",
        "Unknown set of royal roads forms a spanning tree",
        "Can query grader with spanning trees"
      ],
      "goal": "Find exactly which roads are royal roads",
      "mechanism": "Submit candidate spanning trees to count_common_roads(), which returns how many royal roads are in your tree",
      "success_condition": "Return array containing all n-1 royal road labels",
      "constraints": {
        "critical": [
          "Royal roads form a golden set (spanning tree with n-1 edges)",
          "Each query must be a valid spanning tree",
          "Maximum query limit q varies by subtask (30000 max)"
        ],
        "subtasks": {
          "1": {
            "points": 13,
            "req": "n ≤ 7, q = 30000"
          },
          "2": {
            "points": 17,
            "req": "n ≤ 50, q = 30000"
          },
          "3": {
            "points": 21,
            "req": "n ≤ 240, q = 30000"
          },
          "4": {
            "points": 19,
            "req": "q = 12000, complete graph"
          },
          "5": {
            "points": 30,
            "req": "q = 8000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Simurgh",
        "contest": "IOI 2017 day 2",
        "one_line": "Identify n-1 royal roads among m roads using ≤30000 queries"
      },
      "problem": {
        "given": [
          "n cities (0 to n-1)",
          "m bidirectional roads (0 to m-1)",
          "Unknown set of royal roads forms a spanning tree",
          "Can query grader with spanning trees"
        ],
        "goal": "Find exactly which roads are royal roads",
        "mechanism": "Submit candidate spanning trees to count_common_roads(), which returns how many royal roads are in your tree",
        "success_condition": "Return array containing all n-1 royal road labels"
      },
      "constraints": {
        "critical": [
          "Royal roads form a golden set (spanning tree with n-1 edges)",
          "Each query must be a valid spanning tree",
          "Maximum query limit q varies by subtask (30000 max)"
        ],
        "subtasks": {
          "1": {
            "points": 13,
            "req": "n ≤ 7, q = 30000"
          },
          "2": {
            "points": 17,
            "req": "n ≤ 50, q = 30000"
          },
          "3": {
            "points": 21,
            "req": "n ≤ 240, q = 30000"
          },
          "4": {
            "points": 19,
            "req": "q = 12000, complete graph"
          },
          "5": {
            "points": 30,
            "req": "q = 8000"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] find_roads(int n, int[] u, int[] v)",
        "available_api": {
          "count_common_roads": {
            "signature": "int count_common_roads(int[] r)",
            "params": "r: array of n-1 road labels forming a spanning tree",
            "returns": "Number of royal roads in r",
            "side_effect": "None (grader doesn't modify r)"
          }
        },
        "requirements": [
          "Return array of exactly n-1 royal road labels",
          "Each query must be a valid spanning tree",
          "Roads are undirected, cities 0-indexed",
          "Graph is connected with unique edges between cities"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "4 6 30000\n0 1\n0 2\n0 3\n1 2\n1 3\n2 3\n0 1 5",
          "output": "OK\n0 1 5"
        }
      ],
      "original_statement": "According to ancient Persian legends in Shahnameh, Zal, the legendary Persian hero, is madly in love with Rudaba, the princess of Kabul. When Zal asked for Rudaba's hand in marriage, her father gave him a challenge.\nIn Persia there are $$$n$$$ cities, labeled from $$$0$$$ to $$$n - 1$$$, and $$$m$$$ two-way roads, labeled from $$$0$$$ to $$$m - 1$$$. Each road connects a pair of distinct cities. Each pair of cities is connected by at most one road. Some of the roads are\nroyal roads\nused for travels by royals. Zal's task is to determine which of the roads are the royal roads.\nZal has a map with all the cities and the roads in Persia. He does not know which of the roads are royal, but he can get help from Simurgh, the benevolent mythical bird who is Zal's protector. However, Simurgh does not want to reveal the set of royal roads directly. Instead, she tells Zal that the set of all royal roads is a\ngolden set\n. A set of roads is a golden set if and only if:\nit has\nexactly\n$$$n - 1$$$ roads, and\nfor every pair of cities, it is possible to reach one from the other by traveling only along the roads of this set.\nFurthermore, Zal can ask Simurgh some questions. For each question:\nZal chooses a\ngolden\nset of roads, and then\nSimurgh tells Zal how many of the roads in the chosen golden set are royal roads.\nYour program should help Zal find the set of royal roads by asking Simurgh at most $$$q$$$ questions. The grader will play the role of Simurgh.\nImplementation details\nYou should implement the following procedure:\nint[] find_roads(int n, int[] u, int[] v)\n$$$n$$$: number of cities,\n$$$u$$$ and $$$v$$$: arrays of length $$$m$$$. For all $$$0 \\leq i \\leq m - 1$$$, $$$u[i]$$$ and $$$v[i]$$$ are the cities connected by road $$$i$$$.\nThis procedure should return an array of length $$$n - 1$$$ containing the labels of the royal roads (in an arbitrary order).\nYour solution can make at most $$$q$$$ calls to the following grader procedure:\nint count_common_roads(int[] r)\n$$$r$$$: array of length $$$n - 1$$$ containing the labels of roads in a golden set (in an arbitrary order).\nThis procedure returns the number of royal roads in $$$r$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$m$$$ ($$$2 \\leq n \\leq 500$$$, $$$n - 1 \\leq m \\leq n \\cdot (n - 1) / 2$$$)\nline $$$2 + i$$$ (for all $$$0 \\leq i \\leq m - 1$$$): $$$u[i]$$$ $$$v[i]$$$ ($$$0 \\leq u[i], v[i] \\leq n - 1$$$)\nline $$$2 + m$$$: $$$s[0], s[1], \\ldots, s[n - 2]$$$\nHere, $$$s[0], s[1], \\ldots, s[n - 2]$$$ are the labels of the royal roads.\nFor all $$$0 \\leq i \\leq m - 1$$$, road $$$i$$$ connects two different cities (i.e., $$$u[i] \\neq v[i]$$$).\nThere is at most one road between each pair of cities.\nIt is possible to travel between any pair of cities through the roads.\nThe set of all royal roads is a golden set.\nfind_roads\nshould call\ncount_common_roads\nat most $$$q$$$ times. In each call, the set of roads specified by $$$r$$$ should be a golden set.\nOutput\nThe sample grader outputs 'YES', if\nfind_roads\ncalls\ncount_common_roads\nat most $$$30\\,000$$$ times, and returns the correct set of royal roads. Otherwise, it outputs 'NO'.\nBeware that the procedure\ncount_common_roads\nin the sample grader does not check whether $$$r$$$ has all properties of a golden set. Instead, it counts and returns the number of labels of royal roads in the array $$$r$$$. However, if the program you submit calls\ncount_common_roads\nwith a set of labels that does not describe a golden set, the grading verdict will be 'Wrong Answer'.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n13\n$$$n \\leq 7$$$, $$$q = 30\\,000$$$\n2\n17\n$$$n \\leq 50$$$, $$$q = 30\\,000$$$\n3\n21\n$$$n \\leq 240$$$, $$$q = 30\\,000$$$\n4\n19\n$$$q = 12\\,000$$$ and there is a road between every pair of cities\n5\n30\n$$$q = 8000$$$\nExample\nNote\nThe procedure\ncount_common_roads\nin C++ uses the\npass by reference\nmethod for efficiency reasons. You can still call the procedure in the usual way. The grader is guaranteed not to change the value of $$$r$$$.\nfind_roads(4, [0, 0, 0, 1, 1, 2], [1, 2, 3, 2, 3, 3])\nIn this example there are $$$4$$$ cities and $$$6$$$ roads. We denote by $$$(a, b)$$$ a road connecting cities $$$a$$$ and $$$b$$$. The roads are labeled from $$$0$$$ to $$$5$$$ in the following order: $$$(0, 1)$$$, $$$(0, 2)$$$, $$$(0, 3)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$, and $$$(2, 3)$$$. Every golden set has $$$n - 1 = 3$$$ roads.\nAssume that the royal roads are the roads labeled $$$0$$$, $$$1$$$, and $$$5$$$, that is, the roads $$$(0, 1)$$$, $$$(0, 2)$$$, and $$$(2, 3)$$$. Then:\ncount_common_roads([0, 1, 2])\nreturns $$$2$$$. This query is about roads labeled $$$0, 1$$$, and $$$2$$$, that is, roads $$$(0, 1)$$$, $$$(0, 2)$$$ and $$$(0,3)$$$. Two of them are royal roads.\ncount_common_roads([5, 1, 0])\nreturns $$$3$$$. This query is about the set of all royal roads.\nThe procedure\nfind_roads\nshould return $$$[5, 1, 0]$$$ or any other array of length $$$3$$$ that contains these three elements.\nNote that the following calls are not allowed:\ncount_common_roads([0, 1])\n: here the length of $$$r$$$ is not $$$3$$$.\ncount_common_roads([0, 1, 3])\n: here $$$r$$$ does not describe a golden set, because it is impossible to travel from city $$$0$$$ to $$$3$$$ only using the roads $$$(0,1)$$$, $$$(0,2)$$$, $$$(1,2)$$$."
    },
    "original": "According to ancient Persian legends in Shahnameh, Zal, the legendary Persian hero, is madly in love with Rudaba, the princess of Kabul. When Zal asked for Rudaba's hand in marriage, her father gave him a challenge.\nIn Persia there are $$$n$$$ cities, labeled from $$$0$$$ to $$$n - 1$$$, and $$$m$$$ two-way roads, labeled from $$$0$$$ to $$$m - 1$$$. Each road connects a pair of distinct cities. Each pair of cities is connected by at most one road. Some of the roads are\nroyal roads\nused for travels by royals. Zal's task is to determine which of the roads are the royal roads.\nZal has a map with all the cities and the roads in Persia. He does not know which of the roads are royal, but he can get help from Simurgh, the benevolent mythical bird who is Zal's protector. However, Simurgh does not want to reveal the set of royal roads directly. Instead, she tells Zal that the set of all royal roads is a\ngolden set\n. A set of roads is a golden set if and only if:\nit has\nexactly\n$$$n - 1$$$ roads, and\nfor every pair of cities, it is possible to reach one from the other by traveling only along the roads of this set.\nFurthermore, Zal can ask Simurgh some questions. For each question:\nZal chooses a\ngolden\nset of roads, and then\nSimurgh tells Zal how many of the roads in the chosen golden set are royal roads.\nYour program should help Zal find the set of royal roads by asking Simurgh at most $$$q$$$ questions. The grader will play the role of Simurgh.\nImplementation details\nYou should implement the following procedure:\nint[] find_roads(int n, int[] u, int[] v)\n$$$n$$$: number of cities,\n$$$u$$$ and $$$v$$$: arrays of length $$$m$$$. For all $$$0 \\leq i \\leq m - 1$$$, $$$u[i]$$$ and $$$v[i]$$$ are the cities connected by road $$$i$$$.\nThis procedure should return an array of length $$$n - 1$$$ containing the labels of the royal roads (in an arbitrary order).\nYour solution can make at most $$$q$$$ calls to the following grader procedure:\nint count_common_roads(int[] r)\n$$$r$$$: array of length $$$n - 1$$$ containing the labels of roads in a golden set (in an arbitrary order).\nThis procedure returns the number of royal roads in $$$r$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$n$$$ $$$m$$$ ($$$2 \\leq n \\leq 500$$$, $$$n - 1 \\leq m \\leq n \\cdot (n - 1) / 2$$$)\nline $$$2 + i$$$ (for all $$$0 \\leq i \\leq m - 1$$$): $$$u[i]$$$ $$$v[i]$$$ ($$$0 \\leq u[i], v[i] \\leq n - 1$$$)\nline $$$2 + m$$$: $$$s[0], s[1], \\ldots, s[n - 2]$$$\nHere, $$$s[0], s[1], \\ldots, s[n - 2]$$$ are the labels of the royal roads.\nFor all $$$0 \\leq i \\leq m - 1$$$, road $$$i$$$ connects two different cities (i.e., $$$u[i] \\neq v[i]$$$).\nThere is at most one road between each pair of cities.\nIt is possible to travel between any pair of cities through the roads.\nThe set of all royal roads is a golden set.\nfind_roads\nshould call\ncount_common_roads\nat most $$$q$$$ times. In each call, the set of roads specified by $$$r$$$ should be a golden set.\nOutput\nThe sample grader outputs 'YES', if\nfind_roads\ncalls\ncount_common_roads\nat most $$$30\\,000$$$ times, and returns the correct set of royal roads. Otherwise, it outputs 'NO'.\nBeware that the procedure\ncount_common_roads\nin the sample grader does not check whether $$$r$$$ has all properties of a golden set. Instead, it counts and returns the number of labels of royal roads in the array $$$r$$$. However, if the program you submit calls\ncount_common_roads\nwith a set of labels that does not describe a golden set, the grading verdict will be 'Wrong Answer'.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n13\n$$$n \\leq 7$$$, $$$q = 30\\,000$$$\n2\n17\n$$$n \\leq 50$$$, $$$q = 30\\,000$$$\n3\n21\n$$$n \\leq 240$$$, $$$q = 30\\,000$$$\n4\n19\n$$$q = 12\\,000$$$ and there is a road between every pair of cities\n5\n30\n$$$q = 8000$$$\nExample\nNote\nThe procedure\ncount_common_roads\nin C++ uses the\npass by reference\nmethod for efficiency reasons. You can still call the procedure in the usual way. The grader is guaranteed not to change the value of $$$r$$$.\nfind_roads(4, [0, 0, 0, 1, 1, 2], [1, 2, 3, 2, 3, 3])\nIn this example there are $$$4$$$ cities and $$$6$$$ roads. We denote by $$$(a, b)$$$ a road connecting cities $$$a$$$ and $$$b$$$. The roads are labeled from $$$0$$$ to $$$5$$$ in the following order: $$$(0, 1)$$$, $$$(0, 2)$$$, $$$(0, 3)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$, and $$$(2, 3)$$$. Every golden set has $$$n - 1 = 3$$$ roads.\nAssume that the royal roads are the roads labeled $$$0$$$, $$$1$$$, and $$$5$$$, that is, the roads $$$(0, 1)$$$, $$$(0, 2)$$$, and $$$(2, 3)$$$. Then:\ncount_common_roads([0, 1, 2])\nreturns $$$2$$$. This query is about roads labeled $$$0, 1$$$, and $$$2$$$, that is, roads $$$(0, 1)$$$, $$$(0, 2)$$$ and $$$(0,3)$$$. Two of them are royal roads.\ncount_common_roads([5, 1, 0])\nreturns $$$3$$$. This query is about the set of all royal roads.\nThe procedure\nfind_roads\nshould return $$$[5, 1, 0]$$$ or any other array of length $$$3$$$ that contains these three elements.\nNote that the following calls are not allowed:\ncount_common_roads([0, 1])\n: here the length of $$$r$$$ is not $$$3$$$.\ncount_common_roads([0, 1, 3])\n: here $$$r$$$ does not describe a golden set, because it is impossible to travel from city $$$0$$$ to $$$3$$$ only using the roads $$$(0,1)$$$, $$$(0,2)$$$, $$$(1,2)$$$.",
    "_meta": {
      "index": 64,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/E",
      "uuid": "ps_b43591ec3077feda3490b87d693dae9ee9542a9b"
    }
  },
  {
    "planning_view": {
      "title": "C. Carnival Tickets",
      "task": "Maximize prize total over k rounds by optimally assigning n×m tickets within constraints",
      "given": [
        "n colors, m tickets per color (n even, total n×m tickets)",
        "Each ticket has non-negative integer value",
        "Tickets per color sorted in non-decreasing order",
        "Game master chooses b to minimize prize value each round"
      ],
      "goal": "Assign exactly one ticket per color to each of k rounds to maximize total prize value",
      "key_rules": [
        "Must use exactly k tickets per color (one per round)",
        "n is even (important for optimization)",
        "Game master adversarially minimizes prize value each round",
        "Tickets cannot be reused across rounds"
      ],
      "target": {
        "1": {
          "points": 11,
          "req": "m = 1"
        },
        "2": {
          "points": 16,
          "req": "k = 1"
        },
        "3": {
          "points": 14,
          "req": "0 ≤ x[i][j] ≤ 1 for all tickets"
        },
        "4": {
          "points": 14,
          "req": "k = m"
        },
        "5": {
          "points": 12,
          "req": "n, m ≤ 80"
        },
        "6": {
          "points": 23,
          "req": "n, m ≤ 300"
        },
        "7": {
          "points": 10,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Carnival Tickets",
      "contest": "IOI 2020 day 1",
      "one_line": "Maximize prize total over k rounds by optimally assigning n×m tickets within constraints",
      "given": [
        "n colors, m tickets per color (n even, total n×m tickets)",
        "Each ticket has non-negative integer value",
        "Tickets per color sorted in non-decreasing order",
        "Game master chooses b to minimize prize value each round"
      ],
      "goal": "Assign exactly one ticket per color to each of k rounds to maximize total prize value",
      "mechanism": "Each round: select n tickets (one per color), game master chooses b minimizing sum(|a[i]-b|) where a[i] are ticket values",
      "success_condition": "Return maximum possible total prize value across all k rounds",
      "constraints": {
        "critical": [
          "Must use exactly k tickets per color (one per round)",
          "n is even (important for optimization)",
          "Game master adversarially minimizes prize value each round",
          "Tickets cannot be reused across rounds"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "m = 1"
          },
          "2": {
            "points": 16,
            "req": "k = 1"
          },
          "3": {
            "points": 14,
            "req": "0 ≤ x[i][j] ≤ 1 for all tickets"
          },
          "4": {
            "points": 14,
            "req": "k = m"
          },
          "5": {
            "points": 12,
            "req": "n, m ≤ 80"
          },
          "6": {
            "points": 23,
            "req": "n, m ≤ 300"
          },
          "7": {
            "points": 10,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Carnival Tickets",
        "contest": "IOI 2020 day 1",
        "one_line": "Maximize prize total over k rounds by optimally assigning n×m tickets within constraints"
      },
      "problem": {
        "given": [
          "n colors, m tickets per color (n even, total n×m tickets)",
          "Each ticket has non-negative integer value",
          "Tickets per color sorted in non-decreasing order",
          "Game master chooses b to minimize prize value each round"
        ],
        "goal": "Assign exactly one ticket per color to each of k rounds to maximize total prize value",
        "mechanism": "Each round: select n tickets (one per color), game master chooses b minimizing sum(|a[i]-b|) where a[i] are ticket values",
        "success_condition": "Return maximum possible total prize value across all k rounds"
      },
      "constraints": {
        "critical": [
          "Must use exactly k tickets per color (one per round)",
          "n is even (important for optimization)",
          "Game master adversarially minimizes prize value each round",
          "Tickets cannot be reused across rounds"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "m = 1"
          },
          "2": {
            "points": 16,
            "req": "k = 1"
          },
          "3": {
            "points": 14,
            "req": "0 ≤ x[i][j] ≤ 1 for all tickets"
          },
          "4": {
            "points": 14,
            "req": "k = m"
          },
          "5": {
            "points": 12,
            "req": "n, m ≤ 80"
          },
          "6": {
            "points": 23,
            "req": "n, m ≤ 300"
          },
          "7": {
            "points": 10,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 find_maximum(int k, int[][] x)",
        "available_api": {
          "allocate_tickets": {
            "signature": "void allocate_tickets(int[][] s)",
            "params": "s: n×m array where s[i][j] = round number (0 to k-1) if ticket used, -1 if unused",
            "returns": "Nothing",
            "side_effect": "Commits the ticket allocation to the grader"
          }
        },
        "requirements": [
          "Must call allocate_tickets exactly once",
          "Each color's tickets: exactly k get round numbers 0 to k-1, rest get -1",
          "Return maximum total prize value"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "2 3 2\n0 2 5\n1 1 3",
          "output": "OK\n7\n0 -1 1\n1 -1 0"
        }
      ],
      "original_statement": "Ringo is at a carnival in Singapore. He has some prize tickets in his bag, which he would like to use at the prize game stall. Each ticket comes in one of $$$n$$$ colours and has a non-negative integer printed on it. The integers printed on different tickets might be the same. Due to a quirk in the carnival rules, $$$n$$$ is guaranteed to be\neven\n.\nRingo has $$$m$$$ tickets of each colour in his bag, that is a total of $$$n \\cdot m$$$ tickets. The ticket $$$j$$$ of the colour $$$i$$$ has the integer $$$x[i][j]$$$ printed on it ($$$0 \\leq i \\leq n-1$$$ and $$$0 \\leq j \\leq m-1$$$).\nThe prize game is played in $$$k$$$ rounds, numbered from $$$0$$$ to $$$k-1$$$. Each round is played in the following order:\nFrom his bag, Ringo selects a\nset\nof $$$n$$$ tickets, one ticket from each colour. He then gives the set to the game master.\nThe game master notes down the integers $$$a[0], a[1] \\ldots a[n-1]$$$ printed on the tickets of the set. The order of these $$$n$$$ integers is not important.\nThe game master pulls out a special card from a lucky draw box and notes down the integer $$$b$$$ printed on that card.\nThe game master calculates the absolute differences between $$$a[i]$$$ and $$$b$$$ for each $$$i$$$ from $$$0$$$ to $$$n-1$$$. Let's $$$S$$$ be the sum of these absolute differences.\nFor this round, the game master gives Ringo a prize with a value equal to $$$S$$$.\nThe tickets in the set are discarded and cannot be used in future rounds.\nThe remaining tickets in Ringo's bag after $$$k$$$ rounds of the game are discarded.\nBy watching closely, Ringo realized that the prize game is rigged! There is actually a printer inside the lucky draw box. In each round, the game master finds an integer $$$b$$$ that minimizes the value of the prize of that round. The value chosen by the game master is printed on the special card for that round.\nHaving all this information, Ringo would like to allocate tickets to the rounds of the game. That is, he wants to select the ticket set to use in each round in order to maximize the total value of the prizes.\nImplementation details\nYou should implement the following procedure:\nint64 find_maximum(int k, int[][] x)\n$$$k$$$: the number of rounds.\n$$$x$$$: an $$$n\\times m$$$ array describing the integers on each ticket. Tickets of each color are sorted in non-decreasing order of their integers.\nThis procedure is called exactly once.\nThis procedure should make exactly one call to\nallocate_tickets\n(see below), describing $$$k$$$ ticket sets, one for each round. The allocation should maximize the total value of the prizes.\nThis procedure should return the maximum total value of the prizes.\nThe procedure\nallocate_tickets\nis defined as follows:\nvoid allocate_tickets(int[][] s)\n$$$s$$$: an $$$n\\times m$$$ array. The value of $$$s[i][j]$$$ should be $$$r$$$ if the ticket $$$j$$$ of the colour $$$i$$$ is used in the set of round $$$r$$$ of the game, or $$$-1$$$ if it is not used at all.\nFor each $$$0 \\leq i \\leq n - 1$$$, among $$$s[i][0], s[i][1],\\ldots, s[i][m - 1]$$$ each value $$$0,1,2,\\ldots,k-1$$$ must occur exactly once, and all other entries must be $$$-1$$$.\nIf there are multiple allocations resulting in the maximum total prize value, it is allowed to report any of them.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ m\\ k$$$ ($$$2 \\leq n \\leq 1500$$$ and $$$n$$$ is even, $$$1 \\leq k \\leq m \\leq 1500$$$)\nline $$$2+i$$$ ($$$0\\leq i\\leq n-1$$$): $$$x[i][0]\\ x[i][1]\\ldots x[i][m-1]$$$ ($$$0 \\leq x[i][j] \\leq 10^9$$$ $$$x[i][j-1] \\leq x[i][j]$$$ (for all $$$0 \\leq i \\leq n-1$$$ and $$$1 \\leq j \\leq m-1$$$))\nOutput\nThe sample grader prints your answer in the following format:\nline $$$1$$$: the return value of\nfind_maximum\nline $$$2+i$$$ ($$$0\\leq i\\leq n-1$$$): $$$s[i][0]\\ s[i][1]\\ldots s[i][m-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$m = 1$$$\n2\n16\n$$$k = 1$$$\n3\n14\n$$$0 \\leq x[i][j] \\leq 1$$$ (for all $$$0 \\leq i \\leq n-1$$$ and $$$0 \\leq j \\leq m - 1$$$)\n4\n14\n$$$k = m$$$\n5\n12\n$$$n, m \\leq 80$$$\n6\n23\n$$$n, m \\leq 300$$$\n7\n10\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\nThis means that:\nthere are $$$k=2$$$ rounds;\nthe integers printed on the tickets of colour $$$0$$$ are $$$0$$$, $$$2$$$ and $$$5$$$, respectively;\nthe integers printed on the tickets of colour $$$1$$$ are $$$1$$$, $$$1$$$ and $$$3$$$, respectively.\nA possible allocation that gives the maximum total prize value is:\nIn round $$$0$$$, Ringo picks ticket $$$0$$$ of colour $$$0$$$ (with the integer $$$0$$$) and ticket $$$2$$$ of colour $$$1$$$ (with the integer $$$3$$$). The lowest possible value of the prize in this round is $$$3$$$. E.g., the game master may choose $$$b = 1$$$: $$$|1 - 0| + |1 - 3| = 1 + 2 = 3$$$.\nIn round $$$1$$$, Ringo picks ticket $$$2$$$ of colour $$$0$$$ (with the integer $$$5$$$) and ticket $$$1$$$ of colour $$$1$$$ (with the integer $$$1$$$). The lowest possible value of the prize in this round is $$$4$$$. E.g., the game master may choose $$$b = 3$$$: $$$|3 - 1| + |3 - 5| = 2 + 2 = 4$$$.\nTherefore, the total value of the prizes would be $$$3 + 4 = 7$$$.\nTo report this allocation, the procedure\nfind_maximum\nshould make the following call to\nallocate_tickets\n:\nallocate_tickets([[0, -1, 1], [-1, 1, 0]])\nFinally, the procedure\nfind_maximum\nshould return $$$7$$$.\nExample 2\nConsider the following call:\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\nThis means that:\nthere is only one round,\nthe integers printed on the tickets of colour $$$0$$$ are $$$5$$$ and $$$9$$$, respectively;\nthe integers printed on the tickets of colour $$$1$$$ are $$$1$$$ and $$$4$$$, respectively;\nthe integers printed on the tickets of colour $$$2$$$ are $$$3$$$ and $$$6$$$, respectively;\nthe integers printed on the tickets of colour $$$3$$$ are $$$2$$$ and $$$7$$$, respectively.\nA possible allocation that gives the maximum total prize value is:\nIn round $$$0$$$, Ringo picks ticket $$$1$$$ of colour $$$0$$$ (with the integer $$$9$$$), ticket $$$0$$$ of colour $$$1$$$ (with the integer $$$1$$$), ticket $$$0$$$ of colour $$$2$$$ (with the integer $$$3$$$), and ticket $$$1$$$ of colour $$$3$$$ (with the integer $$$7$$$). The lowest possible value of the prize in this round is $$$12$$$, when the game master chooses $$$b = 3$$$: $$$|3 - 9| + |3 - 1| + |3 - 3| + |3 - 7| = 6 + 2 + 0 + 4 = 12$$$.\nTo report this solution, the procedure\nfind_maximum\nshould make the following call to\nallocate_tickets\n:\nallocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])\nFinally, the procedure\nfind_maximum\nshould return $$$12$$$."
    },
    "original": "Ringo is at a carnival in Singapore. He has some prize tickets in his bag, which he would like to use at the prize game stall. Each ticket comes in one of $$$n$$$ colours and has a non-negative integer printed on it. The integers printed on different tickets might be the same. Due to a quirk in the carnival rules, $$$n$$$ is guaranteed to be\neven\n.\nRingo has $$$m$$$ tickets of each colour in his bag, that is a total of $$$n \\cdot m$$$ tickets. The ticket $$$j$$$ of the colour $$$i$$$ has the integer $$$x[i][j]$$$ printed on it ($$$0 \\leq i \\leq n-1$$$ and $$$0 \\leq j \\leq m-1$$$).\nThe prize game is played in $$$k$$$ rounds, numbered from $$$0$$$ to $$$k-1$$$. Each round is played in the following order:\nFrom his bag, Ringo selects a\nset\nof $$$n$$$ tickets, one ticket from each colour. He then gives the set to the game master.\nThe game master notes down the integers $$$a[0], a[1] \\ldots a[n-1]$$$ printed on the tickets of the set. The order of these $$$n$$$ integers is not important.\nThe game master pulls out a special card from a lucky draw box and notes down the integer $$$b$$$ printed on that card.\nThe game master calculates the absolute differences between $$$a[i]$$$ and $$$b$$$ for each $$$i$$$ from $$$0$$$ to $$$n-1$$$. Let's $$$S$$$ be the sum of these absolute differences.\nFor this round, the game master gives Ringo a prize with a value equal to $$$S$$$.\nThe tickets in the set are discarded and cannot be used in future rounds.\nThe remaining tickets in Ringo's bag after $$$k$$$ rounds of the game are discarded.\nBy watching closely, Ringo realized that the prize game is rigged! There is actually a printer inside the lucky draw box. In each round, the game master finds an integer $$$b$$$ that minimizes the value of the prize of that round. The value chosen by the game master is printed on the special card for that round.\nHaving all this information, Ringo would like to allocate tickets to the rounds of the game. That is, he wants to select the ticket set to use in each round in order to maximize the total value of the prizes.\nImplementation details\nYou should implement the following procedure:\nint64 find_maximum(int k, int[][] x)\n$$$k$$$: the number of rounds.\n$$$x$$$: an $$$n\\times m$$$ array describing the integers on each ticket. Tickets of each color are sorted in non-decreasing order of their integers.\nThis procedure is called exactly once.\nThis procedure should make exactly one call to\nallocate_tickets\n(see below), describing $$$k$$$ ticket sets, one for each round. The allocation should maximize the total value of the prizes.\nThis procedure should return the maximum total value of the prizes.\nThe procedure\nallocate_tickets\nis defined as follows:\nvoid allocate_tickets(int[][] s)\n$$$s$$$: an $$$n\\times m$$$ array. The value of $$$s[i][j]$$$ should be $$$r$$$ if the ticket $$$j$$$ of the colour $$$i$$$ is used in the set of round $$$r$$$ of the game, or $$$-1$$$ if it is not used at all.\nFor each $$$0 \\leq i \\leq n - 1$$$, among $$$s[i][0], s[i][1],\\ldots, s[i][m - 1]$$$ each value $$$0,1,2,\\ldots,k-1$$$ must occur exactly once, and all other entries must be $$$-1$$$.\nIf there are multiple allocations resulting in the maximum total prize value, it is allowed to report any of them.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n\\ m\\ k$$$ ($$$2 \\leq n \\leq 1500$$$ and $$$n$$$ is even, $$$1 \\leq k \\leq m \\leq 1500$$$)\nline $$$2+i$$$ ($$$0\\leq i\\leq n-1$$$): $$$x[i][0]\\ x[i][1]\\ldots x[i][m-1]$$$ ($$$0 \\leq x[i][j] \\leq 10^9$$$ $$$x[i][j-1] \\leq x[i][j]$$$ (for all $$$0 \\leq i \\leq n-1$$$ and $$$1 \\leq j \\leq m-1$$$))\nOutput\nThe sample grader prints your answer in the following format:\nline $$$1$$$: the return value of\nfind_maximum\nline $$$2+i$$$ ($$$0\\leq i\\leq n-1$$$): $$$s[i][0]\\ s[i][1]\\ldots s[i][m-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$m = 1$$$\n2\n16\n$$$k = 1$$$\n3\n14\n$$$0 \\leq x[i][j] \\leq 1$$$ (for all $$$0 \\leq i \\leq n-1$$$ and $$$0 \\leq j \\leq m - 1$$$)\n4\n14\n$$$k = m$$$\n5\n12\n$$$n, m \\leq 80$$$\n6\n23\n$$$n, m \\leq 300$$$\n7\n10\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\nThis means that:\nthere are $$$k=2$$$ rounds;\nthe integers printed on the tickets of colour $$$0$$$ are $$$0$$$, $$$2$$$ and $$$5$$$, respectively;\nthe integers printed on the tickets of colour $$$1$$$ are $$$1$$$, $$$1$$$ and $$$3$$$, respectively.\nA possible allocation that gives the maximum total prize value is:\nIn round $$$0$$$, Ringo picks ticket $$$0$$$ of colour $$$0$$$ (with the integer $$$0$$$) and ticket $$$2$$$ of colour $$$1$$$ (with the integer $$$3$$$). The lowest possible value of the prize in this round is $$$3$$$. E.g., the game master may choose $$$b = 1$$$: $$$|1 - 0| + |1 - 3| = 1 + 2 = 3$$$.\nIn round $$$1$$$, Ringo picks ticket $$$2$$$ of colour $$$0$$$ (with the integer $$$5$$$) and ticket $$$1$$$ of colour $$$1$$$ (with the integer $$$1$$$). The lowest possible value of the prize in this round is $$$4$$$. E.g., the game master may choose $$$b = 3$$$: $$$|3 - 1| + |3 - 5| = 2 + 2 = 4$$$.\nTherefore, the total value of the prizes would be $$$3 + 4 = 7$$$.\nTo report this allocation, the procedure\nfind_maximum\nshould make the following call to\nallocate_tickets\n:\nallocate_tickets([[0, -1, 1], [-1, 1, 0]])\nFinally, the procedure\nfind_maximum\nshould return $$$7$$$.\nExample 2\nConsider the following call:\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\nThis means that:\nthere is only one round,\nthe integers printed on the tickets of colour $$$0$$$ are $$$5$$$ and $$$9$$$, respectively;\nthe integers printed on the tickets of colour $$$1$$$ are $$$1$$$ and $$$4$$$, respectively;\nthe integers printed on the tickets of colour $$$2$$$ are $$$3$$$ and $$$6$$$, respectively;\nthe integers printed on the tickets of colour $$$3$$$ are $$$2$$$ and $$$7$$$, respectively.\nA possible allocation that gives the maximum total prize value is:\nIn round $$$0$$$, Ringo picks ticket $$$1$$$ of colour $$$0$$$ (with the integer $$$9$$$), ticket $$$0$$$ of colour $$$1$$$ (with the integer $$$1$$$), ticket $$$0$$$ of colour $$$2$$$ (with the integer $$$3$$$), and ticket $$$1$$$ of colour $$$3$$$ (with the integer $$$7$$$). The lowest possible value of the prize in this round is $$$12$$$, when the game master chooses $$$b = 3$$$: $$$|3 - 9| + |3 - 1| + |3 - 3| + |3 - 7| = 6 + 2 + 0 + 4 = 12$$$.\nTo report this solution, the procedure\nfind_maximum\nshould make the following call to\nallocate_tickets\n:\nallocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])\nFinally, the procedure\nfind_maximum\nshould return $$$12$$$.",
    "_meta": {
      "index": 65,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/C",
      "uuid": "ps_64359cf9e23135264370a59ba5d82a6d0c98aa19"
    }
  },
  {
    "planning_view": {
      "title": "B. Connecting Supertrees",
      "task": "Build bridges to achieve required path counts (0-3) between n towers",
      "given": [
        "n towers labeled 0 to n-1",
        "n×n matrix p with p[i][j] = required paths from i to j",
        "p[i][j] ∈ {0,1,2,3} and p[i][i] = 1"
      ],
      "goal": "Construct bridges so number of paths from i to j equals p[i][j] for all pairs",
      "key_rules": [
        "p[i][j] = p[j][i] (symmetric)",
        "p[i][i] = 1 for all i",
        "No two bridges connect same pair of towers",
        "Graph must be undirected with no self-loops"
      ],
      "target": {
        "1": {
          "points": 11,
          "req": "p[i][j] = 1 for all i,j (always possible with no bridges)"
        },
        "2": {
          "points": 10,
          "req": "p[i][j] ∈ {0,1} for all i,j"
        },
        "3": {
          "points": 19,
          "req": "p[i][j] ∈ {0,2} for all i≠j"
        },
        "4": {
          "points": 35,
          "req": "p[i][j] ∈ {0,1,2} and at least one valid construction exists"
        },
        "5": {
          "points": 21,
          "req": "p[i][j] ∈ {0,1,2} for all i,j"
        },
        "6": {
          "points": 4,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Connecting Supertrees",
      "contest": "IOI 2020 day 1",
      "one_line": "Build bridges to achieve required path counts (0-3) between n towers",
      "given": [
        "n towers labeled 0 to n-1",
        "n×n matrix p with p[i][j] = required paths from i to j",
        "p[i][j] ∈ {0,1,2,3} and p[i][i] = 1"
      ],
      "goal": "Construct bridges so number of paths from i to j equals p[i][j] for all pairs",
      "mechanism": "Bridges connect towers; paths are distinct sequences connected by bridges; multiple paths possible",
      "success_condition": "For all i,j, the number of distinct paths from i to j equals p[i][j]",
      "constraints": {
        "critical": [
          "p[i][j] = p[j][i] (symmetric)",
          "p[i][i] = 1 for all i",
          "No two bridges connect same pair of towers",
          "Graph must be undirected with no self-loops"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "p[i][j] = 1 for all i,j (always possible with no bridges)"
          },
          "2": {
            "points": 10,
            "req": "p[i][j] ∈ {0,1} for all i,j"
          },
          "3": {
            "points": 19,
            "req": "p[i][j] ∈ {0,2} for all i≠j"
          },
          "4": {
            "points": 35,
            "req": "p[i][j] ∈ {0,1,2} and at least one valid construction exists"
          },
          "5": {
            "points": 21,
            "req": "p[i][j] ∈ {0,1,2} for all i,j"
          },
          "6": {
            "points": 4,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Connecting Supertrees",
        "contest": "IOI 2020 day 1",
        "one_line": "Build bridges to achieve required path counts (0-3) between n towers"
      },
      "problem": {
        "given": [
          "n towers labeled 0 to n-1",
          "n×n matrix p with p[i][j] = required paths from i to j",
          "p[i][j] ∈ {0,1,2,3} and p[i][i] = 1"
        ],
        "goal": "Construct bridges so number of paths from i to j equals p[i][j] for all pairs",
        "mechanism": "Bridges connect towers; paths are distinct sequences connected by bridges; multiple paths possible",
        "success_condition": "For all i,j, the number of distinct paths from i to j equals p[i][j]"
      },
      "constraints": {
        "critical": [
          "p[i][j] = p[j][i] (symmetric)",
          "p[i][i] = 1 for all i",
          "No two bridges connect same pair of towers",
          "Graph must be undirected with no self-loops"
        ],
        "subtasks": {
          "1": {
            "points": 11,
            "req": "p[i][j] = 1 for all i,j (always possible with no bridges)"
          },
          "2": {
            "points": 10,
            "req": "p[i][j] ∈ {0,1} for all i,j"
          },
          "3": {
            "points": 19,
            "req": "p[i][j] ∈ {0,2} for all i≠j"
          },
          "4": {
            "points": 35,
            "req": "p[i][j] ∈ {0,1,2} and at least one valid construction exists"
          },
          "5": {
            "points": 21,
            "req": "p[i][j] ∈ {0,1,2} for all i,j"
          },
          "6": {
            "points": 4,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int construct(int[][] p)",
        "available_api": {
          "build": {
            "signature": "void build(int[][] b)",
            "params": "b: n×n adjacency matrix where b[i][j]=1 if bridge between i and j",
            "returns": "none",
            "side_effect": "Submits the solution; can only be called once if solution exists"
          }
        },
        "requirements": [
          "Return 1 and call build() if solution exists",
          "Return 0 without calling build() if impossible",
          "b must be symmetric with zeros on diagonal",
          "n ≤ 1000"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "4\n1 1 2 2\n1 1 2 2\n2 2 1 2\n2 2 2 1",
          "output": "OK\n1\n0 1 1 1\n1 0 0 0\n1 0 0 1\n1 0 1 0"
        }
      ],
      "original_statement": "Gardens by the Bay is a large nature park in Singapore. In the park there are $$$n$$$ towers, known as supertrees. These towers are labelled $$$0$$$ to $$$n - 1$$$. We would like to construct a set of\nzero or more\nbridges. Each bridge connects a pair of distinct towers and may be traversed in\neither\ndirection. No two bridges should connect the same pair of towers.\nA path from tower $$$x$$$ to tower $$$y$$$ is a sequence of one or more towers such that:\nthe first element of the sequence is $$$x$$$,\nthe last element of the sequence is $$$y$$$,\nall elements of the sequence are\ndistinct\n, and\neach two consecutive elements (towers) in the sequence are connected by a bridge.\nNote that by definition there is exactly one path from a tower to itself and the number of different paths from tower $$$i$$$ to tower $$$j$$$ is the same as the number of different paths from tower $$$j$$$ to tower $$$i$$$.\nThe lead architect in charge of the design wishes for the bridges to be built such that for all $$$0 \\leq i, j \\leq n-1$$$ there are exactly $$$p[i][j]$$$ different paths from tower $$$i$$$ to tower $$$j$$$, where $$$0 \\leq p[i][j] \\leq 3$$$.\nConstruct a set of bridges that satisfy the architect's requirements, or determine that it is impossible.\nImplementation details\nYou should implement the following procedure:\nint construct(int[][] p)\n$$$p$$$: an $$$n \\times n$$$ array representing the architect's requirements.\nIf a construction is possible, this procedure should make exactly one call to\nbuild\n(see below) to report the construction, following which it should return $$$1$$$.\nOtherwise, the procedure should return $$$0$$$ without making any calls to\nbuild\n.\nThis procedure is called exactly once.\nThe procedure\nbuild\nis defined as follows:\nvoid build(int[][] b)\n$$$b$$$: an $$$n \\times n$$$ array, with $$$b[i][j]=1$$$ if there is a bridge connecting tower $$$i$$$ and tower $$$j$$$, or $$$b[i][j]=0$$$ otherwise.\nNote that the array $$$b$$$ must satisfy $$$b[i][j]=b[j][i]$$$ for all $$$0 \\leq i,j \\leq n-1$$$ and $$$b[i][i] = 0$$$ for all $$$0 \\leq i \\leq n-1$$$.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n$$$ ($$$1 \\leq n \\leq 1000$$$)\nline $$$2 + i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$p[i][0]\\ p[i][1]\\ldots \\ p[i][n-1]$$$ ($$$p[i][i] = 1$$$ (for all $$$0 \\leq i \\leq n-1$$$) $$$p[i][j] = p[j][i]$$$ (for all $$$0 \\leq i, j \\leq n-1$$$) $$$0 \\leq p[i][j] \\leq 3$$$ (for all $$$0 \\leq i, j \\leq n-1$$$))\nOutput\nThe output of sample grader is in the following format:\nline $$$1$$$: the return value of\nconstruct\n. If the return value of\nconstruct\nis $$$1$$$, the sample grader additionally prints:\nline $$$2 + i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$b[i][0]\\ b[i][1]\\ldots \\ b[i][n-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$p[i][j] = 1$$$ (for all $$$0 \\leq i, j \\leq n-1$$$)\n2\n10\n$$$p[i][j] = 0$$$ or $$$1$$$ (for all $$$0 \\leq i, j \\leq n-1$$$)\n3\n19\n$$$p[i][j] = 0$$$ or $$$2$$$ (for all $$$i\\neq j$$$, $$$0 \\leq i, j \\leq n-1$$$)\n4\n35\n$$$0 \\leq p[i][j] \\leq 2$$$ (for all $$$0 \\leq i, j \\leq n-1$$$) and there is at least one construction satisfying the requirements.\n5\n21\n$$$0 \\leq p[i][j] \\leq 2$$$ (for all $$$0 \\leq i, j \\leq n-1$$$)\n6\n4\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nconstruct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])\nThis means that there should be exactly one path from tower $$$0$$$ to tower $$$1$$$. For all other pairs of towers $$$(x, y)$$$, such that $$$0 \\leq x < y \\leq 3$$$, there should be exactly two paths from tower $$$x$$$ to tower $$$y$$$.\nThis can be achieved with $$$4$$$ bridges, connecting pairs of towers $$$(0, 1)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$ and $$$(2, 3)$$$.\nTo report this solution, the\nconstruct\nprocedure should make the following call:\nbuild([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])\nIt should then return $$$1$$$.\nIn this case, there are multiple constructions that fit the requirements, all of which would be considered correct.\nExample 2\nConsider the following call:\nconstruct([[1, 0], [0, 1]])\nThis means that there should be no way to travel between the two towers. This can only be satisfied by having no bridges.\nTherefore, the\nconstruct\nprocedure should make the following call:\nbuild([[0, 0], [0, 0]])\nAfter which, the\nconstruct\nprocedure should return $$$1$$$.\nExample 3\nConsider the following call:\nconstruct([[1, 3], [3, 1]])\nThis means that there should be exactly $$$3$$$ paths from tower $$$0$$$ to tower $$$1$$$. This set of requirements cannot be satisfied. As such, the\nconstruct\nprocedure should return $$$0$$$ without making any call to\nbuild\n."
    },
    "original": "Gardens by the Bay is a large nature park in Singapore. In the park there are $$$n$$$ towers, known as supertrees. These towers are labelled $$$0$$$ to $$$n - 1$$$. We would like to construct a set of\nzero or more\nbridges. Each bridge connects a pair of distinct towers and may be traversed in\neither\ndirection. No two bridges should connect the same pair of towers.\nA path from tower $$$x$$$ to tower $$$y$$$ is a sequence of one or more towers such that:\nthe first element of the sequence is $$$x$$$,\nthe last element of the sequence is $$$y$$$,\nall elements of the sequence are\ndistinct\n, and\neach two consecutive elements (towers) in the sequence are connected by a bridge.\nNote that by definition there is exactly one path from a tower to itself and the number of different paths from tower $$$i$$$ to tower $$$j$$$ is the same as the number of different paths from tower $$$j$$$ to tower $$$i$$$.\nThe lead architect in charge of the design wishes for the bridges to be built such that for all $$$0 \\leq i, j \\leq n-1$$$ there are exactly $$$p[i][j]$$$ different paths from tower $$$i$$$ to tower $$$j$$$, where $$$0 \\leq p[i][j] \\leq 3$$$.\nConstruct a set of bridges that satisfy the architect's requirements, or determine that it is impossible.\nImplementation details\nYou should implement the following procedure:\nint construct(int[][] p)\n$$$p$$$: an $$$n \\times n$$$ array representing the architect's requirements.\nIf a construction is possible, this procedure should make exactly one call to\nbuild\n(see below) to report the construction, following which it should return $$$1$$$.\nOtherwise, the procedure should return $$$0$$$ without making any calls to\nbuild\n.\nThis procedure is called exactly once.\nThe procedure\nbuild\nis defined as follows:\nvoid build(int[][] b)\n$$$b$$$: an $$$n \\times n$$$ array, with $$$b[i][j]=1$$$ if there is a bridge connecting tower $$$i$$$ and tower $$$j$$$, or $$$b[i][j]=0$$$ otherwise.\nNote that the array $$$b$$$ must satisfy $$$b[i][j]=b[j][i]$$$ for all $$$0 \\leq i,j \\leq n-1$$$ and $$$b[i][i] = 0$$$ for all $$$0 \\leq i \\leq n-1$$$.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$n$$$ ($$$1 \\leq n \\leq 1000$$$)\nline $$$2 + i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$p[i][0]\\ p[i][1]\\ldots \\ p[i][n-1]$$$ ($$$p[i][i] = 1$$$ (for all $$$0 \\leq i \\leq n-1$$$) $$$p[i][j] = p[j][i]$$$ (for all $$$0 \\leq i, j \\leq n-1$$$) $$$0 \\leq p[i][j] \\leq 3$$$ (for all $$$0 \\leq i, j \\leq n-1$$$))\nOutput\nThe output of sample grader is in the following format:\nline $$$1$$$: the return value of\nconstruct\n. If the return value of\nconstruct\nis $$$1$$$, the sample grader additionally prints:\nline $$$2 + i$$$ ($$$0 \\leq i \\leq n - 1$$$): $$$b[i][0]\\ b[i][1]\\ldots \\ b[i][n-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n11\n$$$p[i][j] = 1$$$ (for all $$$0 \\leq i, j \\leq n-1$$$)\n2\n10\n$$$p[i][j] = 0$$$ or $$$1$$$ (for all $$$0 \\leq i, j \\leq n-1$$$)\n3\n19\n$$$p[i][j] = 0$$$ or $$$2$$$ (for all $$$i\\neq j$$$, $$$0 \\leq i, j \\leq n-1$$$)\n4\n35\n$$$0 \\leq p[i][j] \\leq 2$$$ (for all $$$0 \\leq i, j \\leq n-1$$$) and there is at least one construction satisfying the requirements.\n5\n21\n$$$0 \\leq p[i][j] \\leq 2$$$ (for all $$$0 \\leq i, j \\leq n-1$$$)\n6\n4\nNo additional constraints.\nExamples\nNote\nExample 1\nConsider the following call:\nconstruct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])\nThis means that there should be exactly one path from tower $$$0$$$ to tower $$$1$$$. For all other pairs of towers $$$(x, y)$$$, such that $$$0 \\leq x < y \\leq 3$$$, there should be exactly two paths from tower $$$x$$$ to tower $$$y$$$.\nThis can be achieved with $$$4$$$ bridges, connecting pairs of towers $$$(0, 1)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$ and $$$(2, 3)$$$.\nTo report this solution, the\nconstruct\nprocedure should make the following call:\nbuild([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])\nIt should then return $$$1$$$.\nIn this case, there are multiple constructions that fit the requirements, all of which would be considered correct.\nExample 2\nConsider the following call:\nconstruct([[1, 0], [0, 1]])\nThis means that there should be no way to travel between the two towers. This can only be satisfied by having no bridges.\nTherefore, the\nconstruct\nprocedure should make the following call:\nbuild([[0, 0], [0, 0]])\nAfter which, the\nconstruct\nprocedure should return $$$1$$$.\nExample 3\nConsider the following call:\nconstruct([[1, 3], [3, 1]])\nThis means that there should be exactly $$$3$$$ paths from tower $$$0$$$ to tower $$$1$$$. This set of requirements cannot be satisfied. As such, the\nconstruct\nprocedure should return $$$0$$$ without making any call to\nbuild\n.",
    "_meta": {
      "index": 66,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/B",
      "uuid": "ps_b14e9be92227da87a5355e5a5b82f0ace9dbbe17"
    }
  },
  {
    "planning_view": {
      "title": "E. Dancing Elephants",
      "task": "Track min cameras needed after each elephant move to cover all with length-L segments",
      "given": [
        "N elephants on a line with initial sorted positions",
        "Each camera covers segment of length L",
        "Multiple elephants can occupy same position"
      ],
      "goal": "Return minimum number of cameras needed after each elephant position update",
      "key_rules": [
        "Cameras cover continuous segments of exactly length L",
        "Elephants can share positions",
        "Positions can change arbitrarily between acts"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "N=2, distinct positions, ≤100 updates"
        },
        "2": {
          "points": 16,
          "req": "N≤100, distinct positions, ≤100 updates"
        },
        "3": {
          "points": 24,
          "req": "N≤50,000, distinct positions, ≤50,000 updates"
        },
        "4": {
          "points": 47,
          "req": "N≤70,000, positions may overlap, ≤70,000 updates"
        },
        "5": {
          "points": 3,
          "req": "N≤150,000, positions may overlap, ≤150,000 updates"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Dancing Elephants",
      "contest": "IOI 2011 day 2",
      "one_line": "Track min cameras needed after each elephant move to cover all with length-L segments",
      "given": [
        "N elephants on a line with initial sorted positions",
        "Each camera covers segment of length L",
        "Multiple elephants can occupy same position"
      ],
      "goal": "Return minimum number of cameras needed after each elephant position update",
      "mechanism": "Each update(i,y) moves elephant i to position y; must recompute camera coverage",
      "success_condition": "Correctly compute minimum cameras (covering all elephants with length-L segments)",
      "constraints": {
        "critical": [
          "Cameras cover continuous segments of exactly length L",
          "Elephants can share positions",
          "Positions can change arbitrarily between acts"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "N=2, distinct positions, ≤100 updates"
          },
          "2": {
            "points": 16,
            "req": "N≤100, distinct positions, ≤100 updates"
          },
          "3": {
            "points": 24,
            "req": "N≤50,000, distinct positions, ≤50,000 updates"
          },
          "4": {
            "points": 47,
            "req": "N≤70,000, positions may overlap, ≤70,000 updates"
          },
          "5": {
            "points": 3,
            "req": "N≤150,000, positions may overlap, ≤150,000 updates"
          }
        }
      },
      "limits": {
        "time": "5 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Dancing Elephants",
        "contest": "IOI 2011 day 2",
        "one_line": "Track min cameras needed after each elephant move to cover all with length-L segments"
      },
      "problem": {
        "given": [
          "N elephants on a line with initial sorted positions",
          "Each camera covers segment of length L",
          "Multiple elephants can occupy same position"
        ],
        "goal": "Return minimum number of cameras needed after each elephant position update",
        "mechanism": "Each update(i,y) moves elephant i to position y; must recompute camera coverage",
        "success_condition": "Correctly compute minimum cameras (covering all elephants with length-L segments)"
      },
      "constraints": {
        "critical": [
          "Cameras cover continuous segments of exactly length L",
          "Elephants can share positions",
          "Positions can change arbitrarily between acts"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "N=2, distinct positions, ≤100 updates"
          },
          "2": {
            "points": 16,
            "req": "N≤100, distinct positions, ≤100 updates"
          },
          "3": {
            "points": 24,
            "req": "N≤50,000, distinct positions, ≤50,000 updates"
          },
          "4": {
            "points": 47,
            "req": "N≤70,000, positions may overlap, ≤70,000 updates"
          },
          "5": {
            "points": 3,
            "req": "N≤150,000, positions may overlap, ≤150,000 updates"
          }
        }
      },
      "implementation": {
        "function_to_write": "int update(int i, int y)",
        "available_api": {
          "init": {
            "signature": "void init(int N, int L, int[] X)",
            "params": "N: number of elephants, L: camera segment length, X: initial sorted elephant positions",
            "returns": "void",
            "side_effect": "Initializes system state before all update calls"
          },
          "update": {
            "signature": "int update(int i, int y)",
            "params": "i: elephant number (0..N-1), y: new position",
            "returns": "Minimum cameras needed after this move",
            "side_effect": "Updates elephant i's position to y"
          }
        },
        "requirements": [
          "Elephants are 0-indexed (0 to N-1)",
          "Positions are integers 0..1,000,000,000",
          "L is integer 0..1,000,000,000",
          "Must handle position overlaps"
        ]
      },
      "limits": {
        "time": "5 seconds",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "4 10 5\n10\n15\n17\n20\n2 16\n1 25\n3 35\n0 38\n2 0",
          "output": "1\n2\n2\n2\n3"
        }
      ],
      "original_statement": "Dancing Elephants\nis a spectacular show in Pattaya that features $$$N$$$ elephants dancing on a line, known as the\nstage\n.\nAfter years of training, elephants in this show are capable of many amazing dances. The show consists of a series of acts. In each act, exactly one elephant performs a cute dance while possibly moving to a different position.\nThe show producers want to produce a photo book that contains pictures of the entire show. After each act, they want to take pictures of all elephants as seen by the spectators.\nAt any time during the show, multiple elephants may share the same position. In that case, they simply stand behind one another at the same position.\nA single camera can take a picture of a group of elephants if and only if all their positions lie on some segment of length $$$L$$$ (including both its endpoints). As the elephants can spread out across the stage, multiple cameras may be needed in order to take simultaneous snapshots of all the elephants.\nAs an example, suppose that $$$L=10$$$ and that the elephants are at positions $$$10$$$, $$$15$$$, $$$17$$$, and $$$20$$$ on the stage. At this moment, a single camera can take their picture, as shown below. (Elephants are shown as triangles; cameras are shown as trapezoids.)\nIn the following act, the elephant at position $$$15$$$ dances to position $$$32$$$. After this act, we need at least two cameras to take the snapshot.\nIn the next act, the elephant at position $$$10$$$ moves to position $$$7$$$. For the new arrangement of elephants, we need three cameras to photograph all of them.\nIn this interactive task, you have to determine the\nminimum\nnumber of cameras needed to take the pictures after each of the acts. Note that the number of cameras needed may increase, decrease, or stay the same between acts.\nYour task is to write the following procedures:\nProcedure\ninit(N,L,X)\nthat takes the following parameters:\n$$$N$$$— the number of elephants. The elephants are numbered $$$0$$$ through $$$N-1$$$.\n$$$L$$$— the length of the segment captured by a single camera. You may assume that $$$L$$$ is an integer such that $$$0 \\le L \\le 1\\,000\\,000\\,000$$$.\n$$$X$$$— a one-dimensional array of integers representing the initial positions of the elephants. For $$$0 \\le i < N$$$, elephant $$$i$$$ starts at the position $$$X[i]$$$. The initial positions are in sorted order. More precisely, you may assume that $$$0 \\le X[0] \\le \\dots \\le X[N-1] \\le 1\\,000\\,000\\,000$$$. Note that during the dance the elephants may reorder themselves.\nThis procedure will be called only once, prior to all calls to\nupdate\n. It does not return any value.\nProcedure\nupdate(i,y)\nthat takes the following parameters:\n$$$i$$$— the number of the elephant that moves in the current act.\n$$$y$$$— the position where the elephant $$$i$$$ will stand after the current act. You may assume that $$$y$$$ is an integer such that $$$0 \\le y \\le 1\\,000\\,000\\,000$$$.\nThis procedure will be called multiple times. Each call corresponds to a single act (which follows on from all of the previous acts). Each call must return the\nminimum number of cameras needed\nto photograph all elephants after the corresponding act.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$N$$$, $$$L$$$, and $$$M$$$, where $$$M$$$ is the number of acts in the show.\nLines $$$2$$$ to $$$N+1$$$: the initial positions; i.e., line $$$k+2$$$ contains $$$X[k]$$$ for $$$0 \\le k < N$$$.\nLines $$$N+2$$$ to $$$N+M+1$$$: information on $$$M$$$ acts; i.e. line $$$N+1+j$$$ contains $$$i[j]$$$, $$$y[j]$$$, and $$$s[j]$$$, separated by a space, denoting that in the $$$j$$$ act elephant $$$i[j]$$$ moves to position $$$y[j]$$$, and after that act, $$$s[j]$$$ is the mininal number of cameras needed, for $$$1 \\le j \\le M$$$.\nScoring\nSubtask\nPoints\n$$$N$$$\nAdditional Input Constraints\n1\n10\n$$$N = 2$$$\nInitially, and after each act, the positions of all elephants will be distinct. Your procedure\nupdate\nwill be called at most $$$100$$$ times.\n2\n16\n$$$1 \\leq N \\leq 100$$$\nInitially, and after each act, the positions of all elephants will be distinct. Your procedure\nupdate\nwill be called at most $$$100$$$ times.\n3\n24\n$$$1 \\leq N \\leq 50\\,000$$$\nInitially, and after each act, the positions of all elephants will be distinct. Your procedure\nupdate\nwill be called at most $$$50\\,000$$$ times.\n4\n47\n$$$1 \\leq N \\leq 70\\,000$$$\nElephants may share the same position. Your procedure\nupdate\nwill be called at most $$$70\\,000$$$ times.\n5\n3\n$$$1 \\leq N \\leq 150\\,000$$$\nElephants may share the same position. Your procedure\nupdate\nwill be called at most $$$150\\,000$$$ times.\nExample\nNote\nConsider the example.\nFirst, your procedure\ninit\nwill be called with these parameters. Afterwards, your procedure\nupdate\nwill be called once for each act. Here is an example sequence of calls and their correct return values:\nact\ncall parameters\nreturn value\n$$$1$$$\nupdate(2,16)\n$$$1$$$\n$$$2$$$\nupdate(1,25)\n$$$2$$$\n$$$3$$$\nupdate(3,35)\n$$$2$$$\n$$$4$$$\nupdate(0,38)\n$$$2$$$\n$$$5$$$\nupdate(2,0)\n$$$3$$$"
    },
    "original": "Dancing Elephants\nis a spectacular show in Pattaya that features $$$N$$$ elephants dancing on a line, known as the\nstage\n.\nAfter years of training, elephants in this show are capable of many amazing dances. The show consists of a series of acts. In each act, exactly one elephant performs a cute dance while possibly moving to a different position.\nThe show producers want to produce a photo book that contains pictures of the entire show. After each act, they want to take pictures of all elephants as seen by the spectators.\nAt any time during the show, multiple elephants may share the same position. In that case, they simply stand behind one another at the same position.\nA single camera can take a picture of a group of elephants if and only if all their positions lie on some segment of length $$$L$$$ (including both its endpoints). As the elephants can spread out across the stage, multiple cameras may be needed in order to take simultaneous snapshots of all the elephants.\nAs an example, suppose that $$$L=10$$$ and that the elephants are at positions $$$10$$$, $$$15$$$, $$$17$$$, and $$$20$$$ on the stage. At this moment, a single camera can take their picture, as shown below. (Elephants are shown as triangles; cameras are shown as trapezoids.)\nIn the following act, the elephant at position $$$15$$$ dances to position $$$32$$$. After this act, we need at least two cameras to take the snapshot.\nIn the next act, the elephant at position $$$10$$$ moves to position $$$7$$$. For the new arrangement of elephants, we need three cameras to photograph all of them.\nIn this interactive task, you have to determine the\nminimum\nnumber of cameras needed to take the pictures after each of the acts. Note that the number of cameras needed may increase, decrease, or stay the same between acts.\nYour task is to write the following procedures:\nProcedure\ninit(N,L,X)\nthat takes the following parameters:\n$$$N$$$— the number of elephants. The elephants are numbered $$$0$$$ through $$$N-1$$$.\n$$$L$$$— the length of the segment captured by a single camera. You may assume that $$$L$$$ is an integer such that $$$0 \\le L \\le 1\\,000\\,000\\,000$$$.\n$$$X$$$— a one-dimensional array of integers representing the initial positions of the elephants. For $$$0 \\le i < N$$$, elephant $$$i$$$ starts at the position $$$X[i]$$$. The initial positions are in sorted order. More precisely, you may assume that $$$0 \\le X[0] \\le \\dots \\le X[N-1] \\le 1\\,000\\,000\\,000$$$. Note that during the dance the elephants may reorder themselves.\nThis procedure will be called only once, prior to all calls to\nupdate\n. It does not return any value.\nProcedure\nupdate(i,y)\nthat takes the following parameters:\n$$$i$$$— the number of the elephant that moves in the current act.\n$$$y$$$— the position where the elephant $$$i$$$ will stand after the current act. You may assume that $$$y$$$ is an integer such that $$$0 \\le y \\le 1\\,000\\,000\\,000$$$.\nThis procedure will be called multiple times. Each call corresponds to a single act (which follows on from all of the previous acts). Each call must return the\nminimum number of cameras needed\nto photograph all elephants after the corresponding act.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$N$$$, $$$L$$$, and $$$M$$$, where $$$M$$$ is the number of acts in the show.\nLines $$$2$$$ to $$$N+1$$$: the initial positions; i.e., line $$$k+2$$$ contains $$$X[k]$$$ for $$$0 \\le k < N$$$.\nLines $$$N+2$$$ to $$$N+M+1$$$: information on $$$M$$$ acts; i.e. line $$$N+1+j$$$ contains $$$i[j]$$$, $$$y[j]$$$, and $$$s[j]$$$, separated by a space, denoting that in the $$$j$$$ act elephant $$$i[j]$$$ moves to position $$$y[j]$$$, and after that act, $$$s[j]$$$ is the mininal number of cameras needed, for $$$1 \\le j \\le M$$$.\nScoring\nSubtask\nPoints\n$$$N$$$\nAdditional Input Constraints\n1\n10\n$$$N = 2$$$\nInitially, and after each act, the positions of all elephants will be distinct. Your procedure\nupdate\nwill be called at most $$$100$$$ times.\n2\n16\n$$$1 \\leq N \\leq 100$$$\nInitially, and after each act, the positions of all elephants will be distinct. Your procedure\nupdate\nwill be called at most $$$100$$$ times.\n3\n24\n$$$1 \\leq N \\leq 50\\,000$$$\nInitially, and after each act, the positions of all elephants will be distinct. Your procedure\nupdate\nwill be called at most $$$50\\,000$$$ times.\n4\n47\n$$$1 \\leq N \\leq 70\\,000$$$\nElephants may share the same position. Your procedure\nupdate\nwill be called at most $$$70\\,000$$$ times.\n5\n3\n$$$1 \\leq N \\leq 150\\,000$$$\nElephants may share the same position. Your procedure\nupdate\nwill be called at most $$$150\\,000$$$ times.\nExample\nNote\nConsider the example.\nFirst, your procedure\ninit\nwill be called with these parameters. Afterwards, your procedure\nupdate\nwill be called once for each act. Here is an example sequence of calls and their correct return values:\nact\ncall parameters\nreturn value\n$$$1$$$\nupdate(2,16)\n$$$1$$$\n$$$2$$$\nupdate(1,25)\n$$$2$$$\n$$$3$$$\nupdate(3,35)\n$$$2$$$\n$$$4$$$\nupdate(0,38)\n$$$2$$$\n$$$5$$$\nupdate(2,0)\n$$$3$$$",
    "_meta": {
      "index": 67,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/E",
      "uuid": "ps_46523b02ea398476d081b13fd0806e596cf9ba04"
    }
  },
  {
    "planning_view": {
      "title": "D. Horses",
      "task": "Maximize horse sale profits over N years with M updates, modulo 1e9+7",
      "given": [
        "N years with growth factors X[i] and sale prices Y[i]",
        "Start with 1 horse at year 0",
        "Horses multiply by X[i] each year",
        "Can sell any number at price Y[i] after year i"
      ],
      "goal": "Find maximum total money from optimal horse sales",
      "key_rules": [
        "Sales only possible at year ends",
        "All profits computed modulo 1e9+7",
        "Updates are cumulative",
        "X[i], Y[i] always between 1 and 1e9"
      ],
      "target": {
        "1": {
          "points": 17,
          "req": "N ≤ 10, M = 0, small product constraints"
        },
        "2": {
          "points": 17,
          "req": "N ≤ 1000, M ≤ 1000"
        },
        "3": {
          "points": 20,
          "req": "N ≤ 500000, M ≤ 100000, X[i] ≥ 2"
        },
        "4": {
          "points": 23,
          "req": "N ≤ 500000, M ≤ 10000"
        },
        "5": {
          "points": 23,
          "req": "N ≤ 500000, M ≤ 100000"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Horses",
      "contest": "IOI 2015 day 2",
      "one_line": "Maximize horse sale profits over N years with M updates, modulo 1e9+7",
      "given": [
        "N years with growth factors X[i] and sale prices Y[i]",
        "Start with 1 horse at year 0",
        "Horses multiply by X[i] each year",
        "Can sell any number at price Y[i] after year i"
      ],
      "goal": "Find maximum total money from optimal horse sales",
      "mechanism": "After each year, herd size multiplies by X[i]; can sell horses at price Y[i]",
      "success_condition": "First compute initial max profit, then update after each X/Y change",
      "constraints": {
        "critical": [
          "Sales only possible at year ends",
          "All profits computed modulo 1e9+7",
          "Updates are cumulative",
          "X[i], Y[i] always between 1 and 1e9"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "N ≤ 10, M = 0, small product constraints"
          },
          "2": {
            "points": 17,
            "req": "N ≤ 1000, M ≤ 1000"
          },
          "3": {
            "points": 20,
            "req": "N ≤ 500000, M ≤ 100000, X[i] ≥ 2"
          },
          "4": {
            "points": 23,
            "req": "N ≤ 500000, M ≤ 10000"
          },
          "5": {
            "points": 23,
            "req": "N ≤ 500000, M ≤ 100000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Horses",
        "contest": "IOI 2015 day 2",
        "one_line": "Maximize horse sale profits over N years with M updates, modulo 1e9+7"
      },
      "problem": {
        "given": [
          "N years with growth factors X[i] and sale prices Y[i]",
          "Start with 1 horse at year 0",
          "Horses multiply by X[i] each year",
          "Can sell any number at price Y[i] after year i"
        ],
        "goal": "Find maximum total money from optimal horse sales",
        "mechanism": "After each year, herd size multiplies by X[i]; can sell horses at price Y[i]",
        "success_condition": "First compute initial max profit, then update after each X/Y change"
      },
      "constraints": {
        "critical": [
          "Sales only possible at year ends",
          "All profits computed modulo 1e9+7",
          "Updates are cumulative",
          "X[i], Y[i] always between 1 and 1e9"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "N ≤ 10, M = 0, small product constraints"
          },
          "2": {
            "points": 17,
            "req": "N ≤ 1000, M ≤ 1000"
          },
          "3": {
            "points": 20,
            "req": "N ≤ 500000, M ≤ 100000, X[i] ≥ 2"
          },
          "4": {
            "points": 23,
            "req": "N ≤ 500000, M ≤ 10000"
          },
          "5": {
            "points": 23,
            "req": "N ≤ 500000, M ≤ 100000"
          }
        }
      },
      "implementation": {
        "function_to_write": "Three functions: init, updateX, updateY",
        "available_api": {
          "init": {
            "signature": "int init(int N, int X[], int Y[])",
            "params": "N: years count, X: growth factors array, Y: sale prices array",
            "returns": "Max profit modulo 1e9+7",
            "side_effect": "Arrays remain valid, can be modified"
          },
          "updateX": {
            "signature": "int updateX(int pos, int val)",
            "params": "pos: year index (0..N-1), val: new X value",
            "returns": "Max profit after update modulo 1e9+7",
            "side_effect": "Updates X[pos] = val"
          },
          "updateY": {
            "signature": "int updateY(int pos, int val)",
            "params": "pos: year index (0..N-1), val: new Y value",
            "returns": "Max profit after update modulo 1e9+7",
            "side_effect": "Updates Y[pos] = val"
          }
        },
        "requirements": [
          "0-indexed years",
          "Handle up to 500,000 years and 100,000 updates",
          "Return values modulo 1e9+7",
          "All input values between 1 and 1e9"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "1\n2\n3\n0",
          "output": "6"
        }
      ],
      "original_statement": "Mansur loves to breed horses, just like his ancient ancestors did. He now has the largest herd in Kazakhstan. But this was not always the case. $$$N$$$ years ago, Mansur was just a dzhigit (Kazakh for\na young man\n) and he only had a single horse. He dreamed to make a lot of money and to finally become a bai (Kazakh for\na very rich person\n).\nLet us number the years from 0 to $$$N - 1$$$ in chronological order (i.e., year $$$N - 1$$$ is the most recent one). The weather of each year influenced the growth of the herd. For each year $$$i$$$, Mansur remembers a positive integer growth coefficient $$$X[i]$$$. If you started year $$$i$$$ with $$$h$$$ horses, you ended the year with $$$h \\cdot X[i]$$$ horses in your herd.\nHorses could only be sold at the end of a year. For each year $$$i$$$, Mansur remembers a positive integer $$$Y[i]$$$: the price for which he could sell a horse at the end of year $$$i$$$. After each year, it was possible to sell arbitrarily many horses, each at the same price $$$Y[i]$$$.\nMansur wonders what is the largest amount of money he could have now if he had chosen the best moments to sell his horses during the $$$N$$$ years. You have the honor of being a guest on Mansur's toi (Kazakh for\nholiday\n), and he asked you to answer this question.\nMansur's memory improves throughout the evening, and so he makes a sequence of $$$M$$$ updates. Each update will change either one of the values $$$X[i]$$$ or one of the values $$$Y[i]$$$. After each update he again asks you the largest amount of money he could have earned by selling his horses. Mansur's updates are cumulative: each of your answers should take into account all of the previous updates. Note that a single $$$X[i]$$$ or $$$Y[i]$$$ may be updated multiple times.\nThe actual answers to Mansur's questions can be huge. In order to avoid working with large numbers, you are only required to report the answers modulo $$$10^9 + 7$$$.\nYou are given $$$N$$$, $$$X$$$, $$$Y$$$, and the list of updates. Before the first update, and after every update, compute the maximal amount of money that Mansur could get for his horses, modulo $$$10^9 + 7$$$. You need to implement the functions\ninit\n,\nupdateX\n, and\nupdateY\n.\nint init(int N, int X[], int Y[])\n— The grader will call this function first and exactly once.\n$$$N$$$: the number of years.\n$$$X$$$: an array of length $$$N$$$. For $$$0 \\le i\\le N - 1$$$, $$$X[i]$$$ gives the growth coefficient for year $$$i$$$.\n$$$Y$$$: an array of length. For $$$0 \\le i \\le N - 1$$$, $$$Y[i]$$$ gives the price of a horse after year $$$i$$$.\nNote that both $$$X$$$ and $$$Y$$$ specify the initial values given by Mansur (before any updates).\nAfter\ninit\nterminates, the arrays $$$X$$$ and $$$Y$$$ remain valid, and you may modify their contents if you wish.\nThe function should return the maximal amount of money Mansur could get for these initial values of $$$X$$$ and $$$Y$$$, modulo $$$10^9 + 7$$$.\nint updateX(int pos, int val)\n$$$pos$$$: an integer from the range $$$0, \\ldots, N - 1$$$.\n$$$val$$$: the new value for $$$X[pos]$$$.\nThe function should return the maximal amount of money Mansur could get after this update, modulo $$$10^9 + 7$$$.\nint updateY(int pos, int val)\n$$$pos$$$: an integer from the range $$$0, \\ldots, N - 1$$$.\n$$$val$$$: the new value for $$$Y[pos]$$$.\nThe function should return the maximal amount of money Mansur could get after this update, modulo $$$10^9 + 7$$$.\nYou may assume that all the initial, as well as updated values of $$$X[i]$$$ and $$$Y[i]$$$ are between 1 and $$$10^9$$$ inclusive.\nAfter calling\ninit\n, the grader will call\nupdateX\nand\nupdateY\nseveral times.\nThe total number of calls to\nupdateX\nand\nupdateY\nwill be $$$M$$$.\nInput\nThe sample grader reads the input from the file horses.in in the following format:\nline 1: $$$N$$$\nline 2: $$$X[0]\\ \\ldots\\ X[N - 1]$$$\nline 3: $$$Y[0]\\ \\ldots\\ Y[N - 1]$$$\nline 4: $$$M$$$\nlines $$$5, \\ldots, M + 4$$$: three numbers $$$type\\ pos\\ val$$$ ($$$type=1$$$ for\nupdateX\nand $$$type=2$$$ for\nupdateY)\n.\nOutput\nThe sample grader prints the return value of\ninit\nfollowed by the return values of all calls to\nupdateX\nand\nupdateY\n.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\nAdditional constraints\n1\n17\n$$$1 \\le N \\le 10$$$\n$$$M = 0$$$\n$$$X[i], Y[i] \\le 10, X[0]\\cdot X[1] \\cdot \\ldots \\cdot X[N - 1] \\le 1\\,000$$$\n2\n17\n$$$1 \\le N \\le 1\\,000$$$\n$$$0 \\le M \\le 1\\,000$$$\nnone\n3\n20\n$$$1 \\le N \\le 500\\,000$$$\n$$$0 \\le M \\le 100\\,000$$$\n$$$X[i] \\geq 2$$$ and $$$val\\geq 2$$$ for\ninit\nand\nupdateX\ncorrespondingly\n4\n23\n$$$1 \\le N \\le 500\\,000$$$\n$$$0 \\le M \\le 10\\,000$$$\nnone\n5\n23\n$$$1 \\le N \\le 500\\,000$$$\n$$$0 \\le M \\le 100\\,000$$$\nnone\nExample\nNote\nSuppose that there are $$$N = 3$$$ years, with the following information:\n0\n1\n2\nX\n2\n1\n3\nY\n3\n4\n1\nFor these initial values, Mansur can earn the most if he sells both his horses at the end of year 1. The entire process will look as follows:\nInitially, Mansur has 1 horse.\nAfter year 0 he will have $$$1 \\cdot X[0] = 2$$$ horses.\nAfter year 1 he will have $$$2 \\cdot X[1] = 2$$$ horses.\nHe can now sell those two horses. The total profit will be $$$2 \\cdot Y[1] = 8$$$.\nThen, suppose that there is $$$M = 1$$$ update: changing $$$Y[1]$$$ to 2.\nAfter the update we will have:\n0\n1\n2\nX\n2\n1\n3\nY\n3\n2\n1\nIn this case, one of the optimal solutions is to sell one horse after year 0 and then three horses after year 2. The entire process will look as follows:\nInitially, Mansur has 1 horse.\nAfter year 0 he will have $$$1 \\cdot X[0] = 2$$$ horses.\nHe can now sell one of those horses for $$$Y[0] = 3$$$, and have one horse left.\nAfter year 1 he will have $$$1 \\cdot X[1] = 1$$$ horse.\nAfter year 2 he will have $$$1 \\cdot X[2] = 3$$$ horses.\nHe can now sell those three horses for $$$3 \\cdot Y[2] = 3$$$. The total amount of money is $$$3 + 3 = 6$$$."
    },
    "original": "Mansur loves to breed horses, just like his ancient ancestors did. He now has the largest herd in Kazakhstan. But this was not always the case. $$$N$$$ years ago, Mansur was just a dzhigit (Kazakh for\na young man\n) and he only had a single horse. He dreamed to make a lot of money and to finally become a bai (Kazakh for\na very rich person\n).\nLet us number the years from 0 to $$$N - 1$$$ in chronological order (i.e., year $$$N - 1$$$ is the most recent one). The weather of each year influenced the growth of the herd. For each year $$$i$$$, Mansur remembers a positive integer growth coefficient $$$X[i]$$$. If you started year $$$i$$$ with $$$h$$$ horses, you ended the year with $$$h \\cdot X[i]$$$ horses in your herd.\nHorses could only be sold at the end of a year. For each year $$$i$$$, Mansur remembers a positive integer $$$Y[i]$$$: the price for which he could sell a horse at the end of year $$$i$$$. After each year, it was possible to sell arbitrarily many horses, each at the same price $$$Y[i]$$$.\nMansur wonders what is the largest amount of money he could have now if he had chosen the best moments to sell his horses during the $$$N$$$ years. You have the honor of being a guest on Mansur's toi (Kazakh for\nholiday\n), and he asked you to answer this question.\nMansur's memory improves throughout the evening, and so he makes a sequence of $$$M$$$ updates. Each update will change either one of the values $$$X[i]$$$ or one of the values $$$Y[i]$$$. After each update he again asks you the largest amount of money he could have earned by selling his horses. Mansur's updates are cumulative: each of your answers should take into account all of the previous updates. Note that a single $$$X[i]$$$ or $$$Y[i]$$$ may be updated multiple times.\nThe actual answers to Mansur's questions can be huge. In order to avoid working with large numbers, you are only required to report the answers modulo $$$10^9 + 7$$$.\nYou are given $$$N$$$, $$$X$$$, $$$Y$$$, and the list of updates. Before the first update, and after every update, compute the maximal amount of money that Mansur could get for his horses, modulo $$$10^9 + 7$$$. You need to implement the functions\ninit\n,\nupdateX\n, and\nupdateY\n.\nint init(int N, int X[], int Y[])\n— The grader will call this function first and exactly once.\n$$$N$$$: the number of years.\n$$$X$$$: an array of length $$$N$$$. For $$$0 \\le i\\le N - 1$$$, $$$X[i]$$$ gives the growth coefficient for year $$$i$$$.\n$$$Y$$$: an array of length. For $$$0 \\le i \\le N - 1$$$, $$$Y[i]$$$ gives the price of a horse after year $$$i$$$.\nNote that both $$$X$$$ and $$$Y$$$ specify the initial values given by Mansur (before any updates).\nAfter\ninit\nterminates, the arrays $$$X$$$ and $$$Y$$$ remain valid, and you may modify their contents if you wish.\nThe function should return the maximal amount of money Mansur could get for these initial values of $$$X$$$ and $$$Y$$$, modulo $$$10^9 + 7$$$.\nint updateX(int pos, int val)\n$$$pos$$$: an integer from the range $$$0, \\ldots, N - 1$$$.\n$$$val$$$: the new value for $$$X[pos]$$$.\nThe function should return the maximal amount of money Mansur could get after this update, modulo $$$10^9 + 7$$$.\nint updateY(int pos, int val)\n$$$pos$$$: an integer from the range $$$0, \\ldots, N - 1$$$.\n$$$val$$$: the new value for $$$Y[pos]$$$.\nThe function should return the maximal amount of money Mansur could get after this update, modulo $$$10^9 + 7$$$.\nYou may assume that all the initial, as well as updated values of $$$X[i]$$$ and $$$Y[i]$$$ are between 1 and $$$10^9$$$ inclusive.\nAfter calling\ninit\n, the grader will call\nupdateX\nand\nupdateY\nseveral times.\nThe total number of calls to\nupdateX\nand\nupdateY\nwill be $$$M$$$.\nInput\nThe sample grader reads the input from the file horses.in in the following format:\nline 1: $$$N$$$\nline 2: $$$X[0]\\ \\ldots\\ X[N - 1]$$$\nline 3: $$$Y[0]\\ \\ldots\\ Y[N - 1]$$$\nline 4: $$$M$$$\nlines $$$5, \\ldots, M + 4$$$: three numbers $$$type\\ pos\\ val$$$ ($$$type=1$$$ for\nupdateX\nand $$$type=2$$$ for\nupdateY)\n.\nOutput\nThe sample grader prints the return value of\ninit\nfollowed by the return values of all calls to\nupdateX\nand\nupdateY\n.\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$M$$$\nAdditional constraints\n1\n17\n$$$1 \\le N \\le 10$$$\n$$$M = 0$$$\n$$$X[i], Y[i] \\le 10, X[0]\\cdot X[1] \\cdot \\ldots \\cdot X[N - 1] \\le 1\\,000$$$\n2\n17\n$$$1 \\le N \\le 1\\,000$$$\n$$$0 \\le M \\le 1\\,000$$$\nnone\n3\n20\n$$$1 \\le N \\le 500\\,000$$$\n$$$0 \\le M \\le 100\\,000$$$\n$$$X[i] \\geq 2$$$ and $$$val\\geq 2$$$ for\ninit\nand\nupdateX\ncorrespondingly\n4\n23\n$$$1 \\le N \\le 500\\,000$$$\n$$$0 \\le M \\le 10\\,000$$$\nnone\n5\n23\n$$$1 \\le N \\le 500\\,000$$$\n$$$0 \\le M \\le 100\\,000$$$\nnone\nExample\nNote\nSuppose that there are $$$N = 3$$$ years, with the following information:\n0\n1\n2\nX\n2\n1\n3\nY\n3\n4\n1\nFor these initial values, Mansur can earn the most if he sells both his horses at the end of year 1. The entire process will look as follows:\nInitially, Mansur has 1 horse.\nAfter year 0 he will have $$$1 \\cdot X[0] = 2$$$ horses.\nAfter year 1 he will have $$$2 \\cdot X[1] = 2$$$ horses.\nHe can now sell those two horses. The total profit will be $$$2 \\cdot Y[1] = 8$$$.\nThen, suppose that there is $$$M = 1$$$ update: changing $$$Y[1]$$$ to 2.\nAfter the update we will have:\n0\n1\n2\nX\n2\n1\n3\nY\n3\n2\n1\nIn this case, one of the optimal solutions is to sell one horse after year 0 and then three horses after year 2. The entire process will look as follows:\nInitially, Mansur has 1 horse.\nAfter year 0 he will have $$$1 \\cdot X[0] = 2$$$ horses.\nHe can now sell one of those horses for $$$Y[0] = 3$$$, and have one horse left.\nAfter year 1 he will have $$$1 \\cdot X[1] = 1$$$ horse.\nAfter year 2 he will have $$$1 \\cdot X[2] = 3$$$ horses.\nHe can now sell those three horses for $$$3 \\cdot Y[2] = 3$$$. The total amount of money is $$$3 + 3 = 6$$$.",
    "_meta": {
      "index": 68,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/D",
      "uuid": "ps_813b29ca5418106236a394b608a429a931830b1c"
    }
  },
  {
    "planning_view": {
      "title": "E. Mosaic",
      "task": "Answer Q queries counting black tiles in N×N grid with propagation rule",
      "given": [
        "N×N grid initially uncolored except row 0 and column 0",
        "X[0..N-1] colors row 0, Y[0..N-1] colors column 0",
        "X[0] = Y[0]",
        "Q rectangle queries T[k],B[k],L[k],R[k]"
      ],
      "goal": "For each query, count black tiles (1s) in the specified subrectangle",
      "key_rules": [
        "Grid coloring is deterministic: depends only on X and Y",
        "Coloring propagates: tile(i,j) = 1 iff tile(i-1,j) = 0 AND tile(i,j-1) = 0",
        "X[0] must equal Y[0]"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "N ≤ 2; Q ≤ 10"
        },
        "2": {
          "points": 7,
          "req": "N ≤ 200; Q ≤ 200"
        },
        "3": {
          "points": 7,
          "req": "T[k] = B[k] = 0 (queries only row 0)"
        },
        "4": {
          "points": 10,
          "req": "N ≤ 5000"
        },
        "5": {
          "points": 8,
          "req": "X[i] = Y[i] = 0 for all i"
        },
        "6": {
          "points": 22,
          "req": "T[k] = B[k] and L[k] = R[k] (single tile queries)"
        },
        "7": {
          "points": 19,
          "req": "T[k] = B[k] (single row queries)"
        },
        "8": {
          "points": 22,
          "req": "No constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Mosaic",
      "contest": "IOI 2024 day 2",
      "one_line": "Answer Q queries counting black tiles in N×N grid with propagation rule",
      "given": [
        "N×N grid initially uncolored except row 0 and column 0",
        "X[0..N-1] colors row 0, Y[0..N-1] colors column 0",
        "X[0] = Y[0]",
        "Q rectangle queries T[k],B[k],L[k],R[k]"
      ],
      "goal": "For each query, count black tiles (1s) in the specified subrectangle",
      "mechanism": "Uncolored tile's color = 1 if both up and left neighbors are white (0), else white (0)",
      "success_condition": "Return array C where C[k] = number of black tiles in rectangle k",
      "constraints": {
        "critical": [
          "Grid coloring is deterministic: depends only on X and Y",
          "Coloring propagates: tile(i,j) = 1 iff tile(i-1,j) = 0 AND tile(i,j-1) = 0",
          "X[0] must equal Y[0]"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N ≤ 2; Q ≤ 10"
          },
          "2": {
            "points": 7,
            "req": "N ≤ 200; Q ≤ 200"
          },
          "3": {
            "points": 7,
            "req": "T[k] = B[k] = 0 (queries only row 0)"
          },
          "4": {
            "points": 10,
            "req": "N ≤ 5000"
          },
          "5": {
            "points": 8,
            "req": "X[i] = Y[i] = 0 for all i"
          },
          "6": {
            "points": 22,
            "req": "T[k] = B[k] and L[k] = R[k] (single tile queries)"
          },
          "7": {
            "points": 19,
            "req": "T[k] = B[k] (single row queries)"
          },
          "8": {
            "points": 22,
            "req": "No constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Mosaic",
        "contest": "IOI 2024 day 2",
        "one_line": "Answer Q queries counting black tiles in N×N grid with propagation rule"
      },
      "problem": {
        "given": [
          "N×N grid initially uncolored except row 0 and column 0",
          "X[0..N-1] colors row 0, Y[0..N-1] colors column 0",
          "X[0] = Y[0]",
          "Q rectangle queries T[k],B[k],L[k],R[k]"
        ],
        "goal": "For each query, count black tiles (1s) in the specified subrectangle",
        "mechanism": "Uncolored tile's color = 1 if both up and left neighbors are white (0), else white (0)",
        "success_condition": "Return array C where C[k] = number of black tiles in rectangle k"
      },
      "constraints": {
        "critical": [
          "Grid coloring is deterministic: depends only on X and Y",
          "Coloring propagates: tile(i,j) = 1 iff tile(i-1,j) = 0 AND tile(i,j-1) = 0",
          "X[0] must equal Y[0]"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N ≤ 2; Q ≤ 10"
          },
          "2": {
            "points": 7,
            "req": "N ≤ 200; Q ≤ 200"
          },
          "3": {
            "points": 7,
            "req": "T[k] = B[k] = 0 (queries only row 0)"
          },
          "4": {
            "points": 10,
            "req": "N ≤ 5000"
          },
          "5": {
            "points": 8,
            "req": "X[i] = Y[i] = 0 for all i"
          },
          "6": {
            "points": 22,
            "req": "T[k] = B[k] and L[k] = R[k] (single tile queries)"
          },
          "7": {
            "points": 19,
            "req": "T[k] = B[k] (single row queries)"
          },
          "8": {
            "points": 22,
            "req": "No constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "std::vector<long long> mosaic(std::vector<int> X, std::vector<int> Y, std::vector<int> T, std::vector<int> B, std::vector<int> L, std::vector<int> R)",
        "available_api": {},
        "requirements": [
          "0-indexed grid coordinates (0 ≤ i,j < N)",
          "X and Y contain only 0s and 1s",
          "Must return vector<long long> of length Q",
          "Called exactly once per test case"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "4\n1 0 1 0\n1 1 0 1\n2\n0 3 0 3\n2 3 0 2",
          "output": "7\n3"
        }
      ],
      "original_statement": "Salma plans to colour a clay mosaic on a wall. The mosaic is an $$$N \\times N$$$ grid, made of $$$N^2$$$ initially uncoloured $$$1 \\times 1$$$ square tiles. The rows of the mosaic are numbered from $$$0$$$ to $$$N-1$$$ from top to bottom, and the columns are numbered from $$$0$$$ to $$$N-1$$$ from left to right. The tile in row $$$i$$$ and column $$$j$$$ ($$$0 \\leq i < N$$$, $$$0 \\leq j < N$$$) is denoted by $$$(i, j)$$$. Each tile must be coloured either white (denoted by $$$0$$$) or black (denoted by $$$1$$$).\nTo colour the mosaic, Salma first picks two arrays $$$X$$$ and $$$Y$$$ of length $$$N$$$, each consisting of values $$$0$$$ and $$$1$$$, such that $$$X[0] = Y[0]$$$. She colours the tiles of the topmost row (row $$$0$$$) according to array $$$X$$$, such that the colour of tile $$$(0,j)$$$ is $$$X[j]$$$ ($$$0 \\leq j < N$$$). She also colours the tiles of the leftmost column (column $$$0$$$) according to array $$$Y$$$, such that the colour of tile $$$(i,0)$$$ is $$$Y[i]$$$ ($$$0 \\leq i < N$$$).\nThen she repeats the following steps until all tiles are coloured:\nShe finds any\nuncoloured\ntile $$$(i, j)$$$ such that its up neighbor (tile $$$(i-1, j)$$$) and left neighbor (tile $$$(i, j-1)$$$) are both\nalready coloured\n.\nThen, she colours tile $$$(i, j)$$$ black if both of these neighbors are white; otherwise, she colours tile $$$(i, j)$$$ white.\nIt can be shown that the final colours of the tiles do not depend on the order in which Salma is colouring them. Yasmin is very curious about the colours of the tiles in the mosaic. She asks Salma $$$Q$$$ questions, numbered from $$$0$$$ to $$$Q-1$$$. In question $$$k$$$ ($$$0 \\leq k < Q$$$), Yasmin specifies a subrectangle of the mosaic by its:\nTopmost row $$$T[k]$$$ and bottommost row $$$B[k]$$$ ($$$0 \\leq T[k] \\leq B[k] < N$$$),\nLeftmost column $$$L[k]$$$ and rightmost column $$$R[k]$$$ ($$$0 \\leq L[k] \\leq R[k] < N$$$).\nThe answer to the question is the number of black tiles in this subrectangle. Specifically, Salma should find how many tiles $$$(i, j)$$$ exist, such that $$$T[k] \\leq i \\leq B[k]$$$, $$$L[k] \\leq j \\leq R[k]$$$, and the colour of tile $$$(i, j)$$$ is black.\nWrite a program that answers Yasmin's questions.\nImplementation Details\nYou should implement the following procedure.\nstd::vector<long long> mosaic(\nstd::vector<int> X, std::vector<int> Y,\nstd::vector<int> T, std::vector<int> B,\nstd::vector<int> L, std::vector<int> R)\n$$$X$$$, $$$Y$$$: arrays of length $$$N$$$ describing the colours of the tiles in the topmost row and the leftmost column, respectively.\n$$$T$$$, $$$B$$$, $$$L$$$, $$$R$$$: arrays of length $$$Q$$$ describing the questions asked by Yasmin.\nThe procedure should return an array $$$C$$$ of length $$$Q$$$, such that $$$C[k]$$$ provides the answer to question $$$k$$$ ($$$0 \\leq k < Q$$$).\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\leq N \\leq 200\\,000$$$)\nline $$$2$$$: $$$X[0]\\; X[1]\\ldots X[N-1]$$$ ($$$X[i] \\in \\{0, 1\\}$$$)\nline $$$3$$$: $$$Y[0]\\; Y[1]\\ldots Y[N-1]$$$ ($$$Y[i] \\in \\{0, 1\\}$$$)\nline $$$4$$$: $$$Q$$$ ($$$1 \\leq Q \\leq 200\\,000$$$)\nline $$$5 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$T[0]\\; B[0]\\; L[0]\\; R[0]$$$ ($$$0 \\leq T[k] \\leq B[k] < N$$$, $$$0 \\leq L[k] \\leq R[k] < N$$$)\n$$$X[0] = Y[0]$$$\nOutput\nThe sample grader prints $$$S$$$ lines, in the following format:\nline $$$1 + i$$$ ($$$0 \\le i \\le S - 1$$$): $$$C[i]$$$\nHere, $$$S$$$ is the length of the array $$$C$$$ returned by\nmosaic\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$N \\leq 2; Q \\leq 10$$$\n2\n7\n$$$N \\leq 200; Q \\leq 200$$$\n3\n7\n$$$T[k] = B[k] = 0$$$ (for each $$$k$$$ such that $$$0 \\leq k < Q$$$)\n4\n10\n$$$N \\leq 5000$$$\n5\n8\n$$$X[i] = Y[i] = 0$$$ (for each $$$i$$$ such that $$$0 \\leq i < N$$$)\n6\n22\n$$$T[k] = B[k]$$$ and $$$L[k] = R[k]$$$ (for each $$$k$$$ such that $$$0 \\leq k < Q$$$)\n7\n19\n$$$T[k] = B[k]$$$ (for each $$$k$$$ such that $$$0 \\leq k < Q$$$)\n8\n22\nNo additional constraints.\nExample\nNote\nConsider the following call.\nmosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])\nThis example is illustrated in the pictures below. The left picture shows the colours of the tiles in the mosaic. The middle and right pictures show the subrectangles Yasmin asked about in the first and second question, respectively.\nThe answers to the questions (that is, the numbers of ones in the shaded rectangles) are $$$7$$$ and $$$3$$$, respectively. Hence, the procedure should return $$$[7, 3]$$$."
    },
    "original": "Salma plans to colour a clay mosaic on a wall. The mosaic is an $$$N \\times N$$$ grid, made of $$$N^2$$$ initially uncoloured $$$1 \\times 1$$$ square tiles. The rows of the mosaic are numbered from $$$0$$$ to $$$N-1$$$ from top to bottom, and the columns are numbered from $$$0$$$ to $$$N-1$$$ from left to right. The tile in row $$$i$$$ and column $$$j$$$ ($$$0 \\leq i < N$$$, $$$0 \\leq j < N$$$) is denoted by $$$(i, j)$$$. Each tile must be coloured either white (denoted by $$$0$$$) or black (denoted by $$$1$$$).\nTo colour the mosaic, Salma first picks two arrays $$$X$$$ and $$$Y$$$ of length $$$N$$$, each consisting of values $$$0$$$ and $$$1$$$, such that $$$X[0] = Y[0]$$$. She colours the tiles of the topmost row (row $$$0$$$) according to array $$$X$$$, such that the colour of tile $$$(0,j)$$$ is $$$X[j]$$$ ($$$0 \\leq j < N$$$). She also colours the tiles of the leftmost column (column $$$0$$$) according to array $$$Y$$$, such that the colour of tile $$$(i,0)$$$ is $$$Y[i]$$$ ($$$0 \\leq i < N$$$).\nThen she repeats the following steps until all tiles are coloured:\nShe finds any\nuncoloured\ntile $$$(i, j)$$$ such that its up neighbor (tile $$$(i-1, j)$$$) and left neighbor (tile $$$(i, j-1)$$$) are both\nalready coloured\n.\nThen, she colours tile $$$(i, j)$$$ black if both of these neighbors are white; otherwise, she colours tile $$$(i, j)$$$ white.\nIt can be shown that the final colours of the tiles do not depend on the order in which Salma is colouring them. Yasmin is very curious about the colours of the tiles in the mosaic. She asks Salma $$$Q$$$ questions, numbered from $$$0$$$ to $$$Q-1$$$. In question $$$k$$$ ($$$0 \\leq k < Q$$$), Yasmin specifies a subrectangle of the mosaic by its:\nTopmost row $$$T[k]$$$ and bottommost row $$$B[k]$$$ ($$$0 \\leq T[k] \\leq B[k] < N$$$),\nLeftmost column $$$L[k]$$$ and rightmost column $$$R[k]$$$ ($$$0 \\leq L[k] \\leq R[k] < N$$$).\nThe answer to the question is the number of black tiles in this subrectangle. Specifically, Salma should find how many tiles $$$(i, j)$$$ exist, such that $$$T[k] \\leq i \\leq B[k]$$$, $$$L[k] \\leq j \\leq R[k]$$$, and the colour of tile $$$(i, j)$$$ is black.\nWrite a program that answers Yasmin's questions.\nImplementation Details\nYou should implement the following procedure.\nstd::vector<long long> mosaic(\nstd::vector<int> X, std::vector<int> Y,\nstd::vector<int> T, std::vector<int> B,\nstd::vector<int> L, std::vector<int> R)\n$$$X$$$, $$$Y$$$: arrays of length $$$N$$$ describing the colours of the tiles in the topmost row and the leftmost column, respectively.\n$$$T$$$, $$$B$$$, $$$L$$$, $$$R$$$: arrays of length $$$Q$$$ describing the questions asked by Yasmin.\nThe procedure should return an array $$$C$$$ of length $$$Q$$$, such that $$$C[k]$$$ provides the answer to question $$$k$$$ ($$$0 \\leq k < Q$$$).\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\leq N \\leq 200\\,000$$$)\nline $$$2$$$: $$$X[0]\\; X[1]\\ldots X[N-1]$$$ ($$$X[i] \\in \\{0, 1\\}$$$)\nline $$$3$$$: $$$Y[0]\\; Y[1]\\ldots Y[N-1]$$$ ($$$Y[i] \\in \\{0, 1\\}$$$)\nline $$$4$$$: $$$Q$$$ ($$$1 \\leq Q \\leq 200\\,000$$$)\nline $$$5 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$T[0]\\; B[0]\\; L[0]\\; R[0]$$$ ($$$0 \\leq T[k] \\leq B[k] < N$$$, $$$0 \\leq L[k] \\leq R[k] < N$$$)\n$$$X[0] = Y[0]$$$\nOutput\nThe sample grader prints $$$S$$$ lines, in the following format:\nline $$$1 + i$$$ ($$$0 \\le i \\le S - 1$$$): $$$C[i]$$$\nHere, $$$S$$$ is the length of the array $$$C$$$ returned by\nmosaic\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$N \\leq 2; Q \\leq 10$$$\n2\n7\n$$$N \\leq 200; Q \\leq 200$$$\n3\n7\n$$$T[k] = B[k] = 0$$$ (for each $$$k$$$ such that $$$0 \\leq k < Q$$$)\n4\n10\n$$$N \\leq 5000$$$\n5\n8\n$$$X[i] = Y[i] = 0$$$ (for each $$$i$$$ such that $$$0 \\leq i < N$$$)\n6\n22\n$$$T[k] = B[k]$$$ and $$$L[k] = R[k]$$$ (for each $$$k$$$ such that $$$0 \\leq k < Q$$$)\n7\n19\n$$$T[k] = B[k]$$$ (for each $$$k$$$ such that $$$0 \\leq k < Q$$$)\n8\n22\nNo additional constraints.\nExample\nNote\nConsider the following call.\nmosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])\nThis example is illustrated in the pictures below. The left picture shows the colours of the tiles in the mosaic. The middle and right pictures show the subrectangles Yasmin asked about in the first and second question, respectively.\nThe answers to the questions (that is, the numbers of ones in the shaded rectangles) are $$$7$$$ and $$$3$$$, respectively. Hence, the procedure should return $$$[7, 3]$$$.",
    "_meta": {
      "index": 69,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/E",
      "uuid": "ps_d86cfb080e5803d3f9070cdb05fcf24f963b5f98"
    }
  },
  {
    "planning_view": {
      "title": "B. Seats",
      "task": "Count beautiful rectangular seat sets after Q swaps",
      "given": [
        "H×W rectangular hall with seats (r,c)",
        "Each contestant 0 to H·W-1 assigned unique seat",
        "Q swap requests between contestants"
      ],
      "goal": "Compute beauty after each swap",
      "key_rules": [
        "H·W ≤ 1,000,000",
        "Q ≤ 50,000",
        "Beautiful set must contain exactly contestants 0..k-1 for k seats"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "H·W ≤ 100, Q ≤ 5,000"
        },
        "2": {
          "points": 6,
          "req": "H·W ≤ 10,000, Q ≤ 5,000"
        },
        "3": {
          "points": 20,
          "req": "H ≤ 1,000, W ≤ 1,000, Q ≤ 5,000"
        },
        "4": {
          "points": 6,
          "req": "Q ≤ 5,000, |a-b| ≤ 10,000 for any swap"
        },
        "5": {
          "points": 33,
          "req": "H = 1"
        },
        "6": {
          "points": 30,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Seats",
      "contest": "IOI 2018 day 1",
      "one_line": "Count beautiful rectangular seat sets after Q swaps",
      "given": [
        "H×W rectangular hall with seats (r,c)",
        "Each contestant 0 to H·W-1 assigned unique seat",
        "Q swap requests between contestants"
      ],
      "goal": "Compute beauty after each swap",
      "mechanism": "Rectangular set is beautiful if contains contestants 0 to k-1 exactly",
      "success_condition": "Beauty = number of beautiful rectangular sets in current chart",
      "constraints": {
        "critical": [
          "H·W ≤ 1,000,000",
          "Q ≤ 50,000",
          "Beautiful set must contain exactly contestants 0..k-1 for k seats"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "H·W ≤ 100, Q ≤ 5,000"
          },
          "2": {
            "points": 6,
            "req": "H·W ≤ 10,000, Q ≤ 5,000"
          },
          "3": {
            "points": 20,
            "req": "H ≤ 1,000, W ≤ 1,000, Q ≤ 5,000"
          },
          "4": {
            "points": 6,
            "req": "Q ≤ 5,000, |a-b| ≤ 10,000 for any swap"
          },
          "5": {
            "points": 33,
            "req": "H = 1"
          },
          "6": {
            "points": 30,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Seats",
        "contest": "IOI 2018 day 1",
        "one_line": "Count beautiful rectangular seat sets after Q swaps"
      },
      "problem": {
        "given": [
          "H×W rectangular hall with seats (r,c)",
          "Each contestant 0 to H·W-1 assigned unique seat",
          "Q swap requests between contestants"
        ],
        "goal": "Compute beauty after each swap",
        "mechanism": "Rectangular set is beautiful if contains contestants 0 to k-1 exactly",
        "success_condition": "Beauty = number of beautiful rectangular sets in current chart"
      },
      "constraints": {
        "critical": [
          "H·W ≤ 1,000,000",
          "Q ≤ 50,000",
          "Beautiful set must contain exactly contestants 0..k-1 for k seats"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "H·W ≤ 100, Q ≤ 5,000"
          },
          "2": {
            "points": 6,
            "req": "H·W ≤ 10,000, Q ≤ 5,000"
          },
          "3": {
            "points": 20,
            "req": "H ≤ 1,000, W ≤ 1,000, Q ≤ 5,000"
          },
          "4": {
            "points": 6,
            "req": "Q ≤ 5,000, |a-b| ≤ 10,000 for any swap"
          },
          "5": {
            "points": 33,
            "req": "H = 1"
          },
          "6": {
            "points": 30,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int swap_seats(int a, int b)",
        "available_api": {
          "give_initial_chart": {
            "signature": "void give_initial_chart(int H, int W, int[] R, int[] C)",
            "params": "H,W: dimensions; R,C: arrays of length H·W with seat assignments",
            "returns": "void",
            "side_effect": "Initializes seating chart before any swaps"
          }
        },
        "requirements": [
          "swap_seats returns beauty after swapping contestants a and b",
          "R[i], C[i] give seat for contestant i",
          "Rows 0..H-1, columns 0..W-1",
          "Called exactly once before any swap_seats calls"
        ]
      },
      "limits": {
        "time": "3 seconds",
        "memory": "512 megabytes"
      },
      "samples": [
        {
          "input": "2 3 2\n0 0\n1 0\n1 1\n0 1\n0 2\n1 2\n0 5\n0 5",
          "output": "3\n4"
        }
      ],
      "original_statement": "You are going to hold an international programming contest in a rectangular hall, which has $$$ H \\cdot W $$$ seats arranged in $$$ H $$$ rows and $$$ W $$$ columns. The rows are numbered from $$$ 0 $$$ through $$$ H-1 $$$ and the columns are numbered from $$$ 0 $$$ through $$$ W-1. $$$ The seat in row $$$ r $$$ and column $$$ c $$$ is denoted by $$$ (r, c) $$$ . You invited $$$ H \\cdot W $$$ contestants, numbered from 0 through $$$ H \\cdot W - 1. $$$ You also made a seating chart, which assigns the contestant $$$i$$$ $$$( 0 \\le i \\le H \\cdot W-1 )$$$ to the seat $$$ (R_i, C_i).$$$ The chart assigns exactly one contestant to each seat.\nA set of seats in the hall $$$ S $$$ is said to be\nrectangular\nif there are integers $$$ r_1 $$$ , $$$ r_2 $$$ , $$$ c_1 $$$ , and $$$ c_2 $$$ satisfying the following conditions:\n$$$ 0 \\le r_1 \\le r_2 \\le H-1 $$$\n$$$ 0 \\le c_1 \\le c_2 \\le W-1 $$$\n$$$ S $$$ is exactly the set of all seats $$$ (r, c) $$$ such that $$$ r_1 \\le r \\le r_2 $$$ and $$$c_1 \\le c \\le c_2$$$.\nA rectangular set consisting of $$$ k $$$ seats $$$ ( 1 \\le k \\le H \\cdot W) $$$ , is\nbeautiful\nif the contestants whose assigned seats are in the set have numbers from $$$ 0 $$$ through $$$ k-1 $$$ . The\nbeauty\nof a seating chart is the number of beautiful rectangular sets of seats in the chart.\nAfter preparing your seating chart, you receive several requests to swap two seats assigned to two contestants. More precisely, there are $$$ Q $$$ such requests numbered from $$$ 0 $$$ through $$$ Q-1 $$$ in chronological order. The request $$$ j$$$ $$$(0 \\le j \\le Q-1) $$$ is to swap the seats assigned to contestants $$$ A_j $$$ and $$$ B_j $$$ . You accept each request immediately and update the chart. After each update, your goal is to compute the beauty of the current seating chart.\nImplementation details\nYou should implement the following procedure and function:\ngive_initial_chart(int H, int W, int[] R, int[] C)\n$$$ H, W $$$ : the number of rows and the number of columns.\n$$$ R, C $$$ : arrays of length $$$ H \\cdot W $$$ representing the initial seating chart.\nThis procedure is called exactly once, and before any call to\nswap_seats\n.\nint swap_seats(int a, int b)\nThis function describes a request to swap two seats.\n$$$ a, b: $$$ contestants whose seats are to be swapped.\nThis function is called $$$ Q $$$ times.\nThis function should return the beauty of the seating chart after the swap\nConstraints\n$$$ 1 \\le H $$$\n$$$ 1 \\le W $$$\n$$$ H \\cdot W \\le 1\\,000\\,000 $$$\n$$$ 0 \\le Ri \\le H-1 $$$ for all $$$ i: 0 \\le i \\le H \\cdot W-1 $$$\n$$$ 0 \\le Ci \\le W-1 $$$ for all $$$ i: 0 \\le i \\le H \\cdot W-1 $$$\n$$$ (R_i, C_i) \\neq (R_j, C_j) $$$ for all $$$ i, j: 0 \\le i < j \\le H \\cdot W-1 $$$\n$$$ 1 \\le Q \\le 50\\,000 $$$\n$$$ 0 \\le a \\le H \\cdot W -1 $$$ for any call to\nswap_seats\n$$$ 0 \\le b \\le H \\cdot W -1 $$$ for any call to\nswap_seats\n$$$ a \\neq b $$$ for any call to\nswap_seats\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$ 1 $$$\n:\n$$$ H$$$ $$$W$$$ $$$Q$$$\nline\n$$$ 2+i $$$\n:\n$$$R_i$$$ $$$C_i$$$\n$$$ (0 \\le i \\le H \\cdot W-1) $$$\nline\n$$$ 2+H \\cdot W+j $$$\n:\n$$$A_j$$$ $$$B_j$$$\n$$$ (0 \\le j \\le Q-1) $$$\nHere, $$$ A_j $$$ and $$$ B_j $$$ are parameters for the call to\nswap_seats\nfor the request $$$j.$$$\nThe sample grader prints your answers in the following format:\nline\n$$$ 1+j $$$\n:\nthe return value of\nswap_seats\nfor the request $$$ j $$$\n$$$ (0 \\le j \\le Q-1) $$$\nScoring\nSubtasks\nSubtask\nPoints\nAdditional constraints\n$$$1$$$\n$$$5$$$\n$$$ H \\cdot W \\le 100, Q \\le 5\\,000 $$$\n$$$2$$$\n$$$6$$$\n$$$ H \\cdot W \\le 10\\,000, Q \\le 5\\,000 $$$\n$$$3$$$\n$$$20$$$\n$$$ H \\le 1\\,000, W \\le 1\\,000, Q \\le 5\\,000 $$$\n$$$4$$$\n$$$6$$$\n$$$ Q \\le 5\\,000, |a-b| \\le 10\\,000 $$$ for any call to\nswap_seats\n$$$5$$$\n$$$33$$$\n$$$ H=1 $$$\n$$$6$$$\n$$$30$$$\nNo\nExamples\nNote\nExample\nLet $$$ H=2, W=3, R=[0,1,1,0,0,1], C=[0,0,1,1,2,2], $$$ and $$$ Q=2. $$$\nThe grader first calls\ngive_initial_chart(2, 3, [0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 2, 2]).\nAt first, the seating chart is as follows.\nLet's say the grader calls\nswap_seats(0, 5).\nAfter the request 0, the seating chart is as follows\nThe sets of seats corresponding to the contestants $$$ \\{0\\}, \\{0,1,2\\}, $$$ and $$$ \\{0,1,2,3,4,5\\} $$$ are rectangular and beautiful. Thus, the beauty of this seating chart is $$$ 3, $$$ and\nswap_seats\nshould return $$$ 3. $$$\nLet's say the grader calls\nswap_seats(\n0, 5) again. After the request $$$ 1 $$$ , the seating chart goes back to the initial state. The sets of seats corresponding to the contestants $$$ \\{0\\}, \\{0,1\\}, \\{0,1,2,3\\} $$$ and $$$ \\{0,1,2,3,4,5\\} $$$ are rectangular and beautiful. Hence, the beauty of this seating chart is $$$ 4 $$$ , and\nswap_seats\nshould return $$$ 4 $$$ .\nThe files\nsample-01-in.txt\nand\nsample-01-out.txt\nin the zipped attachment package correspond to this example. Other sample inputs/outputs are also available in the package."
    },
    "original": "You are going to hold an international programming contest in a rectangular hall, which has $$$ H \\cdot W $$$ seats arranged in $$$ H $$$ rows and $$$ W $$$ columns. The rows are numbered from $$$ 0 $$$ through $$$ H-1 $$$ and the columns are numbered from $$$ 0 $$$ through $$$ W-1. $$$ The seat in row $$$ r $$$ and column $$$ c $$$ is denoted by $$$ (r, c) $$$ . You invited $$$ H \\cdot W $$$ contestants, numbered from 0 through $$$ H \\cdot W - 1. $$$ You also made a seating chart, which assigns the contestant $$$i$$$ $$$( 0 \\le i \\le H \\cdot W-1 )$$$ to the seat $$$ (R_i, C_i).$$$ The chart assigns exactly one contestant to each seat.\nA set of seats in the hall $$$ S $$$ is said to be\nrectangular\nif there are integers $$$ r_1 $$$ , $$$ r_2 $$$ , $$$ c_1 $$$ , and $$$ c_2 $$$ satisfying the following conditions:\n$$$ 0 \\le r_1 \\le r_2 \\le H-1 $$$\n$$$ 0 \\le c_1 \\le c_2 \\le W-1 $$$\n$$$ S $$$ is exactly the set of all seats $$$ (r, c) $$$ such that $$$ r_1 \\le r \\le r_2 $$$ and $$$c_1 \\le c \\le c_2$$$.\nA rectangular set consisting of $$$ k $$$ seats $$$ ( 1 \\le k \\le H \\cdot W) $$$ , is\nbeautiful\nif the contestants whose assigned seats are in the set have numbers from $$$ 0 $$$ through $$$ k-1 $$$ . The\nbeauty\nof a seating chart is the number of beautiful rectangular sets of seats in the chart.\nAfter preparing your seating chart, you receive several requests to swap two seats assigned to two contestants. More precisely, there are $$$ Q $$$ such requests numbered from $$$ 0 $$$ through $$$ Q-1 $$$ in chronological order. The request $$$ j$$$ $$$(0 \\le j \\le Q-1) $$$ is to swap the seats assigned to contestants $$$ A_j $$$ and $$$ B_j $$$ . You accept each request immediately and update the chart. After each update, your goal is to compute the beauty of the current seating chart.\nImplementation details\nYou should implement the following procedure and function:\ngive_initial_chart(int H, int W, int[] R, int[] C)\n$$$ H, W $$$ : the number of rows and the number of columns.\n$$$ R, C $$$ : arrays of length $$$ H \\cdot W $$$ representing the initial seating chart.\nThis procedure is called exactly once, and before any call to\nswap_seats\n.\nint swap_seats(int a, int b)\nThis function describes a request to swap two seats.\n$$$ a, b: $$$ contestants whose seats are to be swapped.\nThis function is called $$$ Q $$$ times.\nThis function should return the beauty of the seating chart after the swap\nConstraints\n$$$ 1 \\le H $$$\n$$$ 1 \\le W $$$\n$$$ H \\cdot W \\le 1\\,000\\,000 $$$\n$$$ 0 \\le Ri \\le H-1 $$$ for all $$$ i: 0 \\le i \\le H \\cdot W-1 $$$\n$$$ 0 \\le Ci \\le W-1 $$$ for all $$$ i: 0 \\le i \\le H \\cdot W-1 $$$\n$$$ (R_i, C_i) \\neq (R_j, C_j) $$$ for all $$$ i, j: 0 \\le i < j \\le H \\cdot W-1 $$$\n$$$ 1 \\le Q \\le 50\\,000 $$$\n$$$ 0 \\le a \\le H \\cdot W -1 $$$ for any call to\nswap_seats\n$$$ 0 \\le b \\le H \\cdot W -1 $$$ for any call to\nswap_seats\n$$$ a \\neq b $$$ for any call to\nswap_seats\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$ 1 $$$\n:\n$$$ H$$$ $$$W$$$ $$$Q$$$\nline\n$$$ 2+i $$$\n:\n$$$R_i$$$ $$$C_i$$$\n$$$ (0 \\le i \\le H \\cdot W-1) $$$\nline\n$$$ 2+H \\cdot W+j $$$\n:\n$$$A_j$$$ $$$B_j$$$\n$$$ (0 \\le j \\le Q-1) $$$\nHere, $$$ A_j $$$ and $$$ B_j $$$ are parameters for the call to\nswap_seats\nfor the request $$$j.$$$\nThe sample grader prints your answers in the following format:\nline\n$$$ 1+j $$$\n:\nthe return value of\nswap_seats\nfor the request $$$ j $$$\n$$$ (0 \\le j \\le Q-1) $$$\nScoring\nSubtasks\nSubtask\nPoints\nAdditional constraints\n$$$1$$$\n$$$5$$$\n$$$ H \\cdot W \\le 100, Q \\le 5\\,000 $$$\n$$$2$$$\n$$$6$$$\n$$$ H \\cdot W \\le 10\\,000, Q \\le 5\\,000 $$$\n$$$3$$$\n$$$20$$$\n$$$ H \\le 1\\,000, W \\le 1\\,000, Q \\le 5\\,000 $$$\n$$$4$$$\n$$$6$$$\n$$$ Q \\le 5\\,000, |a-b| \\le 10\\,000 $$$ for any call to\nswap_seats\n$$$5$$$\n$$$33$$$\n$$$ H=1 $$$\n$$$6$$$\n$$$30$$$\nNo\nExamples\nNote\nExample\nLet $$$ H=2, W=3, R=[0,1,1,0,0,1], C=[0,0,1,1,2,2], $$$ and $$$ Q=2. $$$\nThe grader first calls\ngive_initial_chart(2, 3, [0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 2, 2]).\nAt first, the seating chart is as follows.\nLet's say the grader calls\nswap_seats(0, 5).\nAfter the request 0, the seating chart is as follows\nThe sets of seats corresponding to the contestants $$$ \\{0\\}, \\{0,1,2\\}, $$$ and $$$ \\{0,1,2,3,4,5\\} $$$ are rectangular and beautiful. Thus, the beauty of this seating chart is $$$ 3, $$$ and\nswap_seats\nshould return $$$ 3. $$$\nLet's say the grader calls\nswap_seats(\n0, 5) again. After the request $$$ 1 $$$ , the seating chart goes back to the initial state. The sets of seats corresponding to the contestants $$$ \\{0\\}, \\{0,1\\}, \\{0,1,2,3\\} $$$ and $$$ \\{0,1,2,3,4,5\\} $$$ are rectangular and beautiful. Hence, the beauty of this seating chart is $$$ 4 $$$ , and\nswap_seats\nshould return $$$ 4 $$$ .\nThe files\nsample-01-in.txt\nand\nsample-01-out.txt\nin the zipped attachment package correspond to this example. Other sample inputs/outputs are also available in the package.",
    "_meta": {
      "index": 70,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/B",
      "uuid": "ps_d795933e6c3a19c1579aeea7e098a622e90bb553"
    }
  },
  {
    "planning_view": {
      "title": "F. Thousands Islands",
      "task": "Find valid circular journey from island 0 in ≤2,000,000 moves",
      "given": [
        "N islands numbered 0 to N-1",
        "M canoes between islands U[i] and V[i]",
        "Each canoe starts docked at U[i]",
        "Journey must return all canoes to initial docks"
      ],
      "goal": "Find a journey starting/ending at island 0 visiting ≥1 other island",
      "key_rules": [
        "Cannot use same canoe twice consecutively",
        "All canoes must return to initial docking positions",
        "Must visit at least one island other than island 0",
        "Maximum 2,000,000 sailing moves allowed"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "N = 2"
        },
        "2": {
          "points": 5,
          "req": "N ≤ 400, exactly 2 canoes per island pair (one docked at each)"
        },
        "3": {
          "points": 21,
          "req": "N ≤ 1000, M even, paired canoes docked at opposite islands"
        },
        "4": {
          "points": 24,
          "req": "N ≤ 1000, M even, paired canoes docked at same island"
        },
        "5": {
          "points": 45,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Thousands Islands",
      "contest": "IOI 2022 day 2",
      "one_line": "Find valid circular journey from island 0 in ≤2,000,000 moves",
      "given": [
        "N islands numbered 0 to N-1",
        "M canoes between islands U[i] and V[i]",
        "Each canoe starts docked at U[i]",
        "Journey must return all canoes to initial docks"
      ],
      "goal": "Find a journey starting/ending at island 0 visiting ≥1 other island",
      "mechanism": "Sailing canoe i moves you to opposite island and docks it there; cannot use same canoe consecutively",
      "success_condition": "Return to island 0 with all canoes in original positions using ≤2,000,000 moves",
      "constraints": {
        "critical": [
          "Cannot use same canoe twice consecutively",
          "All canoes must return to initial docking positions",
          "Must visit at least one island other than island 0",
          "Maximum 2,000,000 sailing moves allowed"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N = 2"
          },
          "2": {
            "points": 5,
            "req": "N ≤ 400, exactly 2 canoes per island pair (one docked at each)"
          },
          "3": {
            "points": 21,
            "req": "N ≤ 1000, M even, paired canoes docked at opposite islands"
          },
          "4": {
            "points": 24,
            "req": "N ≤ 1000, M even, paired canoes docked at same island"
          },
          "5": {
            "points": 45,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Thousands Islands",
        "contest": "IOI 2022 day 2",
        "one_line": "Find valid circular journey from island 0 in ≤2,000,000 moves"
      },
      "problem": {
        "given": [
          "N islands numbered 0 to N-1",
          "M canoes between islands U[i] and V[i]",
          "Each canoe starts docked at U[i]",
          "Journey must return all canoes to initial docks"
        ],
        "goal": "Find a journey starting/ending at island 0 visiting ≥1 other island",
        "mechanism": "Sailing canoe i moves you to opposite island and docks it there; cannot use same canoe consecutively",
        "success_condition": "Return to island 0 with all canoes in original positions using ≤2,000,000 moves"
      },
      "constraints": {
        "critical": [
          "Cannot use same canoe twice consecutively",
          "All canoes must return to initial docking positions",
          "Must visit at least one island other than island 0",
          "Maximum 2,000,000 sailing moves allowed"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N = 2"
          },
          "2": {
            "points": 5,
            "req": "N ≤ 400, exactly 2 canoes per island pair (one docked at each)"
          },
          "3": {
            "points": 21,
            "req": "N ≤ 1000, M even, paired canoes docked at opposite islands"
          },
          "4": {
            "points": 24,
            "req": "N ≤ 1000, M even, paired canoes docked at same island"
          },
          "5": {
            "points": 45,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "union(bool, int[]) find_journey(int N, int M, int[] U, int[] V)",
        "available_api": {
          "find_journey": {
            "signature": "union(bool, int[]) find_journey(int N, int M, int[] U, int[] V)",
            "params": "N: number of islands, M: number of canoes, U/V: arrays of canoe endpoints",
            "returns": "false if no solution, true for partial credit, or int[] of canoe indices for full credit",
            "side_effect": "None - all logic must be computed"
          }
        },
        "requirements": [
          "Return type is flexible: bool or int[]",
          "Array must contain ≤2,000,000 integers if returning journey",
          "Canoe indices must be valid (0 to M-1)",
          "Islands are 0-indexed"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      },
      "samples": [],
      "original_statement": "Thousands Islands is a group of beautiful islands located in the Java Sea. It consists of $$$N$$$ islands, numbered from $$$0$$$ to $$$N - 1$$$.\nThere are $$$M$$$ canoes, numbered from $$$0$$$ to $$$M - 1$$$, that can be used to sail between islands. For each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$, canoe $$$i$$$ can be docked either at island $$$U[i]$$$ or $$$V[i]$$$, and can be used to sail between islands $$$U[i]$$$ and $$$V[i]$$$. Specifically, when the canoe is docked at island $$$U[i]$$$, it can be used to sail from island $$$U[i]$$$ to island $$$V[i]$$$, after which the canoe becomes docked at island $$$V[i]$$$. Similarly, when the canoe is docked at island $$$V[i]$$$, it can be used to sail from island $$$V[i]$$$ to island $$$U[i]$$$, after which the canoe becomes docked at island $$$U[i]$$$. Initially, the canoe is docked at island $$$U[i]$$$. It is possible that multiple canoes can be used to sail between the same pair of islands. It is also possible that multiple canoes are docked at the same island.\nFor safety reasons, a canoe needs to be maintained after every time it is sailed, which forbids the same canoe to be sailed two times in a row. That is, after using some canoe $$$i$$$, another canoe must be used before canoe $$$i$$$ can be used again.\nBu Dengklek wants to plan a journey through some of the islands. Her journey is\nvalid\nif and only if the following conditions are satisfied.\nShe starts and ends her journey at island $$$0$$$.\nShe visits at least one island other than island $$$0$$$.\nAfter the journey ends, each canoe is docked at the same island as it was before the journey. I.e., canoe $$$i$$$, for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$, must be docked at island $$$U[i]$$$.\nHelp Bu Dengklek find any valid journey involving sailing at most $$$2\\;000\\;000$$$ times, or determine that no such valid journey exists. It can be proven that under the constraints specified in this task (see Constraints section), if a valid journey exists, there also exists a valid journey that does not involve sailing more than $$$2\\;000\\;000$$$ times.\nImplementation Details\nYou should implement the following procedure:\nunion(bool, int[]) find_journey(int N, int M, int[] U, int[] V)\n$$$N$$$: the number of islands.\n$$$M$$$: the number of canoes.\n$$$U$$$, $$$V$$$: arrays of length $$$M$$$ describing the canoes.\nThis procedure should return either a boolean or an array of integers.\nIf no valid journey exists, the procedure should return\nfalse\n.\nIf a valid journey exists, you have two options:\nTo be awarded the full score, the procedure should return an array of at most $$$2\\;000\\;000$$$ integers representing a valid journey. More precisely, the elements of this array should be the numbers of the canoes that are used in the journey (in the order they are used).\nTo be awarded a partial score, the procedure should return\ntrue\n, an array of more than $$$2\\;000\\;000$$$ integers, or an array of integers not describing a valid journey. (See the Subtasks section for more details.)\nThis procedure is called exactly once.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$2 \\le N \\le 100\\;000$$$, $$$1 \\le M \\le 200\\;000$$$)\nline $$$2 + i$$$ ($$$0 \\le i \\le M - 1$$$): $$$U[i] \\; V[i]$$$ ($$$0 \\le U[i] \\le N - 1$$$ and $$$0 \\le V[i] \\le N - 1$$$, $$$U[i] \\neq V[i]$$$)\nOutput\nThe sample grader prints your answers in the following format:\nIf\nfind_journey\nreturns a\nbool\n:\nline $$$1$$$: $$$0$$$\nline $$$2$$$: $$$0$$$ if\nfind_journey\nreturns\nfalse\n, or $$$1$$$ otherwise.\nIf\nfind_journey\nreturns an\nint[]\n, denote the elements of this array by $$$c[0], c[1], \\ldots c[k-1]$$$. The sample grader prints:\nline $$$1$$$: $$$1$$$\nline $$$2$$$: $$$k$$$\nline $$$3$$$: $$$c[0] \\; c[1] \\; \\ldots \\; c[k-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$N = 2$$$\n2\n5\n$$$N \\le 400$$$. For each pair of distinct islands $$$x$$$ and $$$y$$$ ($$$0 \\le x \\textless y \\le N - 1$$$), there are exactly two canoes that can be used to sail between them. One of them is docked at island $$$x$$$, and the other one is docked at island $$$y$$$.\n3\n21\n$$$N \\le 1000$$$, $$$M$$$ is even, and for each\neven\n$$$i$$$ such that $$$0 \\le i \\le M - 1$$$, canoes $$$i$$$ and $$$i + 1$$$ can both be used to sail between islands $$$U[i]$$$ and $$$V[i]$$$. Canoe $$$i$$$ is initially docked at island $$$U[i]$$$ and canoe $$$i + 1$$$ is initially docked at island $$$V[i]$$$. Formally, $$$U[i] = V[i + 1]$$$ and $$$V[i] = U[i + 1]$$$.\n4\n24\n$$$N \\le 1000$$$, $$$M$$$ is even, and for each\neven\n$$$i$$$ such that $$$0 \\le i \\le M - 1$$$, canoes $$$i$$$ and $$$i + 1$$$ can both be used to sail between islands $$$U[i]$$$ and $$$V[i]$$$. Both canoes are initially docked at island $$$U[i]$$$. Formally, $$$U[i] = U[i + 1]$$$ and $$$V[i] = V[i + 1]$$$.\n5\n45\nNo additional constraints\nFor each test case in which a valid journey exists, your solution:\ngets full points if it returns a valid journey,\ngets $$$35\\%$$$ of the points if it returns\ntrue\n, an array of more than $$$2\\;000\\;000$$$ integers, or an array that does not describe a valid journey,\ngets $$$0$$$ points otherwise.\nFor each test case in which a valid journey does not exist, your solution:\ngets full points if it returns\nfalse\n,\ngets $$$0$$$ points otherwise.\nNote that the final score for each subtask is the minimum of the points for the test cases in the subtask.\nNote\nExample 1\nConsider the following call:\nfind_journey(4, 5, [0, 1, 2, 0, 3], [1, 2, 3, 3, 1])\nThe islands and canoes are shown in the picture below.\nOne possible valid journey is as follows. Bu Dengklek first sails canoes $$$0$$$, $$$1$$$, $$$2$$$, and $$$4$$$ in that order. As a result, she is at island $$$1$$$. After that, Bu Dengklek can sail canoe $$$0$$$ again as it is currently docked at island $$$1$$$ and the last canoe she used is not canoe $$$0$$$. After sailing canoe $$$0$$$ again, Bu Dengklek is now at island $$$0$$$. However, canoes $$$1$$$, $$$2$$$ and $$$4$$$ are not docked at the same islands as they were before the journey. Bu Dengklek then continues her journey by sailing canoes $$$3$$$, $$$2$$$, $$$1$$$, $$$4$$$, and $$$3$$$ again. Bu Dengklek is back at island $$$0$$$ and all the canoes are docked at the same islands as before the journey.\nTherefore, the returned value $$$[0, 1, 2, 4, 0, 3, 2, 1, 4, 3]$$$ represents a valid journey.\nExample 2\nConsider the following call:\nfind_journey(2, 3, [0, 1, 1], [1, 0, 0])\nThe islands and canoes are shown in the picture below.\nBu Dengklek can only start by sailing canoe $$$0$$$, after which she can sail either canoe $$$1$$$ or $$$2$$$. Note that she cannot sail canoe $$$0$$$ twice in a row. In both cases, Bu Dengklek is back at island $$$0$$$. However, the canoes are not docked at the same islands as they were before the journey, and Bu Dengklek cannot sail any canoe afterwards, as the only canoe docked at island $$$0$$$ is the one she has just used. As there is no valid journey, the procedure should return\nfalse\n."
    },
    "original": "Thousands Islands is a group of beautiful islands located in the Java Sea. It consists of $$$N$$$ islands, numbered from $$$0$$$ to $$$N - 1$$$.\nThere are $$$M$$$ canoes, numbered from $$$0$$$ to $$$M - 1$$$, that can be used to sail between islands. For each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$, canoe $$$i$$$ can be docked either at island $$$U[i]$$$ or $$$V[i]$$$, and can be used to sail between islands $$$U[i]$$$ and $$$V[i]$$$. Specifically, when the canoe is docked at island $$$U[i]$$$, it can be used to sail from island $$$U[i]$$$ to island $$$V[i]$$$, after which the canoe becomes docked at island $$$V[i]$$$. Similarly, when the canoe is docked at island $$$V[i]$$$, it can be used to sail from island $$$V[i]$$$ to island $$$U[i]$$$, after which the canoe becomes docked at island $$$U[i]$$$. Initially, the canoe is docked at island $$$U[i]$$$. It is possible that multiple canoes can be used to sail between the same pair of islands. It is also possible that multiple canoes are docked at the same island.\nFor safety reasons, a canoe needs to be maintained after every time it is sailed, which forbids the same canoe to be sailed two times in a row. That is, after using some canoe $$$i$$$, another canoe must be used before canoe $$$i$$$ can be used again.\nBu Dengklek wants to plan a journey through some of the islands. Her journey is\nvalid\nif and only if the following conditions are satisfied.\nShe starts and ends her journey at island $$$0$$$.\nShe visits at least one island other than island $$$0$$$.\nAfter the journey ends, each canoe is docked at the same island as it was before the journey. I.e., canoe $$$i$$$, for each $$$i$$$ such that $$$0 \\le i \\le M - 1$$$, must be docked at island $$$U[i]$$$.\nHelp Bu Dengklek find any valid journey involving sailing at most $$$2\\;000\\;000$$$ times, or determine that no such valid journey exists. It can be proven that under the constraints specified in this task (see Constraints section), if a valid journey exists, there also exists a valid journey that does not involve sailing more than $$$2\\;000\\;000$$$ times.\nImplementation Details\nYou should implement the following procedure:\nunion(bool, int[]) find_journey(int N, int M, int[] U, int[] V)\n$$$N$$$: the number of islands.\n$$$M$$$: the number of canoes.\n$$$U$$$, $$$V$$$: arrays of length $$$M$$$ describing the canoes.\nThis procedure should return either a boolean or an array of integers.\nIf no valid journey exists, the procedure should return\nfalse\n.\nIf a valid journey exists, you have two options:\nTo be awarded the full score, the procedure should return an array of at most $$$2\\;000\\;000$$$ integers representing a valid journey. More precisely, the elements of this array should be the numbers of the canoes that are used in the journey (in the order they are used).\nTo be awarded a partial score, the procedure should return\ntrue\n, an array of more than $$$2\\;000\\;000$$$ integers, or an array of integers not describing a valid journey. (See the Subtasks section for more details.)\nThis procedure is called exactly once.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$2 \\le N \\le 100\\;000$$$, $$$1 \\le M \\le 200\\;000$$$)\nline $$$2 + i$$$ ($$$0 \\le i \\le M - 1$$$): $$$U[i] \\; V[i]$$$ ($$$0 \\le U[i] \\le N - 1$$$ and $$$0 \\le V[i] \\le N - 1$$$, $$$U[i] \\neq V[i]$$$)\nOutput\nThe sample grader prints your answers in the following format:\nIf\nfind_journey\nreturns a\nbool\n:\nline $$$1$$$: $$$0$$$\nline $$$2$$$: $$$0$$$ if\nfind_journey\nreturns\nfalse\n, or $$$1$$$ otherwise.\nIf\nfind_journey\nreturns an\nint[]\n, denote the elements of this array by $$$c[0], c[1], \\ldots c[k-1]$$$. The sample grader prints:\nline $$$1$$$: $$$1$$$\nline $$$2$$$: $$$k$$$\nline $$$3$$$: $$$c[0] \\; c[1] \\; \\ldots \\; c[k-1]$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$N = 2$$$\n2\n5\n$$$N \\le 400$$$. For each pair of distinct islands $$$x$$$ and $$$y$$$ ($$$0 \\le x \\textless y \\le N - 1$$$), there are exactly two canoes that can be used to sail between them. One of them is docked at island $$$x$$$, and the other one is docked at island $$$y$$$.\n3\n21\n$$$N \\le 1000$$$, $$$M$$$ is even, and for each\neven\n$$$i$$$ such that $$$0 \\le i \\le M - 1$$$, canoes $$$i$$$ and $$$i + 1$$$ can both be used to sail between islands $$$U[i]$$$ and $$$V[i]$$$. Canoe $$$i$$$ is initially docked at island $$$U[i]$$$ and canoe $$$i + 1$$$ is initially docked at island $$$V[i]$$$. Formally, $$$U[i] = V[i + 1]$$$ and $$$V[i] = U[i + 1]$$$.\n4\n24\n$$$N \\le 1000$$$, $$$M$$$ is even, and for each\neven\n$$$i$$$ such that $$$0 \\le i \\le M - 1$$$, canoes $$$i$$$ and $$$i + 1$$$ can both be used to sail between islands $$$U[i]$$$ and $$$V[i]$$$. Both canoes are initially docked at island $$$U[i]$$$. Formally, $$$U[i] = U[i + 1]$$$ and $$$V[i] = V[i + 1]$$$.\n5\n45\nNo additional constraints\nFor each test case in which a valid journey exists, your solution:\ngets full points if it returns a valid journey,\ngets $$$35\\%$$$ of the points if it returns\ntrue\n, an array of more than $$$2\\;000\\;000$$$ integers, or an array that does not describe a valid journey,\ngets $$$0$$$ points otherwise.\nFor each test case in which a valid journey does not exist, your solution:\ngets full points if it returns\nfalse\n,\ngets $$$0$$$ points otherwise.\nNote that the final score for each subtask is the minimum of the points for the test cases in the subtask.\nNote\nExample 1\nConsider the following call:\nfind_journey(4, 5, [0, 1, 2, 0, 3], [1, 2, 3, 3, 1])\nThe islands and canoes are shown in the picture below.\nOne possible valid journey is as follows. Bu Dengklek first sails canoes $$$0$$$, $$$1$$$, $$$2$$$, and $$$4$$$ in that order. As a result, she is at island $$$1$$$. After that, Bu Dengklek can sail canoe $$$0$$$ again as it is currently docked at island $$$1$$$ and the last canoe she used is not canoe $$$0$$$. After sailing canoe $$$0$$$ again, Bu Dengklek is now at island $$$0$$$. However, canoes $$$1$$$, $$$2$$$ and $$$4$$$ are not docked at the same islands as they were before the journey. Bu Dengklek then continues her journey by sailing canoes $$$3$$$, $$$2$$$, $$$1$$$, $$$4$$$, and $$$3$$$ again. Bu Dengklek is back at island $$$0$$$ and all the canoes are docked at the same islands as before the journey.\nTherefore, the returned value $$$[0, 1, 2, 4, 0, 3, 2, 1, 4, 3]$$$ represents a valid journey.\nExample 2\nConsider the following call:\nfind_journey(2, 3, [0, 1, 1], [1, 0, 0])\nThe islands and canoes are shown in the picture below.\nBu Dengklek can only start by sailing canoe $$$0$$$, after which she can sail either canoe $$$1$$$ or $$$2$$$. Note that she cannot sail canoe $$$0$$$ twice in a row. In both cases, Bu Dengklek is back at island $$$0$$$. However, the canoes are not docked at the same islands as they were before the journey, and Bu Dengklek cannot sail any canoe afterwards, as the only canoe docked at island $$$0$$$ is the one she has just used. As there is no valid journey, the procedure should return\nfalse\n.",
    "_meta": {
      "index": 71,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/F",
      "uuid": "ps_4155d0b5134829989ef4cf8f91bf24335ab92966"
    }
  },
  {
    "planning_view": {
      "title": "B. Keys",
      "task": "For each room i, find p[i] rooms reachable; return 1 if p[i] is minimal among all rooms",
      "given": [
        "n rooms (0 to n-1), each has one key type r[i]",
        "m bidirectional connectors between rooms u[j], v[j]",
        "Connector j requires key type c[j] to traverse"
      ],
      "goal": "Find rooms i where p[i] is minimal among all starting rooms",
      "key_rules": [
        "Can only traverse connector if you have collected the required key type",
        "Keys remain collected permanently",
        "Can collect key in current room if not already collected"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "c[j]=0 for all j, n,m ≤ 200"
        },
        "2": {
          "points": 11,
          "req": "n,m ≤ 200"
        },
        "3": {
          "points": 17,
          "req": "n,m ≤ 2000"
        },
        "4": {
          "points": 30,
          "req": "c[j] ≤ 29 and r[i] ≤ 29 for all i,j"
        },
        "5": {
          "points": 33,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Keys",
      "contest": "IOI 2021 day 1",
      "one_line": "For each room i, find p[i] rooms reachable; return 1 if p[i] is minimal among all rooms",
      "given": [
        "n rooms (0 to n-1), each has one key type r[i]",
        "m bidirectional connectors between rooms u[j], v[j]",
        "Connector j requires key type c[j] to traverse"
      ],
      "goal": "Find rooms i where p[i] is minimal among all starting rooms",
      "mechanism": "Starting in room i with no keys, collect keys and traverse connectors to reach rooms",
      "success_condition": "Room j is reachable if you can reach it via connectors using collected keys",
      "constraints": {
        "critical": [
          "Can only traverse connector if you have collected the required key type",
          "Keys remain collected permanently",
          "Can collect key in current room if not already collected"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "c[j]=0 for all j, n,m ≤ 200"
          },
          "2": {
            "points": 11,
            "req": "n,m ≤ 200"
          },
          "3": {
            "points": 17,
            "req": "n,m ≤ 2000"
          },
          "4": {
            "points": 30,
            "req": "c[j] ≤ 29 and r[i] ≤ 29 for all i,j"
          },
          "5": {
            "points": 33,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Keys",
        "contest": "IOI 2021 day 1",
        "one_line": "For each room i, find p[i] rooms reachable; return 1 if p[i] is minimal among all rooms"
      },
      "problem": {
        "given": [
          "n rooms (0 to n-1), each has one key type r[i]",
          "m bidirectional connectors between rooms u[j], v[j]",
          "Connector j requires key type c[j] to traverse"
        ],
        "goal": "Find rooms i where p[i] is minimal among all starting rooms",
        "mechanism": "Starting in room i with no keys, collect keys and traverse connectors to reach rooms",
        "success_condition": "Room j is reachable if you can reach it via connectors using collected keys"
      },
      "constraints": {
        "critical": [
          "Can only traverse connector if you have collected the required key type",
          "Keys remain collected permanently",
          "Can collect key in current room if not already collected"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "c[j]=0 for all j, n,m ≤ 200"
          },
          "2": {
            "points": 11,
            "req": "n,m ≤ 200"
          },
          "3": {
            "points": 17,
            "req": "n,m ≤ 2000"
          },
          "4": {
            "points": 30,
            "req": "c[j] ≤ 29 and r[i] ≤ 29 for all i,j"
          },
          "5": {
            "points": 33,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] find_reachable(int[] r, int[] u, int[] v, int[] c)",
        "available_api": {},
        "requirements": [
          "Return array a of length n where a[i]=1 if p[i] is minimal, else 0",
          "0-indexed rooms and connectors",
          "n ≤ 300,000, m ≤ 300,000",
          "Key types between 0 and n-1 inclusive"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "4 5\n0 1 1 2\n0 1 0\n0 2 0\n1 2 1\n1 3 0\n3 1 2",
          "output": "0 1 1 0"
        }
      ],
      "original_statement": "Timothy the architect has designed a new escape game. In this game, there are $$$n$$$ rooms numbered from $$$0$$$ to $$$n-1$$$. Initially, each room contains exactly one key. Each key has a type, which is an integer between $$$0$$$ and $$$n-1$$$, inclusive. The type of the key in room $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) is $$$r[i]$$$. Note that multiple rooms may contain keys of the same type, i.e., the values $$$r[i]$$$ are not necessarily distinct.\\nThere are also $$$m$$$\\nbidirectional\\nconnectors in the game, numbered from $$$0$$$ to $$$m-1$$$. Connector $$$j$$$ ($$$0 \\leq j \\leq m-1$$$) connects a pair of different rooms $$$u[j]$$$ and $$$v[j]$$$. A pair of rooms can be connected by multiple connectors.\\nThe game is played by a single player who collects the keys and moves between the rooms by traversing the connectors. We say that the player\\ntraverses\\nconnector $$$j$$$ when they use this connector to move from room $$$u[j]$$$ to room $$$v[j]$$$, or vice versa. The player can only traverse connector $$$j$$$ if they have collected a key of type $$$c[j]$$$ before.\\nAt any point during the game, the player is in some room $$$x$$$ and can perform two types of actions:\\ncollect the key in room $$$x$$$, whose type is $$$r[x]$$$ (unless they have collected it already),\\ntraverse a connector $$$j$$$, where either $$$u[j]=x$$$ or $$$v[j]=x$$$, if the player has collected a key of type $$$c[j]$$$ beforehand. Note that the player\\nnever\\ndiscards a key they have collected.\\nThe player\\nstarts\\nthe game in some room $$$s$$$ not carrying any keys. A room $$$t$$$ is\\nreachable\\nfrom a room $$$s$$$, if the player who starts the game in room $$$s$$$ can perform some sequence of actions described above, and reach room $$$t$$$.\\nFor each room $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), denote the number of rooms reachable from room $$$i$$$ as $$$p[i]$$$. Timothy would like to know the set of indices $$$i$$$ that attain the minimum value of $$$p[i]$$$ across $$$0 \\leq i \\leq n-1$$$.\\nImplementation Details\\nYou are to implement the following procedure:\\nint[] find_reachable(int[] r, int[] u, int[] v, int[] c)\\n$$$r$$$: an array of length $$$n$$$. For each $$$i$$$ ($$$0\\\\\\\\leq i\\\\\\\\leq n-1$$$), the key in room $$$i$$$ is of type $$$r[i]$$$.\\n$$$u,v$$$: two arrays of length $$$m$$$. For each $$$j$$$ ($$$0\\\\\\\\leq j\\\\\\\\leq m-1$$$), connector $$$j$$$ connects rooms $$$u[j]$$$ and $$$v[j]$$$.\\n$$$c$$$: an array of length $$$m$$$. For each $$$j$$$ ($$$0\\\\\\\\leq j\\\\\\\\leq m-1$$$) ), the type of key needed to traverse connector $$$j$$$ is $$$c[j]$$$.\\nThis procedure should return an array $$$a$$$ of length $$$n$$$. For each $$$0 \\leq i \\leq n-1$$$, the value of $$$a[i]$$$ should be $$$1$$$ if for every $$$j$$$ such that $$$0 \\leq j \\leq n-1$$$, $$$p[i] \\leq p[j]$$$. Otherwise, the value of $$$a[i]$$$ should be $$$0$$$.\\nInput\\nThe sample grader reads the input in the following format:\\nline $$$1$$$: $$$n\\\\\\ m$$$ ($$$2 \\leq n \\leq 300\\\\,000$$$, $$$1 \\leq m \\leq 300\\\\,000$$$)\\nline $$$2$$$: $$$r[0]\\\\\\ r[1]\\\\ldots \\\\\\ r[n-1]$$$ ($$$0 \\leq r[i] \\leq n-1$$$)\\nline $$$3+j$$$ ($$$0 \\leq j \\leq m - 1$$$): $$$u[j]\\\\\\ v[j]\\\\\\ c[j]$$$ ($$$0 \\leq u[j], v[j] \\leq n-1$$$ and $$$u[j] \\\\neq v[j]$$$, $$$0 \\leq c[j] \\leq n-1$$$)\\nOutput\\nThe sample grader prints the return value of\\nfind_reachable\\nin the following format:\\nline $$$1$$$: $$$a[0]\\\\\\ a[1]\\\\ldots \\\\\\ a[n-1]$$$\\nScoring\\nSubtask\\nPoints\\nAdditional Input Constraints\\n1\\n9\\n$$$c[j]=0$$$ for all $$$0 \\leq j \\leq m-1$$$ and $$$n,m \\leq 200$$$\\n2\\n11\\n$$$n, m \\leq 200$$$\\n3\\n17\\n$$$n, m \\leq 2000$$$\\n4\\n30\\n$$$c[j] \\leq 29$$$ (for all $$$0 \\leq j \\leq m-1$$$) and $$$r[i] \\leq 29$$$ (for all $$$0 \\leq i \\leq n-1$$$)\\n5\\n33\\nNo additional constraints.\\nExamples\\nNote\\nExample 1\\nConsider the following call:\\nfind_reachable([0, 1, 1, 2],\\n[0, 0, 1, 1, 3],\\n[1, 2, 2, 3, 1],\\n[0, 0, 1, 0, 2])\\nIf the player starts the game in room $$$0$$$, they can perform the following sequence of actions:\\nCurrent room\\nAction\\n$$$0$$$\\nCollect key of type $$$0$$$\\n$$$0$$$\\nTraverse connector $$$0$$$ to room $$$1$$$\\n$$$1$$$\\nCollect key of type $$$1$$$\\n$$$1$$$\\nTraverse connector $$$2$$$ to room $$$2$$$\\n$$$2$$$\\nTraverse connector $$$2$$$ to room $$$1$$$\\n$$$1$$$\\nTraverse connector $$$3$$$ to room $$$3$$$\\nHence room $$$3$$$ is reachable from room $$$0$$$. Similarly, we can construct sequences showing that all rooms are reachable from room $$$0$$$, which implies $$$p[0]=4$$$. The table below shows the reachable rooms for all starting rooms:\\nStarting room $$$i$$$\\nReachable rooms\\n$$$p[i]$$$\\n$$$0$$$\\n$$$[0,1,2,3]$$$\\n$$$4$$$\\n$$$1$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$2$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$3$$$\\n$$$[1,2,3]$$$\\n$$$3$$$\\nThe smallest value of $$$p[i]$$$ across all rooms is $$$2$$$, and this is attained for $$$i=1$$$ or $$$i=2$$$. Therefore, this procedure should return $$$[0,1,1,0]$$$.\\nExample 2\\nfind_reachable([0, 1, 1, 2, 2, 1, 2],\\n[0, 0, 1, 1, 2, 3, 3, 4, 4, 5],\\n[1, 2, 2, 3, 3, 4, 5, 5, 6, 6],\\n[0, 0, 1, 0, 0, 1, 2, 0, 2, 1])\\nThe table below shows the reachable rooms:\\nStarting room $$$i$$$\\nReachable rooms\\n$$$p[i]$$$\\n$$$0$$$\\n$$$[0,1,2,3,4,5,6]$$$\\n$$$7$$$\\n$$$1$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$2$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$3$$$\\n$$$[3,4,5,6]$$$\\n$$$4$$$\\n$$$4$$$\\n$$$[4,6]$$$\\n$$$2$$$\\n$$$5$$$\\n$$$[3,4,5,6]$$$\\n$$$4$$$\\n$$$6$$$\\n$$$[4,6]$$$\\n$$$2$$$\\nThe smallest value of $$$p[i]$$$ across all rooms is $$$2$$$, and this is attained for $$$i \\\\\\in \\\\\\{1,2,4,6\\\\\\}$$$. Therefore, this procedure should return $$$[0,1,1,0,1,0,1]$$$.\\nExample 3\\nfind_reachable([0, 0, 0], [0], [1], [0])\\nThe table below shows the reachable rooms:\\nStarting room $$$i$$$\\nReachable rooms\\n$$$p[i]$$$\\n$$$0$$$\\n$$$[0,1]$$$\\n$$$2$$$\\n$$$1$$$\\n$$$[0,1]$$$\\n$$$2$$$\\n$$$2$$$\\n$$$[2]$$$\\n$$$1$$$\\nThe smallest value of $$$p[i]$$$ across all rooms is $$$1$$$, and this is attained when $$$i=2$$$. Therefore, this procedure should return $$$[0,0,1]$$$."
    },
    "original": "Timothy the architect has designed a new escape game. In this game, there are $$$n$$$ rooms numbered from $$$0$$$ to $$$n-1$$$. Initially, each room contains exactly one key. Each key has a type, which is an integer between $$$0$$$ and $$$n-1$$$, inclusive. The type of the key in room $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) is $$$r[i]$$$. Note that multiple rooms may contain keys of the same type, i.e., the values $$$r[i]$$$ are not necessarily distinct.\\nThere are also $$$m$$$\\nbidirectional\\nconnectors in the game, numbered from $$$0$$$ to $$$m-1$$$. Connector $$$j$$$ ($$$0 \\leq j \\leq m-1$$$) connects a pair of different rooms $$$u[j]$$$ and $$$v[j]$$$. A pair of rooms can be connected by multiple connectors.\\nThe game is played by a single player who collects the keys and moves between the rooms by traversing the connectors. We say that the player\\ntraverses\\nconnector $$$j$$$ when they use this connector to move from room $$$u[j]$$$ to room $$$v[j]$$$, or vice versa. The player can only traverse connector $$$j$$$ if they have collected a key of type $$$c[j]$$$ before.\\nAt any point during the game, the player is in some room $$$x$$$ and can perform two types of actions:\\ncollect the key in room $$$x$$$, whose type is $$$r[x]$$$ (unless they have collected it already),\\ntraverse a connector $$$j$$$, where either $$$u[j]=x$$$ or $$$v[j]=x$$$, if the player has collected a key of type $$$c[j]$$$ beforehand. Note that the player\\nnever\\ndiscards a key they have collected.\\nThe player\\nstarts\\nthe game in some room $$$s$$$ not carrying any keys. A room $$$t$$$ is\\nreachable\\nfrom a room $$$s$$$, if the player who starts the game in room $$$s$$$ can perform some sequence of actions described above, and reach room $$$t$$$.\\nFor each room $$$i$$$ ($$$0 \\leq i \\leq n-1$$$), denote the number of rooms reachable from room $$$i$$$ as $$$p[i]$$$. Timothy would like to know the set of indices $$$i$$$ that attain the minimum value of $$$p[i]$$$ across $$$0 \\leq i \\leq n-1$$$.\\nImplementation Details\\nYou are to implement the following procedure:\\nint[] find_reachable(int[] r, int[] u, int[] v, int[] c)\\n$$$r$$$: an array of length $$$n$$$. For each $$$i$$$ ($$$0\\\\\\\\leq i\\\\\\\\leq n-1$$$), the key in room $$$i$$$ is of type $$$r[i]$$$.\\n$$$u,v$$$: two arrays of length $$$m$$$. For each $$$j$$$ ($$$0\\\\\\\\leq j\\\\\\\\leq m-1$$$), connector $$$j$$$ connects rooms $$$u[j]$$$ and $$$v[j]$$$.\\n$$$c$$$: an array of length $$$m$$$. For each $$$j$$$ ($$$0\\\\\\\\leq j\\\\\\\\leq m-1$$$) ), the type of key needed to traverse connector $$$j$$$ is $$$c[j]$$$.\\nThis procedure should return an array $$$a$$$ of length $$$n$$$. For each $$$0 \\leq i \\leq n-1$$$, the value of $$$a[i]$$$ should be $$$1$$$ if for every $$$j$$$ such that $$$0 \\leq j \\leq n-1$$$, $$$p[i] \\leq p[j]$$$. Otherwise, the value of $$$a[i]$$$ should be $$$0$$$.\\nInput\\nThe sample grader reads the input in the following format:\\nline $$$1$$$: $$$n\\\\\\ m$$$ ($$$2 \\leq n \\leq 300\\\\,000$$$, $$$1 \\leq m \\leq 300\\\\,000$$$)\\nline $$$2$$$: $$$r[0]\\\\\\ r[1]\\\\ldots \\\\\\ r[n-1]$$$ ($$$0 \\leq r[i] \\leq n-1$$$)\\nline $$$3+j$$$ ($$$0 \\leq j \\leq m - 1$$$): $$$u[j]\\\\\\ v[j]\\\\\\ c[j]$$$ ($$$0 \\leq u[j], v[j] \\leq n-1$$$ and $$$u[j] \\\\neq v[j]$$$, $$$0 \\leq c[j] \\leq n-1$$$)\\nOutput\\nThe sample grader prints the return value of\\nfind_reachable\\nin the following format:\\nline $$$1$$$: $$$a[0]\\\\\\ a[1]\\\\ldots \\\\\\ a[n-1]$$$\\nScoring\\nSubtask\\nPoints\\nAdditional Input Constraints\\n1\\n9\\n$$$c[j]=0$$$ for all $$$0 \\leq j \\leq m-1$$$ and $$$n,m \\leq 200$$$\\n2\\n11\\n$$$n, m \\leq 200$$$\\n3\\n17\\n$$$n, m \\leq 2000$$$\\n4\\n30\\n$$$c[j] \\leq 29$$$ (for all $$$0 \\leq j \\leq m-1$$$) and $$$r[i] \\leq 29$$$ (for all $$$0 \\leq i \\leq n-1$$$)\\n5\\n33\\nNo additional constraints.\\nExamples\\nNote\\nExample 1\\nConsider the following call:\\nfind_reachable([0, 1, 1, 2],\\n[0, 0, 1, 1, 3],\\n[1, 2, 2, 3, 1],\\n[0, 0, 1, 0, 2])\\nIf the player starts the game in room $$$0$$$, they can perform the following sequence of actions:\\nCurrent room\\nAction\\n$$$0$$$\\nCollect key of type $$$0$$$\\n$$$0$$$\\nTraverse connector $$$0$$$ to room $$$1$$$\\n$$$1$$$\\nCollect key of type $$$1$$$\\n$$$1$$$\\nTraverse connector $$$2$$$ to room $$$2$$$\\n$$$2$$$\\nTraverse connector $$$2$$$ to room $$$1$$$\\n$$$1$$$\\nTraverse connector $$$3$$$ to room $$$3$$$\\nHence room $$$3$$$ is reachable from room $$$0$$$. Similarly, we can construct sequences showing that all rooms are reachable from room $$$0$$$, which implies $$$p[0]=4$$$. The table below shows the reachable rooms for all starting rooms:\\nStarting room $$$i$$$\\nReachable rooms\\n$$$p[i]$$$\\n$$$0$$$\\n$$$[0,1,2,3]$$$\\n$$$4$$$\\n$$$1$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$2$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$3$$$\\n$$$[1,2,3]$$$\\n$$$3$$$\\nThe smallest value of $$$p[i]$$$ across all rooms is $$$2$$$, and this is attained for $$$i=1$$$ or $$$i=2$$$. Therefore, this procedure should return $$$[0,1,1,0]$$$.\\nExample 2\\nfind_reachable([0, 1, 1, 2, 2, 1, 2],\\n[0, 0, 1, 1, 2, 3, 3, 4, 4, 5],\\n[1, 2, 2, 3, 3, 4, 5, 5, 6, 6],\\n[0, 0, 1, 0, 0, 1, 2, 0, 2, 1])\\nThe table below shows the reachable rooms:\\nStarting room $$$i$$$\\nReachable rooms\\n$$$p[i]$$$\\n$$$0$$$\\n$$$[0,1,2,3,4,5,6]$$$\\n$$$7$$$\\n$$$1$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$2$$$\\n$$$[1,2]$$$\\n$$$2$$$\\n$$$3$$$\\n$$$[3,4,5,6]$$$\\n$$$4$$$\\n$$$4$$$\\n$$$[4,6]$$$\\n$$$2$$$\\n$$$5$$$\\n$$$[3,4,5,6]$$$\\n$$$4$$$\\n$$$6$$$\\n$$$[4,6]$$$\\n$$$2$$$\\nThe smallest value of $$$p[i]$$$ across all rooms is $$$2$$$, and this is attained for $$$i \\\\\\in \\\\\\{1,2,4,6\\\\\\}$$$. Therefore, this procedure should return $$$[0,1,1,0,1,0,1]$$$.\\nExample 3\\nfind_reachable([0, 0, 0], [0], [1], [0])\\nThe table below shows the reachable rooms:\\nStarting room $$$i$$$\\nReachable rooms\\n$$$p[i]$$$\\n$$$0$$$\\n$$$[0,1]$$$\\n$$$2$$$\\n$$$1$$$\\n$$$[0,1]$$$\\n$$$2$$$\\n$$$2$$$\\n$$$[2]$$$\\n$$$1$$$\\nThe smallest value of $$$p[i]$$$ across all rooms is $$$1$$$, and this is attained when $$$i=2$$$. Therefore, this procedure should return $$$[0,0,1]$$$.",
    "_meta": {
      "index": 72,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/B",
      "uuid": "ps_d6e448ac385c3e310685f8dda326f35e069d2bf1"
    }
  },
  {
    "planning_view": {
      "title": "F. Towns",
      "task": "Find distance R using ≤N(N-1)/2 getDistance() calls, determine balanced hub",
      "given": [
        "N small towns (0 to N-1)",
        "Unknown number of large cities",
        "Tree network: small towns have degree 1, large cities have degree ≥3",
        "All highways have positive integer lengths"
      ],
      "goal": "Determine R (min distance from any large city to its farthest small town)",
      "key_rules": [
        "Network is a tree: unique path between any two settlements",
        "Large cities are hubs if they minimize distance to farthest small town",
        "Hub is balanced if removing it splits small towns into pieces ≤⌊N/2⌋ each"
      ],
      "target": {
        "1": {
          "points": 13,
          "req": "Find R using at most N(N-1)/2 queries"
        },
        "2": {
          "points": 12,
          "req": "Find R using at most ⌈7N/2⌉ queries"
        },
        "3": {
          "points": 13,
          "req": "Find R and balanced hub using N(N-1)/2 queries"
        },
        "4": {
          "points": 10,
          "req": "Find R and balanced hub using ⌈7N/2⌉ queries, large cities have degree exactly 3"
        },
        "5": {
          "points": 13,
          "req": "Find R and balanced hub using 5N queries"
        },
        "6": {
          "points": 39,
          "req": "Find R and balanced hub using ⌈7N/2⌉ queries"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Towns",
      "contest": "IOI 2015 day 2",
      "one_line": "Find distance R using ≤N(N-1)/2 getDistance() calls, determine balanced hub",
      "given": [
        "N small towns (0 to N-1)",
        "Unknown number of large cities",
        "Tree network: small towns have degree 1, large cities have degree ≥3",
        "All highways have positive integer lengths"
      ],
      "goal": "Determine R (min distance from any large city to its farthest small town)",
      "mechanism": "Call getDistance(i,j) to learn distance between small towns i and j",
      "success_condition": "Return R if balanced hub exists, -R otherwise (subtasks 3-6)",
      "constraints": {
        "critical": [
          "Network is a tree: unique path between any two settlements",
          "Large cities are hubs if they minimize distance to farthest small town",
          "Hub is balanced if removing it splits small towns into pieces ≤⌊N/2⌋ each"
        ],
        "subtasks": {
          "1": {
            "points": 13,
            "req": "Find R using at most N(N-1)/2 queries"
          },
          "2": {
            "points": 12,
            "req": "Find R using at most ⌈7N/2⌉ queries"
          },
          "3": {
            "points": 13,
            "req": "Find R and balanced hub using N(N-1)/2 queries"
          },
          "4": {
            "points": 10,
            "req": "Find R and balanced hub using ⌈7N/2⌉ queries, large cities have degree exactly 3"
          },
          "5": {
            "points": 13,
            "req": "Find R and balanced hub using 5N queries"
          },
          "6": {
            "points": 39,
            "req": "Find R and balanced hub using ⌈7N/2⌉ queries"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Towns",
        "contest": "IOI 2015 day 2",
        "one_line": "Find distance R using ≤N(N-1)/2 getDistance() calls, determine balanced hub"
      },
      "problem": {
        "given": [
          "N small towns (0 to N-1)",
          "Unknown number of large cities",
          "Tree network: small towns have degree 1, large cities have degree ≥3",
          "All highways have positive integer lengths"
        ],
        "goal": "Determine R (min distance from any large city to its farthest small town)",
        "mechanism": "Call getDistance(i,j) to learn distance between small towns i and j",
        "success_condition": "Return R if balanced hub exists, -R otherwise (subtasks 3-6)"
      },
      "constraints": {
        "critical": [
          "Network is a tree: unique path between any two settlements",
          "Large cities are hubs if they minimize distance to farthest small town",
          "Hub is balanced if removing it splits small towns into pieces ≤⌊N/2⌋ each"
        ],
        "subtasks": {
          "1": {
            "points": 13,
            "req": "Find R using at most N(N-1)/2 queries"
          },
          "2": {
            "points": 12,
            "req": "Find R using at most ⌈7N/2⌉ queries"
          },
          "3": {
            "points": 13,
            "req": "Find R and balanced hub using N(N-1)/2 queries"
          },
          "4": {
            "points": 10,
            "req": "Find R and balanced hub using ⌈7N/2⌉ queries, large cities have degree exactly 3"
          },
          "5": {
            "points": 13,
            "req": "Find R and balanced hub using 5N queries"
          },
          "6": {
            "points": 39,
            "req": "Find R and balanced hub using ⌈7N/2⌉ queries"
          }
        }
      },
      "implementation": {
        "function_to_write": "int hubDistance(int N, int sub)",
        "available_api": {
          "getDistance": {
            "signature": "int getDistance(int i, int j)",
            "params": "i, j: small town indices (0 to N-1)",
            "returns": "Distance between towns i and j",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Function called exactly once per test case",
          "Return R or -R for subtasks 1-2",
          "Return R if balanced hub exists, -R otherwise for subtasks 3-6",
          "Initialize all variables for each test case call"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "There are $$$N$$$ small towns in Kazakhstan, numbered from $$$0$$$ through $$$N - 1$$$. There is also an unknown number of large cities. The small towns and large cities of Kazakhstan are jointly called\nsettlements\n.\nAll the settlements of Kazakhstan are connected by a single network of bidirectional highways. Each highway connects two distinct settlements, and each pair of settlements is directly connected by at most one highway. For each pair of settlements $$$a$$$ and $$$b$$$ there is a unique way in which one can go from $$$a$$$ to $$$b$$$ using the highways, as long as no highway is used more than once.\nIt is known that each small town is directly connected to a single other settlement, and each large city is directly connected to three or more settlements.\nThe following figure shows a network of 11 small towns and 7 large cities. Small towns are depicted as circles and labeled by integers, large cities are depicted as squares and labeled by letters.\nEvery highway has a positive integer length. The distance between two settlements is the minimum sum of the lengths of the highways one needs to travel in order to get from one settlement to the other.\nFor each large city $$$C$$$ we can measure the distance $$$r(C)$$$ to the small town that is the farthest away from that city. A large city $$$C$$$ is a hub if the distance $$$r(C)$$$ is the smallest among all large cities. The distance between a hub and a small town that is farthest away from the hub will be denoted by $$$R$$$. Thus, $$$R$$$ is the smallest of all values $$$r(C)$$$.\nIn the above example the farthest small town from city $$$a$$$ is town 8, and the distance between them is $$$r(a) = 1 + 4 + 12 = 17$$$. For city $$$g$$$ we also have $$$r(g) = 17$$$. (One of the small towns that are farthest away from $$$g$$$ is town 6.) The only hub in the above example is city $$$f$$$, with $$$r(f) = 16$$$. Hence, in the above example $$$R$$$ is 16.\nRemoving a hub divides the network into multiple connected pieces. A hub is\nbalanced\nif each of those pieces contains at most $$$\\lfloor \\frac{N}{2} \\rfloor$$$ small towns. (We stress that we do not count the large cities.) Note that $$$\\lfloor x \\rfloor$$$ denotes the largest integer which is not greater than $$$x$$$.\nIn our example, city $$$f$$$ is a hub. If we remove city $$$f$$$, the network will break into four connected pieces. These four pieces consist of the following sets of small towns: {$$$0, 1, 10$$$}, {$$$2, 3$$$}, {$$$4,5,6,7$$$}, and {$$$8, 9$$$}. None of these pieces has more than $$$\\lfloor \\frac{11}{2} \\rfloor = 5$$$ small towns, hence city $$$f$$$ is a balanced hub.\nTask\nInitially, the only information you have about the network of settlements and highways is the number $$$N$$$ of small towns. You do not know the number of large cities. You also do not know anything about the layout of highways in the country. You can only obtain new information by asking queries about distances between pairs of small towns.\nYour task is to determine:\nIn all subtasks: the distance $$$R$$$.\nIn subtasks $$$3$$$ to $$$6$$$: whether there is a balanced hub in the network.\nYou need to implement the function\nhubDistance\n. The grader will evaluate multiple test cases in a single run. The number of test cases per run is at most 40. For each test case the grader will call your function\nhubDistance\nexactly once. Make sure that your function initializes all necessary variables every time it is called.\nint hubDistance(int N, int sub)\n$$$N$$$: the number of small towns.\n$$$sub$$$: the subtask number (explained in the Scoring section).\nIf $$$sub$$$ is 1 or 2, the function can return either $$$R$$$ or $$$-R$$$.\nif $$$sub$$$ is greater than 2, if there exists a balanced hub then the function must return $$$R$$$, otherwise it must return $$$-R$$$.\nYour function\nhubDistance\ncan obtain information about the network of highways by calling the grader function\ngetDistance(i, j)\n. This function returns the distance between the small towns $$$i$$$ and $$$j$$$. Note that if $$$i$$$ and $$$j$$$ are equal, the function returns 0. It also returns 0 when the arguments are invalid.\nInput\nThe sample grader reads the input in the following format:\nline 1: Subtask number and the number of test cases.\nline 2: $$$N_1$$$, the number of small towns in the first test case.\nfollowing $$$N_1$$$ lines: The $$$j$$$-th number $$$(1\\le j \\le N_1)$$$ in the $$$i$$$-th of these lines $$$(1 \\le i \\le N_1)$$$ is the distance between small towns $$$i - 1$$$ and $$$j - 1$$$.\nThe next test cases follow. They are given in the same format as the first test case.\nOutput\nFor each test case, the sample grader prints the return value of\nhubDistance\nand the number of calls made on separate lines.\nScoring\nIn each test case:\n$$$N$$$ is between $$$6$$$ and $$$110$$$ inclusive.\nThe distance between any two distinct small towns is between $$$1$$$ and $$$1\\,000\\,000$$$ inclusive.\nThe number of queries your program may make is limited. The limit varies by subtask, as given in the table below. If your program tries to exceed the limit on the number of queries, it will be terminated and it will be assumed to have given an incorrect answer.\nSubtask\nPoints\nNumber of queries\nFind balanced hub\nAdditional constraints\n1\n13\n$$$\\frac{N(N-1)}{2}$$$\nNO\n—\n2\n12\n$$$\\lceil \\frac{7N}{2} \\rceil$$$\nNO\n—\n3\n13\n$$$\\frac{N(N-1)}{2}$$$\nYES\n—\n4\n10\n$$$\\lceil \\frac{7N}{2} \\rceil$$$\nYES\nEach large city is connected to exactly three settlements\n5\n13\n$$$5n$$$\nYES\n—\n6\n39\n$$$\\lceil \\frac{7N}{2} \\rceil$$$\nYES\n—\nNote that $$$\\lceil x \\rceil$$$ denotes the smallest integer which is greater than or equal to $$$x$$$.\nNote\nNote that the subtask number is a part of the input. The sample grader changes its behavior according to the subtask number.\nThe input file corresponding to the example above is:\n1 1\n11\n0 17 18 20 17 12 20 16 23 20 11\n17 0 23 25 22 17 25 21 28 25 16\n18 23 0 12 21 16 24 20 27 24 17\n20 25 12 0 23 18 26 22 29 26 19\n17 22 21 23 0 9 21 17 26 23 16\n12 17 16 18 9 0 16 12 21 18 11\n20 25 24 26 21 16 0 10 29 26 19\n16 21 20 22 17 12 10 0 25 22 15\n23 28 27 29 26 21 29 25 0 21 22\n20 25 24 26 23 18 26 22 21 0 19\n11 16 17 19 16 11 19 15 22 19 0\nThis format is quite different from specifying the list of highways. Note that you are allowed to modify sample graders, so that they use a different input format."
    },
    "original": "There are $$$N$$$ small towns in Kazakhstan, numbered from $$$0$$$ through $$$N - 1$$$. There is also an unknown number of large cities. The small towns and large cities of Kazakhstan are jointly called\nsettlements\n.\nAll the settlements of Kazakhstan are connected by a single network of bidirectional highways. Each highway connects two distinct settlements, and each pair of settlements is directly connected by at most one highway. For each pair of settlements $$$a$$$ and $$$b$$$ there is a unique way in which one can go from $$$a$$$ to $$$b$$$ using the highways, as long as no highway is used more than once.\nIt is known that each small town is directly connected to a single other settlement, and each large city is directly connected to three or more settlements.\nThe following figure shows a network of 11 small towns and 7 large cities. Small towns are depicted as circles and labeled by integers, large cities are depicted as squares and labeled by letters.\nEvery highway has a positive integer length. The distance between two settlements is the minimum sum of the lengths of the highways one needs to travel in order to get from one settlement to the other.\nFor each large city $$$C$$$ we can measure the distance $$$r(C)$$$ to the small town that is the farthest away from that city. A large city $$$C$$$ is a hub if the distance $$$r(C)$$$ is the smallest among all large cities. The distance between a hub and a small town that is farthest away from the hub will be denoted by $$$R$$$. Thus, $$$R$$$ is the smallest of all values $$$r(C)$$$.\nIn the above example the farthest small town from city $$$a$$$ is town 8, and the distance between them is $$$r(a) = 1 + 4 + 12 = 17$$$. For city $$$g$$$ we also have $$$r(g) = 17$$$. (One of the small towns that are farthest away from $$$g$$$ is town 6.) The only hub in the above example is city $$$f$$$, with $$$r(f) = 16$$$. Hence, in the above example $$$R$$$ is 16.\nRemoving a hub divides the network into multiple connected pieces. A hub is\nbalanced\nif each of those pieces contains at most $$$\\lfloor \\frac{N}{2} \\rfloor$$$ small towns. (We stress that we do not count the large cities.) Note that $$$\\lfloor x \\rfloor$$$ denotes the largest integer which is not greater than $$$x$$$.\nIn our example, city $$$f$$$ is a hub. If we remove city $$$f$$$, the network will break into four connected pieces. These four pieces consist of the following sets of small towns: {$$$0, 1, 10$$$}, {$$$2, 3$$$}, {$$$4,5,6,7$$$}, and {$$$8, 9$$$}. None of these pieces has more than $$$\\lfloor \\frac{11}{2} \\rfloor = 5$$$ small towns, hence city $$$f$$$ is a balanced hub.\nTask\nInitially, the only information you have about the network of settlements and highways is the number $$$N$$$ of small towns. You do not know the number of large cities. You also do not know anything about the layout of highways in the country. You can only obtain new information by asking queries about distances between pairs of small towns.\nYour task is to determine:\nIn all subtasks: the distance $$$R$$$.\nIn subtasks $$$3$$$ to $$$6$$$: whether there is a balanced hub in the network.\nYou need to implement the function\nhubDistance\n. The grader will evaluate multiple test cases in a single run. The number of test cases per run is at most 40. For each test case the grader will call your function\nhubDistance\nexactly once. Make sure that your function initializes all necessary variables every time it is called.\nint hubDistance(int N, int sub)\n$$$N$$$: the number of small towns.\n$$$sub$$$: the subtask number (explained in the Scoring section).\nIf $$$sub$$$ is 1 or 2, the function can return either $$$R$$$ or $$$-R$$$.\nif $$$sub$$$ is greater than 2, if there exists a balanced hub then the function must return $$$R$$$, otherwise it must return $$$-R$$$.\nYour function\nhubDistance\ncan obtain information about the network of highways by calling the grader function\ngetDistance(i, j)\n. This function returns the distance between the small towns $$$i$$$ and $$$j$$$. Note that if $$$i$$$ and $$$j$$$ are equal, the function returns 0. It also returns 0 when the arguments are invalid.\nInput\nThe sample grader reads the input in the following format:\nline 1: Subtask number and the number of test cases.\nline 2: $$$N_1$$$, the number of small towns in the first test case.\nfollowing $$$N_1$$$ lines: The $$$j$$$-th number $$$(1\\le j \\le N_1)$$$ in the $$$i$$$-th of these lines $$$(1 \\le i \\le N_1)$$$ is the distance between small towns $$$i - 1$$$ and $$$j - 1$$$.\nThe next test cases follow. They are given in the same format as the first test case.\nOutput\nFor each test case, the sample grader prints the return value of\nhubDistance\nand the number of calls made on separate lines.\nScoring\nIn each test case:\n$$$N$$$ is between $$$6$$$ and $$$110$$$ inclusive.\nThe distance between any two distinct small towns is between $$$1$$$ and $$$1\\,000\\,000$$$ inclusive.\nThe number of queries your program may make is limited. The limit varies by subtask, as given in the table below. If your program tries to exceed the limit on the number of queries, it will be terminated and it will be assumed to have given an incorrect answer.\nSubtask\nPoints\nNumber of queries\nFind balanced hub\nAdditional constraints\n1\n13\n$$$\\frac{N(N-1)}{2}$$$\nNO\n—\n2\n12\n$$$\\lceil \\frac{7N}{2} \\rceil$$$\nNO\n—\n3\n13\n$$$\\frac{N(N-1)}{2}$$$\nYES\n—\n4\n10\n$$$\\lceil \\frac{7N}{2} \\rceil$$$\nYES\nEach large city is connected to exactly three settlements\n5\n13\n$$$5n$$$\nYES\n—\n6\n39\n$$$\\lceil \\frac{7N}{2} \\rceil$$$\nYES\n—\nNote that $$$\\lceil x \\rceil$$$ denotes the smallest integer which is greater than or equal to $$$x$$$.\nNote\nNote that the subtask number is a part of the input. The sample grader changes its behavior according to the subtask number.\nThe input file corresponding to the example above is:\n1 1\n11\n0 17 18 20 17 12 20 16 23 20 11\n17 0 23 25 22 17 25 21 28 25 16\n18 23 0 12 21 16 24 20 27 24 17\n20 25 12 0 23 18 26 22 29 26 19\n17 22 21 23 0 9 21 17 26 23 16\n12 17 16 18 9 0 16 12 21 18 11\n20 25 24 26 21 16 0 10 29 26 19\n16 21 20 22 17 12 10 0 25 22 15\n23 28 27 29 26 21 29 25 0 21 22\n20 25 24 26 23 18 26 22 21 0 19\n11 16 17 19 16 11 19 15 22 19 0\nThis format is quite different from specifying the list of highways. Note that you are allowed to modify sample graders, so that they use a different input format.",
    "_meta": {
      "index": 73,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/F",
      "uuid": "ps_dccfff7e1a221a37320f4cc77557738c0b76e19f"
    }
  },
  {
    "planning_view": {
      "title": "B. Scales",
      "task": "Sort 6 coins by weight using ≤Q scale queries across multiple test cases",
      "given": [
        "6 coins numbered 1-6 with distinct weights",
        "Special 4-pan scale with four query types",
        "Multiple test cases per run"
      ],
      "goal": "Determine coin order from lightest to heaviest for each test case",
      "key_rules": [
        "Each query uses distinct coin numbers 1-6",
        "getNextLightest returns lightest coin heavier than D, or lightest overall if none heavier",
        "Score depends on minimizing total query count across all test cases"
      ],
      "target": {
        "1": {
          "points": 100,
          "req": "Correct ordering with optimal query count Q"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Scales",
      "contest": "IOI 2015 day 1",
      "one_line": "Sort 6 coins by weight using ≤Q scale queries across multiple test cases",
      "given": [
        "6 coins numbered 1-6 with distinct weights",
        "Special 4-pan scale with four query types",
        "Multiple test cases per run"
      ],
      "goal": "Determine coin order from lightest to heaviest for each test case",
      "mechanism": "Use scale queries that compare coins in pans A, B, C (and D) to deduce relative weights",
      "success_condition": "Call answer(W) with correct coin ordering before returning from orderCoins()",
      "constraints": {
        "critical": [
          "Each query uses distinct coin numbers 1-6",
          "getNextLightest returns lightest coin heavier than D, or lightest overall if none heavier",
          "Score depends on minimizing total query count across all test cases"
        ],
        "subtasks": {
          "1": {
            "points": 100,
            "req": "Correct ordering with optimal query count Q"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Scales",
        "contest": "IOI 2015 day 1",
        "one_line": "Sort 6 coins by weight using ≤Q scale queries across multiple test cases"
      },
      "problem": {
        "given": [
          "6 coins numbered 1-6 with distinct weights",
          "Special 4-pan scale with four query types",
          "Multiple test cases per run"
        ],
        "goal": "Determine coin order from lightest to heaviest for each test case",
        "mechanism": "Use scale queries that compare coins in pans A, B, C (and D) to deduce relative weights",
        "success_condition": "Call answer(W) with correct coin ordering before returning from orderCoins()"
      },
      "constraints": {
        "critical": [
          "Each query uses distinct coin numbers 1-6",
          "getNextLightest returns lightest coin heavier than D, or lightest overall if none heavier",
          "Score depends on minimizing total query count across all test cases"
        ],
        "subtasks": {
          "1": {
            "points": 100,
            "req": "Correct ordering with optimal query count Q"
          }
        }
      },
      "implementation": {
        "function_to_write": "void orderCoins()",
        "available_api": {
          "getHeaviest": {
            "signature": "int getHeaviest(int A, int B, int C)",
            "params": "A, B, C: three distinct coin numbers (1-6)",
            "returns": "Heaviest coin among A, B, C",
            "side_effect": "None"
          },
          "getLightest": {
            "signature": "int getLightest(int A, int B, int C)",
            "params": "A, B, C: three distinct coin numbers (1-6)",
            "returns": "Lightest coin among A, B, C",
            "side_effect": "None"
          },
          "getMedian": {
            "signature": "int getMedian(int A, int B, int C)",
            "params": "A, B, C: three distinct coin numbers (1-6)",
            "returns": "Median coin among A, B, C",
            "side_effect": "None"
          },
          "getNextLightest": {
            "signature": "int getNextLightest(int A, int B, int C, int D)",
            "params": "A, B, C, D: four distinct coin numbers (1-6)",
            "returns": "Lightest coin among A, B, C heavier than D, or lightest overall if none heavier",
            "side_effect": "None"
          },
          "answer": {
            "signature": "void answer(int W[6])",
            "params": "W[0..5]: coin numbers from lightest to heaviest",
            "returns": "None",
            "side_effect": "Records solution for current test case"
          }
        },
        "requirements": [
          "Must implement void init(int T) for initialization",
          "Must implement void orderCoins() once per test case",
          "Coin numbers are integers 1-6",
          "All queries must use distinct coins"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "2\n1 2 3 4 5 6\n3 4 6 2 1 5",
          "output": "1 2 3 4 5 6 6\n3 4 6 2 1 5 6"
        }
      ],
      "original_statement": "Amina has six coins, numbered from $$$1$$$ to $$$6$$$. She knows that the coins all have different weights. She would like to order them according to their weight. For this purpose she has developed a new kind of balance scale.\nA traditional balance scale has two pans. To use such a scale, you place a coin into each pan and the scale will determine which coin is heavier.\nAmina's new scale is more complex. It has four pans, labeled $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$. The scale has four different settings, each of which answers a different question regarding the coins. To use the scale, Amina must place exactly one coin into each of the pans $$$A$$$, $$$B$$$, and $$$C$$$. Additionally, in the fourth setting she must also place exactly one coin into pan $$$D$$$.\nThe four settings will instruct the scale to answer the following four questions:\nWhich of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ is the heaviest?\nWhich of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ is the lightest?\nWhich of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ is the median? (This is the coin that is neither the heaviest nor the lightest of the three.)\nAmong the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$, consider only the coins that are heavier than the coin on pan $$$D$$$. If there are any such coins, which of these coins is the lightest? Otherwise, if there are no such coins, which of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ and is the lightest?\nWrite a program that will order Amina's six coins according to their weight. The program can query Amina's scale to compare weights of coins. Your program will be given several test cases to solve, each corresponding to a new set of six coins.\nYour program should implement the functions\ninit\nand\norderCoins\n. During each run of your program, the grader will first call\ninit\nexactly once. This gives you the number of test cases and allows you to initialize any variables. The grader will then call\norderCoins()\nonce per test case.\nvoid init(int T)\n$$$T$$$: The number of test cases your program will have to solve during this run. $$$T$$$ is an integer from the range $$$1,\\dots,18$$$.\nThis function has no return value.\nvoid orderCoins()\nThis function is called exactly once per test case.\nThe function should determine the correct order of Amina's coins by calling the grader functions\ngetHeaviest()\n,\ngetLightest()\n,\ngetMedian()\n, and/or\ngetNextLightest()\n.\nOnce the function knows the correct order, it should report it by calling the grader function\nanswer()\n.\nAfter calling\nanswer()\n, the function\norderCoins()\nshould return. It has no return value.\nYou may use the following grader functions in your program:\nanswer(W)\n— your program should use this function to report the answer that it has found.\n$$$W$$$: An array of length $$$6$$$ containing the correct order of coins. $$$W[0]$$$ through $$$W[5]$$$ should be the coin numbers (i.e., numbers from $$$1$$$ to $$$6$$$) in order from the lightest to the heaviest coin.\nYour program should only call this function from\norderCoins()\n, once per test case.\nThis function has no return value.\ngetHeaviest(A, B, C)\n,\ngetLightest(A, B, C)\n,\ngetMedian(A, B, C)\n— these correspond to settings $$$1$$$, $$$2$$$ and $$$3$$$ respectively for Amina's scale.\n$$$A, B, C$$$: The coins that are put in pans $$$A$$$, $$$B$$$ and $$$C$$$, respectively. $$$A$$$, $$$B$$$, and $$$C$$$ should be three distinct integers, each between $$$1$$$ and $$$6$$$ inclusive.\nEach function returns one of the numbers $$$A$$$, $$$B$$$, and $$$C$$$: the number of the appropriate coin. For example,\ngetHeaviest(A, B, C)\nreturns the number of the heaviest of the three\ngiven coins.\ngetNextLightest(A, B, C, D)\n— this corresponds to setting 4 for Amina's scale\n$$$A, B, C, D$$$: The coins that are put in pans $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$, respectively. $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$ should be four distinct integers, each between $$$1$$$ and $$$6$$$ inclusive.\nThe function returns one of the numbers $$$A$$$, $$$B$$$, and $$$C$$$: the number of the coin selected by the scale as described above for setting $$$4$$$. That is, the returned coin is the lightest amongst those coins on pans $$$A$$$, $$$B$$$, and $$$C$$$ that are heavier than the coin in pan $$$D$$$; or, if none of them is heavier than the coin on pan $$$D$$$, the returned coin is simply the lightest of all three coins on pans $$$A$$$, $$$B$$$, and $$$C$$$.\nInput\nThe sample grader reads input in the following format:\nline $$$1$$$: $$$T$$$— the number of test cases\neach of the lines from $$$2$$$ to $$$T + 1$$$: a sequence of $$$6$$$ distinct numbers from $$$1$$$ to $$$6$$$ the coins from the lightest to the heaviest.\nScoring\nThere are no subtasks in this problem. Instead, your score will be based on how many weighings (total number of calls to grader functions\ngetLightest()\n,\ngetHeaviest()\n,\ngetMedian()\nand/or\ngetNextLightest()\n) your program makes.\nYour program will be run multiple times with multiple test cases in each run. Let $$$r$$$ be the number of runs of your program. This number is fixed by the test data. If your program does not order the coins correctly in any test case of any run, it will get $$$0$$$ points. Otherwise, the runs are scored individually as follows.\nLet $$$Q$$$ be the smallest number such that it is possible to sort any sequence of six coins using $$$Q$$$ weighings on Amina's scale. To make the task more challenging, we do not reveal the value of $$$Q$$$ here.\nSuppose the largest number of weighings amongst all test cases of all runs is $$$Q + y$$$ for some integer $$$y$$$. Then, consider a single run of your program.\nThen, the score for this run will be $$$\\frac{100}{r(y / 2.5 + 1)}$$$, rounded\ndown\nto two digits after the decimal point.\nIn particular, if your program makes at most $$$Q$$$ weighings in each test case of every run, you will get $$$100$$$ points.\nOn the original contest, scoring was a bit different to award solutions, which are good on average. It's not implemented here.\nExample\nNote\nSuppose the coins are ordered $$$3\\ 4\\ 6\\ 2\\ 1\\ 5$$$ from the lightest to the heaviest.\nFunction call\nReturns\nExplanation\ngetMedian(4, 5, 6)\n6\nCoin $$$6$$$ is the median among coins $$$4$$$, $$$5$$$, and $$$6$$$.\ngetHeaviest(3, 1, 2)\n1\nCoin $$$1$$$ is the heaviest among coins $$$1$$$, $$$2$$$, and $$$3$$$.\ngetNextLightest(2, 3, 4, 5)\n3\nCoins $$$2$$$, $$$3$$$, $$$4$$$ and are all lighter than coin $$$5$$$, so the lightest among them $$$(3)$$$ is returned.\ngetNextLightest(1, 6, 3, 4)\n6\nCoins $$$1$$$ and $$$6$$$ are both heavier than coin $$$4$$$. Among coins $$$1$$$ and $$$6$$$, coin $$$6$$$ is the lightest one.\ngetHeaviest(3, 5, 6)\n5\nCoin $$$5$$$ is the heaviest among coins $$$3$$$, $$$5$$$ and $$$6$$$.\ngetMedian(1, 5, 6)\n1\nCoin $$$1$$$ is the median among coins $$$1$$$, $$$5$$$ and $$$6$$$.\ngetMedian(2, 4, 6)\n6\nCoin $$$6$$$ is the median among coins $$$2$$$, $$$4$$$ and $$$6$$$.\nanswer([3, 4, 6, 2, 1, 5])\nThe program found the right answer fot this test case."
    },
    "original": "Amina has six coins, numbered from $$$1$$$ to $$$6$$$. She knows that the coins all have different weights. She would like to order them according to their weight. For this purpose she has developed a new kind of balance scale.\nA traditional balance scale has two pans. To use such a scale, you place a coin into each pan and the scale will determine which coin is heavier.\nAmina's new scale is more complex. It has four pans, labeled $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$. The scale has four different settings, each of which answers a different question regarding the coins. To use the scale, Amina must place exactly one coin into each of the pans $$$A$$$, $$$B$$$, and $$$C$$$. Additionally, in the fourth setting she must also place exactly one coin into pan $$$D$$$.\nThe four settings will instruct the scale to answer the following four questions:\nWhich of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ is the heaviest?\nWhich of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ is the lightest?\nWhich of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ is the median? (This is the coin that is neither the heaviest nor the lightest of the three.)\nAmong the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$, consider only the coins that are heavier than the coin on pan $$$D$$$. If there are any such coins, which of these coins is the lightest? Otherwise, if there are no such coins, which of the coins in pans $$$A$$$, $$$B$$$ and $$$C$$$ and is the lightest?\nWrite a program that will order Amina's six coins according to their weight. The program can query Amina's scale to compare weights of coins. Your program will be given several test cases to solve, each corresponding to a new set of six coins.\nYour program should implement the functions\ninit\nand\norderCoins\n. During each run of your program, the grader will first call\ninit\nexactly once. This gives you the number of test cases and allows you to initialize any variables. The grader will then call\norderCoins()\nonce per test case.\nvoid init(int T)\n$$$T$$$: The number of test cases your program will have to solve during this run. $$$T$$$ is an integer from the range $$$1,\\dots,18$$$.\nThis function has no return value.\nvoid orderCoins()\nThis function is called exactly once per test case.\nThe function should determine the correct order of Amina's coins by calling the grader functions\ngetHeaviest()\n,\ngetLightest()\n,\ngetMedian()\n, and/or\ngetNextLightest()\n.\nOnce the function knows the correct order, it should report it by calling the grader function\nanswer()\n.\nAfter calling\nanswer()\n, the function\norderCoins()\nshould return. It has no return value.\nYou may use the following grader functions in your program:\nanswer(W)\n— your program should use this function to report the answer that it has found.\n$$$W$$$: An array of length $$$6$$$ containing the correct order of coins. $$$W[0]$$$ through $$$W[5]$$$ should be the coin numbers (i.e., numbers from $$$1$$$ to $$$6$$$) in order from the lightest to the heaviest coin.\nYour program should only call this function from\norderCoins()\n, once per test case.\nThis function has no return value.\ngetHeaviest(A, B, C)\n,\ngetLightest(A, B, C)\n,\ngetMedian(A, B, C)\n— these correspond to settings $$$1$$$, $$$2$$$ and $$$3$$$ respectively for Amina's scale.\n$$$A, B, C$$$: The coins that are put in pans $$$A$$$, $$$B$$$ and $$$C$$$, respectively. $$$A$$$, $$$B$$$, and $$$C$$$ should be three distinct integers, each between $$$1$$$ and $$$6$$$ inclusive.\nEach function returns one of the numbers $$$A$$$, $$$B$$$, and $$$C$$$: the number of the appropriate coin. For example,\ngetHeaviest(A, B, C)\nreturns the number of the heaviest of the three\ngiven coins.\ngetNextLightest(A, B, C, D)\n— this corresponds to setting 4 for Amina's scale\n$$$A, B, C, D$$$: The coins that are put in pans $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$, respectively. $$$A$$$, $$$B$$$, $$$C$$$, and $$$D$$$ should be four distinct integers, each between $$$1$$$ and $$$6$$$ inclusive.\nThe function returns one of the numbers $$$A$$$, $$$B$$$, and $$$C$$$: the number of the coin selected by the scale as described above for setting $$$4$$$. That is, the returned coin is the lightest amongst those coins on pans $$$A$$$, $$$B$$$, and $$$C$$$ that are heavier than the coin in pan $$$D$$$; or, if none of them is heavier than the coin on pan $$$D$$$, the returned coin is simply the lightest of all three coins on pans $$$A$$$, $$$B$$$, and $$$C$$$.\nInput\nThe sample grader reads input in the following format:\nline $$$1$$$: $$$T$$$— the number of test cases\neach of the lines from $$$2$$$ to $$$T + 1$$$: a sequence of $$$6$$$ distinct numbers from $$$1$$$ to $$$6$$$ the coins from the lightest to the heaviest.\nScoring\nThere are no subtasks in this problem. Instead, your score will be based on how many weighings (total number of calls to grader functions\ngetLightest()\n,\ngetHeaviest()\n,\ngetMedian()\nand/or\ngetNextLightest()\n) your program makes.\nYour program will be run multiple times with multiple test cases in each run. Let $$$r$$$ be the number of runs of your program. This number is fixed by the test data. If your program does not order the coins correctly in any test case of any run, it will get $$$0$$$ points. Otherwise, the runs are scored individually as follows.\nLet $$$Q$$$ be the smallest number such that it is possible to sort any sequence of six coins using $$$Q$$$ weighings on Amina's scale. To make the task more challenging, we do not reveal the value of $$$Q$$$ here.\nSuppose the largest number of weighings amongst all test cases of all runs is $$$Q + y$$$ for some integer $$$y$$$. Then, consider a single run of your program.\nThen, the score for this run will be $$$\\frac{100}{r(y / 2.5 + 1)}$$$, rounded\ndown\nto two digits after the decimal point.\nIn particular, if your program makes at most $$$Q$$$ weighings in each test case of every run, you will get $$$100$$$ points.\nOn the original contest, scoring was a bit different to award solutions, which are good on average. It's not implemented here.\nExample\nNote\nSuppose the coins are ordered $$$3\\ 4\\ 6\\ 2\\ 1\\ 5$$$ from the lightest to the heaviest.\nFunction call\nReturns\nExplanation\ngetMedian(4, 5, 6)\n6\nCoin $$$6$$$ is the median among coins $$$4$$$, $$$5$$$, and $$$6$$$.\ngetHeaviest(3, 1, 2)\n1\nCoin $$$1$$$ is the heaviest among coins $$$1$$$, $$$2$$$, and $$$3$$$.\ngetNextLightest(2, 3, 4, 5)\n3\nCoins $$$2$$$, $$$3$$$, $$$4$$$ and are all lighter than coin $$$5$$$, so the lightest among them $$$(3)$$$ is returned.\ngetNextLightest(1, 6, 3, 4)\n6\nCoins $$$1$$$ and $$$6$$$ are both heavier than coin $$$4$$$. Among coins $$$1$$$ and $$$6$$$, coin $$$6$$$ is the lightest one.\ngetHeaviest(3, 5, 6)\n5\nCoin $$$5$$$ is the heaviest among coins $$$3$$$, $$$5$$$ and $$$6$$$.\ngetMedian(1, 5, 6)\n1\nCoin $$$1$$$ is the median among coins $$$1$$$, $$$5$$$ and $$$6$$$.\ngetMedian(2, 4, 6)\n6\nCoin $$$6$$$ is the median among coins $$$2$$$, $$$4$$$ and $$$6$$$.\nanswer([3, 4, 6, 2, 1, 5])\nThe program found the right answer fot this test case.",
    "_meta": {
      "index": 74,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/B",
      "uuid": "ps_e4f0fda028978d5b3dba6eb88cae1a7029928fdf"
    }
  },
  {
    "planning_view": {
      "title": "E. Vision Program",
      "task": "Build ≤10,000 logic gates to check if two black pixels have Manhattan distance K",
      "given": [
        "H×W black/white image grid",
        "Exactly two black pixels per image",
        "All other pixels are white"
      ],
      "goal": "Produce a logic circuit that outputs 1 when black pixels are exactly distance K apart",
      "key_rules": [
        "Max 10,000 instructions total",
        "Max 1,000,000 total inputs across all gates",
        "Gates can only read earlier cells (pixels or previous gate outputs)",
        "Pixels stored row-major in cells 0 to H·W-1"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "max(H,W) ≤ 3"
        },
        "2": {
          "points": 11,
          "req": "max(H,W) ≤ 10"
        },
        "3": {
          "points": 11,
          "req": "max(H,W) ≤ 30"
        },
        "4": {
          "points": 15,
          "req": "max(H,W) ≤ 100"
        },
        "5": {
          "points": 12,
          "req": "min(H,W) = 1"
        },
        "6": {
          "points": 8,
          "req": "Pixel at (0,0) always black"
        },
        "7": {
          "points": 14,
          "req": "K = 1"
        },
        "8": {
          "points": 19,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Vision Program",
      "contest": "IOI 2019 day 2",
      "one_line": "Build ≤10,000 logic gates to check if two black pixels have Manhattan distance K",
      "given": [
        "H×W black/white image grid",
        "Exactly two black pixels per image",
        "All other pixels are white"
      ],
      "goal": "Produce a logic circuit that outputs 1 when black pixels are exactly distance K apart",
      "mechanism": "Program builds gates (NOT/AND/OR/XOR) that read memory cells; outputs stored sequentially",
      "success_condition": "Final gate output = 1 iff |r1-r2| + |c1-c2| = K for black pixel positions",
      "constraints": {
        "critical": [
          "Max 10,000 instructions total",
          "Max 1,000,000 total inputs across all gates",
          "Gates can only read earlier cells (pixels or previous gate outputs)",
          "Pixels stored row-major in cells 0 to H·W-1"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "max(H,W) ≤ 3"
          },
          "2": {
            "points": 11,
            "req": "max(H,W) ≤ 10"
          },
          "3": {
            "points": 11,
            "req": "max(H,W) ≤ 30"
          },
          "4": {
            "points": 15,
            "req": "max(H,W) ≤ 100"
          },
          "5": {
            "points": 12,
            "req": "min(H,W) = 1"
          },
          "6": {
            "points": 8,
            "req": "Pixel at (0,0) always black"
          },
          "7": {
            "points": 14,
            "req": "K = 1"
          },
          "8": {
            "points": 19,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Vision Program",
        "contest": "IOI 2019 day 2",
        "one_line": "Build ≤10,000 logic gates to check if two black pixels have Manhattan distance K"
      },
      "problem": {
        "given": [
          "H×W black/white image grid",
          "Exactly two black pixels per image",
          "All other pixels are white"
        ],
        "goal": "Produce a logic circuit that outputs 1 when black pixels are exactly distance K apart",
        "mechanism": "Program builds gates (NOT/AND/OR/XOR) that read memory cells; outputs stored sequentially",
        "success_condition": "Final gate output = 1 iff |r1-r2| + |c1-c2| = K for black pixel positions"
      },
      "constraints": {
        "critical": [
          "Max 10,000 instructions total",
          "Max 1,000,000 total inputs across all gates",
          "Gates can only read earlier cells (pixels or previous gate outputs)",
          "Pixels stored row-major in cells 0 to H·W-1"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "max(H,W) ≤ 3"
          },
          "2": {
            "points": 11,
            "req": "max(H,W) ≤ 10"
          },
          "3": {
            "points": 11,
            "req": "max(H,W) ≤ 30"
          },
          "4": {
            "points": 15,
            "req": "max(H,W) ≤ 100"
          },
          "5": {
            "points": 12,
            "req": "min(H,W) = 1"
          },
          "6": {
            "points": 8,
            "req": "Pixel at (0,0) always black"
          },
          "7": {
            "points": 14,
            "req": "K = 1"
          },
          "8": {
            "points": 19,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "void construct_network(int H, int W, int K)",
        "available_api": {
          "add_not": {
            "signature": "int add_not(int N)",
            "params": "N: input cell index",
            "returns": "Output cell index (starts at H·W)",
            "side_effect": "Appends NOT gate to program"
          },
          "add_and": {
            "signature": "int add_and(int[] Ns)",
            "params": "Ns: array of input cell indices",
            "returns": "Output cell index",
            "side_effect": "Appends AND gate to program"
          },
          "add_or": {
            "signature": "int add_or(int[] Ns)",
            "params": "Ns: array of input cell indices",
            "returns": "Output cell index",
            "side_effect": "Appends OR gate to program"
          },
          "add_xor": {
            "signature": "int add_xor(int[] Ns)",
            "params": "Ns: array of input cell indices",
            "returns": "Output cell index",
            "side_effect": "Appends XOR gate to program"
          }
        },
        "requirements": [
          "Cells are 0-indexed",
          "Pixel at (i,j) stored in cell i*W + j",
          "Gate outputs stored sequentially starting at H·W",
          "Input arrays cannot be empty"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "You are implementing a vision program for a robot. Each time the robot camera takes a picture, it is stored as a black and white image in the robot's memory. Each image is an $$$H \\times W$$$ grid of pixels, with rows numbered $$$0$$$ through $$$H-1$$$ and columns numbered $$$0$$$ through $$$W-1$$$. There are\nexactly two\nblack pixels in each image, and all other pixels are white.\nThe robot can process each image with a program consisting of simple instructions. You are given the values of $$$H$$$, $$$W$$$, and a positive integer $$$K$$$. Your goal is to write a procedure to produce a program for the robot that, for any image, determines whether the\ndistance\nbetween the two black pixels is exactly $$$K$$$. Here, the distance between a pixel in row $$$r_1$$$ and column $$$c_1$$$ and a pixel in row $$$r_2$$$ and column $$$c_2$$$ is $$$|r_1-r_2|+|c_1-c_2|$$$. In this formula $$$|x|$$$ denotes the absolute value of $$$x$$$, which equals $$$x$$$ if $$$x \\geq 0$$$ and equals $$$-x$$$ if $$$x < 0$$$.\nWe now describe how the robot works.\nThe robot's memory is a sufficiently large array of cells, indexed from $$$0$$$. Each cell can store either $$$0$$$ or $$$1$$$ and its value, once set, will not be changed. The image is stored row by row in cells indexed $$$0$$$ through $$$H \\cdot W - 1$$$. The first row is stored in cells $$$0$$$ through $$$W-1$$$, and the last row is stored in cells $$$(H - 1) \\cdot W$$$ through $$$H \\cdot W - 1$$$. In particular, if the pixel in row $$$i$$$ and column $$$j$$$ is black, the value of cell $$$i \\cdot W + j$$$ is $$$1$$$, otherwise it is $$$0$$$.\nA robot's program is a sequence of\ninstructions\n, which are numbered with consecutive integers starting from $$$0$$$. When the program is run, the instructions are executed one by one. Each instruction reads the values of one or more cells (we call these values the instruction's\ninputs\n) and produces a single value equal to $$$0$$$ or $$$1$$$ (we call this value the instruction's\noutput\n). The output of instruction $$$i$$$ is stored in cell $$$H \\cdot W + i$$$. The inputs of instruction $$$i$$$ can only be cells that store either pixels or outputs of previous instructions, i.e. cells $$$0$$$ to $$$H \\cdot W + i - 1$$$.\nThere are four types of instructions:\nNOT\n: has exactly one input. Its output is $$$1$$$ if the input is $$$0$$$, otherwise its output is $$$0$$$.\nAND\n: has one or more inputs. Its output is $$$1$$$ if and only if\nall\nof the inputs are $$$1$$$.\nOR\n: has one or more inputs. Its output is $$$1$$$ if and only if\nat least one\nof the inputs is $$$1$$$.\nXOR\n: has one or more inputs. Its output is $$$1$$$ if and only if an\nodd number\nof the inputs are $$$1$$$.\nThe output of the last instruction of the program should be $$$1$$$ if the distance between the two black pixels is exactly $$$K$$$, and $$$0$$$ otherwise.\nImplementation details\nYou should implement the following procedure:\nvoid construct_network(int H, int W, int K)\n$$$H, W$$$: dimensions of each image taken by the robot's camera\n$$$K$$$: a positive integer\nThis procedure should produce a robot's program. For any image taken by the robot's camera, this program should determine whether the distance between the two black pixels in the image is exactly $$$K$$$.\nThis procedure should call one or more of the following procedures to append instructions to the robot's program (which is initially empty):\nint add_not(int N)\nint add_and(int[] Ns)\nint add_or(int[] Ns)\nint add_xor(int[] Ns)\nAppend a\nNOT\n,\nAND\n,\nOR\n, or\nXOR\ninstruction, respectively.\n$$$N$$$ (for\nadd_not\n): the index of the cell from which the appended\nNOT\ninstruction reads its input\n$$$Ns$$$ (for\nadd_and\n,\nadd_or\n,\nadd_xor\n): array containing the indices of the cells from which the appended\nAND\n,\nOR\n, or\nXOR\ninstruction reads its inputs\nEach procedure returns the index of the cell that stores the output of the instruction. The consecutive calls to these procedures return consecutive integers starting from $$$H \\cdot W$$$.\nThe robot's program can consist of at most $$$10\\,000$$$ instructions. The instructions can read at most $$$1\\,000\\,000$$$ values in total. In other words, the total length of $$$Ns$$$ arrays in all calls to\nadd_and\n,\nadd_or\nand\nadd_xor\nplus the number of calls to\nadd_not\ncannot exceed $$$1\\,000\\,000$$$.\nAfter appending the last instruction, procedure\nconstruct_network\nshould return. The robot's program will then be evaluated on some number of images. Your solution passes a given test case if for each of these images, the output of the last instruction is $$$1$$$ if and only if the distance between the two black pixels in the image is equal to $$$K$$$.\nThe grading of your solution may result in one of the following error messages:\nInstruction with no inputs\n: an empty array was given as the input to\nadd_and\n,\nadd_or\n, or\nadd_xor\n.\nInvalid index\n: an incorrect (possibly negative) cell index was provided as the input to\nadd_and\n,\nadd_or\n,\nadd_xor\n, or\nadd_not\n.\nToo many instructions\n: your procedure attempted to add more than $$$10\\,000$$$ instructions.\nToo many inputs\n: the instructions read more than $$$1\\,000\\,000$$$ values in total.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$H$$$ $$$W$$$ $$$K$$$ ($$$1 \\leq H, W \\leq 200$$$, $$$2 \\leq H \\cdot W$$$, $$$1 \\leq K \\leq H+W-2$$$)\nline $$$2+i$$$ $$$(i \\geq 0)$$$: $$$r_1[i]$$$ $$$c_1[i]$$$ $$$r_2[i]$$$ $$$c_2[i]$$$\nlast line: $$$-1$$$\nEach line excepting the first and the last line represents an image with two black pixels. We denote the image described in line $$$2+i$$$ by image $$$i$$$. One black pixel is in row $$$r_1[i]$$$ and column $$$c_1[i]$$$ and the other one in row $$$r_2[i]$$$ and column $$$c_2[i]$$$.\nOutput\nThe sample grader first calls\nconstruct_network(H, W, K)\n. If\nconstruct_network\nviolates some constraint described in the problem statement, the sample grader prints one of the error messages listed at the end of Implementation details section and exits.\nOtherwise, the sample grader produces two outputs.\nFirst, the sample grader prints the output of the robot's program in the following format:\nline $$$1+i$$$ $$$(0 \\leq i)$$$: output of the last instruction in the robot's program for image $$$i$$$ ($$$1$$$ or $$$0$$$).\nSecond, the sample grader writes a file 'log.txt' in the current directory in the following format:\nline $$$1+i$$$ $$$(0 \\leq i)$$$: $$$m[i][0], m[i][1], \\ldots, m[i][c-1]$$$\nThe sequence on line $$$1+i$$$ describes the values stored in the robot's memory cells after the robot's program is run, given image $$$i$$$ as the input. Specifically, $$$m[i][j]$$$ gives the value of cell $$$j$$$. Note that the value of $$$c$$$ (the length of the sequence) is equal to $$$H \\cdot W$$$ plus the number of instructions in the robot's program.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$\\max(H, W) \\leq 3$$$\n2\n11\n$$$\\max(H, W) \\leq 10$$$\n3\n11\n$$$\\max(H, W) \\leq 30$$$\n4\n15\n$$$\\max(H, W) \\leq 100$$$\n5\n12\n$$$\\min(H, W)=1$$$\n6\n8\nPixel in row $$$0$$$ and column $$$0$$$ is black in each image.\n7\n14\n$$$K=1$$$\n8\n19\nno additional constraints\nExample\nNote\nAssume $$$H=2$$$, $$$W=3$$$, $$$K=3$$$. There are only two possible images where the distance between the black pixels is $$$3$$$.\nCase 1: black pixels are $$$0$$$ and $$$5$$$\nCase 2: black pixels are $$$2$$$ and $$$3$$$\nA possible solution is to build a robot's program by making the following calls:\nadd_and([0, 5])\n, which adds an instruction that outputs $$$1$$$ if and only if the first case holds. The output is stored in cell $$$6$$$.\nadd_and([2, 3])\n, which adds an instruction that outputs $$$1$$$ if and only if the second case holds. The output is stored in cell $$$7$$$.\nadd_or([6, 7])\n, which adds an instruction that outputs $$$1$$$ if and only if one of the cases above holds."
    },
    "original": "You are implementing a vision program for a robot. Each time the robot camera takes a picture, it is stored as a black and white image in the robot's memory. Each image is an $$$H \\times W$$$ grid of pixels, with rows numbered $$$0$$$ through $$$H-1$$$ and columns numbered $$$0$$$ through $$$W-1$$$. There are\nexactly two\nblack pixels in each image, and all other pixels are white.\nThe robot can process each image with a program consisting of simple instructions. You are given the values of $$$H$$$, $$$W$$$, and a positive integer $$$K$$$. Your goal is to write a procedure to produce a program for the robot that, for any image, determines whether the\ndistance\nbetween the two black pixels is exactly $$$K$$$. Here, the distance between a pixel in row $$$r_1$$$ and column $$$c_1$$$ and a pixel in row $$$r_2$$$ and column $$$c_2$$$ is $$$|r_1-r_2|+|c_1-c_2|$$$. In this formula $$$|x|$$$ denotes the absolute value of $$$x$$$, which equals $$$x$$$ if $$$x \\geq 0$$$ and equals $$$-x$$$ if $$$x < 0$$$.\nWe now describe how the robot works.\nThe robot's memory is a sufficiently large array of cells, indexed from $$$0$$$. Each cell can store either $$$0$$$ or $$$1$$$ and its value, once set, will not be changed. The image is stored row by row in cells indexed $$$0$$$ through $$$H \\cdot W - 1$$$. The first row is stored in cells $$$0$$$ through $$$W-1$$$, and the last row is stored in cells $$$(H - 1) \\cdot W$$$ through $$$H \\cdot W - 1$$$. In particular, if the pixel in row $$$i$$$ and column $$$j$$$ is black, the value of cell $$$i \\cdot W + j$$$ is $$$1$$$, otherwise it is $$$0$$$.\nA robot's program is a sequence of\ninstructions\n, which are numbered with consecutive integers starting from $$$0$$$. When the program is run, the instructions are executed one by one. Each instruction reads the values of one or more cells (we call these values the instruction's\ninputs\n) and produces a single value equal to $$$0$$$ or $$$1$$$ (we call this value the instruction's\noutput\n). The output of instruction $$$i$$$ is stored in cell $$$H \\cdot W + i$$$. The inputs of instruction $$$i$$$ can only be cells that store either pixels or outputs of previous instructions, i.e. cells $$$0$$$ to $$$H \\cdot W + i - 1$$$.\nThere are four types of instructions:\nNOT\n: has exactly one input. Its output is $$$1$$$ if the input is $$$0$$$, otherwise its output is $$$0$$$.\nAND\n: has one or more inputs. Its output is $$$1$$$ if and only if\nall\nof the inputs are $$$1$$$.\nOR\n: has one or more inputs. Its output is $$$1$$$ if and only if\nat least one\nof the inputs is $$$1$$$.\nXOR\n: has one or more inputs. Its output is $$$1$$$ if and only if an\nodd number\nof the inputs are $$$1$$$.\nThe output of the last instruction of the program should be $$$1$$$ if the distance between the two black pixels is exactly $$$K$$$, and $$$0$$$ otherwise.\nImplementation details\nYou should implement the following procedure:\nvoid construct_network(int H, int W, int K)\n$$$H, W$$$: dimensions of each image taken by the robot's camera\n$$$K$$$: a positive integer\nThis procedure should produce a robot's program. For any image taken by the robot's camera, this program should determine whether the distance between the two black pixels in the image is exactly $$$K$$$.\nThis procedure should call one or more of the following procedures to append instructions to the robot's program (which is initially empty):\nint add_not(int N)\nint add_and(int[] Ns)\nint add_or(int[] Ns)\nint add_xor(int[] Ns)\nAppend a\nNOT\n,\nAND\n,\nOR\n, or\nXOR\ninstruction, respectively.\n$$$N$$$ (for\nadd_not\n): the index of the cell from which the appended\nNOT\ninstruction reads its input\n$$$Ns$$$ (for\nadd_and\n,\nadd_or\n,\nadd_xor\n): array containing the indices of the cells from which the appended\nAND\n,\nOR\n, or\nXOR\ninstruction reads its inputs\nEach procedure returns the index of the cell that stores the output of the instruction. The consecutive calls to these procedures return consecutive integers starting from $$$H \\cdot W$$$.\nThe robot's program can consist of at most $$$10\\,000$$$ instructions. The instructions can read at most $$$1\\,000\\,000$$$ values in total. In other words, the total length of $$$Ns$$$ arrays in all calls to\nadd_and\n,\nadd_or\nand\nadd_xor\nplus the number of calls to\nadd_not\ncannot exceed $$$1\\,000\\,000$$$.\nAfter appending the last instruction, procedure\nconstruct_network\nshould return. The robot's program will then be evaluated on some number of images. Your solution passes a given test case if for each of these images, the output of the last instruction is $$$1$$$ if and only if the distance between the two black pixels in the image is equal to $$$K$$$.\nThe grading of your solution may result in one of the following error messages:\nInstruction with no inputs\n: an empty array was given as the input to\nadd_and\n,\nadd_or\n, or\nadd_xor\n.\nInvalid index\n: an incorrect (possibly negative) cell index was provided as the input to\nadd_and\n,\nadd_or\n,\nadd_xor\n, or\nadd_not\n.\nToo many instructions\n: your procedure attempted to add more than $$$10\\,000$$$ instructions.\nToo many inputs\n: the instructions read more than $$$1\\,000\\,000$$$ values in total.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$H$$$ $$$W$$$ $$$K$$$ ($$$1 \\leq H, W \\leq 200$$$, $$$2 \\leq H \\cdot W$$$, $$$1 \\leq K \\leq H+W-2$$$)\nline $$$2+i$$$ $$$(i \\geq 0)$$$: $$$r_1[i]$$$ $$$c_1[i]$$$ $$$r_2[i]$$$ $$$c_2[i]$$$\nlast line: $$$-1$$$\nEach line excepting the first and the last line represents an image with two black pixels. We denote the image described in line $$$2+i$$$ by image $$$i$$$. One black pixel is in row $$$r_1[i]$$$ and column $$$c_1[i]$$$ and the other one in row $$$r_2[i]$$$ and column $$$c_2[i]$$$.\nOutput\nThe sample grader first calls\nconstruct_network(H, W, K)\n. If\nconstruct_network\nviolates some constraint described in the problem statement, the sample grader prints one of the error messages listed at the end of Implementation details section and exits.\nOtherwise, the sample grader produces two outputs.\nFirst, the sample grader prints the output of the robot's program in the following format:\nline $$$1+i$$$ $$$(0 \\leq i)$$$: output of the last instruction in the robot's program for image $$$i$$$ ($$$1$$$ or $$$0$$$).\nSecond, the sample grader writes a file 'log.txt' in the current directory in the following format:\nline $$$1+i$$$ $$$(0 \\leq i)$$$: $$$m[i][0], m[i][1], \\ldots, m[i][c-1]$$$\nThe sequence on line $$$1+i$$$ describes the values stored in the robot's memory cells after the robot's program is run, given image $$$i$$$ as the input. Specifically, $$$m[i][j]$$$ gives the value of cell $$$j$$$. Note that the value of $$$c$$$ (the length of the sequence) is equal to $$$H \\cdot W$$$ plus the number of instructions in the robot's program.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$\\max(H, W) \\leq 3$$$\n2\n11\n$$$\\max(H, W) \\leq 10$$$\n3\n11\n$$$\\max(H, W) \\leq 30$$$\n4\n15\n$$$\\max(H, W) \\leq 100$$$\n5\n12\n$$$\\min(H, W)=1$$$\n6\n8\nPixel in row $$$0$$$ and column $$$0$$$ is black in each image.\n7\n14\n$$$K=1$$$\n8\n19\nno additional constraints\nExample\nNote\nAssume $$$H=2$$$, $$$W=3$$$, $$$K=3$$$. There are only two possible images where the distance between the black pixels is $$$3$$$.\nCase 1: black pixels are $$$0$$$ and $$$5$$$\nCase 2: black pixels are $$$2$$$ and $$$3$$$\nA possible solution is to build a robot's program by making the following calls:\nadd_and([0, 5])\n, which adds an instruction that outputs $$$1$$$ if and only if the first case holds. The output is stored in cell $$$6$$$.\nadd_and([2, 3])\n, which adds an instruction that outputs $$$1$$$ if and only if the second case holds. The output is stored in cell $$$7$$$.\nadd_or([6, 7])\n, which adds an instruction that outputs $$$1$$$ if and only if one of the cases above holds.",
    "_meta": {
      "index": 75,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/E",
      "uuid": "ps_75779beb668b791f327b53dcc5b7998220af9145"
    }
  },
  {
    "planning_view": {
      "title": "E. Highway Tolls",
      "task": "Find hidden cities S and T using ≤100 queries about shortest path costs",
      "given": [
        "N cities, M bidirectional highways forming connected graph",
        "Each highway has toll: A yen (light traffic) or B yen (heavy traffic)",
        "A < B are known, S and T are fixed hidden cities (S ≠ T)",
        "Machine computes shortest toll path between S and T"
      ],
      "goal": "Determine the hidden cities S and T",
      "key_rules": [
        "Max 100 calls to ask() function",
        "Traffic conditions must be binary (0/1) for all M highways",
        "Graph is connected, no multiple edges or self-loops",
        "Grader is non-adaptive: S and T are fixed at start"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "Tree graph (M=N-1), one of S or T is 0, N ≤ 100"
        },
        "2": {
          "points": 7,
          "req": "Tree graph (M=N-1), one of S or T is 0"
        },
        "3": {
          "points": 6,
          "req": "Path graph (M=N-1), consecutive edges"
        },
        "4": {
          "points": 33,
          "req": "Tree graph (M=N-1)"
        },
        "5": {
          "points": 18,
          "req": "A=1, B=2"
        },
        "6": {
          "points": 31,
          "req": "No additional restrictions, scoring depends on query count"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Highway Tolls",
      "contest": "IOI 2018 day 2",
      "one_line": "Find hidden cities S and T using ≤100 queries about shortest path costs",
      "given": [
        "N cities, M bidirectional highways forming connected graph",
        "Each highway has toll: A yen (light traffic) or B yen (heavy traffic)",
        "A < B are known, S and T are fixed hidden cities (S ≠ T)",
        "Machine computes shortest toll path between S and T"
      ],
      "goal": "Determine the hidden cities S and T",
      "mechanism": "Set traffic conditions (0/1 for light/heavy) on highways; machine returns min S-T toll",
      "success_condition": "Call answer(s,t) with correct S and T exactly once",
      "constraints": {
        "critical": [
          "Max 100 calls to ask() function",
          "Traffic conditions must be binary (0/1) for all M highways",
          "Graph is connected, no multiple edges or self-loops",
          "Grader is non-adaptive: S and T are fixed at start"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "Tree graph (M=N-1), one of S or T is 0, N ≤ 100"
          },
          "2": {
            "points": 7,
            "req": "Tree graph (M=N-1), one of S or T is 0"
          },
          "3": {
            "points": 6,
            "req": "Path graph (M=N-1), consecutive edges"
          },
          "4": {
            "points": 33,
            "req": "Tree graph (M=N-1)"
          },
          "5": {
            "points": 18,
            "req": "A=1, B=2"
          },
          "6": {
            "points": 31,
            "req": "No additional restrictions, scoring depends on query count"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Highway Tolls",
        "contest": "IOI 2018 day 2",
        "one_line": "Find hidden cities S and T using ≤100 queries about shortest path costs"
      },
      "problem": {
        "given": [
          "N cities, M bidirectional highways forming connected graph",
          "Each highway has toll: A yen (light traffic) or B yen (heavy traffic)",
          "A < B are known, S and T are fixed hidden cities (S ≠ T)",
          "Machine computes shortest toll path between S and T"
        ],
        "goal": "Determine the hidden cities S and T",
        "mechanism": "Set traffic conditions (0/1 for light/heavy) on highways; machine returns min S-T toll",
        "success_condition": "Call answer(s,t) with correct S and T exactly once"
      },
      "constraints": {
        "critical": [
          "Max 100 calls to ask() function",
          "Traffic conditions must be binary (0/1) for all M highways",
          "Graph is connected, no multiple edges or self-loops",
          "Grader is non-adaptive: S and T are fixed at start"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "Tree graph (M=N-1), one of S or T is 0, N ≤ 100"
          },
          "2": {
            "points": 7,
            "req": "Tree graph (M=N-1), one of S or T is 0"
          },
          "3": {
            "points": 6,
            "req": "Path graph (M=N-1), consecutive edges"
          },
          "4": {
            "points": 33,
            "req": "Tree graph (M=N-1)"
          },
          "5": {
            "points": 18,
            "req": "A=1, B=2"
          },
          "6": {
            "points": 31,
            "req": "No additional restrictions, scoring depends on query count"
          }
        }
      },
      "implementation": {
        "function_to_write": "void find_pair(int N, int[] U, int[] V, int A, int B)",
        "available_api": {
          "ask": {
            "signature": "int64 ask(int[] w)",
            "params": "w: array of length M with traffic conditions (0=light, 1=heavy)",
            "returns": "Minimum toll to travel from S to T under given traffic conditions",
            "side_effect": "Contributes to query count (max 100 total)"
          },
          "answer": {
            "signature": "void answer(int s, int t)",
            "params": "s, t: the hidden cities S and T (order doesn't matter)",
            "returns": "Nothing",
            "side_effect": "Must be called exactly once at the end"
          }
        },
        "requirements": [
          "Cities are 0-indexed (0 to N-1)",
          "Highways are given as parallel arrays U and V of length M",
          "A < B, both positive integers up to 1,000,000,000",
          "N up to 90,000, M up to 130,000"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      },
      "samples": [],
      "original_statement": "In Japan, cities are connected by a network of highways. This network consists of $$$N$$$ cities and $$$M$$$ highways. Each highway connects a pair of distinct cities. No two highways connect the same pair of cities. Cities are numbered from $$$0$$$ through $$$N-1,$$$ and highways are numbered from $$$0$$$ through $$$M-1.$$$ You can drive on any highway in both directions. You can travel from any city to any other city by using the highways.\nA toll is charged for driving on each highway. The toll for a highway depends on the\ntraffic\ncondition on the highway. The traffic is either\nlight\nor\nheavy\n. When the traffic is light, the toll is $$$A$$$ yen (Japanese currency). When the traffic is heavy, the toll is $$$B$$$ yen. It's guaranteed that $$$A < B.$$$ Note that you know the values of $$$A$$$ and $$$B.$$$\nYou have a machine which, given the traffic conditions of all highways, computes the smallest total toll that one has to pay to travel between the pair of cities $$$S$$$ and $$$T (S \\neq T),$$$ under the specified traffic conditions.\nHowever, the machine is just a prototype. The values of $$$S$$$ and $$$T$$$ are fixed (i.e., hardcoded in the machine) and not known to you. You would like to determine $$$S$$$ and $$$T.$$$ In order to do so, you plan to specify several traffic conditions to the machine, and use the toll values that it outputs to deduce $$$S$$$ and $$$T.$$$ Since specifying the traffic conditions is costly, you don't want to use the machine many times.\nImplementation details\nYou should implement the following procedure:\nfind_pair(int N, int[] U, int[] V, int A, int B)\n$$$N$$$: the number of cities.\n$$$U$$$ and $$$V$$$: arrays of length $$$M,$$$ where $$$M$$$ is the number of highways connecting cities. For each $$$i : 0 \\le i \\le M-1,$$$ the highway $$$i$$$ connects the cities $$$U[i]$$$ and $$$V[i].$$$\n$$$A$$$: the toll for a highway when the traffic is light.\n$$$B$$$: the toll for a highway when the traffic is heavy.\nThis procedure is called exactly once for each test case.\nNote that the value of $$$M$$$ is the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nint64 ask(int[] w)\nThe length of $$$w$$$ must be $$$M.$$$ The array $$$w$$$ describes the traffic conditions.\nFor each $$$i: 0 \\le i \\le M-1, w[i]$$$ gives the traffic condition on the highway $$$i.$$$ The value of $$$w[i]$$$ must be either $$$0$$$ or $$$1.$$$\n$$$w[i] = 0$$$ means the traffic of the highway $$$i$$$ is light.\n$$$w[i] = 1$$$ means the traffic of the highway $$$i$$$ is heavy.\nThis function returns the smallest total toll for travelling between the cities $$$S$$$ and $$$T,$$$ under the traffic conditions specified by $$$w.$$$\nThis function can be called at most $$$100$$$ times (for each test case).\nfind_pair\nshould call the following procedure to report the answer:\nanswer(int s, int t)\ns\nand\nt\nmust be the pair $$$S$$$ and $$$T$$$ (the order does not matter).\nThis procedure must be called exactly once.\nIf some of the above conditions are not satisfied, your program is judged as\nWrong Answer\n. Otherwise, your program is judged as\nAccepted\nand your score is calculated by the number of calls to\nask\n(see Subtasks).\nConstraints\n$$$2 \\le N \\le 90\\,000$$$\n$$$1 \\le M \\le 130\\,000$$$\n$$$1 \\le A < B \\le 1\\,000\\,000\\,000$$$\nFor each $$$i: 0 \\le i M-1$$$\n$$$0 \\le U[i] \\le N-1$$$\n$$$0 \\le V[i] \\le N-1$$$\n$$$U[i] \\neq V[i]$$$\n$$$(U[i], V[i]) \\neq (U[j], V[j])$$$ and $$$(U[i], V[j]) \\neq (V[j], U[j])$$$ for all $$$i,j: 0 \\le i < j \\le M-1$$$\nYou can travel from any city to any other city by using the highways.\n$$$0 \\le S \\le N-1$$$\n$$$0 \\le T \\le N-1$$$\n$$$S \\neq T$$$\nIn this problem, the grader is NOT adaptive. This means that $$$S$$$ and $$$T$$$ are fixed at the beginning of the running of the grader and they do not depend on the queries asked by your solution.\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$1$$$\n:\n$$$N$$$ $$$M$$$ $$$A$$$ $$$B$$$ $$$S$$$ $$$T$$$\nline\n$$$2+i$$$\n:\n$$$U[i]$$$ $$$V[i]$$$\n$$$(0 \\le i \\le M-1)$$$\nIf your program is judged as\nAccepted\n, the sample grader prints\nAccepted: q\n, with $$$q$$$ the number of calls to\nask\n.\nIf your program is judged as\nWrong Answer\n, it prints\nWrong Answer: MSG\n, where\nMSG\nis one of:\nanswered not exactly once\n: The procedure answer was not called exactly once.\nw is invalid\n: The length of $$$w$$$ given to\nask\nis not $$$M$$$ or $$$w[i]$$$ is neither $$$0$$$ nor $$$1$$$ for some $$$i: 0 \\le i \\le M-1.$$$\nmore than 100 calls to ask\n: The function\nask\nis called more than $$$100$$$ times.\n{s, t} is wrong\n: The procedure\nanswer\nis called with an incorrect pair $$$s$$$ and $$$t.$$$\nScoring\nSubtasks\nSubtask\nPoints (max)\nAdditional constraints\n$$$1$$$\n$$$5$$$\n$$$M=N-1,$$$ one of $$$S$$$ or $$$T$$$ is $$$0,$$$ $$$N \\le 100$$$\n$$$2$$$\n$$$7$$$\n$$$M=N-1,$$$ one of $$$S$$$ or $$$T$$$ is $$$0$$$\n$$$3$$$\n$$$6$$$\n$$$M=N-1,$$$ $$$U[i] = i,$$$ $$$V[i] = i+1$$$ for all $$$i: 0\\le i \\le M-1$$$\n$$$4$$$\n$$$33$$$\n$$$M=N-1$$$\n$$$5$$$\n$$$18$$$\n$$$A=1,$$$ $$$B=2$$$\n$$$6$$$\n$$$31$$$\nNo\nAssume your program is judged as\nAccepted\n, and makes $$$X$$$ calls to\nask\n. Then your score for $$$P$$$ the test case, depending on its subtask number, is calculated as follows:\nSubtask 1\n$$$P=5$$$\nSubtask 2\nIf $$$X \\le 60,$$$\n$$$P=7.$$$\nOtherwise $$$P=0.$$$\nSubtask 3\nIf $$$X \\le 60,$$$\n$$$P=6.$$$\nOtherwise $$$P=0.$$$\nSubtask 4\nIf $$$X \\le 60,$$$\n$$$P=33.$$$\nOtherwise $$$P=0.$$$\nSubtask 5\nIf $$$X \\le 52,$$$\n$$$P=18.$$$\nOtherwise $$$P=0.$$$\nSubtask 6\nIf $$$X \\le 50,$$$\n$$$P=31.$$$\nIf $$$51\\le X\\le 52, P=21.$$$\nOtherwise $$$P=0.$$$\nNote that your score for each subtask is the minimum of the scores for the test cases in the subtask.\nNote\nExample\nLet $$$N=4,$$$ $$$M=4,$$$ $$$U=[0,0,0,1],$$$ $$$V=[1,2,3,2],$$$ $$$A=1,$$$ $$$B=3,$$$ $$$S=1,$$$ and $$$T=3.$$$\nThe grader calls\nfind_pair(4, [0, 0, 0, 1], [1, 2, 3, 2], 1, 3).\nIn the figure above, the edge with number i corresponds to the highway i. Some possible calls to\nask\nand the corresponding return values are listed below:\nCall\nReturn\nask([0, 0, 0, 0])\n$$$2$$$\nask([0, 1, 1, 0])\n$$$4$$$\nask([1, 0, 1, 0])\n$$$5$$$\nask([1, 1, 1, 1])\n$$$6$$$\nFor the function call\nask([0, 0, 0, 0])\n, the traffic of each highway is light and the toll for each highway is $$$1.$$$ The cheapest route from $$$S=1$$$ to $$$T=3$$$ is $$$1 \\rightarrow 0 \\rightarrow 3.$$$ The total toll for this route is $$$2.$$$ Thus, this function returns $$$2.$$$\nFor a correct answer, the procedure\nfind_pair\nshould call\nanswer(1, 3)\nor\nanswer(3, 1)\n.\nThe file\nsample-01-in.txt\nin the zipped attachment package corresponds to this example. Other sample inputs are also available in the package."
    },
    "original": "In Japan, cities are connected by a network of highways. This network consists of $$$N$$$ cities and $$$M$$$ highways. Each highway connects a pair of distinct cities. No two highways connect the same pair of cities. Cities are numbered from $$$0$$$ through $$$N-1,$$$ and highways are numbered from $$$0$$$ through $$$M-1.$$$ You can drive on any highway in both directions. You can travel from any city to any other city by using the highways.\nA toll is charged for driving on each highway. The toll for a highway depends on the\ntraffic\ncondition on the highway. The traffic is either\nlight\nor\nheavy\n. When the traffic is light, the toll is $$$A$$$ yen (Japanese currency). When the traffic is heavy, the toll is $$$B$$$ yen. It's guaranteed that $$$A < B.$$$ Note that you know the values of $$$A$$$ and $$$B.$$$\nYou have a machine which, given the traffic conditions of all highways, computes the smallest total toll that one has to pay to travel between the pair of cities $$$S$$$ and $$$T (S \\neq T),$$$ under the specified traffic conditions.\nHowever, the machine is just a prototype. The values of $$$S$$$ and $$$T$$$ are fixed (i.e., hardcoded in the machine) and not known to you. You would like to determine $$$S$$$ and $$$T.$$$ In order to do so, you plan to specify several traffic conditions to the machine, and use the toll values that it outputs to deduce $$$S$$$ and $$$T.$$$ Since specifying the traffic conditions is costly, you don't want to use the machine many times.\nImplementation details\nYou should implement the following procedure:\nfind_pair(int N, int[] U, int[] V, int A, int B)\n$$$N$$$: the number of cities.\n$$$U$$$ and $$$V$$$: arrays of length $$$M,$$$ where $$$M$$$ is the number of highways connecting cities. For each $$$i : 0 \\le i \\le M-1,$$$ the highway $$$i$$$ connects the cities $$$U[i]$$$ and $$$V[i].$$$\n$$$A$$$: the toll for a highway when the traffic is light.\n$$$B$$$: the toll for a highway when the traffic is heavy.\nThis procedure is called exactly once for each test case.\nNote that the value of $$$M$$$ is the lengths of the arrays, and can be obtained as indicated in the implementation notice.\nint64 ask(int[] w)\nThe length of $$$w$$$ must be $$$M.$$$ The array $$$w$$$ describes the traffic conditions.\nFor each $$$i: 0 \\le i \\le M-1, w[i]$$$ gives the traffic condition on the highway $$$i.$$$ The value of $$$w[i]$$$ must be either $$$0$$$ or $$$1.$$$\n$$$w[i] = 0$$$ means the traffic of the highway $$$i$$$ is light.\n$$$w[i] = 1$$$ means the traffic of the highway $$$i$$$ is heavy.\nThis function returns the smallest total toll for travelling between the cities $$$S$$$ and $$$T,$$$ under the traffic conditions specified by $$$w.$$$\nThis function can be called at most $$$100$$$ times (for each test case).\nfind_pair\nshould call the following procedure to report the answer:\nanswer(int s, int t)\ns\nand\nt\nmust be the pair $$$S$$$ and $$$T$$$ (the order does not matter).\nThis procedure must be called exactly once.\nIf some of the above conditions are not satisfied, your program is judged as\nWrong Answer\n. Otherwise, your program is judged as\nAccepted\nand your score is calculated by the number of calls to\nask\n(see Subtasks).\nConstraints\n$$$2 \\le N \\le 90\\,000$$$\n$$$1 \\le M \\le 130\\,000$$$\n$$$1 \\le A < B \\le 1\\,000\\,000\\,000$$$\nFor each $$$i: 0 \\le i M-1$$$\n$$$0 \\le U[i] \\le N-1$$$\n$$$0 \\le V[i] \\le N-1$$$\n$$$U[i] \\neq V[i]$$$\n$$$(U[i], V[i]) \\neq (U[j], V[j])$$$ and $$$(U[i], V[j]) \\neq (V[j], U[j])$$$ for all $$$i,j: 0 \\le i < j \\le M-1$$$\nYou can travel from any city to any other city by using the highways.\n$$$0 \\le S \\le N-1$$$\n$$$0 \\le T \\le N-1$$$\n$$$S \\neq T$$$\nIn this problem, the grader is NOT adaptive. This means that $$$S$$$ and $$$T$$$ are fixed at the beginning of the running of the grader and they do not depend on the queries asked by your solution.\nSample grader\nThe sample grader reads the input in the following format:\nline\n$$$1$$$\n:\n$$$N$$$ $$$M$$$ $$$A$$$ $$$B$$$ $$$S$$$ $$$T$$$\nline\n$$$2+i$$$\n:\n$$$U[i]$$$ $$$V[i]$$$\n$$$(0 \\le i \\le M-1)$$$\nIf your program is judged as\nAccepted\n, the sample grader prints\nAccepted: q\n, with $$$q$$$ the number of calls to\nask\n.\nIf your program is judged as\nWrong Answer\n, it prints\nWrong Answer: MSG\n, where\nMSG\nis one of:\nanswered not exactly once\n: The procedure answer was not called exactly once.\nw is invalid\n: The length of $$$w$$$ given to\nask\nis not $$$M$$$ or $$$w[i]$$$ is neither $$$0$$$ nor $$$1$$$ for some $$$i: 0 \\le i \\le M-1.$$$\nmore than 100 calls to ask\n: The function\nask\nis called more than $$$100$$$ times.\n{s, t} is wrong\n: The procedure\nanswer\nis called with an incorrect pair $$$s$$$ and $$$t.$$$\nScoring\nSubtasks\nSubtask\nPoints (max)\nAdditional constraints\n$$$1$$$\n$$$5$$$\n$$$M=N-1,$$$ one of $$$S$$$ or $$$T$$$ is $$$0,$$$ $$$N \\le 100$$$\n$$$2$$$\n$$$7$$$\n$$$M=N-1,$$$ one of $$$S$$$ or $$$T$$$ is $$$0$$$\n$$$3$$$\n$$$6$$$\n$$$M=N-1,$$$ $$$U[i] = i,$$$ $$$V[i] = i+1$$$ for all $$$i: 0\\le i \\le M-1$$$\n$$$4$$$\n$$$33$$$\n$$$M=N-1$$$\n$$$5$$$\n$$$18$$$\n$$$A=1,$$$ $$$B=2$$$\n$$$6$$$\n$$$31$$$\nNo\nAssume your program is judged as\nAccepted\n, and makes $$$X$$$ calls to\nask\n. Then your score for $$$P$$$ the test case, depending on its subtask number, is calculated as follows:\nSubtask 1\n$$$P=5$$$\nSubtask 2\nIf $$$X \\le 60,$$$\n$$$P=7.$$$\nOtherwise $$$P=0.$$$\nSubtask 3\nIf $$$X \\le 60,$$$\n$$$P=6.$$$\nOtherwise $$$P=0.$$$\nSubtask 4\nIf $$$X \\le 60,$$$\n$$$P=33.$$$\nOtherwise $$$P=0.$$$\nSubtask 5\nIf $$$X \\le 52,$$$\n$$$P=18.$$$\nOtherwise $$$P=0.$$$\nSubtask 6\nIf $$$X \\le 50,$$$\n$$$P=31.$$$\nIf $$$51\\le X\\le 52, P=21.$$$\nOtherwise $$$P=0.$$$\nNote that your score for each subtask is the minimum of the scores for the test cases in the subtask.\nNote\nExample\nLet $$$N=4,$$$ $$$M=4,$$$ $$$U=[0,0,0,1],$$$ $$$V=[1,2,3,2],$$$ $$$A=1,$$$ $$$B=3,$$$ $$$S=1,$$$ and $$$T=3.$$$\nThe grader calls\nfind_pair(4, [0, 0, 0, 1], [1, 2, 3, 2], 1, 3).\nIn the figure above, the edge with number i corresponds to the highway i. Some possible calls to\nask\nand the corresponding return values are listed below:\nCall\nReturn\nask([0, 0, 0, 0])\n$$$2$$$\nask([0, 1, 1, 0])\n$$$4$$$\nask([1, 0, 1, 0])\n$$$5$$$\nask([1, 1, 1, 1])\n$$$6$$$\nFor the function call\nask([0, 0, 0, 0])\n, the traffic of each highway is light and the toll for each highway is $$$1.$$$ The cheapest route from $$$S=1$$$ to $$$T=3$$$ is $$$1 \\rightarrow 0 \\rightarrow 3.$$$ The total toll for this route is $$$2.$$$ Thus, this function returns $$$2.$$$\nFor a correct answer, the procedure\nfind_pair\nshould call\nanswer(1, 3)\nor\nanswer(3, 1)\n.\nThe file\nsample-01-in.txt\nin the zipped attachment package corresponds to this example. Other sample inputs are also available in the package.",
    "_meta": {
      "index": 76,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/E",
      "uuid": "ps_f1e9d47e646536b9442c3f8efdd3d5e0c1afab7c"
    }
  },
  {
    "planning_view": {
      "title": "B. Longest Trip",
      "task": "Find longest path in dense graph (δ≥D) using ≤32,640 connectivity queries",
      "given": [
        "N landmarks (0 to N-1)",
        "Undirected graph with density ≥ D (1≤D≤3)",
        "Density: every triplet has ≥ δ roads among them"
      ],
      "goal": "Return sequence of landmarks forming a longest trip (path)",
      "key_rules": [
        "Density guarantee: D=1 (any), D=2 (2+ roads per triplet), D=3 (complete)",
        "Query limits: ≤32,640 calls per longest_trip(), ≤150,000 total",
        "Total elements in queries ≤1,500,000",
        "Arrays A and B must be non-empty, disjoint, contain distinct landmarks"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "D=3 (complete graph), must find actual longest path"
        },
        "2": {
          "points": 10,
          "req": "D=2 (dense), must find actual longest path"
        },
        "3": {
          "points": 25,
          "req": "D=1 (any), path length ≥ ⌈l*/2⌉ where l*=optimal"
        },
        "4": {
          "points": 60,
          "req": "D=1, scoring depends on query count (60pts for ≤400 queries)"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Longest Trip",
      "contest": "IOI 2023 day 1",
      "one_line": "Find longest path in dense graph (δ≥D) using ≤32,640 connectivity queries",
      "given": [
        "N landmarks (0 to N-1)",
        "Undirected graph with density ≥ D (1≤D≤3)",
        "Density: every triplet has ≥ δ roads among them"
      ],
      "goal": "Return sequence of landmarks forming a longest trip (path)",
      "mechanism": "Query are_connected(A,B) to check connectivity between landmark sets",
      "success_condition": "Output sequence must be valid path; quality affects scoring",
      "constraints": {
        "critical": [
          "Density guarantee: D=1 (any), D=2 (2+ roads per triplet), D=3 (complete)",
          "Query limits: ≤32,640 calls per longest_trip(), ≤150,000 total",
          "Total elements in queries ≤1,500,000",
          "Arrays A and B must be non-empty, disjoint, contain distinct landmarks"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "D=3 (complete graph), must find actual longest path"
          },
          "2": {
            "points": 10,
            "req": "D=2 (dense), must find actual longest path"
          },
          "3": {
            "points": 25,
            "req": "D=1 (any), path length ≥ ⌈l*/2⌉ where l*=optimal"
          },
          "4": {
            "points": 60,
            "req": "D=1, scoring depends on query count (60pts for ≤400 queries)"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Longest Trip",
        "contest": "IOI 2023 day 1",
        "one_line": "Find longest path in dense graph (δ≥D) using ≤32,640 connectivity queries"
      },
      "problem": {
        "given": [
          "N landmarks (0 to N-1)",
          "Undirected graph with density ≥ D (1≤D≤3)",
          "Density: every triplet has ≥ δ roads among them"
        ],
        "goal": "Return sequence of landmarks forming a longest trip (path)",
        "mechanism": "Query are_connected(A,B) to check connectivity between landmark sets",
        "success_condition": "Output sequence must be valid path; quality affects scoring"
      },
      "constraints": {
        "critical": [
          "Density guarantee: D=1 (any), D=2 (2+ roads per triplet), D=3 (complete)",
          "Query limits: ≤32,640 calls per longest_trip(), ≤150,000 total",
          "Total elements in queries ≤1,500,000",
          "Arrays A and B must be non-empty, disjoint, contain distinct landmarks"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "D=3 (complete graph), must find actual longest path"
          },
          "2": {
            "points": 10,
            "req": "D=2 (dense), must find actual longest path"
          },
          "3": {
            "points": 25,
            "req": "D=1 (any), path length ≥ ⌈l*/2⌉ where l*=optimal"
          },
          "4": {
            "points": 60,
            "req": "D=1, scoring depends on query count (60pts for ≤400 queries)"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] longest_trip(int N, int D)",
        "available_api": {
          "are_connected": {
            "signature": "bool are_connected(int[] A, int[] B)",
            "params": "A, B: non-empty arrays of distinct landmarks, must be disjoint",
            "returns": "true if any landmark in A connects to any in B",
            "side_effect": "Consumes from query limit and element count"
          }
        },
        "requirements": [
          "Landmarks are 0-indexed (0 to N-1)",
          "Arrays must contain distinct elements within and between A and B",
          "Must handle multiple invocations (C scenarios)",
          "Total N over all calls ≤ 1024"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "The IOI 2023 organizers are in big trouble! They forgot to plan the trip to Ópusztaszer for the upcoming day. But maybe it is not yet too late ...\nThere are $$$N$$$ landmarks at Ópusztaszer indexed from $$$0$$$ to $$$N-1$$$. Some pairs of these landmarks are connected by\nbidirectional\nroads\n. Each pair of landmarks is connected by at most one road. The organizers\ndon't know\nwhich landmarks are connected by roads.\nWe say that the\ndensity\nof the road network at Ópusztaszer is\nat least\n$$$\\delta$$$ if every $$$3$$$ distinct landmarks have at least $$$\\delta$$$ roads among them. In other words, for each triplet of landmarks $$$(u, v, w)$$$ such that $$$0 \\le u < v < w < N$$$, among the pairs of landmarks $$$(u,v), (v,w)$$$ and $$$(u,w)$$$ at least $$$\\delta$$$ pairs are connected by a road.\nThe organizers\nknow\na positive integer $$$D$$$ such that the density of the road network is at least $$$D$$$. Note that the value of $$$D$$$ cannot be greater than $$$3$$$.\nThe organizers can make\ncalls\nto the phone dispatcher at Ópusztaszer to gather information about the road connections between certain landmarks. In each call, two nonempty arrays of landmarks $$$[A[0], \\ldots, A[P-1]]$$$ and $$$[B[0], \\ldots, B[R-1]]$$$ must be specified. The landmarks must be pairwise distinct, that is,\n$$$A[i] \\neq A[j]$$$ for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i < j < P$$$;\n$$$B[i] \\neq B[j]$$$ for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i < j < R$$$;\n$$$A[i] \\neq B[j]$$$ for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i < P$$$ and $$$0\\le j < R$$$.\nFor each call, the dispatcher reports whether there is a road connecting a landmark from $$$A$$$ and a landmark from $$$B$$$. More precisely, the dispatcher iterates over all pairs $$$i$$$ and $$$j$$$ such that $$$0 \\le i < P$$$ and $$$0\\le j < R$$$. If, for any of them, the landmarks $$$A[i]$$$ and $$$B[j]$$$ are connected by a road, the dispatcher returns\ntrue\n. Otherwise, the dispatcher returns\nfalse\n.\nA\ntrip\nof length $$$l$$$ is a sequence of\ndistinct\nlandmarks $$$t[0], t[1], \\ldots, t[l-1]$$$, where for each $$$i$$$ between $$$0$$$ and $$$l-2$$$, inclusive, landmark $$$t[i]$$$ and landmark $$$t[i+1]$$$ are connected by a road. A trip of length $$$l$$$ is called a\nlongest trip\nif there does not exist any trip of length at least $$$l+1$$$.\nYour task is to help the organizers to find a longest trip at Ópusztaszer by making calls to the dispatcher.\nImplementation Details\nYou should implement the following procedure:\nint[] longest_trip(int N, int D)\n$$$N$$$: the number of landmarks at Ópusztaszer.\n$$$D$$$: the guaranteed minimum density of the road network.\nThis procedure should return an array $$$t = [t[0], t[1], \\ldots, t[l-1]]$$$, representing a longest trip.\nThis procedure may be called\nmultiple times\nin each test case.\nThe above procedure can make calls to the following procedure:\nbool are_connected(int[] A, int[] B)\n$$$A$$$: a nonempty array of distinct landmarks.\n$$$B$$$: a nonempty array of distinct landmarks.\n$$$A$$$ and $$$B$$$ should be disjoint.\nThis procedure returns\ntrue\nif there is a landmark from $$$A$$$ and a landmark from $$$B$$$ connected by a road. Otherwise, it returns\nfalse\n.\nThis procedure can be called at most $$$32\\,640$$$ times in each invocation of\nlongest_trip\n, and at most $$$150\\,000$$$ times in total.\nThe total length of arrays $$$A$$$ and $$$B$$$ passed to this procedure over all of its invocations cannot exceed $$$1\\,500\\,000$$$.\nThe grader is\nnot adaptive\n. Each submission is graded on the same set of test cases. That is, the values of $$$N$$$ and $$$D$$$, as well as the pairs of landmarks connected by roads, are fixed for each call of\nlongest_trip\nwithin each test case.\nInput\nLet $$$C$$$ denote the number of scenarios, that is, the number of calls to\nlongest_trip\n. The sample grader reads the input in the following format:\nline $$$1$$$: $$$C$$$\nThe descriptions of $$$C$$$ scenarios follow.\nThe sample grader reads the description of each scenario in the following format:\nline $$$1$$$: $$$N \\; D$$$ ($$$3 \\le N \\le 256$$$, $$$1 \\le D \\le 3$$$)\nline $$$1 + i$$$ ($$$1 \\le i < N$$$): $$$U_i[0] \\; U_i[1] \\; \\ldots \\; U_i[i-1]$$$\nThe sum of $$$N$$$ over all calls to\nlongest_trip\ndoes not exceed $$$1\\,024$$$ in each test case.\nHere, each $$$U_i$$$ ($$$1 \\le i < N$$$) is an array of size $$$i$$$, describing which pairs of landmarks are connected by a road. For each $$$i$$$ and $$$j$$$ such that $$$1 \\le i < N$$$ and $$$0 \\le j < i$$$:\nif landmarks $$$j$$$ and $$$i$$$ are connected by a road, then the value of $$$U_i[j]$$$ should be $$$1$$$;\nif there is no road connecting landmarks $$$j$$$ and $$$i$$$, then the value of $$$U_i[j]$$$ should be $$$0$$$.\nOutput\nIn each scenario, before calling\nlongest_trip\n, the sample grader checks whether the density of the road network is at least $$$D$$$. If this condition is not met, it prints the message\nInsufficient Density\nand terminates.\nIf the sample grader detects a protocol violation, the output of the sample grader is\nProtocol Violation: <MSG>\n, where\n<MSG>\nis one of the following error messages:\ninvalid array\n: in a call to\nare_connected\n, at least one of arrays $$$A$$$ and $$$B$$$\nis empty, or\ncontains an element that is not an integer between $$$0$$$ and $$$N-1$$$, inclusive, or\ncontains the same element at least twice.\nnon-disjoint arrays\n: in a call to\nare_connected\n, arrays $$$A$$$ and $$$B$$$ are not disjoint.\ntoo many calls\n: the number of calls made to\nare_connected\nexceeds $$$32\\,640$$$ over the current invocation of\nlongest trip\n, or exceeds $$$150\\,000$$$ in total.\ntoo many elements\n: the total number of landmarks passed to\nare_connected\nover all calls exceeds $$$1\\,500\\,000$$$.\nOtherwise, let the elements of the array returned by\nlongest_trip\nin a scenario be $$$t[0], t[1], \\ldots, t[l - 1]$$$ for some nonnegative $$$l$$$. The sample grader prints three lines for this scenario in the following format:\nline $$$1$$$: $$$l$$$\nline $$$2$$$: $$$t[0] \\; t[1] \\; \\ldots \\; t[l-1]$$$\nline $$$3$$$: the number of calls to\nare_connected\nover this scenario\nFinally, the sample grader prints:\nline $$$1 + 3 \\cdot C$$$: the maximum number of calls to\nare_connected\nover all calls to\nlongest_trip\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$D = 3$$$\n2\n10\n$$$D = 2$$$\n3\n25\n$$$D = 1$$$. Let $$$l^\\star$$$ denote the length of a longest trip.  Procedure\nlongest_trip\ndoes not have to return a trip of length $$$l^\\star$$$.  Instead, it should return a trip of length at least $$$\\left\\lceil \\frac{l^\\star}{2} \\right\\rceil$$$.\n4\n60\n$$$D = 1$$$\nIn subtask 4 your score is determined based on the number of calls to procedure\nare_connected\nover a single invocation of\nlongest_trip\n. Let $$$q$$$ be the maximum number of calls among all invocations of\nlongest_trip\nover every test case of the subtask. Your score for this subtask is calculated according to the following table:\nCondition\nPoints\n$$$2\\,750 < q \\le 32\\,640$$$\n$$$20$$$\n$$$550 < q \\le 2\\,750$$$\n$$$30$$$\n$$$400 < q \\le 550$$$\n$$$45$$$\n$$$q \\le 400$$$\n$$$60$$$\nIf, in any of the test cases, the calls to the procedure\nare_connected\ndo not conform to the constraints described in\nImplementation Details\n, or the array returned by\nlongest_trip\nis incorrect, the score of your solution for that subtask will be $$$0$$$.\nNote\nExample 1\nConsider a scenario in which $$$N = 5$$$, $$$D = 1$$$, and the road connections are as shown in the following figure:\nThe procedure\nlongest_trip\nis called in the following way:\nlongest_trip(5, 1)\nThe procedure may make calls to\nare_connected\nas follows.\nCall\nPairs connected by a road\nReturn value\nare_connected([0], [1, 2, 4, 3])\n$$$(0,1)$$$ and $$$(0,2)$$$\ntrue\nare_connected([2], [0])\n$$$(2,0)$$$\ntrue\nare_connected([2], [3])\n$$$(2,3)$$$\ntrue\nare_connected([1, 0], [4, 3])\nnone\nfalse\nAfter the fourth call, it turns out that\nnone\nof the pairs $$$(1,4)$$$, $$$(0,4)$$$, $$$(1,3)$$$ and $$$(0,3)$$$ is connected by a road. As the density of the network is at least $$$D = 1$$$, we see that from the triplet $$$(0, 3, 4)$$$, the pair $$$(3,4)$$$ must be connected by a road. Similarly to this, landmarks $$$0$$$ and $$$1$$$ must be connected.\nAt this point, it can be concluded that $$$t = [1, 0, 2, 3, 4]$$$ is a trip of length $$$5$$$, and that there does not exist a trip of length greater than $$$5$$$. Therefore, the procedure\nlongest_trip\nmay return $$$[1, 0, 2, 3, 4]$$$.\nConsider another scenario in which $$$N = 4$$$, $$$D = 1$$$, and the roads between the landmarks are as shown in the following figure:\nThe procedure\nlongest_trip\nis called in the following way:\nlongest_trip(4, 1)\nIn this scenario, the length of a longest trip is $$$2$$$. Therefore, after a few calls to procedure\nare_connected\n, the procedure\nlongest_trip\nmay return one of $$$[0, 1]$$$, $$$[1, 0]$$$, $$$[2, 3]$$$ or $$$[3, 2]$$$.\nExample 2\nSubtask 0 contains an additional example test case with $$$N=256$$$ landmarks. This test case is included in the attachment package that you can download from the contest system."
    },
    "original": "The IOI 2023 organizers are in big trouble! They forgot to plan the trip to Ópusztaszer for the upcoming day. But maybe it is not yet too late ...\nThere are $$$N$$$ landmarks at Ópusztaszer indexed from $$$0$$$ to $$$N-1$$$. Some pairs of these landmarks are connected by\nbidirectional\nroads\n. Each pair of landmarks is connected by at most one road. The organizers\ndon't know\nwhich landmarks are connected by roads.\nWe say that the\ndensity\nof the road network at Ópusztaszer is\nat least\n$$$\\delta$$$ if every $$$3$$$ distinct landmarks have at least $$$\\delta$$$ roads among them. In other words, for each triplet of landmarks $$$(u, v, w)$$$ such that $$$0 \\le u < v < w < N$$$, among the pairs of landmarks $$$(u,v), (v,w)$$$ and $$$(u,w)$$$ at least $$$\\delta$$$ pairs are connected by a road.\nThe organizers\nknow\na positive integer $$$D$$$ such that the density of the road network is at least $$$D$$$. Note that the value of $$$D$$$ cannot be greater than $$$3$$$.\nThe organizers can make\ncalls\nto the phone dispatcher at Ópusztaszer to gather information about the road connections between certain landmarks. In each call, two nonempty arrays of landmarks $$$[A[0], \\ldots, A[P-1]]$$$ and $$$[B[0], \\ldots, B[R-1]]$$$ must be specified. The landmarks must be pairwise distinct, that is,\n$$$A[i] \\neq A[j]$$$ for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i < j < P$$$;\n$$$B[i] \\neq B[j]$$$ for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i < j < R$$$;\n$$$A[i] \\neq B[j]$$$ for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i < P$$$ and $$$0\\le j < R$$$.\nFor each call, the dispatcher reports whether there is a road connecting a landmark from $$$A$$$ and a landmark from $$$B$$$. More precisely, the dispatcher iterates over all pairs $$$i$$$ and $$$j$$$ such that $$$0 \\le i < P$$$ and $$$0\\le j < R$$$. If, for any of them, the landmarks $$$A[i]$$$ and $$$B[j]$$$ are connected by a road, the dispatcher returns\ntrue\n. Otherwise, the dispatcher returns\nfalse\n.\nA\ntrip\nof length $$$l$$$ is a sequence of\ndistinct\nlandmarks $$$t[0], t[1], \\ldots, t[l-1]$$$, where for each $$$i$$$ between $$$0$$$ and $$$l-2$$$, inclusive, landmark $$$t[i]$$$ and landmark $$$t[i+1]$$$ are connected by a road. A trip of length $$$l$$$ is called a\nlongest trip\nif there does not exist any trip of length at least $$$l+1$$$.\nYour task is to help the organizers to find a longest trip at Ópusztaszer by making calls to the dispatcher.\nImplementation Details\nYou should implement the following procedure:\nint[] longest_trip(int N, int D)\n$$$N$$$: the number of landmarks at Ópusztaszer.\n$$$D$$$: the guaranteed minimum density of the road network.\nThis procedure should return an array $$$t = [t[0], t[1], \\ldots, t[l-1]]$$$, representing a longest trip.\nThis procedure may be called\nmultiple times\nin each test case.\nThe above procedure can make calls to the following procedure:\nbool are_connected(int[] A, int[] B)\n$$$A$$$: a nonempty array of distinct landmarks.\n$$$B$$$: a nonempty array of distinct landmarks.\n$$$A$$$ and $$$B$$$ should be disjoint.\nThis procedure returns\ntrue\nif there is a landmark from $$$A$$$ and a landmark from $$$B$$$ connected by a road. Otherwise, it returns\nfalse\n.\nThis procedure can be called at most $$$32\\,640$$$ times in each invocation of\nlongest_trip\n, and at most $$$150\\,000$$$ times in total.\nThe total length of arrays $$$A$$$ and $$$B$$$ passed to this procedure over all of its invocations cannot exceed $$$1\\,500\\,000$$$.\nThe grader is\nnot adaptive\n. Each submission is graded on the same set of test cases. That is, the values of $$$N$$$ and $$$D$$$, as well as the pairs of landmarks connected by roads, are fixed for each call of\nlongest_trip\nwithin each test case.\nInput\nLet $$$C$$$ denote the number of scenarios, that is, the number of calls to\nlongest_trip\n. The sample grader reads the input in the following format:\nline $$$1$$$: $$$C$$$\nThe descriptions of $$$C$$$ scenarios follow.\nThe sample grader reads the description of each scenario in the following format:\nline $$$1$$$: $$$N \\; D$$$ ($$$3 \\le N \\le 256$$$, $$$1 \\le D \\le 3$$$)\nline $$$1 + i$$$ ($$$1 \\le i < N$$$): $$$U_i[0] \\; U_i[1] \\; \\ldots \\; U_i[i-1]$$$\nThe sum of $$$N$$$ over all calls to\nlongest_trip\ndoes not exceed $$$1\\,024$$$ in each test case.\nHere, each $$$U_i$$$ ($$$1 \\le i < N$$$) is an array of size $$$i$$$, describing which pairs of landmarks are connected by a road. For each $$$i$$$ and $$$j$$$ such that $$$1 \\le i < N$$$ and $$$0 \\le j < i$$$:\nif landmarks $$$j$$$ and $$$i$$$ are connected by a road, then the value of $$$U_i[j]$$$ should be $$$1$$$;\nif there is no road connecting landmarks $$$j$$$ and $$$i$$$, then the value of $$$U_i[j]$$$ should be $$$0$$$.\nOutput\nIn each scenario, before calling\nlongest_trip\n, the sample grader checks whether the density of the road network is at least $$$D$$$. If this condition is not met, it prints the message\nInsufficient Density\nand terminates.\nIf the sample grader detects a protocol violation, the output of the sample grader is\nProtocol Violation: <MSG>\n, where\n<MSG>\nis one of the following error messages:\ninvalid array\n: in a call to\nare_connected\n, at least one of arrays $$$A$$$ and $$$B$$$\nis empty, or\ncontains an element that is not an integer between $$$0$$$ and $$$N-1$$$, inclusive, or\ncontains the same element at least twice.\nnon-disjoint arrays\n: in a call to\nare_connected\n, arrays $$$A$$$ and $$$B$$$ are not disjoint.\ntoo many calls\n: the number of calls made to\nare_connected\nexceeds $$$32\\,640$$$ over the current invocation of\nlongest trip\n, or exceeds $$$150\\,000$$$ in total.\ntoo many elements\n: the total number of landmarks passed to\nare_connected\nover all calls exceeds $$$1\\,500\\,000$$$.\nOtherwise, let the elements of the array returned by\nlongest_trip\nin a scenario be $$$t[0], t[1], \\ldots, t[l - 1]$$$ for some nonnegative $$$l$$$. The sample grader prints three lines for this scenario in the following format:\nline $$$1$$$: $$$l$$$\nline $$$2$$$: $$$t[0] \\; t[1] \\; \\ldots \\; t[l-1]$$$\nline $$$3$$$: the number of calls to\nare_connected\nover this scenario\nFinally, the sample grader prints:\nline $$$1 + 3 \\cdot C$$$: the maximum number of calls to\nare_connected\nover all calls to\nlongest_trip\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$D = 3$$$\n2\n10\n$$$D = 2$$$\n3\n25\n$$$D = 1$$$. Let $$$l^\\star$$$ denote the length of a longest trip.  Procedure\nlongest_trip\ndoes not have to return a trip of length $$$l^\\star$$$.  Instead, it should return a trip of length at least $$$\\left\\lceil \\frac{l^\\star}{2} \\right\\rceil$$$.\n4\n60\n$$$D = 1$$$\nIn subtask 4 your score is determined based on the number of calls to procedure\nare_connected\nover a single invocation of\nlongest_trip\n. Let $$$q$$$ be the maximum number of calls among all invocations of\nlongest_trip\nover every test case of the subtask. Your score for this subtask is calculated according to the following table:\nCondition\nPoints\n$$$2\\,750 < q \\le 32\\,640$$$\n$$$20$$$\n$$$550 < q \\le 2\\,750$$$\n$$$30$$$\n$$$400 < q \\le 550$$$\n$$$45$$$\n$$$q \\le 400$$$\n$$$60$$$\nIf, in any of the test cases, the calls to the procedure\nare_connected\ndo not conform to the constraints described in\nImplementation Details\n, or the array returned by\nlongest_trip\nis incorrect, the score of your solution for that subtask will be $$$0$$$.\nNote\nExample 1\nConsider a scenario in which $$$N = 5$$$, $$$D = 1$$$, and the road connections are as shown in the following figure:\nThe procedure\nlongest_trip\nis called in the following way:\nlongest_trip(5, 1)\nThe procedure may make calls to\nare_connected\nas follows.\nCall\nPairs connected by a road\nReturn value\nare_connected([0], [1, 2, 4, 3])\n$$$(0,1)$$$ and $$$(0,2)$$$\ntrue\nare_connected([2], [0])\n$$$(2,0)$$$\ntrue\nare_connected([2], [3])\n$$$(2,3)$$$\ntrue\nare_connected([1, 0], [4, 3])\nnone\nfalse\nAfter the fourth call, it turns out that\nnone\nof the pairs $$$(1,4)$$$, $$$(0,4)$$$, $$$(1,3)$$$ and $$$(0,3)$$$ is connected by a road. As the density of the network is at least $$$D = 1$$$, we see that from the triplet $$$(0, 3, 4)$$$, the pair $$$(3,4)$$$ must be connected by a road. Similarly to this, landmarks $$$0$$$ and $$$1$$$ must be connected.\nAt this point, it can be concluded that $$$t = [1, 0, 2, 3, 4]$$$ is a trip of length $$$5$$$, and that there does not exist a trip of length greater than $$$5$$$. Therefore, the procedure\nlongest_trip\nmay return $$$[1, 0, 2, 3, 4]$$$.\nConsider another scenario in which $$$N = 4$$$, $$$D = 1$$$, and the roads between the landmarks are as shown in the following figure:\nThe procedure\nlongest_trip\nis called in the following way:\nlongest_trip(4, 1)\nIn this scenario, the length of a longest trip is $$$2$$$. Therefore, after a few calls to procedure\nare_connected\n, the procedure\nlongest_trip\nmay return one of $$$[0, 1]$$$, $$$[1, 0]$$$, $$$[2, 3]$$$ or $$$[3, 2]$$$.\nExample 2\nSubtask 0 contains an additional example test case with $$$N=256$$$ landmarks. This test case is included in the attachment package that you can download from the contest system.",
    "_meta": {
      "index": 77,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/B",
      "uuid": "ps_0464a831553d2111625a7e2ea58a0266266c3de5"
    }
  },
  {
    "planning_view": {
      "title": "F. Sphnix",
      "task": "Find vertex colors in connected N≤250 graph using ≤2750 recoloring experiments",
      "given": [
        "Connected graph with N vertices (0 to N-1) and M edges",
        "Each vertex has unknown color C[i] ∈ [0,N-1]",
        "Special Sphinx color N exists but no vertex has it"
      ],
      "goal": "Determine original color C[i] for each vertex",
      "key_rules": [
        "At most 2750 experiments allowed",
        "After experiment, colors revert to original",
        "Monochromatic component = vertices connected by same-color paths"
      ],
      "target": {
        "1": {
          "points": 3,
          "req": "N = 2"
        },
        "2": {
          "points": 7,
          "req": "N ≤ 50"
        },
        "3": {
          "points": 33,
          "req": "Graph is a path"
        },
        "4": {
          "points": 21,
          "req": "Graph is complete"
        },
        "5": {
          "points": 36,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Sphnix",
      "contest": "IOI 2024 day 2",
      "one_line": "Find vertex colors in connected N≤250 graph using ≤2750 recoloring experiments",
      "given": [
        "Connected graph with N vertices (0 to N-1) and M edges",
        "Each vertex has unknown color C[i] ∈ [0,N-1]",
        "Special Sphinx color N exists but no vertex has it"
      ],
      "goal": "Determine original color C[i] for each vertex",
      "mechanism": "Call perform_experiment(E) to temporarily recolor vertices and get monochromatic component count",
      "success_condition": "Return array G where G[i] = C[i] for all vertices",
      "constraints": {
        "critical": [
          "At most 2750 experiments allowed",
          "After experiment, colors revert to original",
          "Monochromatic component = vertices connected by same-color paths"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "N = 2"
          },
          "2": {
            "points": 7,
            "req": "N ≤ 50"
          },
          "3": {
            "points": 33,
            "req": "Graph is a path"
          },
          "4": {
            "points": 21,
            "req": "Graph is complete"
          },
          "5": {
            "points": 36,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Sphnix",
        "contest": "IOI 2024 day 2",
        "one_line": "Find vertex colors in connected N≤250 graph using ≤2750 recoloring experiments"
      },
      "problem": {
        "given": [
          "Connected graph with N vertices (0 to N-1) and M edges",
          "Each vertex has unknown color C[i] ∈ [0,N-1]",
          "Special Sphinx color N exists but no vertex has it"
        ],
        "goal": "Determine original color C[i] for each vertex",
        "mechanism": "Call perform_experiment(E) to temporarily recolor vertices and get monochromatic component count",
        "success_condition": "Return array G where G[i] = C[i] for all vertices"
      },
      "constraints": {
        "critical": [
          "At most 2750 experiments allowed",
          "After experiment, colors revert to original",
          "Monochromatic component = vertices connected by same-color paths"
        ],
        "subtasks": {
          "1": {
            "points": 3,
            "req": "N = 2"
          },
          "2": {
            "points": 7,
            "req": "N ≤ 50"
          },
          "3": {
            "points": 33,
            "req": "Graph is a path"
          },
          "4": {
            "points": 21,
            "req": "Graph is complete"
          },
          "5": {
            "points": 36,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "std::vector<int> find_colours(int N, std::vector<int> X, std::vector<int> Y)",
        "available_api": {
          "perform_experiment": {
            "signature": "int perform_experiment(std::vector<int> E)",
            "params": "E[i]: -1 to keep original color, or 0-N to set color",
            "returns": "Number of monochromatic components after recoloring",
            "side_effect": "Colors revert after experiment; no permanent changes"
          }
        },
        "requirements": [
          "Vertices are 0-indexed (0 to N-1)",
          "Grader is non-adaptive (colors fixed before find_colours called)",
          "Return vector must match original colors exactly for full score"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "The Great Sphinx has a riddle for you. You are given a graph on $$$N$$$ vertices. The vertices are numbered from $$$0$$$ to $$$N - 1$$$. There are $$$M$$$ edges in the graph, numbered from $$$0$$$ to $$$M-1$$$. Each edge connects a pair of distinct vertices and is bidirectional. Specifically, for each $$$j$$$ from $$$0$$$ to $$$M - 1$$$ (inclusive) edge $$$j$$$ connects vertices $$$X[j]$$$ and $$$Y[j]$$$. There is at most one edge connecting any pair of vertices. Two vertices are called\nadjacent\nif they are connected by an edge.\nA sequence of vertices $$$v_0, v_1, \\ldots, v_k$$$ (for $$$k \\ge 0$$$) is called a\npath\nif each two consecutive vertices $$$v_l$$$ and $$$v_{l+1}$$$ (for each $$$l$$$ such that $$$0 \\le l < k$$$) are adjacent. We say that a path $$$v_0, v_1, \\ldots, v_k$$$\nconnects\nvertices $$$v_0$$$ and $$$v_k$$$. In the graph given to you, each pair of vertices is connected by some path.\nThere are $$$N + 1$$$ colours, numbered from $$$0$$$ to $$$N$$$. Colour $$$N$$$ is special and is called the\nSphinx's colour\n. Each vertex is assigned a colour. Specifically, vertex $$$i$$$ ($$$0 \\le i < N$$$) has colour $$$C[i]$$$. Multiple vertices may have the same colour, and there might be colours not assigned to any vertex. No vertex has the Sphinx's colour, that is, $$$0 \\le C[i] < N$$$ ($$$0 \\le i < N$$$).\nA path $$$v_0, v_1, \\ldots, v_k$$$ (for $$$k \\ge 0$$$) is called\nmonochromatic\nif all of its vertices have the same colour, i.e. $$$C[v_l] = C[v_{l+1}]$$$ (for each $$$l$$$ such that $$$0 \\le l < k$$$). Additionally, we say that vertices $$$p$$$ and $$$q$$$ ($$$0 \\le p < N$$$, $$$0 \\le q < N$$$) are in the same\nmonochromatic component\nif and only if they are connected by a monochromatic path.\nYou know the vertices and edges, but you do not know which colour each vertex has. You want to find out the colours of the vertices, by performing\nrecolouring experiments\n.\nIn a recolouring experiment, you may recolour arbitrarily many vertices. Specifically, to perform a recolouring experiment you first choose an array $$$E$$$ of size $$$N$$$, where for each $$$i$$$ ($$$0 \\le i < N$$$), $$$E[i]$$$ is between $$$-1$$$ and $$$N$$$\ninclusive\n. Then, the colour of each vertex $$$i$$$ becomes $$$S[i]$$$, where the value of $$$S[i]$$$ is:\n$$$C[i]$$$, that is, the original colour of $$$i$$$, if $$$E[i] = -1$$$, or\n$$$E[i]$$$, otherwise.\nNote that this means that you can use the Sphinx's colour in your recolouring.\nFinally, the Great Sphinx announces the number of monochromatic components in the graph, after setting the colour of each vertex $$$i$$$ to $$$S[i]$$$ ($$$0 \\le i < N$$$). The new colouring is applied only for this particular recolouring experiment, so\nthe colours of all vertices return to the original ones after the experiment finishes\n.\nYour task is to identify the colours of the vertices in the graph by performing at most $$$2\\,750$$$ recolouring experiments. You may also receive a partial score if you correctly determine for every pair of adjacent vertices, whether they have the same colour.\nImplementation Details\nYou should implement the following procedure.\nstd::vector<int> find_colours(int N,\nstd::vector<int> X, std::vector<int> Y)\n$$$N$$$: the number of vertices in the graph.\n$$$X$$$, $$$Y$$$: arrays of length $$$M$$$ describing the edges.\nThis procedure should return an array $$$G$$$ of length $$$N$$$, representing the colours of vertices in the graph.\nThis procedure is called exactly once for each test case.\nThe above procedure can make calls to the following procedure to perform recolouring experiments:\nint perform_experiment(std::vector<int> E)\n$$$E$$$: an array of length $$$N$$$ specifying how vertices should be recoloured.\nThis procedure returns the number of monochromatic components after recolouring the vertices according to $$$E$$$.\nThis procedure can be called at most $$$2\\,750$$$ times.\nThe grader is\nnot adaptive\n, that is, the colours of the vertices are fixed before a call to\nfind_colours\nis made.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ $$$M$$$ ($$$2 \\le N \\le 250$$$, $$$N - 1 \\le M \\le \\frac{N \\cdot (N - 1)}{2}$$$)\nline $$$2$$$ $$$C[1]\\ldots C[N-1]$$$ ($$$0 \\le C[i] < N$$$)\nline $$$3 + j$$$ ($$$0 \\le j \\le M - 1$$$): $$$X[j]$$$ $$$Y[j]$$$ ($$$0 \\le X[j] < Y[j] < N$$$)\n$$$X[j] \\neq X[k]$$$ or $$$Y[j] \\neq Y[k]$$$ for each $$$j$$$ and $$$k$$$ such that $$$0 \\le j < k < M$$$.\nEach pair of vertices is connected by some path.\nOutput\nThe sample grader prints $$$S$$$ lines, in the following format:\nline $$$1$$$: $$$L$$$ $$$Q$$$\nline $$$2$$$: $$$G[0]\\; G[1]\\ldots G[L-1]$$$\nHere, $$$L$$$ is the length of the array $$$G$$$ returned by\nfind_colours\n, and $$$Q$$$ is the number of calls to\nperform_experiment\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$N = 2$$$\n2\n7\n$$$N \\le 50$$$\n3\n33\nThe graph is a path: $$$M = N - 1$$$ and vertices $$$j$$$ and $$$j+1$$$ are adjacent ($$$0 \\leq j < M$$$).\n4\n21\nThe graph is complete: $$$M = \\frac{N \\cdot (N - 1)}{2}$$$ and any two vertices are adjacent.\n5\n36\nNo additional constraints.\nIn each subtask, you can obtain a partial score if your program determines correctly for every pair of adjacent vertices whether they have the same colour.\nMore precisely, you get the whole score of a subtask if in all of its test cases, the array $$$G$$$ returned by\nfind_colours\nis exactly the same as array $$$C$$$ (i.e. $$$G[i] = C[i]$$$ for all $$$i$$$ such that $$$0 \\le i < N$$$). Otherwise, you get $$$50\\%$$$ of the score for a subtask if the following conditions hold in all of its test cases:\n$$$0 \\le G[i] < N$$$ for each $$$i$$$ such that $$$0 \\le i < N$$$;\nFor each $$$j$$$ such that $$$0 \\le j < M$$$:\n$$$G[X[j]] = G[Y[j]]$$$ if and only if $$$C[X[j]] = C[Y[j]]$$$.\nNote\nConsider the following call.\nfind_colours(4, [0, 1, 0, 0], [1, 2, 2, 3])\nFor this example, suppose that the (hidden) colours of the vertices are given by $$$C = [2, 0, 0, 0]$$$. This scenario is shown in the following figure. Colours are additionally represented by numbers on white labels attached to each vertex.\nThe procedure may call\nperform_experiment\nas follows.\nperform_experiment([-1, -1, -1, -1])\nIn this call, no vertex is recoloured, as all vertices keep their original colours.\nConsider vertex $$$1$$$ and vertex $$$2$$$. They both have colour $$$0$$$ and the path $$$1, 2$$$ is a monochromatic path. As a result, vertices $$$1$$$ and $$$2$$$ are in the same monochromatic component.\nConsider vertex $$$1$$$ and vertex $$$3$$$. Even though both of them have colour $$$0$$$, they are in different monochromatic components as there is no monochromatic path connecting them.\nOverall, there are $$$3$$$ monochromatic components, with vertices $$$\\{0\\}$$$, $$$\\{1, 2\\}$$$, and $$$\\{3\\}$$$. Thus, this call returns $$$3$$$.\nNow the procedure may call\nperform_experiment\nas follows.\nperform_experiment([0, -1, -1, -1])\nIn this call, only vertex $$$0$$$ is recoloured to colour $$$0$$$, which results in the colouring shown in the following figure.\nThis call returns $$$1$$$, as all the vertices belong to the same monochromatic component. We can now deduce that vertices $$$1$$$, $$$2$$$, and $$$3$$$ have colour $$$0$$$.\nThe procedure may then call\nperform_experiment\nas follows.\nperform_experiment([-1, -1, -1, 2])\nIn this call, vertex $$$3$$$ is recoloured to colour $$$2$$$, which results in the colouring shown in the following figure.\nThis call returns $$$2$$$, as there are $$$2$$$ monochromatic components, with vertices $$$\\{0, 3\\}$$$ and $$$\\{1, 2\\}$$$ respectively. We can deduce that vertex $$$0$$$ has colour $$$2$$$.\nThe procedure\nfind_colours\nthen returns the array $$$[2, 0, 0, 0]$$$. Since $$$C = [2, 0, 0, 0]$$$, full score is given.\nNote that there are also multiple return values, for which $$$50\\%$$$ of the score would be given, for example $$$[1, 2, 2, 2]$$$ or $$$[1, 2, 2, 3]$$$."
    },
    "original": "The Great Sphinx has a riddle for you. You are given a graph on $$$N$$$ vertices. The vertices are numbered from $$$0$$$ to $$$N - 1$$$. There are $$$M$$$ edges in the graph, numbered from $$$0$$$ to $$$M-1$$$. Each edge connects a pair of distinct vertices and is bidirectional. Specifically, for each $$$j$$$ from $$$0$$$ to $$$M - 1$$$ (inclusive) edge $$$j$$$ connects vertices $$$X[j]$$$ and $$$Y[j]$$$. There is at most one edge connecting any pair of vertices. Two vertices are called\nadjacent\nif they are connected by an edge.\nA sequence of vertices $$$v_0, v_1, \\ldots, v_k$$$ (for $$$k \\ge 0$$$) is called a\npath\nif each two consecutive vertices $$$v_l$$$ and $$$v_{l+1}$$$ (for each $$$l$$$ such that $$$0 \\le l < k$$$) are adjacent. We say that a path $$$v_0, v_1, \\ldots, v_k$$$\nconnects\nvertices $$$v_0$$$ and $$$v_k$$$. In the graph given to you, each pair of vertices is connected by some path.\nThere are $$$N + 1$$$ colours, numbered from $$$0$$$ to $$$N$$$. Colour $$$N$$$ is special and is called the\nSphinx's colour\n. Each vertex is assigned a colour. Specifically, vertex $$$i$$$ ($$$0 \\le i < N$$$) has colour $$$C[i]$$$. Multiple vertices may have the same colour, and there might be colours not assigned to any vertex. No vertex has the Sphinx's colour, that is, $$$0 \\le C[i] < N$$$ ($$$0 \\le i < N$$$).\nA path $$$v_0, v_1, \\ldots, v_k$$$ (for $$$k \\ge 0$$$) is called\nmonochromatic\nif all of its vertices have the same colour, i.e. $$$C[v_l] = C[v_{l+1}]$$$ (for each $$$l$$$ such that $$$0 \\le l < k$$$). Additionally, we say that vertices $$$p$$$ and $$$q$$$ ($$$0 \\le p < N$$$, $$$0 \\le q < N$$$) are in the same\nmonochromatic component\nif and only if they are connected by a monochromatic path.\nYou know the vertices and edges, but you do not know which colour each vertex has. You want to find out the colours of the vertices, by performing\nrecolouring experiments\n.\nIn a recolouring experiment, you may recolour arbitrarily many vertices. Specifically, to perform a recolouring experiment you first choose an array $$$E$$$ of size $$$N$$$, where for each $$$i$$$ ($$$0 \\le i < N$$$), $$$E[i]$$$ is between $$$-1$$$ and $$$N$$$\ninclusive\n. Then, the colour of each vertex $$$i$$$ becomes $$$S[i]$$$, where the value of $$$S[i]$$$ is:\n$$$C[i]$$$, that is, the original colour of $$$i$$$, if $$$E[i] = -1$$$, or\n$$$E[i]$$$, otherwise.\nNote that this means that you can use the Sphinx's colour in your recolouring.\nFinally, the Great Sphinx announces the number of monochromatic components in the graph, after setting the colour of each vertex $$$i$$$ to $$$S[i]$$$ ($$$0 \\le i < N$$$). The new colouring is applied only for this particular recolouring experiment, so\nthe colours of all vertices return to the original ones after the experiment finishes\n.\nYour task is to identify the colours of the vertices in the graph by performing at most $$$2\\,750$$$ recolouring experiments. You may also receive a partial score if you correctly determine for every pair of adjacent vertices, whether they have the same colour.\nImplementation Details\nYou should implement the following procedure.\nstd::vector<int> find_colours(int N,\nstd::vector<int> X, std::vector<int> Y)\n$$$N$$$: the number of vertices in the graph.\n$$$X$$$, $$$Y$$$: arrays of length $$$M$$$ describing the edges.\nThis procedure should return an array $$$G$$$ of length $$$N$$$, representing the colours of vertices in the graph.\nThis procedure is called exactly once for each test case.\nThe above procedure can make calls to the following procedure to perform recolouring experiments:\nint perform_experiment(std::vector<int> E)\n$$$E$$$: an array of length $$$N$$$ specifying how vertices should be recoloured.\nThis procedure returns the number of monochromatic components after recolouring the vertices according to $$$E$$$.\nThis procedure can be called at most $$$2\\,750$$$ times.\nThe grader is\nnot adaptive\n, that is, the colours of the vertices are fixed before a call to\nfind_colours\nis made.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ $$$M$$$ ($$$2 \\le N \\le 250$$$, $$$N - 1 \\le M \\le \\frac{N \\cdot (N - 1)}{2}$$$)\nline $$$2$$$ $$$C[1]\\ldots C[N-1]$$$ ($$$0 \\le C[i] < N$$$)\nline $$$3 + j$$$ ($$$0 \\le j \\le M - 1$$$): $$$X[j]$$$ $$$Y[j]$$$ ($$$0 \\le X[j] < Y[j] < N$$$)\n$$$X[j] \\neq X[k]$$$ or $$$Y[j] \\neq Y[k]$$$ for each $$$j$$$ and $$$k$$$ such that $$$0 \\le j < k < M$$$.\nEach pair of vertices is connected by some path.\nOutput\nThe sample grader prints $$$S$$$ lines, in the following format:\nline $$$1$$$: $$$L$$$ $$$Q$$$\nline $$$2$$$: $$$G[0]\\; G[1]\\ldots G[L-1]$$$\nHere, $$$L$$$ is the length of the array $$$G$$$ returned by\nfind_colours\n, and $$$Q$$$ is the number of calls to\nperform_experiment\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n3\n$$$N = 2$$$\n2\n7\n$$$N \\le 50$$$\n3\n33\nThe graph is a path: $$$M = N - 1$$$ and vertices $$$j$$$ and $$$j+1$$$ are adjacent ($$$0 \\leq j < M$$$).\n4\n21\nThe graph is complete: $$$M = \\frac{N \\cdot (N - 1)}{2}$$$ and any two vertices are adjacent.\n5\n36\nNo additional constraints.\nIn each subtask, you can obtain a partial score if your program determines correctly for every pair of adjacent vertices whether they have the same colour.\nMore precisely, you get the whole score of a subtask if in all of its test cases, the array $$$G$$$ returned by\nfind_colours\nis exactly the same as array $$$C$$$ (i.e. $$$G[i] = C[i]$$$ for all $$$i$$$ such that $$$0 \\le i < N$$$). Otherwise, you get $$$50\\%$$$ of the score for a subtask if the following conditions hold in all of its test cases:\n$$$0 \\le G[i] < N$$$ for each $$$i$$$ such that $$$0 \\le i < N$$$;\nFor each $$$j$$$ such that $$$0 \\le j < M$$$:\n$$$G[X[j]] = G[Y[j]]$$$ if and only if $$$C[X[j]] = C[Y[j]]$$$.\nNote\nConsider the following call.\nfind_colours(4, [0, 1, 0, 0], [1, 2, 2, 3])\nFor this example, suppose that the (hidden) colours of the vertices are given by $$$C = [2, 0, 0, 0]$$$. This scenario is shown in the following figure. Colours are additionally represented by numbers on white labels attached to each vertex.\nThe procedure may call\nperform_experiment\nas follows.\nperform_experiment([-1, -1, -1, -1])\nIn this call, no vertex is recoloured, as all vertices keep their original colours.\nConsider vertex $$$1$$$ and vertex $$$2$$$. They both have colour $$$0$$$ and the path $$$1, 2$$$ is a monochromatic path. As a result, vertices $$$1$$$ and $$$2$$$ are in the same monochromatic component.\nConsider vertex $$$1$$$ and vertex $$$3$$$. Even though both of them have colour $$$0$$$, they are in different monochromatic components as there is no monochromatic path connecting them.\nOverall, there are $$$3$$$ monochromatic components, with vertices $$$\\{0\\}$$$, $$$\\{1, 2\\}$$$, and $$$\\{3\\}$$$. Thus, this call returns $$$3$$$.\nNow the procedure may call\nperform_experiment\nas follows.\nperform_experiment([0, -1, -1, -1])\nIn this call, only vertex $$$0$$$ is recoloured to colour $$$0$$$, which results in the colouring shown in the following figure.\nThis call returns $$$1$$$, as all the vertices belong to the same monochromatic component. We can now deduce that vertices $$$1$$$, $$$2$$$, and $$$3$$$ have colour $$$0$$$.\nThe procedure may then call\nperform_experiment\nas follows.\nperform_experiment([-1, -1, -1, 2])\nIn this call, vertex $$$3$$$ is recoloured to colour $$$2$$$, which results in the colouring shown in the following figure.\nThis call returns $$$2$$$, as there are $$$2$$$ monochromatic components, with vertices $$$\\{0, 3\\}$$$ and $$$\\{1, 2\\}$$$ respectively. We can deduce that vertex $$$0$$$ has colour $$$2$$$.\nThe procedure\nfind_colours\nthen returns the array $$$[2, 0, 0, 0]$$$. Since $$$C = [2, 0, 0, 0]$$$, full score is given.\nNote that there are also multiple return values, for which $$$50\\%$$$ of the score would be given, for example $$$[1, 2, 2, 2]$$$ or $$$[1, 2, 2, 3]$$$.",
    "_meta": {
      "index": 78,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/F",
      "uuid": "ps_2ebccd82c3d7e0911b320d2a5ea5ae3b1cc33f5d"
    }
  },
  {
    "planning_view": {
      "title": "E. Unscrambling a Messy Bug",
      "task": "Find permutation p that scrambles n-bit integers using ≤w add and ≤r check calls",
      "given": [
        "Bug scrambles n-bit integers using fixed permutation p",
        "n is power of 2",
        "Permutation p unknown"
      ],
      "goal": "Determine the permutation p that scrambles binary digits",
      "key_rules": [
        "compile_set() can be called exactly once",
        "Cannot call add_element() after compile_set()",
        "Cannot call check_element() before compile_set()",
        "Binary strings have length n, first char is most significant bit"
      ],
      "target": {
        "1": {
          "points": 20,
          "req": "n=8, w=256, r=256, at most 2 indices differ from identity"
        },
        "2": {
          "points": 18,
          "req": "n=32, w=320, r=1024"
        },
        "3": {
          "points": 11,
          "req": "n=32, w=1024, r=320"
        },
        "4": {
          "points": 21,
          "req": "n=128, w=1792, r=1792"
        },
        "5": {
          "points": 30,
          "req": "n=128, w=896, r=896"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Unscrambling a Messy Bug",
      "contest": "IOI 2016 day 2",
      "one_line": "Find permutation p that scrambles n-bit integers using ≤w add and ≤r check calls",
      "given": [
        "Bug scrambles n-bit integers using fixed permutation p",
        "n is power of 2",
        "Permutation p unknown"
      ],
      "goal": "Determine the permutation p that scrambles binary digits",
      "mechanism": "Add elements to set, call compile_set() once to scramble all with p, then check elements to deduce p",
      "success_condition": "Return the exact permutation p that was used to scramble the binary digits",
      "constraints": {
        "critical": [
          "compile_set() can be called exactly once",
          "Cannot call add_element() after compile_set()",
          "Cannot call check_element() before compile_set()",
          "Binary strings have length n, first char is most significant bit"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "n=8, w=256, r=256, at most 2 indices differ from identity"
          },
          "2": {
            "points": 18,
            "req": "n=32, w=320, r=1024"
          },
          "3": {
            "points": 11,
            "req": "n=32, w=1024, r=320"
          },
          "4": {
            "points": 21,
            "req": "n=128, w=1792, r=1792"
          },
          "5": {
            "points": 30,
            "req": "n=128, w=896, r=896"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Unscrambling a Messy Bug",
        "contest": "IOI 2016 day 2",
        "one_line": "Find permutation p that scrambles n-bit integers using ≤w add and ≤r check calls"
      },
      "problem": {
        "given": [
          "Bug scrambles n-bit integers using fixed permutation p",
          "n is power of 2",
          "Permutation p unknown"
        ],
        "goal": "Determine the permutation p that scrambles binary digits",
        "mechanism": "Add elements to set, call compile_set() once to scramble all with p, then check elements to deduce p",
        "success_condition": "Return the exact permutation p that was used to scramble the binary digits"
      },
      "constraints": {
        "critical": [
          "compile_set() can be called exactly once",
          "Cannot call add_element() after compile_set()",
          "Cannot call check_element() before compile_set()",
          "Binary strings have length n, first char is most significant bit"
        ],
        "subtasks": {
          "1": {
            "points": 20,
            "req": "n=8, w=256, r=256, at most 2 indices differ from identity"
          },
          "2": {
            "points": 18,
            "req": "n=32, w=320, r=1024"
          },
          "3": {
            "points": 11,
            "req": "n=32, w=1024, r=320"
          },
          "4": {
            "points": 21,
            "req": "n=128, w=1792, r=1792"
          },
          "5": {
            "points": 30,
            "req": "n=128, w=896, r=896"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] restore_permutation(int n, int w, int r)",
        "available_api": {
          "add_element": {
            "signature": "void add_element(string x)",
            "params": "x: string of '0' and '1' of length n",
            "returns": "void",
            "side_effect": "Adds element to set if not present"
          },
          "compile_set": {
            "signature": "void compile_set()",
            "params": "none",
            "returns": "void",
            "side_effect": "Applies permutation p to scramble all elements, can only be called once"
          },
          "check_element": {
            "signature": "boolean check_element(string x)",
            "params": "x: string of '0' and '1' of length n",
            "returns": "true if element is in scrambled set",
            "side_effect": "none"
          }
        },
        "requirements": [
          "Must call compile_set() exactly once",
          "Cannot exceed w calls to add_element",
          "Cannot exceed r calls to check_element",
          "First character of string is most significant bit"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "512 megabytes"
      },
      "samples": [],
      "original_statement": "Ilshat is a software engineer working on efficient data structures. One day he invented a new data structure. This data structure can store a set of\nnon-negative\n$$$n$$$-bit integers, where $$$n$$$ is a power of two. That is, $$$n = 2^b$$$ for some non-negative integer $$$b$$$.\nThe data structure is initially empty. A program using the data structure has to follow the following rules:\nThe program can add elements that are $$$n$$$-bit integers into the data structure, one at a time, by using the function\nadd_element(x)\n. If the program tries to add an element that is already present in the data structure, nothing happens.\nAfter adding the last element the program should call the function\ncompile_set()\nexactly once.\nFinally, the program may call the function\ncheck_element(x)\nto check whether the element $$$x$$$ is present in the data structure. This function may be used multiple times.\nWhen Ilshat first implemented this data structure, he made a bug in the function\ncompile_set()\n. The bug reorders the binary digits of each element in the set in the same manner. Ilshat wants you to find the exact reordering of digits caused by the bug.\nFormally, consider a sequence $$$p_0, \\ldots, p_{n - 1}$$$ in which every number from $$$0$$$ to $$$n - 1$$$ appears exactly once. We call such a sequence a\npermutation\n. Consider an element of the set, whose digits in binary are $$$a_0, \\ldots, a_{n - 1}$$$ (with $$$a_0$$$ being the most significant bit). When the function\ncompile_set()\nis called, this element is replaced by the element $$$a_{p_0}, a_{p_1}, \\ldots, a_{p_{n - 1}}$$$.\nThe same permutation $$$p$$$ is used to reorder the digits of every element. Any permutation is possible, including the possibility that $$$p_i = i$$$ for each $$$0 \\le i \\le n - 1$$$.\nFor example, suppose that $$$n = 4$$$, $$$p = [2, 1, 3, 0]$$$, and you have inserted into the set integers whose binary representations are\n0000\n,\n1100\nand\n0111\n. Calling the function\ncompile_set\nchanges these elements to\n0000\n,\n0101\nand\n1110\n, respectively.\nYour task is to write a program that finds the permutation $$$p$$$ by interacting with the data structure. It should (in the following order):\nchoose a set of $$$n$$$-bit integers,\ninsert those integers into the data structure,\ncall the function\ncompile_set\nto trigger the bug,\ncheck the presence of some elements in the modified set,\nuse that information to determine and return the permutation $$$p$$$.\nNote that your program may call the function\ncompile_set\nonly once.\nIn addition, there is a limit on the number of times your program calls the library functions. Namely, it may\ncall\nadd_element\nat most $$$w$$$ times ($$$w$$$ is for \"writes\"),\ncall\ncheck_element\nat most $$$r$$$ times ($$$r$$$ is for \"reads\").\nImplementation details\nYou should implement one function (method):\nint[] restore_permutation(int n, int w, int r)\nn\n: the number of bits in the binary representation of each element of the set (and also the length of $$$p$$$).\nw\n: the maximum number of\nadd_element\noperations your program can perform.\nr\n: the maximum number of\ncheck_element\noperations your program can perform.\nthe function should return the restored permutation $$$p$$$.\nLibrary functions\nIn order to interact with the data structure, your program should use the following three functions (methods):\nvoid add_element(string x)\nThis function adds the element described by\nx\nto the set.\nx\n: a string of\n'0'\nand\n'1'\ncharacters giving the binary representation of an integer that should be added to the set. The length of\nx\nmust be $$$n$$$.\nvoid compile_set()\nThis function must be called exactly once. Your program cannot call\nadd_element()\nafter this call. Your program cannot call\ncheck_element()\nbefore this call.\nboolean check_element(string x)\nThis function checks whether the element\nx\nis in the modified set.\nx\n: a string of\n'0'\nand\n'1'\ncharacters giving the binary representation of the element that should be checked. The length of\nx\nmust be $$$n$$$.\nreturns\ntrue\nif element\nx\nis in the modified set, and\nfalse\notherwise.\nNote that if your program violates any of the above restrictions, its grading outcome will be \"Wrong Answer\".\nFor all the strings, the first character gives the most significant bit of the corresponding integer.\nThe grader fixes the permutation $$$p$$$ before the function\nrestore_permutation\nis called.\nPlease use the provided template files for details of implementation in your programming language.\nInput\nThe sample grader reads the input in the following format:\nline 1: integers $$$n$$$, $$$w$$$, $$$r$,\nline 2: $$$n$$$ integers giving the elements of $$$p$$$.\nOutput\nOne string — the return value of\nrestore_permutation\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n20\n$$$n = 8$$$, $$$w = 256$$$, $$$r = 256$$$, $$$p_i \\neq i$$$ for at most 2 indices $$$i$$$ ($$$0 \\le i \\leq n - 1$$$)\n2\n18\n$$$n = 32$$$, $$$w = 320$$$, $$$r = 1024$$$\n3\n11\n$$$n = 32$$$, $$$w = 1024$$$, $$$r = 320$$$\n4\n21\n$$$n = 128$$$, $$$w = 1792$$$, $$$r = 1792$$$\n5\n30\n$$$n = 128$$$, $$$w = 896$$$, $$$r = 896$$$\nExample\nNote\nExample\nThe grader makes the following function call:\nrestore_permutation(4, 16, 16)\n. We have $$$n = 4$$$ and the program can do at most $$$16$$$ \"writes\" and $$$16$$$ \"reads\".\nThe program makes the following function calls:\nadd_element(\"0001\")\nadd_element(\"0011\")\nadd_element(\"0100\")\ncompile_set()\ncheck_element(\"0001\")\nreturns\nfalse\ncheck_element(\"0010\")\nreturns\ntrue\ncheck_element(\"0100\")\nreturns\ntrue\ncheck_element(\"1000\")\nreturns\nfalse\ncheck_element(\"0011\")\nreturns\nfalse\ncheck_element(\"0101\")\nreturns\nfalse\ncheck_element(\"1001\")\nreturns\nfalse\ncheck_element(\"0110\")\nreturns\nfalse\ncheck_element(\"1010\")\nreturns\ntrue\ncheck_element(\"1100\")\nreturns\nfalse\nOnly one permutation is consistent with these values returned by\ncheck_element()\n: the permutation $$$p = [2, 1, 3, 0]$$$. Thus,\nrestore_permutation\nshould return\n[2, 1, 3, 0]\n."
    },
    "original": "Ilshat is a software engineer working on efficient data structures. One day he invented a new data structure. This data structure can store a set of\nnon-negative\n$$$n$$$-bit integers, where $$$n$$$ is a power of two. That is, $$$n = 2^b$$$ for some non-negative integer $$$b$$$.\nThe data structure is initially empty. A program using the data structure has to follow the following rules:\nThe program can add elements that are $$$n$$$-bit integers into the data structure, one at a time, by using the function\nadd_element(x)\n. If the program tries to add an element that is already present in the data structure, nothing happens.\nAfter adding the last element the program should call the function\ncompile_set()\nexactly once.\nFinally, the program may call the function\ncheck_element(x)\nto check whether the element $$$x$$$ is present in the data structure. This function may be used multiple times.\nWhen Ilshat first implemented this data structure, he made a bug in the function\ncompile_set()\n. The bug reorders the binary digits of each element in the set in the same manner. Ilshat wants you to find the exact reordering of digits caused by the bug.\nFormally, consider a sequence $$$p_0, \\ldots, p_{n - 1}$$$ in which every number from $$$0$$$ to $$$n - 1$$$ appears exactly once. We call such a sequence a\npermutation\n. Consider an element of the set, whose digits in binary are $$$a_0, \\ldots, a_{n - 1}$$$ (with $$$a_0$$$ being the most significant bit). When the function\ncompile_set()\nis called, this element is replaced by the element $$$a_{p_0}, a_{p_1}, \\ldots, a_{p_{n - 1}}$$$.\nThe same permutation $$$p$$$ is used to reorder the digits of every element. Any permutation is possible, including the possibility that $$$p_i = i$$$ for each $$$0 \\le i \\le n - 1$$$.\nFor example, suppose that $$$n = 4$$$, $$$p = [2, 1, 3, 0]$$$, and you have inserted into the set integers whose binary representations are\n0000\n,\n1100\nand\n0111\n. Calling the function\ncompile_set\nchanges these elements to\n0000\n,\n0101\nand\n1110\n, respectively.\nYour task is to write a program that finds the permutation $$$p$$$ by interacting with the data structure. It should (in the following order):\nchoose a set of $$$n$$$-bit integers,\ninsert those integers into the data structure,\ncall the function\ncompile_set\nto trigger the bug,\ncheck the presence of some elements in the modified set,\nuse that information to determine and return the permutation $$$p$$$.\nNote that your program may call the function\ncompile_set\nonly once.\nIn addition, there is a limit on the number of times your program calls the library functions. Namely, it may\ncall\nadd_element\nat most $$$w$$$ times ($$$w$$$ is for \"writes\"),\ncall\ncheck_element\nat most $$$r$$$ times ($$$r$$$ is for \"reads\").\nImplementation details\nYou should implement one function (method):\nint[] restore_permutation(int n, int w, int r)\nn\n: the number of bits in the binary representation of each element of the set (and also the length of $$$p$$$).\nw\n: the maximum number of\nadd_element\noperations your program can perform.\nr\n: the maximum number of\ncheck_element\noperations your program can perform.\nthe function should return the restored permutation $$$p$$$.\nLibrary functions\nIn order to interact with the data structure, your program should use the following three functions (methods):\nvoid add_element(string x)\nThis function adds the element described by\nx\nto the set.\nx\n: a string of\n'0'\nand\n'1'\ncharacters giving the binary representation of an integer that should be added to the set. The length of\nx\nmust be $$$n$$$.\nvoid compile_set()\nThis function must be called exactly once. Your program cannot call\nadd_element()\nafter this call. Your program cannot call\ncheck_element()\nbefore this call.\nboolean check_element(string x)\nThis function checks whether the element\nx\nis in the modified set.\nx\n: a string of\n'0'\nand\n'1'\ncharacters giving the binary representation of the element that should be checked. The length of\nx\nmust be $$$n$$$.\nreturns\ntrue\nif element\nx\nis in the modified set, and\nfalse\notherwise.\nNote that if your program violates any of the above restrictions, its grading outcome will be \"Wrong Answer\".\nFor all the strings, the first character gives the most significant bit of the corresponding integer.\nThe grader fixes the permutation $$$p$$$ before the function\nrestore_permutation\nis called.\nPlease use the provided template files for details of implementation in your programming language.\nInput\nThe sample grader reads the input in the following format:\nline 1: integers $$$n$$$, $$$w$$$, $$$r$,\nline 2: $$$n$$$ integers giving the elements of $$$p$$$.\nOutput\nOne string — the return value of\nrestore_permutation\n.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n20\n$$$n = 8$$$, $$$w = 256$$$, $$$r = 256$$$, $$$p_i \\neq i$$$ for at most 2 indices $$$i$$$ ($$$0 \\le i \\leq n - 1$$$)\n2\n18\n$$$n = 32$$$, $$$w = 320$$$, $$$r = 1024$$$\n3\n11\n$$$n = 32$$$, $$$w = 1024$$$, $$$r = 320$$$\n4\n21\n$$$n = 128$$$, $$$w = 1792$$$, $$$r = 1792$$$\n5\n30\n$$$n = 128$$$, $$$w = 896$$$, $$$r = 896$$$\nExample\nNote\nExample\nThe grader makes the following function call:\nrestore_permutation(4, 16, 16)\n. We have $$$n = 4$$$ and the program can do at most $$$16$$$ \"writes\" and $$$16$$$ \"reads\".\nThe program makes the following function calls:\nadd_element(\"0001\")\nadd_element(\"0011\")\nadd_element(\"0100\")\ncompile_set()\ncheck_element(\"0001\")\nreturns\nfalse\ncheck_element(\"0010\")\nreturns\ntrue\ncheck_element(\"0100\")\nreturns\ntrue\ncheck_element(\"1000\")\nreturns\nfalse\ncheck_element(\"0011\")\nreturns\nfalse\ncheck_element(\"0101\")\nreturns\nfalse\ncheck_element(\"1001\")\nreturns\nfalse\ncheck_element(\"0110\")\nreturns\nfalse\ncheck_element(\"1010\")\nreturns\ntrue\ncheck_element(\"1100\")\nreturns\nfalse\nOnly one permutation is consistent with these values returned by\ncheck_element()\n: the permutation $$$p = [2, 1, 3, 0]$$$. Thus,\nrestore_permutation\nshould return\n[2, 1, 3, 0]\n.",
    "_meta": {
      "index": 79,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/E",
      "uuid": "ps_780c374b7f4d1c9bae63fdfb2703220e9a42a4bf"
    }
  },
  {
    "planning_view": {
      "title": "D. Digital Circuit",
      "task": "Count parameter assignments making gate 0 state=1 after Q toggle updates",
      "given": [
        "N threshold gates (0 to N-1)",
        "M source gates (N to N+M-1)",
        "Tree structure: each gate i>0 has parent P[i] (threshold gate)",
        "Source gates have initial states A[j]"
      ],
      "goal": "After each source gate toggle update, count valid parameter assignments modulo 1,000,002,022",
      "key_rules": [
        "Parameter assignments: threshold gate with c inputs has parameter choice 1..c",
        "Gate states propagate bottom-up from source gates",
        "Updates toggle source gates in range [L,R]"
      ],
      "target": {
        "1": {
          "points": 2,
          "req": "N=1, M≤1000, Q≤5"
        },
        "2": {
          "points": 7,
          "req": "N,M≤1000, Q≤5, each threshold gate has exactly 2 inputs"
        },
        "3": {
          "points": 9,
          "req": "N,M≤1000, Q≤5"
        },
        "4": {
          "points": 4,
          "req": "Complete binary tree, M=N+1=2^z, L=R"
        },
        "5": {
          "points": 12,
          "req": "Complete binary tree, M=N+1=2^z"
        },
        "6": {
          "points": 27,
          "req": "Each threshold gate has exactly 2 inputs"
        },
        "7": {
          "points": 28,
          "req": "N,M≤5000"
        },
        "8": {
          "points": 11,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Digital Circuit",
      "contest": "IOI 2022 day 2",
      "one_line": "Count parameter assignments making gate 0 state=1 after Q toggle updates",
      "given": [
        "N threshold gates (0 to N-1)",
        "M source gates (N to N+M-1)",
        "Tree structure: each gate i>0 has parent P[i] (threshold gate)",
        "Source gates have initial states A[j]"
      ],
      "goal": "After each source gate toggle update, count valid parameter assignments modulo 1,000,002,022",
      "mechanism": "Threshold gates compute state=1 if ≥p inputs are 1; parameters p ∈ [1, input_count]",
      "success_condition": "Gate 0 has state 1 under the parameter assignment",
      "constraints": {
        "critical": [
          "Parameter assignments: threshold gate with c inputs has parameter choice 1..c",
          "Gate states propagate bottom-up from source gates",
          "Updates toggle source gates in range [L,R]"
        ],
        "subtasks": {
          "1": {
            "points": 2,
            "req": "N=1, M≤1000, Q≤5"
          },
          "2": {
            "points": 7,
            "req": "N,M≤1000, Q≤5, each threshold gate has exactly 2 inputs"
          },
          "3": {
            "points": 9,
            "req": "N,M≤1000, Q≤5"
          },
          "4": {
            "points": 4,
            "req": "Complete binary tree, M=N+1=2^z, L=R"
          },
          "5": {
            "points": 12,
            "req": "Complete binary tree, M=N+1=2^z"
          },
          "6": {
            "points": 27,
            "req": "Each threshold gate has exactly 2 inputs"
          },
          "7": {
            "points": 28,
            "req": "N,M≤5000"
          },
          "8": {
            "points": 11,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Digital Circuit",
        "contest": "IOI 2022 day 2",
        "one_line": "Count parameter assignments making gate 0 state=1 after Q toggle updates"
      },
      "problem": {
        "given": [
          "N threshold gates (0 to N-1)",
          "M source gates (N to N+M-1)",
          "Tree structure: each gate i>0 has parent P[i] (threshold gate)",
          "Source gates have initial states A[j]"
        ],
        "goal": "After each source gate toggle update, count valid parameter assignments modulo 1,000,002,022",
        "mechanism": "Threshold gates compute state=1 if ≥p inputs are 1; parameters p ∈ [1, input_count]",
        "success_condition": "Gate 0 has state 1 under the parameter assignment"
      },
      "constraints": {
        "critical": [
          "Parameter assignments: threshold gate with c inputs has parameter choice 1..c",
          "Gate states propagate bottom-up from source gates",
          "Updates toggle source gates in range [L,R]"
        ],
        "subtasks": {
          "1": {
            "points": 2,
            "req": "N=1, M≤1000, Q≤5"
          },
          "2": {
            "points": 7,
            "req": "N,M≤1000, Q≤5, each threshold gate has exactly 2 inputs"
          },
          "3": {
            "points": 9,
            "req": "N,M≤1000, Q≤5"
          },
          "4": {
            "points": 4,
            "req": "Complete binary tree, M=N+1=2^z, L=R"
          },
          "5": {
            "points": 12,
            "req": "Complete binary tree, M=N+1=2^z"
          },
          "6": {
            "points": 27,
            "req": "Each threshold gate has exactly 2 inputs"
          },
          "7": {
            "points": 28,
            "req": "N,M≤5000"
          },
          "8": {
            "points": 11,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int count_ways(int L, int R)",
        "available_api": {
          "init": {
            "signature": "void init(int N, int M, int[] P, int[] A)",
            "params": "N: threshold gates count, M: source gates count, P: parent array length N+M, A: source states length M",
            "returns": "void",
            "side_effect": "Initializes circuit structure"
          },
          "count_ways": {
            "signature": "int count_ways(int L, int R)",
            "params": "L,R: source gate range to toggle (N≤L≤R≤N+M-1)",
            "returns": "Number of valid parameter assignments modulo 1,000,002,022",
            "side_effect": "Toggles specified source gates before counting"
          }
        },
        "requirements": [
          "init called once before any count_ways calls",
          "count_ways called exactly Q times",
          "Parameters chosen independently for each threshold gate",
          "Modulo 1,000,002,022"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      },
      "samples": [
        {
          "input": "3 4 3\n-1 0 1 2 1 1 0\n1 0 1 0\n3 4\n4 5\n3 6",
          "output": "2\n0\n6"
        }
      ],
      "original_statement": "There is a circuit, which consists of $$$N + M$$$\ngates\nnumbered from $$$0$$$ to $$$N + M - 1$$$. Gates $$$0$$$ to $$$N - 1$$$ are\nthreshold gates\n, whereas gates $$$N$$$ to $$$N + M - 1$$$ are\nsource gates\n.\nEach gate, except for gate $$$0$$$, is an\ninput\nto exactly one threshold gate. Specifically, for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$, gate $$$i$$$ is an input to gate $$$P[i]$$$, where $$$0 \\le P[i] \\le N-1$$$. Importantly, we also have $$$P[i] \\textless i$$$. Moreover, we assume $$$P[0] = -1$$$. Each threshold gate has one or more inputs. Source gates do not have any inputs.\nEach gate has a\nstate\nwhich is either $$$0$$$ or $$$1$$$. The initial states of the source gates are given by an array $$$A$$$ of $$$M$$$ integers. That is, for each $$$j$$$ such that $$$0 \\le j \\le M - 1$$$, the initial state of the source gate $$$N + j$$$ is $$$A[j]$$$.\nThe state of each threshold gate depends on the states of its inputs and is determined as follows. First, each threshold gate is assigned a threshold\nparameter\n. The parameter assigned to a threshold gate with $$$c$$$ inputs must be an integer between $$$1$$$ and $$$c$$$ (inclusive). Then, the state of a threshold gate with parameter $$$p$$$ is $$$1$$$, if at least $$$p$$$ of its inputs have state $$$1$$$, and $$$0$$$ otherwise.\nFor example, suppose there are $$$N = 3$$$ threshold gates and $$$M = 4$$$ source gates. The inputs to gate $$$0$$$ are gates $$$1$$$ and $$$6$$$, the inputs to gate $$$1$$$ are gates $$$2$$$, $$$4$$$, and $$$5$$$, and the only input to gate $$$2$$$ is gate $$$3$$$.\nThis example is illustrated in the following picture.\nSuppose that source gates $$$3$$$ and $$$5$$$ have state $$$1$$$, while source gates $$$4$$$ and $$$6$$$ have state $$$0$$$. Assume we assign parameters $$$1$$$, $$$2$$$ and $$$2$$$ to threshold gates $$$2$$$, $$$1$$$ and $$$0$$$ respectively. In this case, gate $$$2$$$ has state $$$1$$$, gate $$$1$$$ has state $$$1$$$ and gate $$$0$$$ has state $$$0$$$. This assignment of parameter values and the states is illustrated in the following picture. Gates whose state is $$$1$$$ are marked in black.\nThe states of the source gates will undergo $$$Q$$$ updates. Each update is described by two integers $$$L$$$ and $$$R$$$ ($$$N \\le L \\le R \\le N + M - 1$$$) and toggles the states of all source gates numbered between $$$L$$$ and $$$R$$$, inclusive. That is, for each $$$i$$$ such that $$$L \\le i \\le R$$$, source gate $$$i$$$ changes its state to $$$1$$$, if its state is $$$0$$$, or to $$$0$$$, if its state is $$$1$$$. The new state of each toggled gate remains unchanged until it is possibly toggled by one of the later updates.\nYour goal is to count, after each update, how many different assignments of parameters to threshold gates result in gate $$$0$$$ having state $$$1$$$. Two assignments are considered different if there exists at least one threshold gate that has a different value of its parameter in both assignments. As the number of ways can be large, you should compute it modulo $$$1\\;000\\;002\\;022$$$.\nNote that in the example above, there are $$$6$$$ different assignments of parameters to threshold gates, since gates $$$0$$$, $$$1$$$ and $$$2$$$ have $$$2$$$, $$$3$$$ and $$$1$$$ inputs respectively. In $$$2$$$ out of these $$$6$$$ assignments, gate $$$0$$$ has state $$$1$$$.\nImplementation Details\nYour task is to implement two procedures.\nvoid init(int N, int M, int[] P, int[] A)\n$$$N$$$: the number of threshold gates.\n$$$M$$$: the number of source gates.\n$$$P$$$: an array of length $$$N + M$$$ describing the inputs to the threshold gates.\n$$$A$$$: an array of length $$$M$$$ describing the initial states of the source gates.\nThis procedure is called exactly once, before any calls to\ncount_ways\n.\nint count_ways(int L, int R)\n$$$L$$$, $$$R$$$: the boundaries of the range of source gates, whose states are toggled.\nThis procedure should first perform the specified update, and then return the number of ways, modulo $$$1\\;000\\;002\\;022$$$, of assigning parameters to the threshold gates, which result in gate $$$0$$$ having state $$$1$$$.\nThis procedure is called exactly $$$Q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M \\; Q$$$ ($$$1 \\le N, M \\le 100\\;000$$$, $$$1 \\le Q \\le 100\\;000$$$)\nline $$$2$$$: $$$P[0] \\; P[1] \\; \\ldots \\; P[N + M - 1]$$$ ($$$P[0] = -1$$$, $$$0 \\le P[i] \\textless i$$$ and $$$P[i] \\le N - 1$$$ (for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$))\nline $$$3$$$: $$$A[0] \\; A[1] \\; \\ldots \\; A[M - 1]$$$ ($$$0 \\le A[j] \\le 1$$$)\nline $$$4 + k$$$ ($$$0 \\le k \\le Q - 1$$$): $$$L \\; R$$$ for update $$$k$$$ ($$$N \\le L \\le R \\le N + M - 1$$$)\nEach threshold gate has at least one input (for each $$$i$$$ such that $$$0 \\le i \\le N - 1$$$ there exists an index $$$x$$$ such that $$$i \\textless x \\le N + M - 1$$$ and $$$P[x] = i$$$).\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + k$$$ ($$$0 \\le k \\le Q - 1$$$): the return value of\ncount_ways\nfor update $$$k$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n2\n$$$N = 1$$$, $$$M \\le 1000$$$, $$$Q \\le 5$$$\n2\n7\n$$$N, M \\le 1000$$$, $$$Q \\le 5$$$, each threshold gate has exactly two inputs.\n3\n9\n$$$N, M \\le 1000$$$, $$$Q \\le 5$$$\n4\n4\n$$$M = N + 1$$$, $$$M = 2^z$$$ (for some positive integer $$$z$$$), $$$P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$$$ (for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$), $$$L = R$$$\n5\n12\n$$$M = N + 1$$$, $$$M = 2^z$$$ (for some positive integer $$$z$$$), $$$P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$$$ (for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$)\n6\n27\nEach threshold gate has exactly two inputs.\n7\n28\n$$$N, M \\le 5000$$$\n8\n11\nNo additional constraints\nExample\nNote\nConsider the following sequence of calls:\ninit(3, 4, [-1, 0, 1, 2, 1, 1, 0], [1, 0, 1, 0])\nThis example is illustrated in the task description above.\ncount_ways(3, 4)\nThis toggles the states of gates $$$3$$$ and $$$4$$$, i.e. the state of gate $$$3$$$ becomes $$$0$$$, and the state of gate $$$4$$$ becomes $$$1$$$. Two ways of assigning the parameters which result in gate $$$0$$$ having state $$$1$$$ are illustrated in the pictures below.\nWay $$$1$$$\nWay $$$2$$$\nIn all other assignments of parameters, gate $$$0$$$ has state $$$0$$$. Thus, the procedure should return $$$2$$$.\ncount_ways(4, 5)\nThis toggles the states of gates $$$4$$$ and $$$5$$$. As a result, all source gates have state $$$0$$$, and for any assignment of parameters, gate $$$0$$$ has state $$$0$$$. Thus, the procedure should return $$$0$$$.\ncount_ways(3, 6)\nThis changes the states of all source gates to $$$1$$$. As a result, for any assignment of parameters, gate $$$0$$$ has state $$$1$$$. Thus, the procedure should return $$$6$$$."
    },
    "original": "There is a circuit, which consists of $$$N + M$$$\ngates\nnumbered from $$$0$$$ to $$$N + M - 1$$$. Gates $$$0$$$ to $$$N - 1$$$ are\nthreshold gates\n, whereas gates $$$N$$$ to $$$N + M - 1$$$ are\nsource gates\n.\nEach gate, except for gate $$$0$$$, is an\ninput\nto exactly one threshold gate. Specifically, for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$, gate $$$i$$$ is an input to gate $$$P[i]$$$, where $$$0 \\le P[i] \\le N-1$$$. Importantly, we also have $$$P[i] \\textless i$$$. Moreover, we assume $$$P[0] = -1$$$. Each threshold gate has one or more inputs. Source gates do not have any inputs.\nEach gate has a\nstate\nwhich is either $$$0$$$ or $$$1$$$. The initial states of the source gates are given by an array $$$A$$$ of $$$M$$$ integers. That is, for each $$$j$$$ such that $$$0 \\le j \\le M - 1$$$, the initial state of the source gate $$$N + j$$$ is $$$A[j]$$$.\nThe state of each threshold gate depends on the states of its inputs and is determined as follows. First, each threshold gate is assigned a threshold\nparameter\n. The parameter assigned to a threshold gate with $$$c$$$ inputs must be an integer between $$$1$$$ and $$$c$$$ (inclusive). Then, the state of a threshold gate with parameter $$$p$$$ is $$$1$$$, if at least $$$p$$$ of its inputs have state $$$1$$$, and $$$0$$$ otherwise.\nFor example, suppose there are $$$N = 3$$$ threshold gates and $$$M = 4$$$ source gates. The inputs to gate $$$0$$$ are gates $$$1$$$ and $$$6$$$, the inputs to gate $$$1$$$ are gates $$$2$$$, $$$4$$$, and $$$5$$$, and the only input to gate $$$2$$$ is gate $$$3$$$.\nThis example is illustrated in the following picture.\nSuppose that source gates $$$3$$$ and $$$5$$$ have state $$$1$$$, while source gates $$$4$$$ and $$$6$$$ have state $$$0$$$. Assume we assign parameters $$$1$$$, $$$2$$$ and $$$2$$$ to threshold gates $$$2$$$, $$$1$$$ and $$$0$$$ respectively. In this case, gate $$$2$$$ has state $$$1$$$, gate $$$1$$$ has state $$$1$$$ and gate $$$0$$$ has state $$$0$$$. This assignment of parameter values and the states is illustrated in the following picture. Gates whose state is $$$1$$$ are marked in black.\nThe states of the source gates will undergo $$$Q$$$ updates. Each update is described by two integers $$$L$$$ and $$$R$$$ ($$$N \\le L \\le R \\le N + M - 1$$$) and toggles the states of all source gates numbered between $$$L$$$ and $$$R$$$, inclusive. That is, for each $$$i$$$ such that $$$L \\le i \\le R$$$, source gate $$$i$$$ changes its state to $$$1$$$, if its state is $$$0$$$, or to $$$0$$$, if its state is $$$1$$$. The new state of each toggled gate remains unchanged until it is possibly toggled by one of the later updates.\nYour goal is to count, after each update, how many different assignments of parameters to threshold gates result in gate $$$0$$$ having state $$$1$$$. Two assignments are considered different if there exists at least one threshold gate that has a different value of its parameter in both assignments. As the number of ways can be large, you should compute it modulo $$$1\\;000\\;002\\;022$$$.\nNote that in the example above, there are $$$6$$$ different assignments of parameters to threshold gates, since gates $$$0$$$, $$$1$$$ and $$$2$$$ have $$$2$$$, $$$3$$$ and $$$1$$$ inputs respectively. In $$$2$$$ out of these $$$6$$$ assignments, gate $$$0$$$ has state $$$1$$$.\nImplementation Details\nYour task is to implement two procedures.\nvoid init(int N, int M, int[] P, int[] A)\n$$$N$$$: the number of threshold gates.\n$$$M$$$: the number of source gates.\n$$$P$$$: an array of length $$$N + M$$$ describing the inputs to the threshold gates.\n$$$A$$$: an array of length $$$M$$$ describing the initial states of the source gates.\nThis procedure is called exactly once, before any calls to\ncount_ways\n.\nint count_ways(int L, int R)\n$$$L$$$, $$$R$$$: the boundaries of the range of source gates, whose states are toggled.\nThis procedure should first perform the specified update, and then return the number of ways, modulo $$$1\\;000\\;002\\;022$$$, of assigning parameters to the threshold gates, which result in gate $$$0$$$ having state $$$1$$$.\nThis procedure is called exactly $$$Q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M \\; Q$$$ ($$$1 \\le N, M \\le 100\\;000$$$, $$$1 \\le Q \\le 100\\;000$$$)\nline $$$2$$$: $$$P[0] \\; P[1] \\; \\ldots \\; P[N + M - 1]$$$ ($$$P[0] = -1$$$, $$$0 \\le P[i] \\textless i$$$ and $$$P[i] \\le N - 1$$$ (for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$))\nline $$$3$$$: $$$A[0] \\; A[1] \\; \\ldots \\; A[M - 1]$$$ ($$$0 \\le A[j] \\le 1$$$)\nline $$$4 + k$$$ ($$$0 \\le k \\le Q - 1$$$): $$$L \\; R$$$ for update $$$k$$$ ($$$N \\le L \\le R \\le N + M - 1$$$)\nEach threshold gate has at least one input (for each $$$i$$$ such that $$$0 \\le i \\le N - 1$$$ there exists an index $$$x$$$ such that $$$i \\textless x \\le N + M - 1$$$ and $$$P[x] = i$$$).\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + k$$$ ($$$0 \\le k \\le Q - 1$$$): the return value of\ncount_ways\nfor update $$$k$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n2\n$$$N = 1$$$, $$$M \\le 1000$$$, $$$Q \\le 5$$$\n2\n7\n$$$N, M \\le 1000$$$, $$$Q \\le 5$$$, each threshold gate has exactly two inputs.\n3\n9\n$$$N, M \\le 1000$$$, $$$Q \\le 5$$$\n4\n4\n$$$M = N + 1$$$, $$$M = 2^z$$$ (for some positive integer $$$z$$$), $$$P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$$$ (for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$), $$$L = R$$$\n5\n12\n$$$M = N + 1$$$, $$$M = 2^z$$$ (for some positive integer $$$z$$$), $$$P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$$$ (for each $$$i$$$ such that $$$1 \\le i \\le N + M - 1$$$)\n6\n27\nEach threshold gate has exactly two inputs.\n7\n28\n$$$N, M \\le 5000$$$\n8\n11\nNo additional constraints\nExample\nNote\nConsider the following sequence of calls:\ninit(3, 4, [-1, 0, 1, 2, 1, 1, 0], [1, 0, 1, 0])\nThis example is illustrated in the task description above.\ncount_ways(3, 4)\nThis toggles the states of gates $$$3$$$ and $$$4$$$, i.e. the state of gate $$$3$$$ becomes $$$0$$$, and the state of gate $$$4$$$ becomes $$$1$$$. Two ways of assigning the parameters which result in gate $$$0$$$ having state $$$1$$$ are illustrated in the pictures below.\nWay $$$1$$$\nWay $$$2$$$\nIn all other assignments of parameters, gate $$$0$$$ has state $$$0$$$. Thus, the procedure should return $$$2$$$.\ncount_ways(4, 5)\nThis toggles the states of gates $$$4$$$ and $$$5$$$. As a result, all source gates have state $$$0$$$, and for any assignment of parameters, gate $$$0$$$ has state $$$0$$$. Thus, the procedure should return $$$0$$$.\ncount_ways(3, 6)\nThis changes the states of all source gates to $$$1$$$. As a result, for any assignment of parameters, gate $$$0$$$ has state $$$1$$$. Thus, the procedure should return $$$6$$$.",
    "_meta": {
      "index": 80,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/D",
      "uuid": "ps_969fd0e2734d57b842286186e2891d40aebf4fb3"
    }
  },
  {
    "planning_view": {
      "title": "E. Rarest Insects",
      "task": "Find rarest insect type cardinality using ≤40000 button presses and moves",
      "given": [
        "N insects indexed 0 to N-1",
        "Each insect has integer type (0 to 10^9)",
        "Machine tracks insects inside it"
      ],
      "goal": "Determine cardinality of rarest insect type among all N insects",
      "key_rules": [
        "Total operations (move_inside + move_outside + press_button) ≤40000 each",
        "Grader is non-adaptive (types fixed before min_cardinality call)",
        "Duplicate moves allowed but count toward limit"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "N ≤ 200"
        },
        "2": {
          "points": 15,
          "req": "N ≤ 1000"
        },
        "3": {
          "points": 75,
          "req": "No constraints, partial scoring based on efficiency"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Rarest Insects",
      "contest": "IOI 2022 day 2",
      "one_line": "Find rarest insect type cardinality using ≤40000 button presses and moves",
      "given": [
        "N insects indexed 0 to N-1",
        "Each insect has integer type (0 to 10^9)",
        "Machine tracks insects inside it"
      ],
      "goal": "Determine cardinality of rarest insect type among all N insects",
      "mechanism": "Move insects in/out machine, press button to get max frequency inside",
      "success_condition": "Return correct minimum group size among all insect types",
      "constraints": {
        "critical": [
          "Total operations (move_inside + move_outside + press_button) ≤40000 each",
          "Grader is non-adaptive (types fixed before min_cardinality call)",
          "Duplicate moves allowed but count toward limit"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "N ≤ 200"
          },
          "2": {
            "points": 15,
            "req": "N ≤ 1000"
          },
          "3": {
            "points": 75,
            "req": "No constraints, partial scoring based on efficiency"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Rarest Insects",
        "contest": "IOI 2022 day 2",
        "one_line": "Find rarest insect type cardinality using ≤40000 button presses and moves"
      },
      "problem": {
        "given": [
          "N insects indexed 0 to N-1",
          "Each insect has integer type (0 to 10^9)",
          "Machine tracks insects inside it"
        ],
        "goal": "Determine cardinality of rarest insect type among all N insects",
        "mechanism": "Move insects in/out machine, press button to get max frequency inside",
        "success_condition": "Return correct minimum group size among all insect types"
      },
      "constraints": {
        "critical": [
          "Total operations (move_inside + move_outside + press_button) ≤40000 each",
          "Grader is non-adaptive (types fixed before min_cardinality call)",
          "Duplicate moves allowed but count toward limit"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "N ≤ 200"
          },
          "2": {
            "points": 15,
            "req": "N ≤ 1000"
          },
          "3": {
            "points": 75,
            "req": "No constraints, partial scoring based on efficiency"
          }
        }
      },
      "implementation": {
        "function_to_write": "int min_cardinality(int N)",
        "available_api": {
          "move_inside": {
            "signature": "void move_inside(int i)",
            "params": "i: insect index (0 to N-1)",
            "returns": "void",
            "side_effect": "Moves insect i inside machine (no effect if already inside)"
          },
          "move_outside": {
            "signature": "void move_outside(int i)",
            "params": "i: insect index (0 to N-1)",
            "returns": "void",
            "side_effect": "Moves insect i outside machine (no effect if already outside)"
          },
          "press_button": {
            "signature": "int press_button()",
            "params": "none",
            "returns": "Cardinality of most frequent type among insects inside machine",
            "side_effect": "none"
          }
        },
        "requirements": [
          "Indices are 0-indexed (0 to N-1)",
          "All three API calls count toward 40000 limit each",
          "Return correct minimum group size"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "2048 MB"
      },
      "samples": [],
      "original_statement": "There are $$$N$$$ insects, indexed from $$$0$$$ to $$$N - 1$$$, running around Pak Blangkon's house. Each insect has a\ntype\n, which is an integer between $$$0$$$ and $$$10^9$$$ inclusive. Multiple insects may have the same type.\nSuppose insects are grouped by type. We define the cardinality of the\nmost frequent\ninsect type as the number of insects in a group with the most number of insects. Similarly, the cardinality of the\nrarest\ninsect type is the number of insects in a group with the least number of insects.\nFor example, suppose that there are $$$11$$$ insects, whose types are $$$[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$$$. In this case, the cardinality of the\nmost frequent\ninsect type is $$$3$$$. The groups with the most number of insects are type $$$9$$$ and type $$$11$$$, each consisting of $$$3$$$ insects. The cardinality of the\nrarest\ninsect type is $$$1$$$. The groups with the least number of insects are type $$$7$$$, type $$$0$$$, and type $$$100$$$, each consisting of $$$1$$$ insect.\nPak Blangkon does not know the type of any insect. He has a machine with a single button that can provide some information about the types of the insects. Initially, the machine is empty. To use the machine, three types of operations can be performed:\nMove an insect to inside the machine.\nMove an insect to outside the machine.\nPress the button on the machine.\nEach type of operation can be performed at most $$$40\\;000$$$ times.\nWhenever the button is pressed, the machine reports the cardinality of the\nmost frequent\ninsect type, considering only insects inside the machine.\nYour task is to determine the cardinality of the\nrarest\ninsect type among all $$$N$$$ insects in Pak Blangkon's house by using the machine. Additionally, in some subtasks, your score depends on the maximum number of operations of a given type that are performed (see Subtasks section for details).\nImplementation Details\nYou should implement the following procedure:\nint min_cardinality(int N)\n$$$N$$$: the number of insects.\nThis procedure should return the cardinality of the\nrarest\ninsect type among all $$$N$$$ insects in Pak Blangkon's house.\nThis procedure is called exactly once.\nThe above procedure can make calls to the following procedures:\nvoid move_inside(int i)\n$$$i$$$: the index of the insect to be moved inside the machine. The value of $$$i$$$ must be between $$$0$$$ and $$$N - 1$$$ inclusive.\nIf this insect is already inside the machine, the call has no effect on the set of insects in the machine. However, it is still counted as a separate call.\nThis procedure can be called at most $$$40\\;000$$$ times.\nvoid move_outside(int i)\n$$$i$$$: the index of the insect to be moved outside the machine. The value of $$$i$$$ must be between $$$0$$$ and $$$N - 1$$$ inclusive.\nIf this insect is already outside the machine, the call has no effect on the set of insects in the machine. However, it is still counted as a separate call.\nThis procedure can be called at most $$$40\\;000$$$ times.\nint press_button()\nThis procedure returns the cardinality of the\nmost frequent\ninsect type, considering only insects inside the machine.\nThis procedure can be called at most $$$40\\;000$$$ times.\nThe grader is\nnot adaptive\n. That is, the types of all $$$N$$$ insects are fixed before\nmin_cardinality\nis called.\nInteraction\nLet $$$T$$$ be an array of $$$N$$$ integers where $$$T[i]$$$ is the type of insect $$$i$$$.\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$ ($$$2 \\le N \\le 2000$$$)\nline $$$2$$$: $$$T[0] \\; T[1] \\; \\ldots \\; T[N - 1]$$$\nIf the sample grader detects a protocol violation, the output of the sample grader is\nProtocol Violation: <MSG>\n, where <MSG> is one of the following:\ninvalid parameter\n: in a call to\nmove_inside\nor\nmove_outside\n, the value of $$$i$$$ is not between $$$0$$$ and $$$N - 1$$$ inclusive.\ntoo many calls\n: the number of calls to\nany\nof\nmove_inside\n,\nmove_outside\n, or\npress_button\nexceeds $$$40\\;000$$$.\nOtherwise, the output of the sample grader is in the following format:\nline $$$1$$$: the return value of\nmin_cardinality\nline $$$2$$$: $$$q$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$N \\le 200$$$\n2\n15\n$$$N \\le 1000$$$\n3\n75\nNo additional constraints\nIf in any of the test cases, the calls to the procedures\nmove_inside\n,\nmove_outside\n, or\npress_button\ndo not conform to the constraints described in Implementation Details, or the return value of\nmin_cardinality\nis incorrect, the score of your solution for that subtask will be $$$0$$$.\nLet $$$q$$$ be the\nmaximum\nof the following three values: the number of calls to\nmove_inside\n, the number of calls to\nmove_outside\n, and the number of calls to\npress_button\n.\nIn subtask 3, you can obtain a partial score. Let $$$m$$$ be the maximum value of $$$\\frac{q}{N}$$$ across all test cases in this subtask. Your score for this subtask is calculated according to the following table:\nCondition\nPoints\n$$$20 \\textless m$$$\n$$$0$$$ (reported as\nquot;\nOutput isn't correct\nquot; in CMS)\n$$$6 \\textless m \\le 20$$$\n$$$\\frac{225}{m - 2}$$$\n$$$3 \\textless m \\le 6$$$\n$$$81 - \\frac{2}{3} m^2$$$\n$$$m \\le 3$$$\n$$$75$$$\nNote\nConsider a scenario in which there are $$$6$$$ insects of types $$$[5, 8, 9, 5, 9, 9]$$$ respectively. The procedure\nmin_cardinality\nis called in the following way:\nmin_cardinality(6)\nThe procedure may call\nmove_inside\n,\nmove_outside\n, and\npress_button\nas follows.\nCall\nReturn value\nInsects in the machine\nTypes of insects in the machine\n$$$\\{\\}$$$\n$$$[]$$$\nmove_inside(0)\n$$$\\{0\\}$$$\n$$$[5]$$$\npress_button()\n$$$1$$$\n$$$\\{0\\}$$$\n$$$[5]$$$\nmove_inside(1)\n$$$\\{0, 1\\}$$$\n$$$[5, 8]$$$\npress_button()\n$$$1$$$\n$$$\\{0, 1\\}$$$\n$$$[5, 8]$$$\nmove_inside(3)\n$$$\\{0, 1, 3\\}$$$\n$$$[5, 8, 5]$$$\npress_button()\n$$$2$$$\n$$$\\{0, 1, 3\\}$$$\n$$$[5, 8, 5]$$$\nmove_inside(2)\n$$$\\{0, 1, 2, 3\\}$$$\n$$$[5, 8, 9, 5]$$$\nmove_inside(4)\n$$$\\{0, 1, 2, 3, 4\\}$$$\n$$$[5, 8, 9, 5, 9]$$$\nmove_inside(5)\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\npress_button()\n$$$3$$$\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\nmove_inside(5)\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\npress_button()\n$$$3$$$\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\nmove_outside(5)\n$$$\\{0, 1, 2, 3, 4\\}$$$\n$$$[5, 8, 9, 5, 9]$$$\npress_button()\n$$$2$$$\n$$$\\{0, 1, 2, 3, 4\\}$$$\n$$$[5, 8, 9, 5, 9]$$$\nAt this point, there is sufficient information to conclude that the cardinality of the rarest insect type is $$$1$$$. Therefore, the procedure\nmin_cardinality\nshould return $$$1$$$.\nIn this example,\nmove_inside\nis called $$$7$$$ times,\nmove_outside\nis called $$$1$$$ time, and\npress_button\nis called $$$6$$$ times."
    },
    "original": "There are $$$N$$$ insects, indexed from $$$0$$$ to $$$N - 1$$$, running around Pak Blangkon's house. Each insect has a\ntype\n, which is an integer between $$$0$$$ and $$$10^9$$$ inclusive. Multiple insects may have the same type.\nSuppose insects are grouped by type. We define the cardinality of the\nmost frequent\ninsect type as the number of insects in a group with the most number of insects. Similarly, the cardinality of the\nrarest\ninsect type is the number of insects in a group with the least number of insects.\nFor example, suppose that there are $$$11$$$ insects, whose types are $$$[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$$$. In this case, the cardinality of the\nmost frequent\ninsect type is $$$3$$$. The groups with the most number of insects are type $$$9$$$ and type $$$11$$$, each consisting of $$$3$$$ insects. The cardinality of the\nrarest\ninsect type is $$$1$$$. The groups with the least number of insects are type $$$7$$$, type $$$0$$$, and type $$$100$$$, each consisting of $$$1$$$ insect.\nPak Blangkon does not know the type of any insect. He has a machine with a single button that can provide some information about the types of the insects. Initially, the machine is empty. To use the machine, three types of operations can be performed:\nMove an insect to inside the machine.\nMove an insect to outside the machine.\nPress the button on the machine.\nEach type of operation can be performed at most $$$40\\;000$$$ times.\nWhenever the button is pressed, the machine reports the cardinality of the\nmost frequent\ninsect type, considering only insects inside the machine.\nYour task is to determine the cardinality of the\nrarest\ninsect type among all $$$N$$$ insects in Pak Blangkon's house by using the machine. Additionally, in some subtasks, your score depends on the maximum number of operations of a given type that are performed (see Subtasks section for details).\nImplementation Details\nYou should implement the following procedure:\nint min_cardinality(int N)\n$$$N$$$: the number of insects.\nThis procedure should return the cardinality of the\nrarest\ninsect type among all $$$N$$$ insects in Pak Blangkon's house.\nThis procedure is called exactly once.\nThe above procedure can make calls to the following procedures:\nvoid move_inside(int i)\n$$$i$$$: the index of the insect to be moved inside the machine. The value of $$$i$$$ must be between $$$0$$$ and $$$N - 1$$$ inclusive.\nIf this insect is already inside the machine, the call has no effect on the set of insects in the machine. However, it is still counted as a separate call.\nThis procedure can be called at most $$$40\\;000$$$ times.\nvoid move_outside(int i)\n$$$i$$$: the index of the insect to be moved outside the machine. The value of $$$i$$$ must be between $$$0$$$ and $$$N - 1$$$ inclusive.\nIf this insect is already outside the machine, the call has no effect on the set of insects in the machine. However, it is still counted as a separate call.\nThis procedure can be called at most $$$40\\;000$$$ times.\nint press_button()\nThis procedure returns the cardinality of the\nmost frequent\ninsect type, considering only insects inside the machine.\nThis procedure can be called at most $$$40\\;000$$$ times.\nThe grader is\nnot adaptive\n. That is, the types of all $$$N$$$ insects are fixed before\nmin_cardinality\nis called.\nInteraction\nLet $$$T$$$ be an array of $$$N$$$ integers where $$$T[i]$$$ is the type of insect $$$i$$$.\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$ ($$$2 \\le N \\le 2000$$$)\nline $$$2$$$: $$$T[0] \\; T[1] \\; \\ldots \\; T[N - 1]$$$\nIf the sample grader detects a protocol violation, the output of the sample grader is\nProtocol Violation: <MSG>\n, where <MSG> is one of the following:\ninvalid parameter\n: in a call to\nmove_inside\nor\nmove_outside\n, the value of $$$i$$$ is not between $$$0$$$ and $$$N - 1$$$ inclusive.\ntoo many calls\n: the number of calls to\nany\nof\nmove_inside\n,\nmove_outside\n, or\npress_button\nexceeds $$$40\\;000$$$.\nOtherwise, the output of the sample grader is in the following format:\nline $$$1$$$: the return value of\nmin_cardinality\nline $$$2$$$: $$$q$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$N \\le 200$$$\n2\n15\n$$$N \\le 1000$$$\n3\n75\nNo additional constraints\nIf in any of the test cases, the calls to the procedures\nmove_inside\n,\nmove_outside\n, or\npress_button\ndo not conform to the constraints described in Implementation Details, or the return value of\nmin_cardinality\nis incorrect, the score of your solution for that subtask will be $$$0$$$.\nLet $$$q$$$ be the\nmaximum\nof the following three values: the number of calls to\nmove_inside\n, the number of calls to\nmove_outside\n, and the number of calls to\npress_button\n.\nIn subtask 3, you can obtain a partial score. Let $$$m$$$ be the maximum value of $$$\\frac{q}{N}$$$ across all test cases in this subtask. Your score for this subtask is calculated according to the following table:\nCondition\nPoints\n$$$20 \\textless m$$$\n$$$0$$$ (reported as\nquot;\nOutput isn't correct\nquot; in CMS)\n$$$6 \\textless m \\le 20$$$\n$$$\\frac{225}{m - 2}$$$\n$$$3 \\textless m \\le 6$$$\n$$$81 - \\frac{2}{3} m^2$$$\n$$$m \\le 3$$$\n$$$75$$$\nNote\nConsider a scenario in which there are $$$6$$$ insects of types $$$[5, 8, 9, 5, 9, 9]$$$ respectively. The procedure\nmin_cardinality\nis called in the following way:\nmin_cardinality(6)\nThe procedure may call\nmove_inside\n,\nmove_outside\n, and\npress_button\nas follows.\nCall\nReturn value\nInsects in the machine\nTypes of insects in the machine\n$$$\\{\\}$$$\n$$$[]$$$\nmove_inside(0)\n$$$\\{0\\}$$$\n$$$[5]$$$\npress_button()\n$$$1$$$\n$$$\\{0\\}$$$\n$$$[5]$$$\nmove_inside(1)\n$$$\\{0, 1\\}$$$\n$$$[5, 8]$$$\npress_button()\n$$$1$$$\n$$$\\{0, 1\\}$$$\n$$$[5, 8]$$$\nmove_inside(3)\n$$$\\{0, 1, 3\\}$$$\n$$$[5, 8, 5]$$$\npress_button()\n$$$2$$$\n$$$\\{0, 1, 3\\}$$$\n$$$[5, 8, 5]$$$\nmove_inside(2)\n$$$\\{0, 1, 2, 3\\}$$$\n$$$[5, 8, 9, 5]$$$\nmove_inside(4)\n$$$\\{0, 1, 2, 3, 4\\}$$$\n$$$[5, 8, 9, 5, 9]$$$\nmove_inside(5)\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\npress_button()\n$$$3$$$\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\nmove_inside(5)\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\npress_button()\n$$$3$$$\n$$$\\{0, 1, 2, 3, 4, 5\\}$$$\n$$$[5, 8, 9, 5, 9, 9]$$$\nmove_outside(5)\n$$$\\{0, 1, 2, 3, 4\\}$$$\n$$$[5, 8, 9, 5, 9]$$$\npress_button()\n$$$2$$$\n$$$\\{0, 1, 2, 3, 4\\}$$$\n$$$[5, 8, 9, 5, 9]$$$\nAt this point, there is sufficient information to conclude that the cardinality of the rarest insect type is $$$1$$$. Therefore, the procedure\nmin_cardinality\nshould return $$$1$$$.\nIn this example,\nmove_inside\nis called $$$7$$$ times,\nmove_outside\nis called $$$1$$$ time, and\npress_button\nis called $$$6$$$ times.",
    "_meta": {
      "index": 81,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/E",
      "uuid": "ps_15cc1a71d25fef76053956a8cbff16c4d557828c"
    }
  },
  {
    "planning_view": {
      "title": "D. Mechanical Doll",
      "task": "Design circuit with switches to trigger sequence A using ≤400,000 switches, P≤20M state changes",
      "given": [
        "M triggers (serial numbers 1..M)",
        "Sequence A of N trigger serial numbers (N≤200,000)",
        "One origin device (serial 0)",
        "Switches with X/Y states that toggle when used"
      ],
      "goal": "Build circuit connecting devices so ball travels trigger sequence A and returns to origin",
      "key_rules": [
        "Maximum 400,000 switches allowed",
        "Total switch state changes P ≤ 20,000,000",
        "Ball must return to origin exactly after N triggers",
        "All switches must be in 'X' state at return"
      ],
      "target": {
        "1": {
          "points": 2,
          "req": "Each trigger appears at most once in A"
        },
        "2": {
          "points": 4,
          "req": "Each trigger appears at most twice in A"
        },
        "3": {
          "points": 10,
          "req": "Each trigger appears at most 4 times in A"
        },
        "4": {
          "points": 10,
          "req": "N=16"
        },
        "5": {
          "points": 18,
          "req": "M=1"
        },
        "6": {
          "points": 56,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Mechanical Doll",
      "contest": "IOI 2018 day 2",
      "one_line": "Design circuit with switches to trigger sequence A using ≤400,000 switches, P≤20M state changes",
      "given": [
        "M triggers (serial numbers 1..M)",
        "Sequence A of N trigger serial numbers (N≤200,000)",
        "One origin device (serial 0)",
        "Switches with X/Y states that toggle when used"
      ],
      "goal": "Build circuit connecting devices so ball travels trigger sequence A and returns to origin",
      "mechanism": "Ball moves through connected devices; switches route based on state and toggle after use",
      "success_condition": "First return to origin after N triggers, all switches in 'X' state",
      "constraints": {
        "critical": [
          "Maximum 400,000 switches allowed",
          "Total switch state changes P ≤ 20,000,000",
          "Ball must return to origin exactly after N triggers",
          "All switches must be in 'X' state at return"
        ],
        "subtasks": {
          "1": {
            "points": 2,
            "req": "Each trigger appears at most once in A"
          },
          "2": {
            "points": 4,
            "req": "Each trigger appears at most twice in A"
          },
          "3": {
            "points": 10,
            "req": "Each trigger appears at most 4 times in A"
          },
          "4": {
            "points": 10,
            "req": "N=16"
          },
          "5": {
            "points": 18,
            "req": "M=1"
          },
          "6": {
            "points": 56,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Mechanical Doll",
        "contest": "IOI 2018 day 2",
        "one_line": "Design circuit with switches to trigger sequence A using ≤400,000 switches, P≤20M state changes"
      },
      "problem": {
        "given": [
          "M triggers (serial numbers 1..M)",
          "Sequence A of N trigger serial numbers (N≤200,000)",
          "One origin device (serial 0)",
          "Switches with X/Y states that toggle when used"
        ],
        "goal": "Build circuit connecting devices so ball travels trigger sequence A and returns to origin",
        "mechanism": "Ball moves through connected devices; switches route based on state and toggle after use",
        "success_condition": "First return to origin after N triggers, all switches in 'X' state"
      },
      "constraints": {
        "critical": [
          "Maximum 400,000 switches allowed",
          "Total switch state changes P ≤ 20,000,000",
          "Ball must return to origin exactly after N triggers",
          "All switches must be in 'X' state at return"
        ],
        "subtasks": {
          "1": {
            "points": 2,
            "req": "Each trigger appears at most once in A"
          },
          "2": {
            "points": 4,
            "req": "Each trigger appears at most twice in A"
          },
          "3": {
            "points": 10,
            "req": "Each trigger appears at most 4 times in A"
          },
          "4": {
            "points": 10,
            "req": "N=16"
          },
          "5": {
            "points": 18,
            "req": "M=1"
          },
          "6": {
            "points": 56,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "void create_circuit(int M, int[] A)",
        "available_api": {
          "answer": {
            "signature": "void answer(int[] C, int[] X, int[] Y)",
            "params": "C: array[M+1] for device connections, X/Y: arrays[S] for switch outputs",
            "returns": "void",
            "side_effect": "Submits circuit design to grader"
          }
        },
        "requirements": [
          "C[i] must connect device i (0≤i≤M) to another device",
          "X[j], Y[j] define switch -j-1's X and Y outputs",
          "All connection values must be between -S and M inclusive",
          "Must call answer() exactly once"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "A mechanical doll is a doll which automatically repeats a specific sequence of motions.\nIn Japan, many mechanical dolls have been created since ancient times. The motions of a mechanical doll are controlled by a\ncircuit\nthat consists of\ndevices\n. The devices are connected with tubes. Each device has one or two\nexits\n, and can have arbitrarily many (possibly zero)\nentrances\n. Each tube connects an exit of a device to an entrance of the same or another device. Exactly one tube is connected to each entrance, and exactly one tube is connected to each exit.\nTo describe how the doll makes motions, consider a\nball\nthat is placed on one of the devices. The ball travels through the circuit. At each step of the travel, the ball leaves the device using one of its exits, travels along the tube connected to the exit and enters the device at the other end of the tube.\nThere are three types of devices:\norigin\n,\ntrigger\n, and\nswitch\n. There are exactly one origin, $$$M$$$ triggers, and $$$S$$$ switches ($$$S$$$ can be zero). You must decide the value of $$$S$$$.\nEach device has a unique serial number. The origin is the device where the ball is initially placed. It has one exit. Its serial number is $$$0$$$.\nA trigger causes the doll to make a specific motion whenever the ball enters it. Every trigger has one exit. The serial numbers of the triggers are from $$$1$$$ through $$$M$$$.\nEach switch has two exits, which are called 'X' and 'Y'. The\nstate\nof a switch is either 'X' or 'Y'. After the ball enters a switch, it leaves the switch using the exit given by the current state of the switch. After that, the switch changes its state to the opposite one. Initially, the state of every switch is 'X'. The serial numbers of the switches are from $$$-1$$$ through $$$-S$$$.\nYou are given the number of triggers $$$M$$$. You are also given a sequence $$$A$$$ of length $$$N$$$, each of whose element is a serial number of a trigger. Each trigger might appear some (possibly zero) times in the sequence $$$A$$$. Your task is to create a circuit that satisfies the following conditions:\nThe ball returns to the origin after some steps.\nWhen the ball first returns to the origin, the state of every switch is 'X'.\nThe ball first returns to the origin after entering triggers exactly $$$N$$$ times. The serial numbers of the triggers, in the order that they are entered, are $$$A_0,A_1,\\ldots,A_{N-1}$$$.\nLet $$$P$$$ be the total number of state changes of all switches caused by the ball before the ball first returns to the origin. The value of $$$P$$$ doesn't exceed $$$20\\,000\\,000$$$.\nAt the same time, you don't want to use too many switches.\nImplementation details\nYou should implement the following procedure.\ncreate_circuit(int M, int[] A)\n$$$M$$$: the number of triggers.\n$$$A$$$: an array of length $$$N$$$, giving the serial numbers of the triggers the ball needs to enter, in the order they are to be entered.\nThis procedure is called exactly once.\nNote that the value of $$$N$$$ is the length of the array $$$A$$$, and can be obtained as indicated in the implementation notice.\nYour program should call the following procedure to answer.\nanswer(int[] C, int[] X, int[] Y)\n$$$C$$$: an array of length $$$M+1$$$. The exit of the device $$$i$$$ ($$$0 \\le i \\le M$$$) is connected to the device $$$C[i]$$$.\n$$$X$$$, $$$Y$$$: arrays of the same length. The length $$$S$$$ of these arrays is the number of the switches. For the switch $$$-j$$$ ($$$1 \\le j \\le S$$$), its exit 'X' is connected to the device $$$X[j - 1]$$$ and its exit 'Y' is connected to the device $$$Y[j - 1]$$$.\nEvery element of $$$C$$$, $$$X$$$, and $$$Y$$$ must be an integer between $$$-S$$$ and $$$M$$$, inclusive.\n$$$S$$$ must be at most $$$400\\,000$$$.\nThis procedure must be called exactly once.\nThe circuit represented by $$$C$$$, $$$X$$$, and $$$Y$$$ must satisfy the conditions in the problem statement.\nIf some of the above conditions are not satisfied, your program is judged as\nWrong Answer\n. Otherwise, your program is judged as\nAccepted\nand your score is calculated by $$$S$$$(see Subtasks).\nInput\nThe sample grader reads the input from the standard input in the following format.\nline $$$1$$$: $$$M\\ N$$$ ($$$1 \\le M \\le 100\\,000$$$, $$1 \\le N \\le 200\\,000$$$)\nline $$$2$$$: $$$A_0\\ A_1\\ldots A_{N-1}$$$ ($$$1 \\le A_i \\le M$$$)\nOutput\nThe sample grader produces three outputs.\nFirst, the sample grader outputs your answer to a file named out.txt in the following format.\nline $$$1$$$: $$$S$$$\nline $$$2 + i$$$ ($$$0 \\le i \\le M$$$): $$$C[i]$$$\nline $$$2 + M + j$$$ ($$$1 \\le j \\le S$$$): $$$X[j-1]\\ Y[j-1]$$$\nSecond, the sample grader simulates the moves of the ball. It outputs the serial numbers of the devices the ball entered in order to a file named log.txt.\nThird, the sample grader prints the evaluation of your answer to the standard output.\nIf your program is judged as\nAccepted\n, the sample grader prints $$$S$$$ and $$$P$$$ in the following format Accepted: $$$S\\ P$$$.\nIf your program is judged as\nWrong Answer\n, it prints Wrong Answer: MSG. The meaning of MSG is as follows:\nanswered not exactly once\n: The procedure answer is called not exactly once.\nwrong array length\n: The length of $$$C$$$ is not $$$M+1$$$, or the lengths of $$$X$$$ and $$$Y$$$ are different.\nover $$$400000$$$ switches\n: $$$S$$$ is larger than $$$400\\,000$$$.\nwrong serial number\n: There is an element of $$$C$$$, $$$X$$$, or $$$Y$$$ which is smaller than $$$-S$$$ or larger than $$$M$$$.\nover $$$20\\,000\\,000$$$ inversions\n: The ball doesn't return to the origin within $$$20\\,000\\,000$$$ state changes of the switches.\nstate 'Y'\n: There is a switch whose state is 'Y' when the ball first returns to the origin.\nwrong motion\n: The triggers which cause motions are different from the sequence $$$A$$$.\nNote that the sample grader might not create out.txt and/or log.txt when your program is judged as\nWrong Answer\n.\nScoring\nThe score and the constraints for each test case are as follows:\nSubtask\nPoints\nAdditional Input Constraints\n1\n2\nFor each $$$i$$$ ($$$1\\le i \\le M$$$), the integer $$$i$$$ appears at most once in the sequence $$$A_0,A_1,\\ldots A_{N-1}$$$.\n2\n4\nFor each $$$i$$$ ($$$1\\le i \\le M$$$), the integer $$$i$$$ appears at most twice in the sequence $$$A_0,A_1,\\ldots A_{N-1}$$$.\n3\n10\nFor each $$$i$$$ ($$$1\\le i\\le M$$$), the integer $$$i$$$ appears at most $$$4$$$ times in the sequence $$$A_0,A_1,\\ldots A_{N-1}$$$.\n4\n10\n$$$N=16$$$\n5\n18\n$$$M=1$$$\n6\n56\nNo additional constraints\nFor each test case, if your program is judged as\nAccepted\n, your score is calculated according to the value of $$$S$$$:\nIf $$$S\\le N + \\log_2{N}$$$, you gain the full score for the test case.\nFor each test case in Subtasks $$$5$$$ and $$$6$$$, if $$$N + \\log_2{N} \\textless S \\le 2\\cdot N$$$, you gain a partial score. The score for the test case is $$$0.5 + 0.4 \\times (\\frac{2N - S}{N - \\log_2{N}})^2$$$, multiplied by the score assigned to the subtask.\nOtherwise, the score is $$$0$$$.\nNote that your score for each subtask is the minimum of the scores for the test cases in the subtask.\nNote\nExample\nLet $$$M=4$$$, $$$N=4$$$, and $$$A=[1,2,1,3]$$$. The grader calls\ncreate_circuit(4, [1, 2, 1, 3])\n.\nThe above figure shows a circuit, which is described by a call\nanswer([1, -1, -2, 0, 2], [2, -2], [3, 1])\n. The numbers in the figure are the serial numbers of the devices.\nTwo switches are used. Thus $$$S=2$$$.\nInitially, the states of the switches $$$-1$$$ and $$$-2$$$ are both 'X'.\nThe ball travels as follows:\n$$$0\\rightarrow 1 \\rightarrow -1 \\stackrel{X}\\rightarrow 2 \\rightarrow -2 \\stackrel{X}\\rightarrow -2 \\stackrel{Y}\\rightarrow 1 \\rightarrow -1 \\stackrel{Y}\\rightarrow 3 \\rightarrow 0$$$\nWhen the ball first enters the switch $$$-1$$$, its state is 'X'. Hence, the ball travels to the trigger $$$2$$$. Then the state of the switch $$$-1$$$ is changed to 'Y'.\nWhen the ball enters the switch $$$-1$$$ for the second time, its state is 'Y'. Hence, the ball travels to the trigger $$$3$$$. Then the state of the switch $$$-1$$$ is changed to 'X'.\nThe ball first returns to the origin, having entered the triggers $$$1,2,1,3$$$. The states of the switches $$$-1$$$ and $$$-2$$$ are both 'X'. The value of $$$P$$$ is $$$4$$$. Therefore, this circuit satisfies the conditions.\nThe file sample-01-in.txt in the zipped attachment package corresponds to this example. Other sample inputs are also available in the package."
    },
    "original": "A mechanical doll is a doll which automatically repeats a specific sequence of motions.\nIn Japan, many mechanical dolls have been created since ancient times. The motions of a mechanical doll are controlled by a\ncircuit\nthat consists of\ndevices\n. The devices are connected with tubes. Each device has one or two\nexits\n, and can have arbitrarily many (possibly zero)\nentrances\n. Each tube connects an exit of a device to an entrance of the same or another device. Exactly one tube is connected to each entrance, and exactly one tube is connected to each exit.\nTo describe how the doll makes motions, consider a\nball\nthat is placed on one of the devices. The ball travels through the circuit. At each step of the travel, the ball leaves the device using one of its exits, travels along the tube connected to the exit and enters the device at the other end of the tube.\nThere are three types of devices:\norigin\n,\ntrigger\n, and\nswitch\n. There are exactly one origin, $$$M$$$ triggers, and $$$S$$$ switches ($$$S$$$ can be zero). You must decide the value of $$$S$$$.\nEach device has a unique serial number. The origin is the device where the ball is initially placed. It has one exit. Its serial number is $$$0$$$.\nA trigger causes the doll to make a specific motion whenever the ball enters it. Every trigger has one exit. The serial numbers of the triggers are from $$$1$$$ through $$$M$$$.\nEach switch has two exits, which are called 'X' and 'Y'. The\nstate\nof a switch is either 'X' or 'Y'. After the ball enters a switch, it leaves the switch using the exit given by the current state of the switch. After that, the switch changes its state to the opposite one. Initially, the state of every switch is 'X'. The serial numbers of the switches are from $$$-1$$$ through $$$-S$$$.\nYou are given the number of triggers $$$M$$$. You are also given a sequence $$$A$$$ of length $$$N$$$, each of whose element is a serial number of a trigger. Each trigger might appear some (possibly zero) times in the sequence $$$A$$$. Your task is to create a circuit that satisfies the following conditions:\nThe ball returns to the origin after some steps.\nWhen the ball first returns to the origin, the state of every switch is 'X'.\nThe ball first returns to the origin after entering triggers exactly $$$N$$$ times. The serial numbers of the triggers, in the order that they are entered, are $$$A_0,A_1,\\ldots,A_{N-1}$$$.\nLet $$$P$$$ be the total number of state changes of all switches caused by the ball before the ball first returns to the origin. The value of $$$P$$$ doesn't exceed $$$20\\,000\\,000$$$.\nAt the same time, you don't want to use too many switches.\nImplementation details\nYou should implement the following procedure.\ncreate_circuit(int M, int[] A)\n$$$M$$$: the number of triggers.\n$$$A$$$: an array of length $$$N$$$, giving the serial numbers of the triggers the ball needs to enter, in the order they are to be entered.\nThis procedure is called exactly once.\nNote that the value of $$$N$$$ is the length of the array $$$A$$$, and can be obtained as indicated in the implementation notice.\nYour program should call the following procedure to answer.\nanswer(int[] C, int[] X, int[] Y)\n$$$C$$$: an array of length $$$M+1$$$. The exit of the device $$$i$$$ ($$$0 \\le i \\le M$$$) is connected to the device $$$C[i]$$$.\n$$$X$$$, $$$Y$$$: arrays of the same length. The length $$$S$$$ of these arrays is the number of the switches. For the switch $$$-j$$$ ($$$1 \\le j \\le S$$$), its exit 'X' is connected to the device $$$X[j - 1]$$$ and its exit 'Y' is connected to the device $$$Y[j - 1]$$$.\nEvery element of $$$C$$$, $$$X$$$, and $$$Y$$$ must be an integer between $$$-S$$$ and $$$M$$$, inclusive.\n$$$S$$$ must be at most $$$400\\,000$$$.\nThis procedure must be called exactly once.\nThe circuit represented by $$$C$$$, $$$X$$$, and $$$Y$$$ must satisfy the conditions in the problem statement.\nIf some of the above conditions are not satisfied, your program is judged as\nWrong Answer\n. Otherwise, your program is judged as\nAccepted\nand your score is calculated by $$$S$$$(see Subtasks).\nInput\nThe sample grader reads the input from the standard input in the following format.\nline $$$1$$$: $$$M\\ N$$$ ($$$1 \\le M \\le 100\\,000$$$, $$1 \\le N \\le 200\\,000$$$)\nline $$$2$$$: $$$A_0\\ A_1\\ldots A_{N-1}$$$ ($$$1 \\le A_i \\le M$$$)\nOutput\nThe sample grader produces three outputs.\nFirst, the sample grader outputs your answer to a file named out.txt in the following format.\nline $$$1$$$: $$$S$$$\nline $$$2 + i$$$ ($$$0 \\le i \\le M$$$): $$$C[i]$$$\nline $$$2 + M + j$$$ ($$$1 \\le j \\le S$$$): $$$X[j-1]\\ Y[j-1]$$$\nSecond, the sample grader simulates the moves of the ball. It outputs the serial numbers of the devices the ball entered in order to a file named log.txt.\nThird, the sample grader prints the evaluation of your answer to the standard output.\nIf your program is judged as\nAccepted\n, the sample grader prints $$$S$$$ and $$$P$$$ in the following format Accepted: $$$S\\ P$$$.\nIf your program is judged as\nWrong Answer\n, it prints Wrong Answer: MSG. The meaning of MSG is as follows:\nanswered not exactly once\n: The procedure answer is called not exactly once.\nwrong array length\n: The length of $$$C$$$ is not $$$M+1$$$, or the lengths of $$$X$$$ and $$$Y$$$ are different.\nover $$$400000$$$ switches\n: $$$S$$$ is larger than $$$400\\,000$$$.\nwrong serial number\n: There is an element of $$$C$$$, $$$X$$$, or $$$Y$$$ which is smaller than $$$-S$$$ or larger than $$$M$$$.\nover $$$20\\,000\\,000$$$ inversions\n: The ball doesn't return to the origin within $$$20\\,000\\,000$$$ state changes of the switches.\nstate 'Y'\n: There is a switch whose state is 'Y' when the ball first returns to the origin.\nwrong motion\n: The triggers which cause motions are different from the sequence $$$A$$$.\nNote that the sample grader might not create out.txt and/or log.txt when your program is judged as\nWrong Answer\n.\nScoring\nThe score and the constraints for each test case are as follows:\nSubtask\nPoints\nAdditional Input Constraints\n1\n2\nFor each $$$i$$$ ($$$1\\le i \\le M$$$), the integer $$$i$$$ appears at most once in the sequence $$$A_0,A_1,\\ldots A_{N-1}$$$.\n2\n4\nFor each $$$i$$$ ($$$1\\le i \\le M$$$), the integer $$$i$$$ appears at most twice in the sequence $$$A_0,A_1,\\ldots A_{N-1}$$$.\n3\n10\nFor each $$$i$$$ ($$$1\\le i\\le M$$$), the integer $$$i$$$ appears at most $$$4$$$ times in the sequence $$$A_0,A_1,\\ldots A_{N-1}$$$.\n4\n10\n$$$N=16$$$\n5\n18\n$$$M=1$$$\n6\n56\nNo additional constraints\nFor each test case, if your program is judged as\nAccepted\n, your score is calculated according to the value of $$$S$$$:\nIf $$$S\\le N + \\log_2{N}$$$, you gain the full score for the test case.\nFor each test case in Subtasks $$$5$$$ and $$$6$$$, if $$$N + \\log_2{N} \\textless S \\le 2\\cdot N$$$, you gain a partial score. The score for the test case is $$$0.5 + 0.4 \\times (\\frac{2N - S}{N - \\log_2{N}})^2$$$, multiplied by the score assigned to the subtask.\nOtherwise, the score is $$$0$$$.\nNote that your score for each subtask is the minimum of the scores for the test cases in the subtask.\nNote\nExample\nLet $$$M=4$$$, $$$N=4$$$, and $$$A=[1,2,1,3]$$$. The grader calls\ncreate_circuit(4, [1, 2, 1, 3])\n.\nThe above figure shows a circuit, which is described by a call\nanswer([1, -1, -2, 0, 2], [2, -2], [3, 1])\n. The numbers in the figure are the serial numbers of the devices.\nTwo switches are used. Thus $$$S=2$$$.\nInitially, the states of the switches $$$-1$$$ and $$$-2$$$ are both 'X'.\nThe ball travels as follows:\n$$$0\\rightarrow 1 \\rightarrow -1 \\stackrel{X}\\rightarrow 2 \\rightarrow -2 \\stackrel{X}\\rightarrow -2 \\stackrel{Y}\\rightarrow 1 \\rightarrow -1 \\stackrel{Y}\\rightarrow 3 \\rightarrow 0$$$\nWhen the ball first enters the switch $$$-1$$$, its state is 'X'. Hence, the ball travels to the trigger $$$2$$$. Then the state of the switch $$$-1$$$ is changed to 'Y'.\nWhen the ball enters the switch $$$-1$$$ for the second time, its state is 'Y'. Hence, the ball travels to the trigger $$$3$$$. Then the state of the switch $$$-1$$$ is changed to 'X'.\nThe ball first returns to the origin, having entered the triggers $$$1,2,1,3$$$. The states of the switches $$$-1$$$ and $$$-2$$$ are both 'X'. The value of $$$P$$$ is $$$4$$$. Therefore, this circuit satisfies the conditions.\nThe file sample-01-in.txt in the zipped attachment package corresponds to this example. Other sample inputs are also available in the package.",
    "_meta": {
      "index": 82,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/D",
      "uuid": "ps_be628d0db2448a7d59ff54518a91255462ecfb28"
    }
  },
  {
    "planning_view": {
      "title": "C. Tree",
      "task": "Find min cost coefficient assignment where each subtree sum ∈ [L,R]",
      "given": [
        "Rooted tree with N vertices (0..N-1)",
        "Each vertex has weight W[i]",
        "Parent array P where P[i] < i for all i ≥ 1"
      ],
      "goal": "Answer Q queries: for each (L,R), find min total cost of valid coefficient sequence",
      "key_rules": [
        "Subtree sum for every vertex i must be between L and R",
        "Coefficients can be negative, zero, or positive",
        "Tree structure guarantees P[i] < i (topological ordering)"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "Q ≤ 10; W[P[i]] ≤ W[i] for all i ≥ 1"
        },
        "2": {
          "points": 13,
          "req": "Q ≤ 10; N ≤ 2000"
        },
        "3": {
          "points": 18,
          "req": "Q ≤ 10; N ≤ 60000"
        },
        "4": {
          "points": 7,
          "req": "All weights = 1"
        },
        "5": {
          "points": 11,
          "req": "All weights ≤ 1"
        },
        "6": {
          "points": 22,
          "req": "L = 1"
        },
        "7": {
          "points": 19,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "C. Tree",
      "contest": "IOI 2024 day 1",
      "one_line": "Find min cost coefficient assignment where each subtree sum ∈ [L,R]",
      "given": [
        "Rooted tree with N vertices (0..N-1)",
        "Each vertex has weight W[i]",
        "Parent array P where P[i] < i for all i ≥ 1"
      ],
      "goal": "Answer Q queries: for each (L,R), find min total cost of valid coefficient sequence",
      "mechanism": "Assign coefficients C[i] to vertices; subtree sum constraints must satisfy L ≤ sum ≤ R; cost = sum(|C[i]| × W[i])",
      "success_condition": "Minimum total cost over all valid coefficient sequences",
      "constraints": {
        "critical": [
          "Subtree sum for every vertex i must be between L and R",
          "Coefficients can be negative, zero, or positive",
          "Tree structure guarantees P[i] < i (topological ordering)"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "Q ≤ 10; W[P[i]] ≤ W[i] for all i ≥ 1"
          },
          "2": {
            "points": 13,
            "req": "Q ≤ 10; N ≤ 2000"
          },
          "3": {
            "points": 18,
            "req": "Q ≤ 10; N ≤ 60000"
          },
          "4": {
            "points": 7,
            "req": "All weights = 1"
          },
          "5": {
            "points": 11,
            "req": "All weights ≤ 1"
          },
          "6": {
            "points": 22,
            "req": "L = 1"
          },
          "7": {
            "points": 19,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "C. Tree",
        "contest": "IOI 2024 day 1",
        "one_line": "Find min cost coefficient assignment where each subtree sum ∈ [L,R]"
      },
      "problem": {
        "given": [
          "Rooted tree with N vertices (0..N-1)",
          "Each vertex has weight W[i]",
          "Parent array P where P[i] < i for all i ≥ 1"
        ],
        "goal": "Answer Q queries: for each (L,R), find min total cost of valid coefficient sequence",
        "mechanism": "Assign coefficients C[i] to vertices; subtree sum constraints must satisfy L ≤ sum ≤ R; cost = sum(|C[i]| × W[i])",
        "success_condition": "Minimum total cost over all valid coefficient sequences"
      },
      "constraints": {
        "critical": [
          "Subtree sum for every vertex i must be between L and R",
          "Coefficients can be negative, zero, or positive",
          "Tree structure guarantees P[i] < i (topological ordering)"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "Q ≤ 10; W[P[i]] ≤ W[i] for all i ≥ 1"
          },
          "2": {
            "points": 13,
            "req": "Q ≤ 10; N ≤ 2000"
          },
          "3": {
            "points": 18,
            "req": "Q ≤ 10; N ≤ 60000"
          },
          "4": {
            "points": 7,
            "req": "All weights = 1"
          },
          "5": {
            "points": 11,
            "req": "All weights ≤ 1"
          },
          "6": {
            "points": 22,
            "req": "L = 1"
          },
          "7": {
            "points": 19,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "long long query(int L, int R)",
        "available_api": {
          "init": {
            "signature": "void init(std::vector<int> P, std::vector<int> W)",
            "params": "P: parent array of length N, W: weight array of length N",
            "returns": "void",
            "side_effect": "Initializes tree structure for subsequent queries"
          },
          "query": {
            "signature": "long long query(int L, int R)",
            "params": "L, R: query bounds for subtree sum constraints",
            "returns": "Minimum total cost for valid coefficient sequence",
            "side_effect": "None"
          }
        },
        "requirements": [
          "init called exactly once before any queries",
          "query called Q times",
          "Vertices 0-indexed",
          "P[0] = -1 (root has no parent)"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "3\n0 0\n1 1 1\n2\n1 1\n1 2",
          "output": "3\n2"
        }
      ],
      "original_statement": "Consider a\ntree\nconsisting of $$$N$$$\nvertices\n, numbered from $$$0$$$ to $$$N - 1$$$. Vertex $$$0$$$ is called the\nroot\n. Every vertex, except for the root, has a single\nparent\n. For every $$$i$$$, such that $$$1 \\leq i < N$$$, the parent of vertex $$$i$$$ is vertex $$$P[i]$$$, where $$$P[i] < i$$$. We also assume $$$P[0] = -1$$$.\nFor any vertex $$$i$$$ ($$$0 \\leq i < N$$$), the\nsubtree\nof $$$i$$$ is the set of the following vertices:\n$$$i$$$, and\nany vertex whose parent is $$$i$$$, and\nany vertex whose parent's parent is $$$i$$$, and\nany vertex whose parent's parent's parent is $$$i$$$, and\netc.\nThe picture below shows an example tree consisting of $$$N = 6$$$ vertices. Each arrow connects a vertex to its parent, except for the root, which has no parent. The subtree of vertex $$$2$$$ contains vertices $$$2, 3, 4$$$ and $$$5$$$. The subtree of vertex $$$0$$$ contains all $$$6$$$ vertices of the tree and the subtree of vertex $$$4$$$ contains only vertex $$$4$$$.\nEach vertex is assigned a nonnegative integer\nweight\n. We denote the weight of vertex $$$i$$$ ($$$0 \\leq i < N$$$) by $$$W[i]$$$.\nYour task is to write a program that will answer $$$Q$$$ queries, each specified by a pair of positive integers $$$(L, R)$$$. The answer to the query should be computed as follows.\nConsider assigning an integer, called a\ncoefficient\n, to each vertex of the tree. Such an assignment is described by a sequence $$$C[0], \\ldots, C[N-1]$$$, where $$$C[i]$$$ ($$$0 \\leq i < N$$$) is the coefficient assigned to vertex $$$i$$$. Let us call this sequence a\ncoefficient sequence\n. Note that the elements of the coefficient sequence can be negative, $$$0$$$, or positive.\nFor a query $$$(L, R)$$$, a coefficient sequence is called\nvalid\nif, for every vertex $$$i$$$ ($$$0 \\leq i < N$$$), the following condition holds: the sum of the coefficients of the vertices in the subtree of vertex $$$i$$$ is not less than $$$L$$$ and not greater than $$$R$$$.\nFor a given coefficient sequence $$$C[0], \\ldots, C[N-1]$$$, the\ncost\nof a vertex $$$i$$$ is $$$|C[i]| \\cdot W[i]$$$, where $$$|C[i]|$$$ denotes the absolute value of $$$C[i]$$$. Finally, the\ntotal cost\nis the sum of the costs of all vertices. Your task is to compute, for each query, the\nminimum total cost\nthat can be attained by some valid coefficient sequence.\nIt can be shown that for any query, at least one valid coefficient sequence exists.\nImplementation Details\nYou should implement the following two procedures:\nvoid init(std::vector<int> P, std::vector<int> W)\n$$$P$$$, $$$W$$$: arrays of integers of length $$$N$$$ specifying the parents and the weights.\nThis procedure is called exactly once in the beginning of the interaction between the grader and your program in each test case.\nlong long query(int L, int R)\n$$$L$$$, $$$R$$$: integers describing a query.\nThis procedure is called $$$Q$$$ times after the invocation of\ninit\nin each test case.\nThis procedure should return the answer to the given query.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\le N \\le 200\\;000$$$)\nline $$$2$$$: $$$P[1]\\; P[2]\\ldots P[N-1]$$$ ($$$0 \\le P[i] < i$$$)\nline $$$3$$$: $$$W[0]\\; W[1]\\ldots W[N-1]$$$ ($$$0 \\le W[i] \\le 1\\,000\\,000$$$)\nline $$$4$$$: $$$Q$$$ ($$$1 \\le Q \\le 100\\;000$$$)\nline $$$5 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$L[j]$$$ $$$R[j]$$$ ($$$1 \\le L[i] \\le R[i] \\le 1\\,000\\,000$$$)\nwhere $$$L[j]$$$ and $$$R[j]$$$ (for $$$0 \\le j < Q$$$) are the input arguments in the $$$j$$$-th call to\nquery\n. Note that the second line of the input contains\nonly\n$$$N - 1$$$\nintegers\n, as the sample grader does not read the value of $$$P[0]$$$.\n$$$P[0] = -1$$$\nOutput\nThe sample grader prints $$$Q$$$ lines, in the following format:\nline $$$1 + i$$$ ($$$0 \\le i \\le Q - 1$$$): $$$A[i]$$$\nwhere $$$A[j]$$$ (for $$$0 \\le j < Q$$$) is the value returned by the $$$j$$$-th call to query.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$Q\\le 10$$$; $$$W[P[i]]\\le W[i]$$$ for each $$$i$$$ such that $$$1\\le i< N$$$\n2\n13\n$$$Q\\le 10$$$; $$$N\\le 2000$$$\n3\n18\n$$$Q\\le 10$$$; $$$N\\le 60\\,000$$$\n4\n7\n$$$W[i] = 1$$$ for each $$$i$$$ such that $$$0 \\leq i < N$$$\n5\n11\n$$$W[i] \\leq 1$$$ for each $$$i$$$ such that $$$0 \\leq i < N$$$\n6\n22\n$$$L = 1$$$\n7\n19\nNo additional constraints.\nExample\nNote\nConsider the following calls:\ninit([-1, 0, 0], [1, 1, 1])\nThe tree consists of $$$3$$$ vertices, the root and its $$$2$$$ children. All vertices have weight $$$1$$$.\nquery(1, 1)\nIn this query $$$L = R = 1$$$, which means the sum of coefficients in every subtree must be equal to $$$1$$$. Consider the coefficient sequence $$$[-1, 1, 1]$$$. The tree and the corresponding coefficients (in shaded rectangles) are illustrated below.\nFor every vertex $$$i$$$ ($$$0 \\leq i < 3$$$), the sum of the coefficients of all vertices in the subtree of $$$i$$$ is equal to $$$1$$$. Hence, this coefficient sequence is valid. The total cost is computed as follows:\nVertex\nWeight\nCoefficient\nCost\n0\n1\n-1\n$$$\\mid -1 \\mid \\cdot 1 = 1$$$\n1\n1\n1\n$$$\\mid 1 \\mid \\cdot 1 = 1$$$\n2\n1\n1\n$$$\\mid 1 \\mid \\cdot 1 = 1$$$\nTherefore the total cost is $$$3$$$. This is the only valid coefficient sequence, therefore this call should return $$$3$$$.\nquery(1, 2)\nThe minimum total cost for this query is $$$2$$$, and is attained when the coefficient sequence is $$$[0, 1, 1]$$$."
    },
    "original": "Consider a\ntree\nconsisting of $$$N$$$\nvertices\n, numbered from $$$0$$$ to $$$N - 1$$$. Vertex $$$0$$$ is called the\nroot\n. Every vertex, except for the root, has a single\nparent\n. For every $$$i$$$, such that $$$1 \\leq i < N$$$, the parent of vertex $$$i$$$ is vertex $$$P[i]$$$, where $$$P[i] < i$$$. We also assume $$$P[0] = -1$$$.\nFor any vertex $$$i$$$ ($$$0 \\leq i < N$$$), the\nsubtree\nof $$$i$$$ is the set of the following vertices:\n$$$i$$$, and\nany vertex whose parent is $$$i$$$, and\nany vertex whose parent's parent is $$$i$$$, and\nany vertex whose parent's parent's parent is $$$i$$$, and\netc.\nThe picture below shows an example tree consisting of $$$N = 6$$$ vertices. Each arrow connects a vertex to its parent, except for the root, which has no parent. The subtree of vertex $$$2$$$ contains vertices $$$2, 3, 4$$$ and $$$5$$$. The subtree of vertex $$$0$$$ contains all $$$6$$$ vertices of the tree and the subtree of vertex $$$4$$$ contains only vertex $$$4$$$.\nEach vertex is assigned a nonnegative integer\nweight\n. We denote the weight of vertex $$$i$$$ ($$$0 \\leq i < N$$$) by $$$W[i]$$$.\nYour task is to write a program that will answer $$$Q$$$ queries, each specified by a pair of positive integers $$$(L, R)$$$. The answer to the query should be computed as follows.\nConsider assigning an integer, called a\ncoefficient\n, to each vertex of the tree. Such an assignment is described by a sequence $$$C[0], \\ldots, C[N-1]$$$, where $$$C[i]$$$ ($$$0 \\leq i < N$$$) is the coefficient assigned to vertex $$$i$$$. Let us call this sequence a\ncoefficient sequence\n. Note that the elements of the coefficient sequence can be negative, $$$0$$$, or positive.\nFor a query $$$(L, R)$$$, a coefficient sequence is called\nvalid\nif, for every vertex $$$i$$$ ($$$0 \\leq i < N$$$), the following condition holds: the sum of the coefficients of the vertices in the subtree of vertex $$$i$$$ is not less than $$$L$$$ and not greater than $$$R$$$.\nFor a given coefficient sequence $$$C[0], \\ldots, C[N-1]$$$, the\ncost\nof a vertex $$$i$$$ is $$$|C[i]| \\cdot W[i]$$$, where $$$|C[i]|$$$ denotes the absolute value of $$$C[i]$$$. Finally, the\ntotal cost\nis the sum of the costs of all vertices. Your task is to compute, for each query, the\nminimum total cost\nthat can be attained by some valid coefficient sequence.\nIt can be shown that for any query, at least one valid coefficient sequence exists.\nImplementation Details\nYou should implement the following two procedures:\nvoid init(std::vector<int> P, std::vector<int> W)\n$$$P$$$, $$$W$$$: arrays of integers of length $$$N$$$ specifying the parents and the weights.\nThis procedure is called exactly once in the beginning of the interaction between the grader and your program in each test case.\nlong long query(int L, int R)\n$$$L$$$, $$$R$$$: integers describing a query.\nThis procedure is called $$$Q$$$ times after the invocation of\ninit\nin each test case.\nThis procedure should return the answer to the given query.\nInput\nThe sample grader reads in the following format:\nline $$$1$$$: $$$N$$$ ($$$1 \\le N \\le 200\\;000$$$)\nline $$$2$$$: $$$P[1]\\; P[2]\\ldots P[N-1]$$$ ($$$0 \\le P[i] < i$$$)\nline $$$3$$$: $$$W[0]\\; W[1]\\ldots W[N-1]$$$ ($$$0 \\le W[i] \\le 1\\,000\\,000$$$)\nline $$$4$$$: $$$Q$$$ ($$$1 \\le Q \\le 100\\;000$$$)\nline $$$5 + j$$$ ($$$0 \\le j \\le Q - 1$$$): $$$L[j]$$$ $$$R[j]$$$ ($$$1 \\le L[i] \\le R[i] \\le 1\\,000\\,000$$$)\nwhere $$$L[j]$$$ and $$$R[j]$$$ (for $$$0 \\le j < Q$$$) are the input arguments in the $$$j$$$-th call to\nquery\n. Note that the second line of the input contains\nonly\n$$$N - 1$$$\nintegers\n, as the sample grader does not read the value of $$$P[0]$$$.\n$$$P[0] = -1$$$\nOutput\nThe sample grader prints $$$Q$$$ lines, in the following format:\nline $$$1 + i$$$ ($$$0 \\le i \\le Q - 1$$$): $$$A[i]$$$\nwhere $$$A[j]$$$ (for $$$0 \\le j < Q$$$) is the value returned by the $$$j$$$-th call to query.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n10\n$$$Q\\le 10$$$; $$$W[P[i]]\\le W[i]$$$ for each $$$i$$$ such that $$$1\\le i< N$$$\n2\n13\n$$$Q\\le 10$$$; $$$N\\le 2000$$$\n3\n18\n$$$Q\\le 10$$$; $$$N\\le 60\\,000$$$\n4\n7\n$$$W[i] = 1$$$ for each $$$i$$$ such that $$$0 \\leq i < N$$$\n5\n11\n$$$W[i] \\leq 1$$$ for each $$$i$$$ such that $$$0 \\leq i < N$$$\n6\n22\n$$$L = 1$$$\n7\n19\nNo additional constraints.\nExample\nNote\nConsider the following calls:\ninit([-1, 0, 0], [1, 1, 1])\nThe tree consists of $$$3$$$ vertices, the root and its $$$2$$$ children. All vertices have weight $$$1$$$.\nquery(1, 1)\nIn this query $$$L = R = 1$$$, which means the sum of coefficients in every subtree must be equal to $$$1$$$. Consider the coefficient sequence $$$[-1, 1, 1]$$$. The tree and the corresponding coefficients (in shaded rectangles) are illustrated below.\nFor every vertex $$$i$$$ ($$$0 \\leq i < 3$$$), the sum of the coefficients of all vertices in the subtree of $$$i$$$ is equal to $$$1$$$. Hence, this coefficient sequence is valid. The total cost is computed as follows:\nVertex\nWeight\nCoefficient\nCost\n0\n1\n-1\n$$$\\mid -1 \\mid \\cdot 1 = 1$$$\n1\n1\n1\n$$$\\mid 1 \\mid \\cdot 1 = 1$$$\n2\n1\n1\n$$$\\mid 1 \\mid \\cdot 1 = 1$$$\nTherefore the total cost is $$$3$$$. This is the only valid coefficient sequence, therefore this call should return $$$3$$$.\nquery(1, 2)\nThe minimum total cost for this query is $$$2$$$, and is attained when the coefficient sequence is $$$[0, 1, 1]$$$.",
    "_meta": {
      "index": 83,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/C",
      "uuid": "ps_1274f3dca4d969c598b9cf107186cd169f3531bc"
    }
  },
  {
    "planning_view": {
      "title": "B. Prisoner Challenge",
      "task": "Design prisoner strategy with ≤x whiteboard states to identify smaller bag",
      "given": [
        "Two bags (A, B) with 1-N coins each",
        "Bag amounts different, whiteboard starts at 0",
        "500 prisoners enter room one by one"
      ],
      "goal": "Ensure a prisoner correctly identifies the bag with fewer coins",
      "key_rules": [
        "Prisoners don't know previous prisoners' actions",
        "Must guess correctly - wrong guess loses",
        "Can only update whiteboard or make final guess",
        "x determines score (smaller x = higher score)"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "N ≤ 500, x ≤ 500"
        },
        "2": {
          "points": 5,
          "req": "N ≤ 500, x ≤ 70"
        },
        "3": {
          "points": 90,
          "req": "x ≤ 60, partial scoring based on x value"
        }
      }
    },
    "algorithm_view": {
      "title": "B. Prisoner Challenge",
      "contest": "IOI 2022 day 1",
      "one_line": "Design prisoner strategy with ≤x whiteboard states to identify smaller bag",
      "given": [
        "Two bags (A, B) with 1-N coins each",
        "Bag amounts different, whiteboard starts at 0",
        "500 prisoners enter room one by one"
      ],
      "goal": "Ensure a prisoner correctly identifies the bag with fewer coins",
      "mechanism": "Prisoners read whiteboard, inspect a bag, then update whiteboard or guess",
      "success_condition": "Any prisoner correctly identifies the smaller bag",
      "constraints": {
        "critical": [
          "Prisoners don't know previous prisoners' actions",
          "Must guess correctly - wrong guess loses",
          "Can only update whiteboard or make final guess",
          "x determines score (smaller x = higher score)"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N ≤ 500, x ≤ 500"
          },
          "2": {
            "points": 5,
            "req": "N ≤ 500, x ≤ 70"
          },
          "3": {
            "points": 90,
            "req": "x ≤ 60, partial scoring based on x value"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "B. Prisoner Challenge",
        "contest": "IOI 2022 day 1",
        "one_line": "Design prisoner strategy with ≤x whiteboard states to identify smaller bag"
      },
      "problem": {
        "given": [
          "Two bags (A, B) with 1-N coins each",
          "Bag amounts different, whiteboard starts at 0",
          "500 prisoners enter room one by one"
        ],
        "goal": "Ensure a prisoner correctly identifies the bag with fewer coins",
        "mechanism": "Prisoners read whiteboard, inspect a bag, then update whiteboard or guess",
        "success_condition": "Any prisoner correctly identifies the smaller bag"
      },
      "constraints": {
        "critical": [
          "Prisoners don't know previous prisoners' actions",
          "Must guess correctly - wrong guess loses",
          "Can only update whiteboard or make final guess",
          "x determines score (smaller x = higher score)"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "N ≤ 500, x ≤ 500"
          },
          "2": {
            "points": 5,
            "req": "N ≤ 500, x ≤ 70"
          },
          "3": {
            "points": 90,
            "req": "x ≤ 60, partial scoring based on x value"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[][] devise_strategy(int N)",
        "available_api": {},
        "requirements": [
          "Return array s of arrays with length N+1",
          "s[i][0] = 0 (inspect A) or 1 (inspect B)",
          "s[i][j] = -1 (guess A), -2 (guess B), or number 0-x to write",
          "Strategy must work for all valid coin distributions"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      },
      "samples": [],
      "original_statement": "In a prison, there are $$$500$$$ prisoners. One day, the warden offers them a chance to free themselves. He places two bags with money, bag A and bag B, in a room. Each bag contains between $$$1$$$ and $$$N$$$ coins, inclusive. The number of coins in bag A is\ndifferent\nfrom the number of coins in bag B. The warden presents the prisoners with a challenge. The goal of the prisoners is to identify the bag with fewer coins.\nThe room, in addition to the money bags, also contains a whiteboard. A single number must be written on the whiteboard at any time. Initially, the number on the whiteboard is $$$0$$$.\nThen, the warden asks the prisoners to enter the room, one by one. The prisoner who enters the room does not know which or how many other prisoners have entered the room before them. Every time a prisoner enters the room, they read the number currently written on the whiteboard. After reading the number, they must choose either bag A or bag B. The prisoner then\ninspects\nthe chosen bag, thus getting to know the number of coins inside it. Then, the prisoner must perform either of the following two\nactions\n:\nOverwrite the number on the whiteboard with a non-negative integer and leave the room. Note that they can either change or keep the current number. The challenge continues after that (unless all $$$500$$$ prisoners have already entered the room).\nIdentify one bag as the one that has fewer coins. This immediately ends the challenge.\nThe warden will not ask a prisoner who has left the room to enter the room again.\nThe prisoners win the challenge if one of them correctly identifies the bag with fewer coins. They lose if any of them identifies the bag incorrectly, or all $$$500$$$ of them have entered the room and not attempted to identify the bag with fewer coins.\nBefore the challenge starts, the prisoners gather in the prison hall and decide on a common\nstrategy\nfor the challenge in three steps.\nThey pick a non-negative integer $$$x$$$, which is the largest number they may ever want to write on the whiteboard.\nThey decide, for any number $$$i$$$ written on the whiteboard ($$$0 \\le i \\le x$$$), which bag should be inspected by a prisoner who reads number $$$i$$$ from the whiteboard upon entering the room.\nThey decide what action a prisoner in the room should perform after getting to know the number of coins in the inspected bag. Specifically, for any number $$$i$$$ written on the whiteboard ($$$0 \\le i \\le x$$$) and any number of coins $$$j$$$ seen in the inspected bag ($$$1 \\le j \\le N$$$), they either decide\nwhat number between $$$0$$$ and $$$x$$$ (inclusive) should be written on the whiteboard, or\nwhich bag should be identified as the one with fewer coins.\nUpon winning the challenge, the warden will release the prisoners after serving $$$x$$$ more days.\nYour task is to devise a strategy for the prisoners that would ensure they win the challenge (regardless of the number of coins in bag A and bag B). The score of your solution depends on the value of $$$x$$$ (see Subtasks section for details).\nImplementation Details\nYou should implement the following procedure:\nint[][] devise_strategy(int N)\n$$$N$$$: the maximum possible number of coins in each bag.\nThis procedure should return an array $$$s$$$ of arrays of $$$N + 1$$$ integers, representing your strategy. The value of $$$x$$$ is the length of array $$$s$$$ minus one. For each $$$i$$$ such that $$$0 \\le i \\le x$$$, the array $$$s[i]$$$ represents what a prisoner should do if they read number $$$i$$$ from the whiteboard upon entering the room:\nThe value of $$$s[i][0]$$$ is $$$0$$$ if the prisoner should inspect bag A, or $$$1$$$ if the prisoner should inspect bag B.\nLet $$$j$$$ be the number of coins seen in the chosen bag. The prisoner should then perform the following action:\nIf the value of $$$s[i][j]$$$ is $$$-1$$$, the prisoner should identify bag A as the one with fewer coins.\nIf the value of $$$s[i][j]$$$ is $$$-2$$$, the prisoner should identify bag B as the one with fewer coins.\nIf the value of $$$s[i][j]$$$ is a non-negative number, the prisoner should write that number on the whiteboard. Note that $$$s[i][j]$$$ must be at most $$$x$$$.\nThis procedure is called exactly once.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$ ($$$2 \\le N \\le 5000$$$)\nline $$$2 + k$$$ ($$$0 \\le k$$$): $$$A[k] \\; B[k]$$\nlast line: $$$-1$$$\nEach line except the first and the last one represents a scenario. We refer to the scenario described in line $$$2 + k$$$ as scenario $$$k$$$. In scenario $$$k$$$ bag A contains $$$A[k]$$$ coins and bag B contains $$$B[k]$$$ coins.\nOutput\nThe sample grader first calls\ndevise_strategy(N)\n. The value of $$$x$$$ is the length of the array returned by the call minus one. Then, if the sample grader detects that the array returned by\ndevise_strategy\ndoes not conform to the constraints described in Implementation Details, it prints one of the following error messages and exits:\ns is an empty array\n: $$$s$$$ is an empty array (which does not represent a valid strategy).\ns[i] contains incorrect length\n: There exists an index $$$i$$$ ($$$0 \\le i \\le x$$$) such that the length of $$$s[i]$$$ is not $$$N + 1$$$.\nFirst element of s[i] is non-binary\n: There exists an index $$$i$$$ ($$$0 \\le i \\le x$$$) such that $$$s[i][0]$$$ is neither $$$0$$$ nor $$$1$$$.\ns[i][j] contains incorrect value\n: There exist indices $$$i, j$$$ ($$$0 \\le i \\le x, 1 \\le j \\le N$$$) such that $$$s[i][j]$$$ is not between $$$-2$$$ and $$$x$$$.\nOtherwise, the sample grader produces two outputs.\nFirst, the sample grader prints the output of your strategy in the following format:\nline $$$1 + k$$$ ($$$0 \\le k$$$): output of your strategy for scenario $$$k$$$. If applying the strategy leads to a prisoner identifying bag A as the one with fewer coins, then the output is the character 'A'. If applying the strategy leads to a prisoner identifying bag B as the one with fewer coins, then the output is the character 'B'. If applying the strategy does not lead to any prisoner identifying a bag with fewer coins, then the output is the character 'X'.\nSecond, the sample grader writes a file 'log.txt' in the current directory in the following format:\nline $$$1 + k$$$ ($$$0 \\le k$$$): $$$w[k][0] \\; w[k][1] \\; \\ldots$$$\nThe sequence on line $$$1 + k$$$ corresponds to scenario $$$k$$$ and describes the numbers written on the whiteboard. Specifically, $$$w[k][l]$$$ is the number written by the $$${(l+1)}^{th}$$$ prisoner to enter the room.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$N \\le 500$$$, the value of $$$x$$$ must not be more than $$$500$$$\n2\n5\n$$$N \\le 500$$$, the value of $$$x$$$ must not be more than $$$70$$$\n3\n90\nThe value of $$$x$$$ must not be more than $$$60$$$\nIf in any of the test cases, the array returned by\ndevise_strategy\ndoes not represent a correct strategy, the score of your solution for that subtask will be $$$0$$$.\nIn subtask 3 you can obtain a partial score. Let $$$m$$$ be the maximum value of $$$x$$$ for the returned arrays over all test cases in this subtask. Your score for this subtask is calculated according to the following table:\nCondition\nPoints\n$$$40 \\le m \\le 60$$$\n$$$20$$$\n$$$26 \\le m \\le 39$$$\n$$$25 + 1.5 \\times (40 - m)$$$\n$$$m = 25$$$\n$$$50$$$\n$$$m = 24$$$\n$$$55$$$\n$$$m = 23$$$\n$$$62$$$\n$$$m = 22$$$\n$$$70$$$\n$$$m = 21$$$\n$$$80$$$\n$$$m \\le 20$$$\n$$$90$$$\nNote\nConsider the following call:\ndevise_strategy(3)\nLet $$$v$$$ denote the number the prisoner reads from the whiteboard upon entering the room. One of the correct strategies is as follows:\nIf $$$v = 0$$$ (including the initial number), inspect bag A.\nIf it contains $$$1$$$ coin, identify bag A as the one with fewer coins.\nIf it contains $$$3$$$ coins, identify bag B as the one with fewer coins.\nIf it contains $$$2$$$ coins, write $$$1$$$ on the whiteboard (overwriting $$$0$$$).\nIf $$$v = 1$$$, inspect bag B.\nIf it contains $$$1$$$ coin, identify bag B as the one with fewer coins.\nIf it contains $$$3$$$ coins, identify bag A as the one with fewer coins.\nIf it contains $$$2$$$ coins, write $$$0$$$ on the whiteboard (overwriting $$$1$$$). Note that this case can never happen, as we can conclude that both bags contain $$$2$$$ coins, which is not allowed.\nTo report this strategy the procedure should return\n[[0, -1, 1, -2], [1, -2, 0, -1]]\n. The length of the returned array is $$$2$$$, so for this return value the value of $$$x$$$ is $$$2 - 1 = 1$$$."
    },
    "original": "In a prison, there are $$$500$$$ prisoners. One day, the warden offers them a chance to free themselves. He places two bags with money, bag A and bag B, in a room. Each bag contains between $$$1$$$ and $$$N$$$ coins, inclusive. The number of coins in bag A is\ndifferent\nfrom the number of coins in bag B. The warden presents the prisoners with a challenge. The goal of the prisoners is to identify the bag with fewer coins.\nThe room, in addition to the money bags, also contains a whiteboard. A single number must be written on the whiteboard at any time. Initially, the number on the whiteboard is $$$0$$$.\nThen, the warden asks the prisoners to enter the room, one by one. The prisoner who enters the room does not know which or how many other prisoners have entered the room before them. Every time a prisoner enters the room, they read the number currently written on the whiteboard. After reading the number, they must choose either bag A or bag B. The prisoner then\ninspects\nthe chosen bag, thus getting to know the number of coins inside it. Then, the prisoner must perform either of the following two\nactions\n:\nOverwrite the number on the whiteboard with a non-negative integer and leave the room. Note that they can either change or keep the current number. The challenge continues after that (unless all $$$500$$$ prisoners have already entered the room).\nIdentify one bag as the one that has fewer coins. This immediately ends the challenge.\nThe warden will not ask a prisoner who has left the room to enter the room again.\nThe prisoners win the challenge if one of them correctly identifies the bag with fewer coins. They lose if any of them identifies the bag incorrectly, or all $$$500$$$ of them have entered the room and not attempted to identify the bag with fewer coins.\nBefore the challenge starts, the prisoners gather in the prison hall and decide on a common\nstrategy\nfor the challenge in three steps.\nThey pick a non-negative integer $$$x$$$, which is the largest number they may ever want to write on the whiteboard.\nThey decide, for any number $$$i$$$ written on the whiteboard ($$$0 \\le i \\le x$$$), which bag should be inspected by a prisoner who reads number $$$i$$$ from the whiteboard upon entering the room.\nThey decide what action a prisoner in the room should perform after getting to know the number of coins in the inspected bag. Specifically, for any number $$$i$$$ written on the whiteboard ($$$0 \\le i \\le x$$$) and any number of coins $$$j$$$ seen in the inspected bag ($$$1 \\le j \\le N$$$), they either decide\nwhat number between $$$0$$$ and $$$x$$$ (inclusive) should be written on the whiteboard, or\nwhich bag should be identified as the one with fewer coins.\nUpon winning the challenge, the warden will release the prisoners after serving $$$x$$$ more days.\nYour task is to devise a strategy for the prisoners that would ensure they win the challenge (regardless of the number of coins in bag A and bag B). The score of your solution depends on the value of $$$x$$$ (see Subtasks section for details).\nImplementation Details\nYou should implement the following procedure:\nint[][] devise_strategy(int N)\n$$$N$$$: the maximum possible number of coins in each bag.\nThis procedure should return an array $$$s$$$ of arrays of $$$N + 1$$$ integers, representing your strategy. The value of $$$x$$$ is the length of array $$$s$$$ minus one. For each $$$i$$$ such that $$$0 \\le i \\le x$$$, the array $$$s[i]$$$ represents what a prisoner should do if they read number $$$i$$$ from the whiteboard upon entering the room:\nThe value of $$$s[i][0]$$$ is $$$0$$$ if the prisoner should inspect bag A, or $$$1$$$ if the prisoner should inspect bag B.\nLet $$$j$$$ be the number of coins seen in the chosen bag. The prisoner should then perform the following action:\nIf the value of $$$s[i][j]$$$ is $$$-1$$$, the prisoner should identify bag A as the one with fewer coins.\nIf the value of $$$s[i][j]$$$ is $$$-2$$$, the prisoner should identify bag B as the one with fewer coins.\nIf the value of $$$s[i][j]$$$ is a non-negative number, the prisoner should write that number on the whiteboard. Note that $$$s[i][j]$$$ must be at most $$$x$$$.\nThis procedure is called exactly once.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N$$$ ($$$2 \\le N \\le 5000$$$)\nline $$$2 + k$$$ ($$$0 \\le k$$$): $$$A[k] \\; B[k]$$\nlast line: $$$-1$$$\nEach line except the first and the last one represents a scenario. We refer to the scenario described in line $$$2 + k$$$ as scenario $$$k$$$. In scenario $$$k$$$ bag A contains $$$A[k]$$$ coins and bag B contains $$$B[k]$$$ coins.\nOutput\nThe sample grader first calls\ndevise_strategy(N)\n. The value of $$$x$$$ is the length of the array returned by the call minus one. Then, if the sample grader detects that the array returned by\ndevise_strategy\ndoes not conform to the constraints described in Implementation Details, it prints one of the following error messages and exits:\ns is an empty array\n: $$$s$$$ is an empty array (which does not represent a valid strategy).\ns[i] contains incorrect length\n: There exists an index $$$i$$$ ($$$0 \\le i \\le x$$$) such that the length of $$$s[i]$$$ is not $$$N + 1$$$.\nFirst element of s[i] is non-binary\n: There exists an index $$$i$$$ ($$$0 \\le i \\le x$$$) such that $$$s[i][0]$$$ is neither $$$0$$$ nor $$$1$$$.\ns[i][j] contains incorrect value\n: There exist indices $$$i, j$$$ ($$$0 \\le i \\le x, 1 \\le j \\le N$$$) such that $$$s[i][j]$$$ is not between $$$-2$$$ and $$$x$$$.\nOtherwise, the sample grader produces two outputs.\nFirst, the sample grader prints the output of your strategy in the following format:\nline $$$1 + k$$$ ($$$0 \\le k$$$): output of your strategy for scenario $$$k$$$. If applying the strategy leads to a prisoner identifying bag A as the one with fewer coins, then the output is the character 'A'. If applying the strategy leads to a prisoner identifying bag B as the one with fewer coins, then the output is the character 'B'. If applying the strategy does not lead to any prisoner identifying a bag with fewer coins, then the output is the character 'X'.\nSecond, the sample grader writes a file 'log.txt' in the current directory in the following format:\nline $$$1 + k$$$ ($$$0 \\le k$$$): $$$w[k][0] \\; w[k][1] \\; \\ldots$$$\nThe sequence on line $$$1 + k$$$ corresponds to scenario $$$k$$$ and describes the numbers written on the whiteboard. Specifically, $$$w[k][l]$$$ is the number written by the $$${(l+1)}^{th}$$$ prisoner to enter the room.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n5\n$$$N \\le 500$$$, the value of $$$x$$$ must not be more than $$$500$$$\n2\n5\n$$$N \\le 500$$$, the value of $$$x$$$ must not be more than $$$70$$$\n3\n90\nThe value of $$$x$$$ must not be more than $$$60$$$\nIf in any of the test cases, the array returned by\ndevise_strategy\ndoes not represent a correct strategy, the score of your solution for that subtask will be $$$0$$$.\nIn subtask 3 you can obtain a partial score. Let $$$m$$$ be the maximum value of $$$x$$$ for the returned arrays over all test cases in this subtask. Your score for this subtask is calculated according to the following table:\nCondition\nPoints\n$$$40 \\le m \\le 60$$$\n$$$20$$$\n$$$26 \\le m \\le 39$$$\n$$$25 + 1.5 \\times (40 - m)$$$\n$$$m = 25$$$\n$$$50$$$\n$$$m = 24$$$\n$$$55$$$\n$$$m = 23$$$\n$$$62$$$\n$$$m = 22$$$\n$$$70$$$\n$$$m = 21$$$\n$$$80$$$\n$$$m \\le 20$$$\n$$$90$$$\nNote\nConsider the following call:\ndevise_strategy(3)\nLet $$$v$$$ denote the number the prisoner reads from the whiteboard upon entering the room. One of the correct strategies is as follows:\nIf $$$v = 0$$$ (including the initial number), inspect bag A.\nIf it contains $$$1$$$ coin, identify bag A as the one with fewer coins.\nIf it contains $$$3$$$ coins, identify bag B as the one with fewer coins.\nIf it contains $$$2$$$ coins, write $$$1$$$ on the whiteboard (overwriting $$$0$$$).\nIf $$$v = 1$$$, inspect bag B.\nIf it contains $$$1$$$ coin, identify bag B as the one with fewer coins.\nIf it contains $$$3$$$ coins, identify bag A as the one with fewer coins.\nIf it contains $$$2$$$ coins, write $$$0$$$ on the whiteboard (overwriting $$$1$$$). Note that this case can never happen, as we can conclude that both bags contain $$$2$$$ coins, which is not allowed.\nTo report this strategy the procedure should return\n[[0, -1, 1, -2], [1, -2, 0, -1]]\n. The length of the returned array is $$$2$$$, so for this return value the value of $$$x$$$ is $$$2 - 1 = 1$$$.",
    "_meta": {
      "index": 84,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/B",
      "uuid": "ps_290416af5e7c48cc30bca2c995c4f8128920c38d"
    }
  },
  {
    "planning_view": {
      "title": "A4. Pebbling odometer - subtask 4",
      "task": "Collect ≤15 scattered pebbles to cell (0,0) in ≤2M steps (200K optimal)",
      "given": [
        "256×256 grid with at most 15 pebbles",
        "No two pebbles start in same cell",
        "Odometer starts at (0,0) facing north"
      ],
      "goal": "Move all pebbles to the northwest corner cell (0,0)",
      "key_rules": [
        "Program size ≤200 commands (comments/labels excluded)",
        "Execution length scored logarithmically (200K optimal)",
        "Cells hold max 15 pebbles; odometer has infinite pebbles",
        "Border movement blocked; must use pebble/border checks"
      ],
      "target": {
        "4": {
          "points": "0-32 (depends on execution length)",
          "req": "L ≤ 200K: 32 pts; 200K < L < 2M: 32-32*log10(L/200K); L ≥ 2M: 0 pts"
        }
      }
    },
    "algorithm_view": {
      "title": "A4. Pebbling odometer - subtask 4",
      "contest": "IOI 2012 day 1",
      "one_line": "Collect ≤15 scattered pebbles to cell (0,0) in ≤2M steps (200K optimal)",
      "given": [
        "256×256 grid with at most 15 pebbles",
        "No two pebbles start in same cell",
        "Odometer starts at (0,0) facing north"
      ],
      "goal": "Move all pebbles to the northwest corner cell (0,0)",
      "mechanism": "Program odometer with movement, pebble collection, and conditional jumping commands",
      "success_condition": "Exactly x pebbles in (0,0) and zero elsewhere (x = initial total)",
      "constraints": {
        "critical": [
          "Program size ≤200 commands (comments/labels excluded)",
          "Execution length scored logarithmically (200K optimal)",
          "Cells hold max 15 pebbles; odometer has infinite pebbles",
          "Border movement blocked; must use pebble/border checks"
        ],
        "subtasks": {
          "4": {
            "points": "0-32 (depends on execution length)",
            "req": "L ≤ 200K: 32 pts; 200K < L < 2M: 32-32*log10(L/200K); L ≥ 2M: 0 pts"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A4. Pebbling odometer - subtask 4",
        "contest": "IOI 2012 day 1",
        "one_line": "Collect ≤15 scattered pebbles to cell (0,0) in ≤2M steps (200K optimal)"
      },
      "problem": {
        "given": [
          "256×256 grid with at most 15 pebbles",
          "No two pebbles start in same cell",
          "Odometer starts at (0,0) facing north"
        ],
        "goal": "Move all pebbles to the northwest corner cell (0,0)",
        "mechanism": "Program odometer with movement, pebble collection, and conditional jumping commands",
        "success_condition": "Exactly x pebbles in (0,0) and zero elsewhere (x = initial total)"
      },
      "constraints": {
        "critical": [
          "Program size ≤200 commands (comments/labels excluded)",
          "Execution length scored logarithmically (200K optimal)",
          "Cells hold max 15 pebbles; odometer has infinite pebbles",
          "Border movement blocked; must use pebble/border checks"
        ],
        "subtasks": {
          "4": {
            "points": "0-32 (depends on execution length)",
            "req": "L ≤ 200K: 32 pts; 200K < L < 2M: 32-32*log10(L/200K); L ≥ 2M: 0 pts"
          }
        }
      },
      "implementation": {
        "function_to_write": "Complete odometer program file",
        "available_api": {
          "move": {
            "signature": "move",
            "params": "None",
            "returns": "None",
            "side_effect": "Move forward one cell if not at border"
          },
          "left/right": {
            "signature": "left / right",
            "params": "None",
            "returns": "None",
            "side_effect": "Rotate 90° counterclockwise/clockwise"
          },
          "get/put": {
            "signature": "get / put",
            "params": "None",
            "returns": "None",
            "side_effect": "Remove/add pebble from/to current cell (if possible)"
          },
          "border": {
            "signature": "border L",
            "params": "L: label name",
            "returns": "None",
            "side_effect": "Jump to label L if at border facing edge"
          },
          "pebble": {
            "signature": "pebble L",
            "params": "L: label name",
            "returns": "None",
            "side_effect": "Jump to label L if current cell has ≥1 pebble"
          },
          "jump": {
            "signature": "jump L",
            "params": "L: label name",
            "returns": "None",
            "side_effect": "Unconditional jump to label L"
          },
          "halt": {
            "signature": "halt",
            "params": "None",
            "returns": "None",
            "side_effect": "Terminate program"
          }
        },
        "requirements": [
          "Submit complete .txt program file",
          "Max 5 MiB file size",
          "Labels: case-sensitive, a-zA-Z0-9, ≤128 chars",
          "# for comments, empty lines ignored",
          "Commands ≤1 per line"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask 4. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$."
    },
    "original": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask 4. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$.",
    "_meta": {
      "index": 85,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A4",
      "uuid": "ps_dac39b4c3d54a467704d04a9dbf4b1f688864afe"
    }
  },
  {
    "planning_view": {
      "title": "F. Parrots",
      "task": "Send N message bytes (0-255) via K parrots arriving in random order",
      "given": [
        "Message M of N integers (0-255)",
        "K parrots (K depends on N)",
        "Each parrot carries one number in range 0-R",
        "Parrots arrive in arbitrary order"
      ],
      "goal": "Encode message for parrots to carry, then decode from received numbers",
      "key_rules": [
        "Parrots arrive in arbitrary order (numbers permuted)",
        "Maximum K parrots can be used (K=10N or 15N depending on subtask)",
        "Sent numbers must be in range 0-R"
      ],
      "target": {
        "1": {
          "points": 17,
          "req": "N=8, binary message (0/1), K=10N, R≤65535"
        },
        "2": {
          "points": 17,
          "req": "N≤16, K=10N, R≤65535"
        },
        "3": {
          "points": 18,
          "req": "N≤16, K=10N, R≤255"
        },
        "4": {
          "points": 29,
          "req": "N≤32, K=10N, R≤255"
        },
        "5": {
          "points": "up to 19",
          "req": "N=16-64, K=15N, R≤255, score depends on compression ratio L/N"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Parrots",
      "contest": "IOI 2011 day 2",
      "one_line": "Send N message bytes (0-255) via K parrots arriving in random order",
      "given": [
        "Message M of N integers (0-255)",
        "K parrots (K depends on N)",
        "Each parrot carries one number in range 0-R",
        "Parrots arrive in arbitrary order"
      ],
      "goal": "Encode message for parrots to carry, then decode from received numbers",
      "mechanism": "Write encode(N,M) calling send(a) for each parrot, then decode(N,L,X) calling output(b) for each message byte",
      "success_condition": "Decoded output must match original message M exactly",
      "constraints": {
        "critical": [
          "Parrots arrive in arbitrary order (numbers permuted)",
          "Maximum K parrots can be used (K=10N or 15N depending on subtask)",
          "Sent numbers must be in range 0-R"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "N=8, binary message (0/1), K=10N, R≤65535"
          },
          "2": {
            "points": 17,
            "req": "N≤16, K=10N, R≤65535"
          },
          "3": {
            "points": 18,
            "req": "N≤16, K=10N, R≤255"
          },
          "4": {
            "points": 29,
            "req": "N≤32, K=10N, R≤255"
          },
          "5": {
            "points": "up to 19",
            "req": "N=16-64, K=15N, R≤255, score depends on compression ratio L/N"
          }
        }
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Parrots",
        "contest": "IOI 2011 day 2",
        "one_line": "Send N message bytes (0-255) via K parrots arriving in random order"
      },
      "problem": {
        "given": [
          "Message M of N integers (0-255)",
          "K parrots (K depends on N)",
          "Each parrot carries one number in range 0-R",
          "Parrots arrive in arbitrary order"
        ],
        "goal": "Encode message for parrots to carry, then decode from received numbers",
        "mechanism": "Write encode(N,M) calling send(a) for each parrot, then decode(N,L,X) calling output(b) for each message byte",
        "success_condition": "Decoded output must match original message M exactly"
      },
      "constraints": {
        "critical": [
          "Parrots arrive in arbitrary order (numbers permuted)",
          "Maximum K parrots can be used (K=10N or 15N depending on subtask)",
          "Sent numbers must be in range 0-R"
        ],
        "subtasks": {
          "1": {
            "points": 17,
            "req": "N=8, binary message (0/1), K=10N, R≤65535"
          },
          "2": {
            "points": 17,
            "req": "N≤16, K=10N, R≤65535"
          },
          "3": {
            "points": 18,
            "req": "N≤16, K=10N, R≤255"
          },
          "4": {
            "points": 29,
            "req": "N≤32, K=10N, R≤255"
          },
          "5": {
            "points": "up to 19",
            "req": "N=16-64, K=15N, R≤255, score depends on compression ratio L/N"
          }
        }
      },
      "implementation": {
        "function_to_write": "Two procedures: encode(N,M) and decode(N,L,X)",
        "available_api": {
          "send": {
            "signature": "void send(int a)",
            "params": "a: number to send via parrot (0-R)",
            "returns": "void",
            "side_effect": "Adds to sequence of parrot messages"
          },
          "output": {
            "signature": "void output(int b)",
            "params": "b: decoded message byte",
            "returns": "void",
            "side_effect": "Reports final output sequence"
          }
        },
        "requirements": [
          "encode and decode run in separate executions",
          "No shared state between encode and decode",
          "encode must call send ≤K times",
          "decode must call output exactly N times"
        ]
      },
      "limits": {
        "time": "2 seconds",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "Yanee is a bird enthusiast. Since reading about\nIP over Avian Carriers\n(IPoAC), she has spent much of her time training a flock of intelligent parrots to carry messages over long distances.\nYanee's dream is to use her birds to send a message $$$M$$$ to a land far far away. Her message $$$M$$$ is a sequence of $$$N$$$ (not necessarily distinct) integers, each between $$$0$$$ and $$$255$$$, inclusive. Yanee keeps $$$K$$$ specially-trained parrots. All the parrots look the same; Yanee cannot tell them apart. Each bird can remember a single integer between $$$0$$$ and $$$R$$$, inclusive.\nEarly on, she tried a simple scheme: to send a message, Yanee carefully let the birds out of the cage one by one. Before each bird soared into the air, she taught it a number from the message sequence in order. Unfortunately, this scheme did not work. Eventually, all the birds did arrive at the destination, but they did not necessarily arrive in the order in which they left. With this scheme, Yanee could recover all the numbers she sent, but she was unable to put them into the right order.\nTo realize her dream, Yanee will need a better scheme, and for that she needs your help. Given a message $$$M$$$, she plans to let the birds out one by one like before. She needs you to write a program that will perform two separate operations:\nFirst, your program should be able to read a message $$$M$$$ and transform it into a sequence of at most $$$K$$$ integers between $$$0$$$ and $$$R$$$ that she will teach the birds.\nSecond, your program should be able to read the list of integers between $$$0$$$ and $$$R$$$ received as the birds reach their destination, and then transform it back to the original message $$$M$$$.\nYou may assume that all parrots always arrive at the destination, and that each of them remembers the number it was assigned. Yanee reminds you once again that the parrots may arrive in any order. Note that Yanee only has $$$K$$$ parrots, so the sequence of integers between $$$0$$$ and $$$R$$$ that you produce must contain at most $$$K$$$ integers.\nYour task is to write two separate procedures. One of them will be used by the sender (encoder) and the other by the receiver (decoder).\nThe overall process is shown in the following figure.\nThe two procedures you are to write are:\nProcedure\nencode(N,M)\nthat takes the following parameters:\n$$$N$$$— the length of the message.\n$$$M$$$— a one-dimensional array of $$$N$$$ integers representing the message. You may assume that $$$0 \\leq M[i] \\leq 255$$$ for $$$0 \\leq i < N$$$.\nThis procedure must encode the message $$$M$$$ into a sequence of integers between $$$0$$$ and $$$R$$$, inclusive, that shall be sent using the parrots. To report this sequence, your procedure\nencode\nmust call the procedure\nsend(a)\nfor each integer $$$a$$$ that you wish to give to one of the birds.\nProcedure\ndecode(N,L,X)\nthat takes the following parameters:\n$$$N$$$— the length of the original message.\n$$$L$$$— the length of the message received (the number of birds that were sent).\n$$$X$$$— a one-dimensional array of $$$L$$$ integers representing the received numbers. The numbers $$$X[i]$$$ for $$$0 \\leq i < L$$$ are precisely the numbers that your procedure encode produced, but possibly rearranged into a different order.\nThis procedure must recover the original message. To report it, your procedure\ndecode\nmust call the procedure\noutput(b)\nfor each integer $$$b$$$ in the decoded message, in the correct order.\nNote that $$$R$$$ and $$$K$$$ are not given as input parameters— please see the subtask descriptions below. In order to correctly solve a given subtask, your procedures must satisfy the following conditions:\nAll integers sent by your procedure\nencode\nmust be in the range specified in the subtask.\nThe number of times your procedure\nencode\ncalls the procedure\nsend\nmust not exceed the limit $$$K$$$ specified in the subtask. Please note that $$$K$$$ depends on the length of the message.\nProcedure\ndecode\nmust correctly recover the original message $$$M$$$ and call the procedure\noutput(b)\nexactly $$$N$$$ times, with $$$b$$$ equal to $$$M[0], M[1], \\dots, M[N-1]$$$, respectively.\nIn the last subtask, your score varies according to the ratio between the lengths of the encoded message and the original message.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$N$$$\nLine $$$2$$$: a list of $$$N$$$ numbers: $$$M[0], M[1], \\dots, M[N-1]$$$\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$R$$$\nAdditional Input Constraints\n1\n17\n$$$N = 8$$$\n$$$0 \\le R \\le 65535$$$\nEach integer in the array $$$M$$$ is either $$$0$$$ or $$$1$$$.  The number of times you can call the procedure send is at most $$$K=10 \\cdot N$$$.\n2\n17\n$$$1 \\leq N \\leq 16$$$\n$$$0 \\le R \\le 65535$$$\nThe number of times you can call the procedure send is at most $$$K=10 \\cdot N$$$\n3\n18\n$$$1 \\leq N \\leq 16$$$\n$$$0 \\le R \\le 255$$$\nThe number of times you can call the procedure send is at most $$$K=10 \\cdot N$$$.\n4\n29\n$$$1 \\leq N \\leq 32$$$\n$$$0 \\le R \\le 255$$$\nThe number of times you can call the procedure\nsend\nis at most $$$K=10 \\cdot N$$$.\n5\nup to 19 points\n$$$16 \\leq N \\leq 64$$$\n$$$0 \\le R \\le 255$$$\nThe number of times you can call the procedure\nsend\nis at most $$$K=15 \\cdot N$$$\nImportant\n: the score for this subtask depends on the ratio between the length of the encoded message and that of the original message. For a given test case $$$t$$$ in this subtask, let $$$P_t=\\frac{L_t}{N_t}$$$ be the ratio between the length $$$L_t$$$ of the encoded message and the length $$$N_t$$$ of the original message. Let $$$P$$$ be the maximum of all $$$P_t$$$. Your score for this subtask will be determined using the following rules:\nIf $$$P \\leq 5$$$, you get the full score of $$$19$$$ points.\nIf $$$5 < P \\leq 6$$$, you get $$$18$$$ points.\nIf $$$6 < P \\leq 7$$$, you get $$$17$$$ points.\nIf $$$7 < P \\leq 15$$$, your score is $$$1 + 2 \\cdot (15 - P)$$$, rounded down to the nearest integer.\nIf $$$P > 15$$$ or any of your outputs is incorrect, your score is $$$0$$$.\n—\nImportant\n: Any valid solution for subtasks $$$1$$$ to $$$4$$$ will also solve all preceding subtasks. However, due to the larger bound on $$$K$$$, a valid solution to subtask $$$5$$$ might not be able to solve subtasks $$$1$$$ to $$$4$$$. It is possible to solve all subtasks using the same solution.\nNote\nConsider the case where $$$N = 3$$$, and $$$M=[10,30,20]$$$\nProcedure\nencode(N,M)\n, using some strange method, may encode the message as the sequence of numbers $$$[7, 3, 2, 70, 15, 20, 3]$$$. To report this sequence, it should call the procedure\nsend\nas follows:\nsend(7)\nsend(3)\nsend(2)\nsend(70)\nsend(15)\nsend(20)\nsend(3)\nOnce all parrots reach their destination, assume we obtain the following list of transcribed numbers: $$$[3, 20, 70, 15, 2, 3, 7]$$$. The procedure\ndecode\nwill then be called with $$$N=3$$$, $$$L=7$$$, and $$$X=[3, 20, 70, 15, 2, 3, 7]$$$\nThe procedure\ndecode\nmust produce the original message $$$[10, 30, 20]$$$. It reports the result by calling the procedure output as follows.\noutput(10)\noutput(30)\noutput(20)\nNotes about limits:\nGrading Environment: In the real grading environment, your submissions will be executed twice, so all your global variables would be cleared between running encode and decode. The first run only calls encode and the second run only calls\ndecode\n.\nLimits: The first run will make at most $$$50$$$ calls to procedure encode. The second run will make at most $$$50$$$ calls to procedure\ndecode\n.\nEach run must use cpu and memory within time and memory limit. They are checked independently."
    },
    "original": "Yanee is a bird enthusiast. Since reading about\nIP over Avian Carriers\n(IPoAC), she has spent much of her time training a flock of intelligent parrots to carry messages over long distances.\nYanee's dream is to use her birds to send a message $$$M$$$ to a land far far away. Her message $$$M$$$ is a sequence of $$$N$$$ (not necessarily distinct) integers, each between $$$0$$$ and $$$255$$$, inclusive. Yanee keeps $$$K$$$ specially-trained parrots. All the parrots look the same; Yanee cannot tell them apart. Each bird can remember a single integer between $$$0$$$ and $$$R$$$, inclusive.\nEarly on, she tried a simple scheme: to send a message, Yanee carefully let the birds out of the cage one by one. Before each bird soared into the air, she taught it a number from the message sequence in order. Unfortunately, this scheme did not work. Eventually, all the birds did arrive at the destination, but they did not necessarily arrive in the order in which they left. With this scheme, Yanee could recover all the numbers she sent, but she was unable to put them into the right order.\nTo realize her dream, Yanee will need a better scheme, and for that she needs your help. Given a message $$$M$$$, she plans to let the birds out one by one like before. She needs you to write a program that will perform two separate operations:\nFirst, your program should be able to read a message $$$M$$$ and transform it into a sequence of at most $$$K$$$ integers between $$$0$$$ and $$$R$$$ that she will teach the birds.\nSecond, your program should be able to read the list of integers between $$$0$$$ and $$$R$$$ received as the birds reach their destination, and then transform it back to the original message $$$M$$$.\nYou may assume that all parrots always arrive at the destination, and that each of them remembers the number it was assigned. Yanee reminds you once again that the parrots may arrive in any order. Note that Yanee only has $$$K$$$ parrots, so the sequence of integers between $$$0$$$ and $$$R$$$ that you produce must contain at most $$$K$$$ integers.\nYour task is to write two separate procedures. One of them will be used by the sender (encoder) and the other by the receiver (decoder).\nThe overall process is shown in the following figure.\nThe two procedures you are to write are:\nProcedure\nencode(N,M)\nthat takes the following parameters:\n$$$N$$$— the length of the message.\n$$$M$$$— a one-dimensional array of $$$N$$$ integers representing the message. You may assume that $$$0 \\leq M[i] \\leq 255$$$ for $$$0 \\leq i < N$$$.\nThis procedure must encode the message $$$M$$$ into a sequence of integers between $$$0$$$ and $$$R$$$, inclusive, that shall be sent using the parrots. To report this sequence, your procedure\nencode\nmust call the procedure\nsend(a)\nfor each integer $$$a$$$ that you wish to give to one of the birds.\nProcedure\ndecode(N,L,X)\nthat takes the following parameters:\n$$$N$$$— the length of the original message.\n$$$L$$$— the length of the message received (the number of birds that were sent).\n$$$X$$$— a one-dimensional array of $$$L$$$ integers representing the received numbers. The numbers $$$X[i]$$$ for $$$0 \\leq i < L$$$ are precisely the numbers that your procedure encode produced, but possibly rearranged into a different order.\nThis procedure must recover the original message. To report it, your procedure\ndecode\nmust call the procedure\noutput(b)\nfor each integer $$$b$$$ in the decoded message, in the correct order.\nNote that $$$R$$$ and $$$K$$$ are not given as input parameters— please see the subtask descriptions below. In order to correctly solve a given subtask, your procedures must satisfy the following conditions:\nAll integers sent by your procedure\nencode\nmust be in the range specified in the subtask.\nThe number of times your procedure\nencode\ncalls the procedure\nsend\nmust not exceed the limit $$$K$$$ specified in the subtask. Please note that $$$K$$$ depends on the length of the message.\nProcedure\ndecode\nmust correctly recover the original message $$$M$$$ and call the procedure\noutput(b)\nexactly $$$N$$$ times, with $$$b$$$ equal to $$$M[0], M[1], \\dots, M[N-1]$$$, respectively.\nIn the last subtask, your score varies according to the ratio between the lengths of the encoded message and the original message.\nInput\nThe sample grader reads the input in the following format:\nLine $$$1$$$: $$$N$$$\nLine $$$2$$$: a list of $$$N$$$ numbers: $$$M[0], M[1], \\dots, M[N-1]$$$\nScoring\nSubtask\nPoints\n$$$N$$$\n$$$R$$$\nAdditional Input Constraints\n1\n17\n$$$N = 8$$$\n$$$0 \\le R \\le 65535$$$\nEach integer in the array $$$M$$$ is either $$$0$$$ or $$$1$$$.  The number of times you can call the procedure send is at most $$$K=10 \\cdot N$$$.\n2\n17\n$$$1 \\leq N \\leq 16$$$\n$$$0 \\le R \\le 65535$$$\nThe number of times you can call the procedure send is at most $$$K=10 \\cdot N$$$\n3\n18\n$$$1 \\leq N \\leq 16$$$\n$$$0 \\le R \\le 255$$$\nThe number of times you can call the procedure send is at most $$$K=10 \\cdot N$$$.\n4\n29\n$$$1 \\leq N \\leq 32$$$\n$$$0 \\le R \\le 255$$$\nThe number of times you can call the procedure\nsend\nis at most $$$K=10 \\cdot N$$$.\n5\nup to 19 points\n$$$16 \\leq N \\leq 64$$$\n$$$0 \\le R \\le 255$$$\nThe number of times you can call the procedure\nsend\nis at most $$$K=15 \\cdot N$$$\nImportant\n: the score for this subtask depends on the ratio between the length of the encoded message and that of the original message. For a given test case $$$t$$$ in this subtask, let $$$P_t=\\frac{L_t}{N_t}$$$ be the ratio between the length $$$L_t$$$ of the encoded message and the length $$$N_t$$$ of the original message. Let $$$P$$$ be the maximum of all $$$P_t$$$. Your score for this subtask will be determined using the following rules:\nIf $$$P \\leq 5$$$, you get the full score of $$$19$$$ points.\nIf $$$5 < P \\leq 6$$$, you get $$$18$$$ points.\nIf $$$6 < P \\leq 7$$$, you get $$$17$$$ points.\nIf $$$7 < P \\leq 15$$$, your score is $$$1 + 2 \\cdot (15 - P)$$$, rounded down to the nearest integer.\nIf $$$P > 15$$$ or any of your outputs is incorrect, your score is $$$0$$$.\n—\nImportant\n: Any valid solution for subtasks $$$1$$$ to $$$4$$$ will also solve all preceding subtasks. However, due to the larger bound on $$$K$$$, a valid solution to subtask $$$5$$$ might not be able to solve subtasks $$$1$$$ to $$$4$$$. It is possible to solve all subtasks using the same solution.\nNote\nConsider the case where $$$N = 3$$$, and $$$M=[10,30,20]$$$\nProcedure\nencode(N,M)\n, using some strange method, may encode the message as the sequence of numbers $$$[7, 3, 2, 70, 15, 20, 3]$$$. To report this sequence, it should call the procedure\nsend\nas follows:\nsend(7)\nsend(3)\nsend(2)\nsend(70)\nsend(15)\nsend(20)\nsend(3)\nOnce all parrots reach their destination, assume we obtain the following list of transcribed numbers: $$$[3, 20, 70, 15, 2, 3, 7]$$$. The procedure\ndecode\nwill then be called with $$$N=3$$$, $$$L=7$$$, and $$$X=[3, 20, 70, 15, 2, 3, 7]$$$\nThe procedure\ndecode\nmust produce the original message $$$[10, 30, 20]$$$. It reports the result by calling the procedure output as follows.\noutput(10)\noutput(30)\noutput(20)\nNotes about limits:\nGrading Environment: In the real grading environment, your submissions will be executed twice, so all your global variables would be cleared between running encode and decode. The first run only calls encode and the second run only calls\ndecode\n.\nLimits: The first run will make at most $$$50$$$ calls to procedure encode. The second run will make at most $$$50$$$ calls to procedure\ndecode\n.\nEach run must use cpu and memory within time and memory limit. They are checked independently.",
    "_meta": {
      "index": 86,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/F",
      "uuid": "ps_51bcdb7057ebac255b5b42d7424d53673ca2c0b4"
    }
  },
  {
    "planning_view": {
      "title": "D. Gondola",
      "task": "Analyze gondola sequences from broken/replaced gondolas on circular track",
      "given": [
        "n gondolas on circular rail (1 to n)",
        "Broken gondolas replaced with lowest-numbered spares (n+1, n+2, ...)",
        "Gondola sequence: n gondolas passing station in order"
      ],
      "goal": "Validate sequences, find replacement sequences, or count possible replacements",
      "key_rules": [
        "Circular rail: after gondola i passes, next is i+1 (or 1 if i=n)",
        "Replacements use lowest-numbered available spare gondola",
        "Multiple valid starting positions possible for same configuration"
      ],
      "target": {
        "1": {
          "points": 5,
          "req": "n ≤ 100, inputSeq contains each number from 1 to n exactly once"
        },
        "2": {
          "points": 5,
          "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ n"
        },
        "3": {
          "points": 10,
          "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 250,000"
        },
        "4": {
          "points": 5,
          "req": "n ≤ 100, 1 ≤ gondolaSeq[i] ≤ n+1"
        },
        "5": {
          "points": 10,
          "req": "n ≤ 1,000, 1 ≤ gondolaSeq[i] ≤ 5,000"
        },
        "6": {
          "points": 20,
          "req": "n ≤ 100,000, 1 ≤ gondolaSeq[i] ≤ 250,000"
        },
        "7": {
          "points": 5,
          "req": "4 ≤ n ≤ 50, 1 ≤ inputSeq[i] ≤ n+3"
        },
        "8": {
          "points": 15,
          "req": "4 ≤ n ≤ 50, 1 ≤ inputSeq[i] ≤ 100, at least n-3 initial gondolas intact"
        },
        "9": {
          "points": 15,
          "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 250,000"
        },
        "10": {
          "points": 10,
          "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 1,000,000,000"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Gondola",
      "contest": "IOI 2014 day 2",
      "one_line": "Analyze gondola sequences from broken/replaced gondolas on circular track",
      "given": [
        "n gondolas on circular rail (1 to n)",
        "Broken gondolas replaced with lowest-numbered spares (n+1, n+2, ...)",
        "Gondola sequence: n gondolas passing station in order"
      ],
      "goal": "Validate sequences, find replacement sequences, or count possible replacements",
      "mechanism": "Circular rail with gondolas passing station sequentially; broken gondolas replaced with lowest-numbered spares",
      "success_condition": "Return correct validation/replacement/count based on subtask",
      "constraints": {
        "critical": [
          "Circular rail: after gondola i passes, next is i+1 (or 1 if i=n)",
          "Replacements use lowest-numbered available spare gondola",
          "Multiple valid starting positions possible for same configuration"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "n ≤ 100, inputSeq contains each number from 1 to n exactly once"
          },
          "2": {
            "points": 5,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ n"
          },
          "3": {
            "points": 10,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 250,000"
          },
          "4": {
            "points": 5,
            "req": "n ≤ 100, 1 ≤ gondolaSeq[i] ≤ n+1"
          },
          "5": {
            "points": 10,
            "req": "n ≤ 1,000, 1 ≤ gondolaSeq[i] ≤ 5,000"
          },
          "6": {
            "points": 20,
            "req": "n ≤ 100,000, 1 ≤ gondolaSeq[i] ≤ 250,000"
          },
          "7": {
            "points": 5,
            "req": "4 ≤ n ≤ 50, 1 ≤ inputSeq[i] ≤ n+3"
          },
          "8": {
            "points": 15,
            "req": "4 ≤ n ≤ 50, 1 ≤ inputSeq[i] ≤ 100, at least n-3 initial gondolas intact"
          },
          "9": {
            "points": 15,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 250,000"
          },
          "10": {
            "points": 10,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 1,000,000,000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Gondola",
        "contest": "IOI 2014 day 2",
        "one_line": "Analyze gondola sequences from broken/replaced gondolas on circular track"
      },
      "problem": {
        "given": [
          "n gondolas on circular rail (1 to n)",
          "Broken gondolas replaced with lowest-numbered spares (n+1, n+2, ...)",
          "Gondola sequence: n gondolas passing station in order"
        ],
        "goal": "Validate sequences, find replacement sequences, or count possible replacements",
        "mechanism": "Circular rail with gondolas passing station sequentially; broken gondolas replaced with lowest-numbered spares",
        "success_condition": "Return correct validation/replacement/count based on subtask"
      },
      "constraints": {
        "critical": [
          "Circular rail: after gondola i passes, next is i+1 (or 1 if i=n)",
          "Replacements use lowest-numbered available spare gondola",
          "Multiple valid starting positions possible for same configuration"
        ],
        "subtasks": {
          "1": {
            "points": 5,
            "req": "n ≤ 100, inputSeq contains each number from 1 to n exactly once"
          },
          "2": {
            "points": 5,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ n"
          },
          "3": {
            "points": 10,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 250,000"
          },
          "4": {
            "points": 5,
            "req": "n ≤ 100, 1 ≤ gondolaSeq[i] ≤ n+1"
          },
          "5": {
            "points": 10,
            "req": "n ≤ 1,000, 1 ≤ gondolaSeq[i] ≤ 5,000"
          },
          "6": {
            "points": 20,
            "req": "n ≤ 100,000, 1 ≤ gondolaSeq[i] ≤ 250,000"
          },
          "7": {
            "points": 5,
            "req": "4 ≤ n ≤ 50, 1 ≤ inputSeq[i] ≤ n+3"
          },
          "8": {
            "points": 15,
            "req": "4 ≤ n ≤ 50, 1 ≤ inputSeq[i] ≤ 100, at least n-3 initial gondolas intact"
          },
          "9": {
            "points": 15,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 250,000"
          },
          "10": {
            "points": 10,
            "req": "n ≤ 100,000, 1 ≤ inputSeq[i] ≤ 1,000,000,000"
          }
        }
      },
      "implementation": {
        "function_to_write": "Three functions: valid(), replacement(), countReplacement()",
        "available_api": {
          "valid": {
            "signature": "int valid(int n, int inputSeq[])",
            "params": "n: sequence length, inputSeq: array of n integers",
            "returns": "1 if valid gondola sequence, 0 otherwise",
            "side_effect": "None"
          },
          "replacement": {
            "signature": "int replacement(int n, int gondolaSeq[], int replacementSeq[])",
            "params": "n: sequence length, gondolaSeq: valid gondola sequence, replacementSeq: output array",
            "returns": "Length l of replacement sequence",
            "side_effect": "Fills replacementSeq[0..l-1] with replacement sequence"
          },
          "countReplacement": {
            "signature": "int countReplacement(int n, int inputSeq[])",
            "params": "n: sequence length, inputSeq: array of n integers",
            "returns": "Number of replacement sequences modulo 1000000009",
            "side_effect": "None"
          }
        },
        "requirements": [
          "Implement all three functions even if solving partial subtasks",
          "Include gondola.h header file",
          "Use correct function signatures exactly",
          "Output modulo 1000000009 for countReplacement"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [
        {
          "input": "1\n30\n16 26 18 19 20 13 22 21 24 25 17 27 28 29 30 1 2 3 11 5 6 8 7 9 10 12 4 23 14 15",
          "output": "0"
        }
      ],
      "original_statement": "Mao-Kong Gondola is a famous attraction in Taipei. The gondola system consists of a circular rail, a single station, and $$$n$$$ gondolas numbered consecutively from $$$1$$$ to $$$n$$$ running around the rail in a fixed direction. After gondola $$$i$$$ passes the station, the next gondola to pass the station will be gondola $$$i + 1$$$ if $$$i < n$$$, or gondola 1 if $$$i = n$$$.\nGondolas may break down. Luckily we have an infinite supply of spare gondolas, which are numbered $$$n + 1, n + 2$$$, and so on. When a gondola breaks down we replace it (in the same position on the track) with the first available spare gondola, that is, the one with the lowest number. For example, if there are five gondolas and gondola 1 breaks down, then we will replace it with gondola 6.\nYou like to stand at the station and watch the gondolas as they pass by. A\ngondola sequence\nis a sequence of $$$n$$$ numbers of gondolas that pass the station. It is possible that one or more gondolas broke down (and were replaced) before you arrived, but none of the gondolas break down while you are watching.\nNote that the same configuration of gondolas on the rail can give multiple gondola sequences, depending on which gondola passes first when you arrive at the station. For example, if none of the gondolas have broken down then both $$$(2, 3, 4, 5, 1)$$$ and $$$(4, 5, 1, 2, 3)$$$ are possible gondola sequences, but $$$(4, 3, 2, 5, 1)$$$ is not (because the gondolas appear in the wrong order).\nIf gondola $$$1$$$ breaks down, then we might now observe the gondola sequence $$$(4, 5, 6, 2, 3)$$$. If gondola $$$4$$$ breaks down next, we replace it with gondola $$$7$$$ and we might observe the gondola sequence $$$(6, 2, 3, 7, 5)$$$. If gondola $$$7$$$ breaks down after this, we replace it with gondola $$$8$$$ and we may now observe the gondola sequence $$$(3, 8, 5, 6, 2)$$$.\nBroken gondola\nNew gondola\nPossible gondola sequence\n1\n6\n$$$(4, 5, 6, 2, 3)$$$\n4\n7\n$$$(6, 2, 3, 7, 5)$$$\n7\n8\n$$$(3, 8, 5, 6, 2)$$$\nA\nreplacement sequence\nis a sequence consisting of the numbers of the gondolas that have broken down, in the order in which they break down. In the previous example the replacement sequence is $$$(1, 4, 7)$$$. A replacement sequence $$$r$$$\nproduces\na gondola sequence $$$g$$$ if, after gondolas break down according to the replacement sequence $$$r$$$, the gondola sequence $$$g$$$ may be observed.\nGondola Sequence Checking\nIn the first three subtasks you must check whether an input sequence is a gondola sequence. See the table below for examples of sequences that are and are not gondola sequences. You need to implement a function\nvalid\n.\nint valid(int n, int inputSeq[])\n$$$n$$$: the length of the input sequence.\n$$$inputSeq$$$: array of length $$$n$$$; $$$inputSeq[i]$$$ is element $$$i$$$ of the input sequence, for $$$0 \\le i \\le n - 1$$$.\nThe function should return $$$1$$$ if the input sequence is a gondola sequence, or $$$0$$$ otherwise.\nReplacement Sequence\nIn the next three subtasks you must construct a possible replacement sequence that produces a given gondola sequence. Any such replacement sequence will be accepted. You need to implement a function\nreplacement\n.\nint replacement(int n, int gondolaSeq[], int replacementSeq[])\n$$$n$$$: the length of the input sequence.\n$$$gondolaSeq$$$: array of length $$$n$$$; $$$gondolaSeq$$$ is guaranteed to be a gondola sequence, and $$$gondolaSeq[i]$$$ is element $$$i$$$ of the sequence, for $$$0 \\le i \\le n - 1$$$.\nThe function should return $$$l$$$, the length of the replacement sequence.\n$$$replacementSeq$$$: array that is sufficiently large to store the replacement sequence; you should return your sequence by placing element $$$i$$$ of your replacement sequence into $$$replacementSeq[i]$$$, for $$$0 \\le i \\le l - 1$$$.\nCount Replacement Sequences\nIn the next four subtasks you must count the number of possible replacement sequences that produce a given sequence (which may or may not be a gondola sequence), modulo $$$1\\,000\\,000\\,009$$$. You need to implement a function\ncountReplacement\n.\nint countReplacement(int n, int inputSeq[])\n$$$n$$$: the length of the input sequence.\n$$$inputSeq$$$: array of length $$$n$$$; $$$inputSeq[i]$$$ is element $$$i$$$ of the input sequence, for $$$0 \\le i \\le n - 1$$$.\nIf the input sequence is a gondola sequence, then count the number of replacement sequences that produce this gondola sequence (which could be extremely large),\nand return this number modulo\n$$$1\\,000\\,000\\,009$$$. If the input sequence is not a gondola sequence, the function should return $$$0$$$. If the input sequence is a gondola sequence but no gondolas broke down, the function should return $$$1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$T$$$, the subtask number your program intends to solve $$$(1 \\le T \\le 10)$$$.\nline 2: $$$n$$$, the length of the input sequence.\nline 3: If $$$T$$$ is $$$4$$$, $$$5$$$, or $$$6$$$, this line contains $$$gondolaSeq[0], \\ldots, gondolaSeq[n - 1]$$$. Otherwise this line contains $$$inputSeq[0], \\ldots, inputSeq[n - 1]$$$.\nOutput\nThe sample grader prints the following output:\nIf subtask is 1, 2 or 3\nline 1: return value of\nvalid\nIf subtask is 4, 5 or 6\nline 1: return value of\nreplacement\n$$$l$$$.\nlines $$$2 + l (0 \\le i < l)$$$: $$$replacementSequence[i]$$$.\nIf subtask is 7, 8, 9 or 10\nline 1: return value of\ncountReplacement\nScoring\nSubtask\nPoints\nn\ninputSeq\n1\n5\n$$$n \\le 100$$$\nhas each number from $$$1$$$ to $$$n$$$ exactly once\n2\n5\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le n$$$\n3\n10\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le 250\\,000$$$\nSubtask\nPoints\nn\ngondolaSeq\n4\n5\n$$$n \\le 100$$$\n$$$1 \\le gondolaSeq[i] \\le n + 1$$$\n5\n10\n$$$n \\le 1\\,000$$$\n$$$1 \\le gondolaSeq[i] \\le 5\\,000$$$\n6\n20\n$$$n \\le 100\\,000$$$\n$$$1 \\le gondolaSeq[i] \\le 250\\,000$$$\nSubtask\nPoints\nn\ninputSeq\n7\n5\n$$$4 \\le n \\le 50$$$\n$$$1 \\le inputSeq[i] \\le n + 3$$$\n8\n15\n$$$4 \\le n \\le 50$$$\n$$$1 \\le inputSeq[i] \\le 100$$$, and at least $$$n - 3$$$ of the initial gondolas did not break down.\n9\n15\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le 250\\,000$$$\n10\n10\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le 1\\,000\\,000\\,000$$$\nExamples\nNote\nYou have to submit exactly one file, called\ngondola.cpp\n. This file should implement all three subprograms described above (even if you only plan to solve some of the subtasks), using the signatures. You also need to include a header file\ngondola.h\nfor C/C++ implementation.\nSubtask\ninputSeq\nReturn value\nNote\n1\n$$$(1, 2, 3, 4, 5, 6, 7)$$$\n1\n—\n1\n$$$(3, 4, 5, 6, 1, 2)$$$\n1\n—\n1\n$$$(1, 5, 3, 4, 2, 7, 6)$$$\n0\n1 cannot appear just before 5\n1\n$$$(4, 3, 2, 1)$$$\n0\n4 cannot appear just before 3\n2\n$$$(1, 2, 3, 4, 5, 6, 5)$$$\n0\ntwo gondolas numbered 5\n3\n$$$(2, 3, 4, 9, 6, 7, 1)$$$\n1\nreplacement sequence (5, 8)\n3\n$$$(10, 4, 3, 11, 12)$$$\n0\n4 4 cannot appear just before 3\nSubtask\ngondolaSeq\nReturn value\nReplacementSeq\n4\n$$$(3, 1, 4)$$$\n1\n$$$(2)$$$\n4\n$$$(5, 1, 2, 3, 4)$$$\n0\n$$$()$$$\n5\n$$$(2, 3, 4, 9, 6, 7, 1)$$$\n2\n$$$(5, 8)$$$\nSubtask\ninputSeq\nReturn value\nReplacement sequence\n7\n$$$(1, 2, 7, 6)$$$\n2\n$$$(3, 4, 5)$$$ or $$$(4, 5, 3)$$$\n8\n$$$(2, 3, 4, 12, 6, 7, 1)$$$\n1\n$$$(5, 8, 9, 10, 11)$$$\n9\n$$$(4, 7, 4, 7)$$$\n0\n$$$inputSeq$$$ is not a gondola sequence\n10\n$$$(3, 4)$$$\n2\n$$$(1, 2)$$$ or $$$(2, 1)$$$"
    },
    "original": "Mao-Kong Gondola is a famous attraction in Taipei. The gondola system consists of a circular rail, a single station, and $$$n$$$ gondolas numbered consecutively from $$$1$$$ to $$$n$$$ running around the rail in a fixed direction. After gondola $$$i$$$ passes the station, the next gondola to pass the station will be gondola $$$i + 1$$$ if $$$i < n$$$, or gondola 1 if $$$i = n$$$.\nGondolas may break down. Luckily we have an infinite supply of spare gondolas, which are numbered $$$n + 1, n + 2$$$, and so on. When a gondola breaks down we replace it (in the same position on the track) with the first available spare gondola, that is, the one with the lowest number. For example, if there are five gondolas and gondola 1 breaks down, then we will replace it with gondola 6.\nYou like to stand at the station and watch the gondolas as they pass by. A\ngondola sequence\nis a sequence of $$$n$$$ numbers of gondolas that pass the station. It is possible that one or more gondolas broke down (and were replaced) before you arrived, but none of the gondolas break down while you are watching.\nNote that the same configuration of gondolas on the rail can give multiple gondola sequences, depending on which gondola passes first when you arrive at the station. For example, if none of the gondolas have broken down then both $$$(2, 3, 4, 5, 1)$$$ and $$$(4, 5, 1, 2, 3)$$$ are possible gondola sequences, but $$$(4, 3, 2, 5, 1)$$$ is not (because the gondolas appear in the wrong order).\nIf gondola $$$1$$$ breaks down, then we might now observe the gondola sequence $$$(4, 5, 6, 2, 3)$$$. If gondola $$$4$$$ breaks down next, we replace it with gondola $$$7$$$ and we might observe the gondola sequence $$$(6, 2, 3, 7, 5)$$$. If gondola $$$7$$$ breaks down after this, we replace it with gondola $$$8$$$ and we may now observe the gondola sequence $$$(3, 8, 5, 6, 2)$$$.\nBroken gondola\nNew gondola\nPossible gondola sequence\n1\n6\n$$$(4, 5, 6, 2, 3)$$$\n4\n7\n$$$(6, 2, 3, 7, 5)$$$\n7\n8\n$$$(3, 8, 5, 6, 2)$$$\nA\nreplacement sequence\nis a sequence consisting of the numbers of the gondolas that have broken down, in the order in which they break down. In the previous example the replacement sequence is $$$(1, 4, 7)$$$. A replacement sequence $$$r$$$\nproduces\na gondola sequence $$$g$$$ if, after gondolas break down according to the replacement sequence $$$r$$$, the gondola sequence $$$g$$$ may be observed.\nGondola Sequence Checking\nIn the first three subtasks you must check whether an input sequence is a gondola sequence. See the table below for examples of sequences that are and are not gondola sequences. You need to implement a function\nvalid\n.\nint valid(int n, int inputSeq[])\n$$$n$$$: the length of the input sequence.\n$$$inputSeq$$$: array of length $$$n$$$; $$$inputSeq[i]$$$ is element $$$i$$$ of the input sequence, for $$$0 \\le i \\le n - 1$$$.\nThe function should return $$$1$$$ if the input sequence is a gondola sequence, or $$$0$$$ otherwise.\nReplacement Sequence\nIn the next three subtasks you must construct a possible replacement sequence that produces a given gondola sequence. Any such replacement sequence will be accepted. You need to implement a function\nreplacement\n.\nint replacement(int n, int gondolaSeq[], int replacementSeq[])\n$$$n$$$: the length of the input sequence.\n$$$gondolaSeq$$$: array of length $$$n$$$; $$$gondolaSeq$$$ is guaranteed to be a gondola sequence, and $$$gondolaSeq[i]$$$ is element $$$i$$$ of the sequence, for $$$0 \\le i \\le n - 1$$$.\nThe function should return $$$l$$$, the length of the replacement sequence.\n$$$replacementSeq$$$: array that is sufficiently large to store the replacement sequence; you should return your sequence by placing element $$$i$$$ of your replacement sequence into $$$replacementSeq[i]$$$, for $$$0 \\le i \\le l - 1$$$.\nCount Replacement Sequences\nIn the next four subtasks you must count the number of possible replacement sequences that produce a given sequence (which may or may not be a gondola sequence), modulo $$$1\\,000\\,000\\,009$$$. You need to implement a function\ncountReplacement\n.\nint countReplacement(int n, int inputSeq[])\n$$$n$$$: the length of the input sequence.\n$$$inputSeq$$$: array of length $$$n$$$; $$$inputSeq[i]$$$ is element $$$i$$$ of the input sequence, for $$$0 \\le i \\le n - 1$$$.\nIf the input sequence is a gondola sequence, then count the number of replacement sequences that produce this gondola sequence (which could be extremely large),\nand return this number modulo\n$$$1\\,000\\,000\\,009$$$. If the input sequence is not a gondola sequence, the function should return $$$0$$$. If the input sequence is a gondola sequence but no gondolas broke down, the function should return $$$1$$$.\nInput\nThe sample grader reads the input in the following format:\nline 1: $$$T$$$, the subtask number your program intends to solve $$$(1 \\le T \\le 10)$$$.\nline 2: $$$n$$$, the length of the input sequence.\nline 3: If $$$T$$$ is $$$4$$$, $$$5$$$, or $$$6$$$, this line contains $$$gondolaSeq[0], \\ldots, gondolaSeq[n - 1]$$$. Otherwise this line contains $$$inputSeq[0], \\ldots, inputSeq[n - 1]$$$.\nOutput\nThe sample grader prints the following output:\nIf subtask is 1, 2 or 3\nline 1: return value of\nvalid\nIf subtask is 4, 5 or 6\nline 1: return value of\nreplacement\n$$$l$$$.\nlines $$$2 + l (0 \\le i < l)$$$: $$$replacementSequence[i]$$$.\nIf subtask is 7, 8, 9 or 10\nline 1: return value of\ncountReplacement\nScoring\nSubtask\nPoints\nn\ninputSeq\n1\n5\n$$$n \\le 100$$$\nhas each number from $$$1$$$ to $$$n$$$ exactly once\n2\n5\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le n$$$\n3\n10\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le 250\\,000$$$\nSubtask\nPoints\nn\ngondolaSeq\n4\n5\n$$$n \\le 100$$$\n$$$1 \\le gondolaSeq[i] \\le n + 1$$$\n5\n10\n$$$n \\le 1\\,000$$$\n$$$1 \\le gondolaSeq[i] \\le 5\\,000$$$\n6\n20\n$$$n \\le 100\\,000$$$\n$$$1 \\le gondolaSeq[i] \\le 250\\,000$$$\nSubtask\nPoints\nn\ninputSeq\n7\n5\n$$$4 \\le n \\le 50$$$\n$$$1 \\le inputSeq[i] \\le n + 3$$$\n8\n15\n$$$4 \\le n \\le 50$$$\n$$$1 \\le inputSeq[i] \\le 100$$$, and at least $$$n - 3$$$ of the initial gondolas did not break down.\n9\n15\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le 250\\,000$$$\n10\n10\n$$$n \\le 100\\,000$$$\n$$$1 \\le inputSeq[i] \\le 1\\,000\\,000\\,000$$$\nExamples\nNote\nYou have to submit exactly one file, called\ngondola.cpp\n. This file should implement all three subprograms described above (even if you only plan to solve some of the subtasks), using the signatures. You also need to include a header file\ngondola.h\nfor C/C++ implementation.\nSubtask\ninputSeq\nReturn value\nNote\n1\n$$$(1, 2, 3, 4, 5, 6, 7)$$$\n1\n—\n1\n$$$(3, 4, 5, 6, 1, 2)$$$\n1\n—\n1\n$$$(1, 5, 3, 4, 2, 7, 6)$$$\n0\n1 cannot appear just before 5\n1\n$$$(4, 3, 2, 1)$$$\n0\n4 cannot appear just before 3\n2\n$$$(1, 2, 3, 4, 5, 6, 5)$$$\n0\ntwo gondolas numbered 5\n3\n$$$(2, 3, 4, 9, 6, 7, 1)$$$\n1\nreplacement sequence (5, 8)\n3\n$$$(10, 4, 3, 11, 12)$$$\n0\n4 4 cannot appear just before 3\nSubtask\ngondolaSeq\nReturn value\nReplacementSeq\n4\n$$$(3, 1, 4)$$$\n1\n$$$(2)$$$\n4\n$$$(5, 1, 2, 3, 4)$$$\n0\n$$$()$$$\n5\n$$$(2, 3, 4, 9, 6, 7, 1)$$$\n2\n$$$(5, 8)$$$\nSubtask\ninputSeq\nReturn value\nReplacement sequence\n7\n$$$(1, 2, 7, 6)$$$\n2\n$$$(3, 4, 5)$$$ or $$$(4, 5, 3)$$$\n8\n$$$(2, 3, 4, 12, 6, 7, 1)$$$\n1\n$$$(5, 8, 9, 10, 11)$$$\n9\n$$$(4, 7, 4, 7)$$$\n0\n$$$inputSeq$$$ is not a gondola sequence\n10\n$$$(3, 4)$$$\n2\n$$$(1, 2)$$$ or $$$(2, 1)$$$",
    "_meta": {
      "index": 87,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/D",
      "uuid": "ps_84dac2ef7b1d23bbce6be2f063078d41e35056b3"
    }
  },
  {
    "planning_view": {
      "title": "A2. Pebbling odometer - subtask 2",
      "task": "Program odometer to sort pebbles: end in (0,0) if x≤y, (0,1) if x>y, preserving pebble counts",
      "given": [
        "256x256 grid, odometer starts at (0,0) facing north",
        "x pebbles in (0,0), y pebbles in (0,1), all other cells empty",
        "Cells hold max 15 pebbles",
        "Odometer responds to movement and pebble commands"
      ],
      "goal": "Terminate with odometer in correct cell based on pebble comparison",
      "key_rules": [
        "Must preserve exact pebble counts: (0,0) ends with x pebbles, (0,1) ends with y pebbles",
        "Cells max 15 pebbles",
        "Border cells exist, movement stops at borders",
        "Cannot move to non-existent cells"
      ],
      "target": {
        "2": {
          "points": 12,
          "req": "Program size ≤ 200, execution length ≤ 2000"
        }
      }
    },
    "algorithm_view": {
      "title": "A2. Pebbling odometer - subtask 2",
      "contest": "IOI 2012 day 1",
      "one_line": "Program odometer to sort pebbles: end in (0,0) if x≤y, (0,1) if x>y, preserving pebble counts",
      "given": [
        "256x256 grid, odometer starts at (0,0) facing north",
        "x pebbles in (0,0), y pebbles in (0,1), all other cells empty",
        "Cells hold max 15 pebbles",
        "Odometer responds to movement and pebble commands"
      ],
      "goal": "Terminate with odometer in correct cell based on pebble comparison",
      "mechanism": "Program controls odometer movement and pebble manipulation on grid using specific commands",
      "success_condition": "Odometer in (0,0) if x≤y, (0,1) if x>y; pebble counts in (0,0) and (0,1) preserved exactly",
      "constraints": {
        "critical": [
          "Must preserve exact pebble counts: (0,0) ends with x pebbles, (0,1) ends with y pebbles",
          "Cells max 15 pebbles",
          "Border cells exist, movement stops at borders",
          "Cannot move to non-existent cells"
        ],
        "subtasks": {
          "2": {
            "points": 12,
            "req": "Program size ≤ 200, execution length ≤ 2000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "A2. Pebbling odometer - subtask 2",
        "contest": "IOI 2012 day 1",
        "one_line": "Program odometer to sort pebbles: end in (0,0) if x≤y, (0,1) if x>y, preserving pebble counts"
      },
      "problem": {
        "given": [
          "256x256 grid, odometer starts at (0,0) facing north",
          "x pebbles in (0,0), y pebbles in (0,1), all other cells empty",
          "Cells hold max 15 pebbles",
          "Odometer responds to movement and pebble commands"
        ],
        "goal": "Terminate with odometer in correct cell based on pebble comparison",
        "mechanism": "Program controls odometer movement and pebble manipulation on grid using specific commands",
        "success_condition": "Odometer in (0,0) if x≤y, (0,1) if x>y; pebble counts in (0,0) and (0,1) preserved exactly"
      },
      "constraints": {
        "critical": [
          "Must preserve exact pebble counts: (0,0) ends with x pebbles, (0,1) ends with y pebbles",
          "Cells max 15 pebbles",
          "Border cells exist, movement stops at borders",
          "Cannot move to non-existent cells"
        ],
        "subtasks": {
          "2": {
            "points": 12,
            "req": "Program size ≤ 200, execution length ≤ 2000"
          }
        }
      },
      "implementation": {
        "function_to_write": "Complete odometer program in specified language",
        "available_api": {
          "left": {
            "signature": "left",
            "params": "none",
            "returns": "none",
            "side_effect": "Turn 90° counter-clockwise"
          },
          "right": {
            "signature": "right",
            "params": "none",
            "returns": "none",
            "side_effect": "Turn 90° clockwise"
          },
          "move": {
            "signature": "move",
            "params": "none",
            "returns": "none",
            "side_effect": "Move forward one cell if possible"
          },
          "get": {
            "signature": "get",
            "params": "none",
            "returns": "none",
            "side_effect": "Remove one pebble from current cell if available"
          },
          "put": {
            "signature": "put",
            "params": "none",
            "returns": "none",
            "side_effect": "Add one pebble to current cell if <15"
          },
          "halt": {
            "signature": "halt",
            "params": "none",
            "returns": "none",
            "side_effect": "Terminate execution"
          },
          "jump": {
            "signature": "jump L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Jump to label L"
          },
          "border": {
            "signature": "border L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Jump to L if at border facing edge"
          },
          "pebble": {
            "signature": "pebble L",
            "params": "L: label name",
            "returns": "none",
            "side_effect": "Jump to L if current cell has ≥1 pebble"
          }
        },
        "requirements": [
          "Program in odometer language (only allowed language)",
          "Max one command per line",
          "Labels: strings ≤128 chars from [a-zA-Z0-9]",
          "Comments with #, empty lines ignored"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "256 megabytes"
      },
      "samples": [],
      "original_statement": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask2. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$."
    },
    "original": "This problem contains 5 subtasks. Technically, they are implemented as 5 different problems. They have the same statement, but the tests and checker are from the corresponding subtask. You need to submit your solutions separately on them. Only odometer language is allowed for this problem.\nPlease refer to subtask 1 statement for problem details.This Task is subtask2. \nLeonardo invented the original odometer: a cart which could measure distances by dropping pebbles as the cart's wheels turned. Counting the pebbles gave the number of turns of the wheel, which allowed the user to compute the distance travelled by the odometer. As computer scientists, we have added software control to the odometer, extending its functionalities. Your task is to program the odometer under the rules specified below.\nOperation grid\nThe odometer moves on an imaginary square grid of $$$256 \\times 256$$$ unit cells. Each cell can contain at most 15 pebbles and is identified by a pair of coordinates (row, column), where each coordinate is in the range $$$0, \\dots, 255$$$. Given a cell $$$(i,~j)$$$, the cells adjacent to it are (if they exist) $$$(i - 1, j)$$$, $$$(i + 1, j)$$$,$$$(i, j - 1)$$$ and $$$(i, j + 1)$$$. Any cell laying on the first or last row, or on the first or last column, is called a border. The odometer always starts at cell $$$(0, 0)$$$ (the north-west corner), facing north.\nBasic commands\nThe odometer can be programmed using the following commands.\nleft\n— turn 90 degrees to the left (counter clockwise) and remain in the current cell (e.g. if it was facing south before, then it will face east after the command).\nright\n— turn 90 degrees to the right (clockwise) and remain in the current cell (e.g. if it was facing west before, then it will face north after the command).\nmove — move one unit forwards (in the direction the odometer is facing) into an adjacent cell. If no such cell exists (i.e. the border in that direction has been already reached) then this command has no effect.\nget\n— remove one pebble from the current cell. If the current cell has no pebbles, then the command has no effect.\nput\n— add one pebble to the current cell. If the current cell already contains 15 pebbles, then the command has no effect. The odometer never runs out of pebbles.\nhalt\n— terminate the execution.\nThe odometer executes the commands in the order they are given in the program. The program must contain at most one command per line. Empty lines are ignored. The symbol # indicates a comment; any text that follows, up to the end of the line, is ignored. If the odometer reaches the end of the program, execution is terminated.\nExample 1\nConsider the following program for the odometer. It takes the odometer to the cell (0, 2), facing east. (Note that the first move is ignored, because the odometer is on the north-west corner facing north.)\nmove # no effect\nright\n# now the odometer is facing east\nmove\nmove\nLabels, borders and pebbles\nTo alter the flow of the program depending on the current status, you can use labels, which are case-sensitive strings of at most 128 symbols chosen from\na\n, ...,\nz\n,\nA\n, ...,\nZ\n,\n0\n, ...,\n9\n. The new commands concerning labels are listed below. In the descriptions below, L denotes any valid label.\nL:\n(i.e. L followed by a colon ':') — declares the location within a program of a label L. All declared labels must be unique. Declaring a label has no effect on the odometer.\njump L\n— continue the execution by unconditionally jumping to the line with label L.\nborder L\n— continue the execution jumping to the line with label L, if the odometer is on a border facing the edge of the grid (i.e. a move instruction would have no effect); otherwise, the execution continues normally and this command has no effect.\npebble L\n— continue the execution jumping to the line with label L, if the current cell contains at least one pebble; otherwise, the execution continues normally and this command has no effect\nExample 2\nThe following program locates the first (westmost) pebble in row 0 and stops there; if there are no pebbles in row 0, it stops on the border at the end of the row. It uses two labels leonardo and davinci.\nright\nleonardo:\npebble davinci # pebble found\nborder davinci # end of the row\nmove\njump leonardo\ndavinci:\nhalt\nThe odometer starts by turning to its right. The loop begins with the label declaration leonardo: and ends with the jump leonardo command. In the loop, the odometer checks for the presence of a pebble or the border at the end of the row; if not so, the odometer makes a move from the current cell (0, j) to the adjacent cell (0, j + 1) since the latter exists. (The halt command is not strictly necessary here as the program terminates anyway.)\nStatement\nYou should submit a program in the odometer's own language, as described above, that makes the odometer behave as expected. Each subtask (see below) specifies a behavior the odometer is required to fulfill and the constraints the submitted solution must satisfy. The constraints concern the two following matters.\nProgram size — the program must be short enough. The size of a program is the number of commands in it. Label declarations, comments and blank lines are not counted in the size.\nExecution length — the program must terminate fast enough. The execution length is the number of performed steps: every single command execution counts as a step, regardless of whether the command had an effect or not; label declarations, comments and blank lines do not count as a step.\nIn Example 1, the program size is 4 and the execution length is 4. In Example 2, the program size is 6 and, when executed on a grid with a single pebble in cell (0, 10), the execution length is 43 steps: right, 10 iterations of the loop, each iteration taking 4 steps (pebble davinci; border davinci; move; jump leonardo), and finally, pebble davinci and halt.\nImplementation details\nYou have to submit exactly one file per subtask, written according to the syntax rules specified above. Each submitted file can have a maximum size of 5 MiB.\nSimulator\nFor testing purposes, you are provided with an odometer simulator, which you can feed with your programs and input grids. Odometer programs will be written in the same format used for submission (i.e., the one described above).\nGrid descriptions will be given using the following format: each line of the file must contain three numbers, $$$R$$$, $$$C$$$ and $$$P$$$, meaning that the cell at row R and column C contains P pebbles. All cells not specified in the grid description are assumed to contain no pebbles. For example, consider the file:\n0 10 3\n4 5 12\nThe grid described by this file would contain 15 pebbles: 3 in the cell $$$(0, 10)$$$ and 12 in the cell $$$(4, 5)$$$.\nYou can invoke the test simulator by calling the program simulator.py in your task directory, passing the program file name as argument. The simulator program will accept the following command line options:\n-h will give a brief overview of the available options;\n-g GRID_FILE loads the grid description from file GRID_FILE (default: empty grid);\n-s GRID_SIDE sets the size of the grid to GRID_SIDE x GRID_SIDE (default: 256, as used in the problem specification); usage of smaller grids can be useful for program debugging;\n-m STEPS limits the number of execution steps in the simulation to at most STEPS;\n-c enters compilation mode; in compilation mode, the simulator returns exactly the same output, but instead of doing the simulation with Python, it generates and compiles a small C program. This causes a larger overhead when starting, but then gives significantly faster results; you are advised to use it when your program is expected to run for more than about $$$10\\,000\\,000$$$ steps. Also, this is mode, that is used in judge.\nBecause of technical reasons, in judge and custom invocation the interpreter is configured a bit differently. Instead of receiving -g and -s options it read them as two integers in the additional first line of input.\nScoring\nSubtask 1 [9 points]\nAt the beginning there are $$$x$$$ pebbles in cell $$$(0, 0)$$$ and $$$y$$$ in cell $$$(0, 1)$$$, whereas all the other cells are empty. Remember that there can be at most 15 pebbles in any cell. Write a program that terminates with the odometer in cell $$$(0, 0)$$$ if $$$x \\le y$$$, and in cell $$$(0, 1)$$$ otherwise. (We do not care about the direction the odometer is facing at the end; we also do not care about how many pebbles are present at the end on the grid, or where they are located.)\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 1 000$$$.\nSubtask 2 [12 points]\nSame task as above but when the program ends, the cell $$$(0, 0)$$$ must contain exactly $$$x$$$ pebbles and cell $$$(0, 1)$$$ must contain exactly $$$y$$$ pebbles. Limits: program size $$$\\le 200$$$, execution length $$$\\le 2 000$$$.\nSubtask 3 [19 points]\nThere are exactly two pebbles somewhere in row 0: one is in cell $$$(0, x)$$$, the other in cell $$$(0, y)$$$; $$$x$$$ and $$$y$$$ are distinct, and $$$x + y$$$ is even. Write a program that leaves the odometer in cell $$$(0, (x + y) / 2)$$$, i.e., exactly in the midpoint between the two cells containing the pebbles. The final state of the grid is not relevant.\nLimits: program size $$$\\le 100$$$, execution length $$$\\le 200 000$$$.\nSubtask 4 [up to 32 points]\nThere are at most 15 pebbles in the grid, no two of them in the same cell. Write a program that collects them all in the north-west corner; more precisely, if there were x pebbles in the grid at the beginning, at the end there must be exactly x pebbles in cell (0, 0) and no pebbles elsewhere.\nThe score for this subtask depends on the execution length of the submitted program. More precisely, if L is the maximum of the execution lengths on the various test cases, your score will be:\n$$$32$$$ points if $$$L \\le 200\\,000$$$;\n$$$32 - 32 \\log_{10} (L / 200\\,000)$$$ points if $$$200\\,000 < L < 2\\,000\\,000$$$;\n$$$0$$$ points if $$$L \\ge 2\\,000\\,000$$$.\nLimits: program size $$$\\le 200$$$.\nSubtask 5 [up to 28 points]\nThere may be any number of pebbles in each cell of the grid (of course, between 0 and 15). Write a program that finds the minimum, i.e., that terminates with the odometer in a cell $$$(i, j)$$$ such that every other cell contains at least as many pebbles as (i, j). After running the program, the number of pebbles in each cell must be the same as before running the program. The score for this subtask depends on the program size P of the submitted program.\nMore precisely, your score will be:\n$$$28$$$ points if $$$P \\le 444$$$;\n$$$28 - 28 \\log_{10} (P / 444)$$$ points if $$$444 < P < 4 440$$$;\n$$$0$$$ points if $$$P \\ge 4\\,440$$$.\nLimits: execution length $$$\\le 44\\,400\\,000$$$.",
    "_meta": {
      "index": 88,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A2",
      "uuid": "ps_c4064783688f36f44f2798858233ffd62564e100"
    }
  },
  {
    "planning_view": {
      "title": "F. Bit Shift Registers",
      "task": "Compute min or sort n k-bit integers using bitwise operations in ≤4000 instructions",
      "given": [
        "m=100 registers, each b=2000 bits",
        "Input: n k-bit integers stored in register 0",
        "9 instruction types available for bit manipulation"
      ],
      "goal": "Output min (s=0) or sorted (s=1) integers in register 0",
      "key_rules": [
        "Maximum q instructions allowed (q=4000)",
        "Input integers packed in first n*k bits of register 0",
        "Output must occupy first n*k bits of register 0",
        "Addition is modulo 2^b",
        "Shift operations pad with zeros"
      ],
      "target": {
        "1": {
          "points": 10,
          "req": "s=0, n=2, k≤2, q=1000"
        },
        "2": {
          "points": 11,
          "req": "s=0, n=2, k≤2, q=20"
        },
        "3": {
          "points": 12,
          "req": "s=0, any n,k, q=4000"
        },
        "4": {
          "points": 25,
          "req": "s=0, any n,k, q=150"
        },
        "5": {
          "points": 13,
          "req": "s=1, n≤10, any k, q=4000"
        },
        "6": {
          "points": 29,
          "req": "s=1, any n,k, q=4000"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Bit Shift Registers",
      "contest": "IOI 2021 day 2",
      "one_line": "Compute min or sort n k-bit integers using bitwise operations in ≤4000 instructions",
      "given": [
        "m=100 registers, each b=2000 bits",
        "Input: n k-bit integers stored in register 0",
        "9 instruction types available for bit manipulation"
      ],
      "goal": "Output min (s=0) or sorted (s=1) integers in register 0",
      "mechanism": "Construct program by appending instructions; registers manipulate bits via AND/OR/XOR/NOT/shifts/add",
      "success_condition": "Program output matches required min/sorted order when evaluated on test cases",
      "constraints": {
        "critical": [
          "Maximum q instructions allowed (q=4000)",
          "Input integers packed in first n*k bits of register 0",
          "Output must occupy first n*k bits of register 0",
          "Addition is modulo 2^b",
          "Shift operations pad with zeros"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "s=0, n=2, k≤2, q=1000"
          },
          "2": {
            "points": 11,
            "req": "s=0, n=2, k≤2, q=20"
          },
          "3": {
            "points": 12,
            "req": "s=0, any n,k, q=4000"
          },
          "4": {
            "points": 25,
            "req": "s=0, any n,k, q=150"
          },
          "5": {
            "points": 13,
            "req": "s=1, n≤10, any k, q=4000"
          },
          "6": {
            "points": 29,
            "req": "s=1, any n,k, q=4000"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Bit Shift Registers",
        "contest": "IOI 2021 day 2",
        "one_line": "Compute min or sort n k-bit integers using bitwise operations in ≤4000 instructions"
      },
      "problem": {
        "given": [
          "m=100 registers, each b=2000 bits",
          "Input: n k-bit integers stored in register 0",
          "9 instruction types available for bit manipulation"
        ],
        "goal": "Output min (s=0) or sorted (s=1) integers in register 0",
        "mechanism": "Construct program by appending instructions; registers manipulate bits via AND/OR/XOR/NOT/shifts/add",
        "success_condition": "Program output matches required min/sorted order when evaluated on test cases"
      },
      "constraints": {
        "critical": [
          "Maximum q instructions allowed (q=4000)",
          "Input integers packed in first n*k bits of register 0",
          "Output must occupy first n*k bits of register 0",
          "Addition is modulo 2^b",
          "Shift operations pad with zeros"
        ],
        "subtasks": {
          "1": {
            "points": 10,
            "req": "s=0, n=2, k≤2, q=1000"
          },
          "2": {
            "points": 11,
            "req": "s=0, n=2, k≤2, q=20"
          },
          "3": {
            "points": 12,
            "req": "s=0, any n,k, q=4000"
          },
          "4": {
            "points": 25,
            "req": "s=0, any n,k, q=150"
          },
          "5": {
            "points": 13,
            "req": "s=1, n≤10, any k, q=4000"
          },
          "6": {
            "points": 29,
            "req": "s=1, any n,k, q=4000"
          }
        }
      },
      "implementation": {
        "function_to_write": "void construct_instructions(int s, int n, int k, int q)",
        "available_api": {
          "append_move": {
            "signature": "void append_move(int t, int y)",
            "params": "t: destination register (0-99), y: source register (0-99)",
            "returns": "void",
            "side_effect": "Copies register y to register t"
          },
          "append_store": {
            "signature": "void append_store(int t, bool[] v)",
            "params": "t: destination register (0-99), v: array of exactly b=2000 bits",
            "returns": "void",
            "side_effect": "Stores bit array v in register t"
          },
          "append_and": {
            "signature": "void append_and(int t, int x, int y)",
            "params": "t: destination register (0-99), x,y: source registers (0-99)",
            "returns": "void",
            "side_effect": "Bitwise AND of registers x and y stored in t"
          },
          "append_or": {
            "signature": "void append_or(int t, int x, int y)",
            "params": "t: destination register (0-99), x,y: source registers (0-99)",
            "returns": "void",
            "side_effect": "Bitwise OR of registers x and y stored in t"
          },
          "append_xor": {
            "signature": "void append_xor(int t, int x, int y)",
            "params": "t: destination register (0-99), x,y: source registers (0-99)",
            "returns": "void",
            "side_effect": "Bitwise XOR of registers x and y stored in t"
          },
          "append_not": {
            "signature": "void append_not(int t, int x)",
            "params": "t: destination register (0-99), x: source register (0-99)",
            "returns": "void",
            "side_effect": "Bitwise NOT of register x stored in t"
          },
          "append_left": {
            "signature": "void append_left(int t, int x, int p)",
            "params": "t: destination register (0-99), x: source register (0-99), p: shift amount (0-2000)",
            "returns": "void",
            "side_effect": "Left shift register x by p bits, pad with zeros"
          },
          "append_right": {
            "signature": "void append_right(int t, int x, int p)",
            "params": "t: destination register (0-99), x: source register (0-99), p: shift amount (0-2000)",
            "returns": "void",
            "side_effect": "Right shift register x by p bits, pad with zeros"
          },
          "append_add": {
            "signature": "void append_add(int t, int x, int y)",
            "params": "t: destination register (0-99), x,y: source registers (0-99)",
            "returns": "void",
            "side_effect": "Add integer values of x and y modulo 2^b, store in t"
          },
          "append_print": {
            "signature": "void append_print(int t)",
            "params": "t: register to print (0-99)",
            "returns": "void",
            "side_effect": "Ignored during grading; for debugging only"
          }
        },
        "requirements": [
          "Registers are 0-indexed (0 to 99)",
          "All register indices must be valid (0-99)",
          "Shift amount p must be 0-2000",
          "store instruction requires exactly 2000 bits",
          "Maximum q instructions total"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "2048 MB"
      },
      "samples": [],
      "original_statement": "Christopher the engineer is working on a new type of computer processor.\nThe processor has access to $$$m$$$ different $$$b$$$-bit memory cells (where $$$m = 100$$$ and $$$b=2000$$$), which are\ncalled\nregisters, and are numbered from $$$0$$$ to $$$m-1$$$. We denote the registers by $$$r[0], r[1], \\ldots, r[m-1]$$$. Each register is an array of $$$b$$$ bits, numbered from $$$0$$$ (the rightmost bit) to $$$b-1$$$ (the leftmost bit). For each $$$i$$$ $$$(0\\leq i \\leq m-1)$$$ and each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ we denote the $$$j$$$-th bit of register $$$i$$$ by $$$r[i][j]$$$.\nFor any sequence of bits $$$d\\_0, d\\_1, \\ldots, d\\_{l-1}$$$ (of arbitrary length $$$l$$$) the\ninteger value\nof the sequence is equal to $$$2^0 \\cdot d\\_0 + 2^1 \\cdot d\\_1 + \\ldots + 2^{l-1} \\cdot d\\_{l-1}$$$. We say that the\ninteger value stored in a register\n$$$i$$$ is the integer value of the sequence of its bits, i.e., it is $$$2^0 \\cdot r[i][0] + 2^1 \\cdot r[i][1] + \\ldots + 2^{b-1} \\cdot r[i][b-1]$$$.\nThe processor has $$$9$$$ types of\ninstructions\nthat can be used to modify the bits in the registers. Each instruction operates on one or more registers and stores the output in one of the registers. In the following, we use $$$x := y$$$ to denote an operation of changing the value of $$$x$$$ such that it becomes equal to $$$y$$$. The operations performed by each type of instruction are described below\n$$$move(t,y)$$$: copy the array of bits in register $$$y$$$ to register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := r[y][j]$$$.\n$$$store(t,v)$$$: set register $$$t$$$ to be equal to $$$v$$$, where $$$v$$$ is an array of $$$b$$$ bits. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := v[j]$$$.\n$$$and(t,x,y)$$$: take the bitwise-AND of registers $$$x$$$ and $$$y$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1$$$ if\nboth\n$$$r[x][j]$$$ and $$$r[y][j]$$$ are $$$1$$$, and set $$$r[t][j] := 0$$$ otherwise.\n$$$or(t,x,y)$$$: Take the bitwise-OR of registers $$$x$$$ and $$$y$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1$$$ if\nat least one\nof $$$r[x][j]$$$ and $$$r[y][j]$$$ are $$$1$$$, and set $$$r[t][j] := 0$$$ otherwise.\n$$$xor(t,x,y)$$$: Take the bitwise-XOR of registers $$$x$$$ and $$$y$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1$$$ if\nexactly one\nof $$$r[x][j]$$$ and $$$r[y][j]$$$ is $$$1$$$, and set $$$r[t][j] := 0$$$ otherwise.\n$$$not(t,x)$$$: Take the bitwise-NOT of register $$$x$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1-r[x][j]$$$.\n$$$left(t,x,p)$$$: Shift all bits in register $$$x$$$ to the left by $$$p$$$, and store the result in register $$$t$$$. The result of shifting the bits in register $$$x$$$ to the left by $$$p$$$ is an array $$$v$$$ consisting of $$$b$$$ bits. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$, $$$v[j] = r[x][j-p]$$$, if $$$j \\geq p$$$, and $$$v[j] = 0$$$ otherwise. For all $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := v[j]$$$.\n$$$right(t,x,p)$$$: Shift all bits in register $$$x$$$ to the right by $$$p$$$, and store the result in register $$$t$$$. The result of shifting the bits in register $$$x$$$ to the right by $$$p$$$ is an array $$$v$$$ consisting of $$$b$$$ bits. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ $$$v[j] = r[x][j+p]$$$, if $$$j \\leq b - 1 - p$$$, and $$$v[j] = 0$$$ otherwise. For all $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := v[j]$$$.\n$$$add(t,x,y)$$$: Add the integer values stored in register $$$x$$$ and register $$$y$$$, and store the result in register $$$t$$$. The addition is carried out modulo $$$2^b$$$. Formally, let $$$X$$$ be the integer value stored in register $$$x$$$, and $$$Y$$$ be the integer value stored in register $$$y$$$ before the operation. Let $$$T$$$ be the integer value stored in register $$$t$$$ after the operation. If $$$X+Y < 2^b$$$, set the bits of $$$t$$$, such that $$$T = X+Y$$$. Otherwise, set the bits of $$$t$$$, such that $$$T=X+Y-2^b$$$.\nChristopher would like you to solve two types of tasks using the new processor. The type of a task is denoted by an integer $$$s$$$. For both types of tasks, you need to produce a\nprogram\n, that is a sequence of instructions defined above.\nThe\ninput\nto the program consists of $$$n$$$ integers $$$a[0],a[1],\\ldots,a[n-1]$$$each having $$$k$$$ bits, i.e., $$$a[i] < 2^k$$$ ($$$0 \\leq i \\leq n-1$$$). Before the program is executed, all of the input numbers are stored sequentially in register $$$0$$$, such that for each $$$i$$$ $$$(0 \\leq i \\leq n-1)$$$ the integer value of the sequence of $$$k$$$ bits $$$r[0][i \\cdot k], r[0][i \\cdot k + 1], \\ldots, r[0][(i+1) \\cdot k - 1]$$$ is equal to $$$a[i]$$$. Note that $$$n \\cdot k \\leq b$$$. All other bits in register $$$0$$$ (i.e., those with indices between $$$n \\cdot k$$$ and$$$b-1$$$, inclusive) and all bits in all other registers are initialized to $$$0$$$.\nRunning a program consists in executing its instructions in order. After the last instruction is executed, the\noutput\nof the program is computed based on the final value of bits in register $$$0$$$. Specifically, the output is a sequence of $$$n$$$ integers $$$c[0], c[1], \\ldots, c[n-1]$$$, where for each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) $$$c[i]$$$ is the integer value of a sequence consisting of bits $$$i\\cdot k$$$ to $$$(i + 1)\\cdot k-1$$$ of register $$$0$$$. Note that after running the program the remaining bits of register $$$0$$$ (with indices at least $$$n \\cdot k$$$) and all bits of all other registers can be arbitrary.\nThe first task $$$(s=0)$$$ s to find the smallest integer among the input integers $$$a[0],a[1],\\ldots,a[n-1]$$$. Specifically, $$$c[0]$$$ must be the minimum of $$$a[0], a[1], \\ldots, a[n-1]$$$. The values of $$$c[1], c[2], \\ldots, c[n-1]$$$ can be arbitrary.\nThe second task $$$(s=1)$$$ is to sort the input integers $$$a[0],a[1],\\ldots,a[n-1]$$$ in nondecreasing order. Specifically, for each $$$i$$$ ($$$0\\leq i\\leq n-1$$$), $$$c[i]$$$ should be equal to the $$$(1+i)$$$-th smallest integer among $$$a[0],a[1],\\ldots, a[n-1]$$$ (i.e., $$$c[0]$$$ is the smallest integer among the input integers).\nProvide Christopher with programs, consisting of at most $$$q$$$ instructions each, that can solve these tasks.\nImplementation Details\nYou should implement the following procedure:\nvoid construct_instructions(int s, int n, int k, int q)\n$$$s$$$: type of task.\n$$$n$$$: number of integers in the input\n$$$k$$$: number of bits in each input integer.\n$$$q$$$: maximum number of instructions allowed.\nThis procedure is called exactly once and should construct a sequence of instructions to perform the required task.\nThis procedure should call one or more of the following procedures to construct a sequence of instructions:\nvoid append_move(int t, int y)\nvoid append_store(int t, bool[] v)\nvoid append_and(int t, int x, int y)\nvoid append_or(int t, int x, int y)\nvoid append_xor(int t, int x, int y)\nvoid append_not(int t, int x)\nvoid append_left(int t, int x, int p)\nvoid append_right(int t, int x, int p)\nvoid append_add(int t, int x, int y)\nEach procedure appends a $$$move(t,y)$$$ $$$store(t,v)$$$, $$$and(t,x,y)$$$, $$$or(t,x,y)$$$, $$$xor(t,x,y)$$$, $$$not(t,x)$$$, $$$left(t,x,p)$$$, $$$right(t,x,p)$$$ or $$$add(t,x,y)$$$ instruction to the program, respectively.\nFor all relevant instructions, $$$t$$$, $$$x$$$, $$$y$$$ must be at least $$$0$$$ and at most $$$m-1$$$.\nFor all relevant instructions, $$$t$$$, $$$x$$$, $$$y$$$ are not necessarily pairwise distinct.\nFor $$$left$$$ and $$$right$$$ instructions, $$$p$$$ must be at least $$$0$$$ and at most $$$b$$$.\nFor $$$store$$$ instructions, the length of $$$v$$$ must be $$$b$$$.\nYou may also call the following procedure to help you in testing your solution:\nvoid append_print(int t)\nAny call to this procedure will be ignored during the grading of your solution.\nIn the sample grader, this procedure appends a $$$print(t)$$$ operation to the program\nWhen the sample grader encounters a $$$print(t)$$$ operation during the execution of a program, it prints $$$n$$$ $$$k$$$-bit integers formed by the first $$$n \\cdot k$$$ bits of register $$$t$$$ (see \"Sample Grader\" section for details).\n$$$t$$$ must satisfy $$$0 \\leq t \\leq m-1$$$.\nAny call to this procedure does not add to the number of constructed instructions.\nAfter appending the last instruction,\nconstruct_instructions\nshould return. The program is then evaluated on some number of test cases, each specifying an input consisting of $$$n$$$ $$$k$$$-bit integers $$$a[0], a[1], \\ldots, a[n-1]$$$. Your solution passes a given test case if the output of the program $$$c[0], c[1], \\ldots, c[n-1]$$$ for the provided input satisfies the following conditions:\nif $$$s = 0$$$, $$$c[0]$$$ should be the smallest value among $$$a[0], a[1], \\ldots, a[n-1]$$$.\nif $$$s = 1$$$, for all $$$i$$$ ($$$0\\leq i\\leq n-1$$$) $$$c[i]$$$ should be the $$$(1+i)$$$-th smallest integer among $$$a[0],a[1],\\ldots, a[n-1]$$$.\nInput\nThe sample grader reads the input in the following format\nline $$$1$$$ : $$$s\\ n\\ k\\ q$$$ ($$$0 \\leq s \\leq 1$$$, $$$2 \\leq n \\leq 100$$$, $$$1 \\leq k \\leq 10$$$, $$$q \\leq 4000$$$)\nThis is followed by some number of lines, each describing a single test case. Each test case is provided in the following format:\n$$$a[0]\\ a[1]\\ldots \\ a[n - 1]$$$ ($$$0 \\leq a[i] \\leq 2^k-1$$$)\nand describes a test case whose input consists of $$$n$$$ integers $$$a[0], a[1],\\ldots, a[n-1]$$$. The description of all test cases is followed by a single line containing solely $$$-1$$$.\nOutput\nThe sample grader first calls\nconstruct_instructions(s, n, k, q)\n. If this call violates some constraint described in the problem statement, the sample grader prints one of the error messages listed at the end of this section and exits. Otherwise, the sample grader first prints each instruction appended by\nconstruct_instructions(s, n, k, q)\n, in order. For $$$store$$$ instructions, $$$v$$$ is printed from index $$$0$$$ to index $$$b-1$$$.\nThen, the sample grader processes test cases in order. For each test case, it runs the constructed program on the input of the test case.\nFor each $$$print(t)$$$ operation, let $$$d[0], d[1], \\ldots, d[n-1]$$$ be a sequence of integers, such that for each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) $$$d[i]$$$ is the integer value of the sequence of bits $$$i\\cdot k$$$ to $$$(i + 1)\\cdot k-1$$$ of register $$$t$$$ (when the operation is executed). The grader prints this sequence in the following format:\nregister\n$$$t$$$: $$$d[0]\\ d[1]\\ldots \\ d[n-1]$$$.\nOnce all instructions have been executed, the sample grader prints the output of the program.\nIf $$$s = 0$$$, the output of the sample grader for each test case is in the following format:\n$$$c[0]$$$.\nIf $$$s = 1$$$, the output of the sample grader for each test case is in the following format:\n$$$c[0]\\ c[1]\\ldots \\ c[n-1]$$$.\nAfter executing all test cases, the grader prints\nnumber of instructions\n: $$$X$$$, where $$$X$$$ is the number of instructions in your program.\nThe grading of your solution may result in one of the following error messages:\nInvalid index\n: an incorrect (possibly negative) register index was provided as parameter $$$t$$$, $$$x$$$ or $$$y$$$ for some call of one of the procedures.\nValue to store is not b bits long\n: the length of $$$v$$$ given to\nappend_store\n, is not equal to $$$b$$$.\nInvalid shift value\n: the value of $$$p$$$ given to\nappend_left\nor\nappend_right\n, is not between $$$0$$$ and $$$b$$$ inclusive.\nToo many instructions\n: your procedure attempted to append more than $$$q$$$ instructions.\nScoring\nSubtask\nPoints\n$$$s$$$\n$$$n$$$\n$$$k$$$\n$$$q$$$\n1\n10\n$$$s=0$$$\n$$$n=2$$$\n$$$k\\leq2$$$\n$$$q=1000$$$\n2\n11\n$$$s=0$$$\n$$$n=2$$$\n$$$k\\leq2$$$\n$$$q=20$$$\n3\n12\n$$$s=0$$$\n—\n—\n$$$q=4000$$$\n4\n25\n$$$s=0$$$\n—\n—\n$$$q=150$$$\n5\n13\n$$$s=1$$$\n$$$n \\leq 10$$$\n—\n$$$q=4000$$$\n6\n29\n$$$s=1$$$\n—\n—\n$$$q=4000$$$\nNote\nExample 1\nSuppose $$$s = 0$$$, $$$n = 2$$$, $$$k = 1$$$, $$$q = 1000$$$. There are two input integers $$$a[0]$$$ and $$$a[1]$$$, each having $$$k=1$$$ bit. Before the program is executed, $$$r[0][0] = a[0]$$$ and $$$r[0][1] = a[1]$$$. All other bits in the processor are set to $$$0$$$. After all the instructions in the program are executed, we need to have $$$c[0]=r[0][0] = \\min(a[0], a[1])$$$, which is the minimum of $$$a[0]$$$ and $$$a[1]$$$.\nThere are only 4 possible inputs to the program:\nCase $$$1$$$: $$$a[0]=0, a[1]=0$$$\nCase $$$2$$$: $$$a[0]=0, a[1]=1$$$\nCase $$$3$$$: $$$a[0]=1, a[1]=0$$$\nCase $$$4$$$: $$$a[0]=1, a[1]=1$$$\nWe can notice that for all 4 cases, $$$\\min(a[0], a[1])$$$ s equal to the bitwise-AND of $$$a[0]$$$ and $$$a[1]$$$. Therefore, a possible solution is to construct a program by making the following calls:\nappend_move(1, 0)\n, which appends an instruction to copy $$$r[0]$$$ to $$$r[1]$$$.\nappend_right(1, 1, 1)\n, which appends an instruction that takes all bits in $$$r[1]$$$, shifts them to the right by $$$1$$$ bit, and then stores the result back in $$$r[1]$$$. Since each integer is $$$1$$$-bit long, this results in $$$r[1][0]$$$ being equal to $$$a[1]$$$.\nappend_and(0, 0, 1)\n, which appends an instruction to take the bitwise-AND of $$$r[0]$$$ and $$$r[1]$$$, then store the result in $$$r[0]$$$. After this instruction is executed, $$$r[0][0]$$$ is set to the bitwiseAND of $$$r[0][0]$$$ and $$$r[1][0]$$$, which is equal to the bitwise-AND of $$$a[0]$$$ and $$$a[1]$$$, as desired.\nExample 2\nSuppose $$$s=1$$$, $$$n=2$$$, $$$k=1$$$, $$$q=1000$$$. As with the earlier example, there are only 4 possible inputs to the program. For all 4 cases, $$$\\min(a[0], a[1])$$$ is the bitwise-AND of $$$a[0]$$$ and $$$a[1]$$$, and $$$\\max(a[0], a[1])$$$ is the bitwise-OR of $$$a[0]$$$ and $$$a[1]$$$. A possible solution is to make the following calls:\nappend_move(1,0)\nappend_right(1,1,1)\nappend_and(2,0,1)\nappend_or(3,0,1)\nappend_left(3,3,1)\nappend_or(0,2,3)\nAfter executing these instructions, $$$c[0]=r[0][0]$$$ contains $$$\\min(a[0],a[1])$$$, and $$$c[1]=r[0][1]$$$ contains $$$\\max(a[0],a[1])$$$, which sorts the input."
    },
    "original": "Christopher the engineer is working on a new type of computer processor.\nThe processor has access to $$$m$$$ different $$$b$$$-bit memory cells (where $$$m = 100$$$ and $$$b=2000$$$), which are\ncalled\nregisters, and are numbered from $$$0$$$ to $$$m-1$$$. We denote the registers by $$$r[0], r[1], \\ldots, r[m-1]$$$. Each register is an array of $$$b$$$ bits, numbered from $$$0$$$ (the rightmost bit) to $$$b-1$$$ (the leftmost bit). For each $$$i$$$ $$$(0\\leq i \\leq m-1)$$$ and each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ we denote the $$$j$$$-th bit of register $$$i$$$ by $$$r[i][j]$$$.\nFor any sequence of bits $$$d\\_0, d\\_1, \\ldots, d\\_{l-1}$$$ (of arbitrary length $$$l$$$) the\ninteger value\nof the sequence is equal to $$$2^0 \\cdot d\\_0 + 2^1 \\cdot d\\_1 + \\ldots + 2^{l-1} \\cdot d\\_{l-1}$$$. We say that the\ninteger value stored in a register\n$$$i$$$ is the integer value of the sequence of its bits, i.e., it is $$$2^0 \\cdot r[i][0] + 2^1 \\cdot r[i][1] + \\ldots + 2^{b-1} \\cdot r[i][b-1]$$$.\nThe processor has $$$9$$$ types of\ninstructions\nthat can be used to modify the bits in the registers. Each instruction operates on one or more registers and stores the output in one of the registers. In the following, we use $$$x := y$$$ to denote an operation of changing the value of $$$x$$$ such that it becomes equal to $$$y$$$. The operations performed by each type of instruction are described below\n$$$move(t,y)$$$: copy the array of bits in register $$$y$$$ to register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := r[y][j]$$$.\n$$$store(t,v)$$$: set register $$$t$$$ to be equal to $$$v$$$, where $$$v$$$ is an array of $$$b$$$ bits. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := v[j]$$$.\n$$$and(t,x,y)$$$: take the bitwise-AND of registers $$$x$$$ and $$$y$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1$$$ if\nboth\n$$$r[x][j]$$$ and $$$r[y][j]$$$ are $$$1$$$, and set $$$r[t][j] := 0$$$ otherwise.\n$$$or(t,x,y)$$$: Take the bitwise-OR of registers $$$x$$$ and $$$y$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1$$$ if\nat least one\nof $$$r[x][j]$$$ and $$$r[y][j]$$$ are $$$1$$$, and set $$$r[t][j] := 0$$$ otherwise.\n$$$xor(t,x,y)$$$: Take the bitwise-XOR of registers $$$x$$$ and $$$y$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1$$$ if\nexactly one\nof $$$r[x][j]$$$ and $$$r[y][j]$$$ is $$$1$$$, and set $$$r[t][j] := 0$$$ otherwise.\n$$$not(t,x)$$$: Take the bitwise-NOT of register $$$x$$$, and store the result in register $$$t$$$. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := 1-r[x][j]$$$.\n$$$left(t,x,p)$$$: Shift all bits in register $$$x$$$ to the left by $$$p$$$, and store the result in register $$$t$$$. The result of shifting the bits in register $$$x$$$ to the left by $$$p$$$ is an array $$$v$$$ consisting of $$$b$$$ bits. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$, $$$v[j] = r[x][j-p]$$$, if $$$j \\geq p$$$, and $$$v[j] = 0$$$ otherwise. For all $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := v[j]$$$.\n$$$right(t,x,p)$$$: Shift all bits in register $$$x$$$ to the right by $$$p$$$, and store the result in register $$$t$$$. The result of shifting the bits in register $$$x$$$ to the right by $$$p$$$ is an array $$$v$$$ consisting of $$$b$$$ bits. For each $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ $$$v[j] = r[x][j+p]$$$, if $$$j \\leq b - 1 - p$$$, and $$$v[j] = 0$$$ otherwise. For all $$$j$$$ $$$(0 \\leq j \\leq b-1)$$$ set $$$r[t][j] := v[j]$$$.\n$$$add(t,x,y)$$$: Add the integer values stored in register $$$x$$$ and register $$$y$$$, and store the result in register $$$t$$$. The addition is carried out modulo $$$2^b$$$. Formally, let $$$X$$$ be the integer value stored in register $$$x$$$, and $$$Y$$$ be the integer value stored in register $$$y$$$ before the operation. Let $$$T$$$ be the integer value stored in register $$$t$$$ after the operation. If $$$X+Y < 2^b$$$, set the bits of $$$t$$$, such that $$$T = X+Y$$$. Otherwise, set the bits of $$$t$$$, such that $$$T=X+Y-2^b$$$.\nChristopher would like you to solve two types of tasks using the new processor. The type of a task is denoted by an integer $$$s$$$. For both types of tasks, you need to produce a\nprogram\n, that is a sequence of instructions defined above.\nThe\ninput\nto the program consists of $$$n$$$ integers $$$a[0],a[1],\\ldots,a[n-1]$$$each having $$$k$$$ bits, i.e., $$$a[i] < 2^k$$$ ($$$0 \\leq i \\leq n-1$$$). Before the program is executed, all of the input numbers are stored sequentially in register $$$0$$$, such that for each $$$i$$$ $$$(0 \\leq i \\leq n-1)$$$ the integer value of the sequence of $$$k$$$ bits $$$r[0][i \\cdot k], r[0][i \\cdot k + 1], \\ldots, r[0][(i+1) \\cdot k - 1]$$$ is equal to $$$a[i]$$$. Note that $$$n \\cdot k \\leq b$$$. All other bits in register $$$0$$$ (i.e., those with indices between $$$n \\cdot k$$$ and$$$b-1$$$, inclusive) and all bits in all other registers are initialized to $$$0$$$.\nRunning a program consists in executing its instructions in order. After the last instruction is executed, the\noutput\nof the program is computed based on the final value of bits in register $$$0$$$. Specifically, the output is a sequence of $$$n$$$ integers $$$c[0], c[1], \\ldots, c[n-1]$$$, where for each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) $$$c[i]$$$ is the integer value of a sequence consisting of bits $$$i\\cdot k$$$ to $$$(i + 1)\\cdot k-1$$$ of register $$$0$$$. Note that after running the program the remaining bits of register $$$0$$$ (with indices at least $$$n \\cdot k$$$) and all bits of all other registers can be arbitrary.\nThe first task $$$(s=0)$$$ s to find the smallest integer among the input integers $$$a[0],a[1],\\ldots,a[n-1]$$$. Specifically, $$$c[0]$$$ must be the minimum of $$$a[0], a[1], \\ldots, a[n-1]$$$. The values of $$$c[1], c[2], \\ldots, c[n-1]$$$ can be arbitrary.\nThe second task $$$(s=1)$$$ is to sort the input integers $$$a[0],a[1],\\ldots,a[n-1]$$$ in nondecreasing order. Specifically, for each $$$i$$$ ($$$0\\leq i\\leq n-1$$$), $$$c[i]$$$ should be equal to the $$$(1+i)$$$-th smallest integer among $$$a[0],a[1],\\ldots, a[n-1]$$$ (i.e., $$$c[0]$$$ is the smallest integer among the input integers).\nProvide Christopher with programs, consisting of at most $$$q$$$ instructions each, that can solve these tasks.\nImplementation Details\nYou should implement the following procedure:\nvoid construct_instructions(int s, int n, int k, int q)\n$$$s$$$: type of task.\n$$$n$$$: number of integers in the input\n$$$k$$$: number of bits in each input integer.\n$$$q$$$: maximum number of instructions allowed.\nThis procedure is called exactly once and should construct a sequence of instructions to perform the required task.\nThis procedure should call one or more of the following procedures to construct a sequence of instructions:\nvoid append_move(int t, int y)\nvoid append_store(int t, bool[] v)\nvoid append_and(int t, int x, int y)\nvoid append_or(int t, int x, int y)\nvoid append_xor(int t, int x, int y)\nvoid append_not(int t, int x)\nvoid append_left(int t, int x, int p)\nvoid append_right(int t, int x, int p)\nvoid append_add(int t, int x, int y)\nEach procedure appends a $$$move(t,y)$$$ $$$store(t,v)$$$, $$$and(t,x,y)$$$, $$$or(t,x,y)$$$, $$$xor(t,x,y)$$$, $$$not(t,x)$$$, $$$left(t,x,p)$$$, $$$right(t,x,p)$$$ or $$$add(t,x,y)$$$ instruction to the program, respectively.\nFor all relevant instructions, $$$t$$$, $$$x$$$, $$$y$$$ must be at least $$$0$$$ and at most $$$m-1$$$.\nFor all relevant instructions, $$$t$$$, $$$x$$$, $$$y$$$ are not necessarily pairwise distinct.\nFor $$$left$$$ and $$$right$$$ instructions, $$$p$$$ must be at least $$$0$$$ and at most $$$b$$$.\nFor $$$store$$$ instructions, the length of $$$v$$$ must be $$$b$$$.\nYou may also call the following procedure to help you in testing your solution:\nvoid append_print(int t)\nAny call to this procedure will be ignored during the grading of your solution.\nIn the sample grader, this procedure appends a $$$print(t)$$$ operation to the program\nWhen the sample grader encounters a $$$print(t)$$$ operation during the execution of a program, it prints $$$n$$$ $$$k$$$-bit integers formed by the first $$$n \\cdot k$$$ bits of register $$$t$$$ (see \"Sample Grader\" section for details).\n$$$t$$$ must satisfy $$$0 \\leq t \\leq m-1$$$.\nAny call to this procedure does not add to the number of constructed instructions.\nAfter appending the last instruction,\nconstruct_instructions\nshould return. The program is then evaluated on some number of test cases, each specifying an input consisting of $$$n$$$ $$$k$$$-bit integers $$$a[0], a[1], \\ldots, a[n-1]$$$. Your solution passes a given test case if the output of the program $$$c[0], c[1], \\ldots, c[n-1]$$$ for the provided input satisfies the following conditions:\nif $$$s = 0$$$, $$$c[0]$$$ should be the smallest value among $$$a[0], a[1], \\ldots, a[n-1]$$$.\nif $$$s = 1$$$, for all $$$i$$$ ($$$0\\leq i\\leq n-1$$$) $$$c[i]$$$ should be the $$$(1+i)$$$-th smallest integer among $$$a[0],a[1],\\ldots, a[n-1]$$$.\nInput\nThe sample grader reads the input in the following format\nline $$$1$$$ : $$$s\\ n\\ k\\ q$$$ ($$$0 \\leq s \\leq 1$$$, $$$2 \\leq n \\leq 100$$$, $$$1 \\leq k \\leq 10$$$, $$$q \\leq 4000$$$)\nThis is followed by some number of lines, each describing a single test case. Each test case is provided in the following format:\n$$$a[0]\\ a[1]\\ldots \\ a[n - 1]$$$ ($$$0 \\leq a[i] \\leq 2^k-1$$$)\nand describes a test case whose input consists of $$$n$$$ integers $$$a[0], a[1],\\ldots, a[n-1]$$$. The description of all test cases is followed by a single line containing solely $$$-1$$$.\nOutput\nThe sample grader first calls\nconstruct_instructions(s, n, k, q)\n. If this call violates some constraint described in the problem statement, the sample grader prints one of the error messages listed at the end of this section and exits. Otherwise, the sample grader first prints each instruction appended by\nconstruct_instructions(s, n, k, q)\n, in order. For $$$store$$$ instructions, $$$v$$$ is printed from index $$$0$$$ to index $$$b-1$$$.\nThen, the sample grader processes test cases in order. For each test case, it runs the constructed program on the input of the test case.\nFor each $$$print(t)$$$ operation, let $$$d[0], d[1], \\ldots, d[n-1]$$$ be a sequence of integers, such that for each $$$i$$$ ($$$0 \\leq i \\leq n-1$$$) $$$d[i]$$$ is the integer value of the sequence of bits $$$i\\cdot k$$$ to $$$(i + 1)\\cdot k-1$$$ of register $$$t$$$ (when the operation is executed). The grader prints this sequence in the following format:\nregister\n$$$t$$$: $$$d[0]\\ d[1]\\ldots \\ d[n-1]$$$.\nOnce all instructions have been executed, the sample grader prints the output of the program.\nIf $$$s = 0$$$, the output of the sample grader for each test case is in the following format:\n$$$c[0]$$$.\nIf $$$s = 1$$$, the output of the sample grader for each test case is in the following format:\n$$$c[0]\\ c[1]\\ldots \\ c[n-1]$$$.\nAfter executing all test cases, the grader prints\nnumber of instructions\n: $$$X$$$, where $$$X$$$ is the number of instructions in your program.\nThe grading of your solution may result in one of the following error messages:\nInvalid index\n: an incorrect (possibly negative) register index was provided as parameter $$$t$$$, $$$x$$$ or $$$y$$$ for some call of one of the procedures.\nValue to store is not b bits long\n: the length of $$$v$$$ given to\nappend_store\n, is not equal to $$$b$$$.\nInvalid shift value\n: the value of $$$p$$$ given to\nappend_left\nor\nappend_right\n, is not between $$$0$$$ and $$$b$$$ inclusive.\nToo many instructions\n: your procedure attempted to append more than $$$q$$$ instructions.\nScoring\nSubtask\nPoints\n$$$s$$$\n$$$n$$$\n$$$k$$$\n$$$q$$$\n1\n10\n$$$s=0$$$\n$$$n=2$$$\n$$$k\\leq2$$$\n$$$q=1000$$$\n2\n11\n$$$s=0$$$\n$$$n=2$$$\n$$$k\\leq2$$$\n$$$q=20$$$\n3\n12\n$$$s=0$$$\n—\n—\n$$$q=4000$$$\n4\n25\n$$$s=0$$$\n—\n—\n$$$q=150$$$\n5\n13\n$$$s=1$$$\n$$$n \\leq 10$$$\n—\n$$$q=4000$$$\n6\n29\n$$$s=1$$$\n—\n—\n$$$q=4000$$$\nNote\nExample 1\nSuppose $$$s = 0$$$, $$$n = 2$$$, $$$k = 1$$$, $$$q = 1000$$$. There are two input integers $$$a[0]$$$ and $$$a[1]$$$, each having $$$k=1$$$ bit. Before the program is executed, $$$r[0][0] = a[0]$$$ and $$$r[0][1] = a[1]$$$. All other bits in the processor are set to $$$0$$$. After all the instructions in the program are executed, we need to have $$$c[0]=r[0][0] = \\min(a[0], a[1])$$$, which is the minimum of $$$a[0]$$$ and $$$a[1]$$$.\nThere are only 4 possible inputs to the program:\nCase $$$1$$$: $$$a[0]=0, a[1]=0$$$\nCase $$$2$$$: $$$a[0]=0, a[1]=1$$$\nCase $$$3$$$: $$$a[0]=1, a[1]=0$$$\nCase $$$4$$$: $$$a[0]=1, a[1]=1$$$\nWe can notice that for all 4 cases, $$$\\min(a[0], a[1])$$$ s equal to the bitwise-AND of $$$a[0]$$$ and $$$a[1]$$$. Therefore, a possible solution is to construct a program by making the following calls:\nappend_move(1, 0)\n, which appends an instruction to copy $$$r[0]$$$ to $$$r[1]$$$.\nappend_right(1, 1, 1)\n, which appends an instruction that takes all bits in $$$r[1]$$$, shifts them to the right by $$$1$$$ bit, and then stores the result back in $$$r[1]$$$. Since each integer is $$$1$$$-bit long, this results in $$$r[1][0]$$$ being equal to $$$a[1]$$$.\nappend_and(0, 0, 1)\n, which appends an instruction to take the bitwise-AND of $$$r[0]$$$ and $$$r[1]$$$, then store the result in $$$r[0]$$$. After this instruction is executed, $$$r[0][0]$$$ is set to the bitwiseAND of $$$r[0][0]$$$ and $$$r[1][0]$$$, which is equal to the bitwise-AND of $$$a[0]$$$ and $$$a[1]$$$, as desired.\nExample 2\nSuppose $$$s=1$$$, $$$n=2$$$, $$$k=1$$$, $$$q=1000$$$. As with the earlier example, there are only 4 possible inputs to the program. For all 4 cases, $$$\\min(a[0], a[1])$$$ is the bitwise-AND of $$$a[0]$$$ and $$$a[1]$$$, and $$$\\max(a[0], a[1])$$$ is the bitwise-OR of $$$a[0]$$$ and $$$a[1]$$$. A possible solution is to make the following calls:\nappend_move(1,0)\nappend_right(1,1,1)\nappend_and(2,0,1)\nappend_or(3,0,1)\nappend_left(3,3,1)\nappend_or(0,2,3)\nAfter executing these instructions, $$$c[0]=r[0][0]$$$ contains $$$\\min(a[0],a[1])$$$, and $$$c[1]=r[0][1]$$$ contains $$$\\max(a[0],a[1])$$$, which sorts the input.",
    "_meta": {
      "index": 89,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/F",
      "uuid": "ps_28cfe9d93837686cdc28d377ecbf257925ded513"
    }
  },
  {
    "planning_view": {
      "title": "E. Overtaking",
      "task": "Compute reserve bus hotel arrival time given departure Y ≤10^6 queries",
      "given": [
        "Road length L km with M sorting stations",
        "N+1 buses: N scheduled buses + 1 reserve bus",
        "Buses have departure times and speeds (km/time)",
        "No overtaking except at sorting stations"
      ],
      "goal": "Answer Q queries: given reserve bus departure time Y, find its hotel arrival time",
      "key_rules": [
        "Arrival time at station j = max(expected time, times of earlier-arriving buses at j-1)",
        "Buses maintain order from previous station when bunching occurs",
        "Sorting stations allow overtaking/reordering"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "N = 1, Q ≤ 1,000"
        },
        "2": {
          "points": 10,
          "req": "M = 2, Q ≤ 1,000"
        },
        "3": {
          "points": 20,
          "req": "N, M, Q ≤ 100"
        },
        "4": {
          "points": 26,
          "req": "Q ≤ 5,000"
        },
        "5": {
          "points": 35,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "E. Overtaking",
      "contest": "IOI 2023 day 2",
      "one_line": "Compute reserve bus hotel arrival time given departure Y ≤10^6 queries",
      "given": [
        "Road length L km with M sorting stations",
        "N+1 buses: N scheduled buses + 1 reserve bus",
        "Buses have departure times and speeds (km/time)",
        "No overtaking except at sorting stations"
      ],
      "goal": "Answer Q queries: given reserve bus departure time Y, find its hotel arrival time",
      "mechanism": "Buses bunch behind slower buses between stations, overtake at stations",
      "success_condition": "Return correct arrival time for each query",
      "constraints": {
        "critical": [
          "Arrival time at station j = max(expected time, times of earlier-arriving buses at j-1)",
          "Buses maintain order from previous station when bunching occurs",
          "Sorting stations allow overtaking/reordering"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N = 1, Q ≤ 1,000"
          },
          "2": {
            "points": 10,
            "req": "M = 2, Q ≤ 1,000"
          },
          "3": {
            "points": 20,
            "req": "N, M, Q ≤ 100"
          },
          "4": {
            "points": 26,
            "req": "Q ≤ 5,000"
          },
          "5": {
            "points": 35,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "2.5 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "E. Overtaking",
        "contest": "IOI 2023 day 2",
        "one_line": "Compute reserve bus hotel arrival time given departure Y ≤10^6 queries"
      },
      "problem": {
        "given": [
          "Road length L km with M sorting stations",
          "N+1 buses: N scheduled buses + 1 reserve bus",
          "Buses have departure times and speeds (km/time)",
          "No overtaking except at sorting stations"
        ],
        "goal": "Answer Q queries: given reserve bus departure time Y, find its hotel arrival time",
        "mechanism": "Buses bunch behind slower buses between stations, overtake at stations",
        "success_condition": "Return correct arrival time for each query"
      },
      "constraints": {
        "critical": [
          "Arrival time at station j = max(expected time, times of earlier-arriving buses at j-1)",
          "Buses maintain order from previous station when bunching occurs",
          "Sorting stations allow overtaking/reordering"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N = 1, Q ≤ 1,000"
          },
          "2": {
            "points": 10,
            "req": "M = 2, Q ≤ 1,000"
          },
          "3": {
            "points": 20,
            "req": "N, M, Q ≤ 100"
          },
          "4": {
            "points": 26,
            "req": "Q ≤ 5,000"
          },
          "5": {
            "points": 35,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int64 arrival_time(int64 Y)",
        "available_api": {
          "init": {
            "signature": "void init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)",
            "params": "L: road length, N: bus count, T: departure times, W: speeds, X: reserve bus speed, M: station count, S: station positions",
            "returns": "void",
            "side_effect": "Initializes problem data for subsequent queries"
          },
          "arrival_time": {
            "signature": "int64 arrival_time(int64 Y)",
            "params": "Y: reserve bus departure time",
            "returns": "Hotel arrival time for reserve bus",
            "side_effect": "None"
          }
        },
        "requirements": [
          "init called once before any arrival_time calls",
          "arrival_time called Q times per test case",
          "Use 64-bit integers for large values (up to 10^18)"
        ]
      },
      "limits": {
        "time": "2.5 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "6 4 10 4 2\n20 10 40 0\n5 20 20 30\n0 1 3 6\n0\n50",
          "output": "60\n130"
        }
      ],
      "original_statement": "There is a one-lane, one-way road from Budapest Airport to Hotel Forrás. The road is $$$L$$$ kilometres long.\nOver the IOI 2023 event, $$$N+1$$$ transfer buses traverse this road. Buses are numbered from $$$0$$$ to $$$N$$$. Bus $$$i$$$ ($$$0 \\le i < N$$$) is scheduled to leave the airport at the $$$T[i]$$$-th second of the event, and can travel $$$1$$$ kilometre in $$$W[i]$$$ seconds. Bus $$$N$$$ is a reserve bus that can travel $$$1$$$ kilometre in $$$X$$$ seconds. The time $$$Y$$$ when it will leave the airport has not yet been decided.\nOvertaking is not allowed on the road in general, but the buses are allowed to overtake each other at\nsorting stations\n. There are $$$M$$$ ($$$M > 1$$$) sorting stations, numbered from $$$0$$$ to $$$M - 1$$$, on different positions on the road. Sorting station $$$j$$$ ($$$0 \\le j < M$$$) is located $$$S[j]$$$ kilometres from the airport along the road. The sorting stations are sorted in increasing distance from the airport, that is, $$$S[j] < S[j+1]$$$ for each $$$0 \\le j \\le M - 2$$$. The first sorting station is the airport and the last one is the hotel, that is, $$$S[0] = 0$$$ and $$$S[M-1] = L$$$.\nEach bus travels at maximum speed unless it catches up to a slower bus travelling ahead of it on the road, in which case they get bunched and forced to travel at the speed of the slower bus, until they reach the next sorting station. There, the faster buses will overtake the slower buses.\nFormally, for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i \\le N$$$ and $$$0 \\le j < M$$$, the time $$$t_{i,j}$$$ (in seconds) when bus $$$i$$$\narrives at\nsorting station $$$j$$$ is defined as follows. Let $$$t_{i,0} = T[i]$$$ for each $$$0 \\le i < N$$$, and let $$$t_{N,0} = Y$$$. For each $$$j$$$ such that $$$0 < j < M$$$:\nDefine the\nexpected time of arrival\n(in seconds) of bus $$$i$$$ at sorting station $$$j$$$, denoted by $$$e_{i,j}$$$, as the time when bus $$$i$$$ would arrive at sorting station $$$j$$$ if it was travelling at full speed from the time it arrived at sorting station $$$j-1$$$. That is, let\n$$$e_{i,j} = t_{i,j-1} + W[i] \\cdot (S[j]-S[j-1])$$$ for each $$$0 \\le i < N$$$, and\n$$$e_{N,j} = t_{N,j-1} + X \\cdot (S[j]-S[j-1])$$$.\nBus $$$i$$$ arrives at sorting station $$$j$$$ at the\nmaximum\nof the expected times of arrivals of bus $$$i$$$ and of every other bus that arrived at station $$$j-1$$$ earlier than bus $$$i$$$. Formally, let $$$t_{i,j}$$$ be the maximum of $$$e_{i,j}$$$ and every $$$e_{k,j}$$$ for which $$$0 \\le k \\le N$$$ and $$$t_{k,j-1} < t_{i,j-1}$$$.\nThe IOI organizers want to schedule the reserve bus (bus $$$N$$$). Your task is to answer $$$Q$$$ questions of the organizers, which are of the following form: given the time $$$Y$$$ (in seconds) when the reserve bus is supposed to leave the airport, at what time would it arrive at the hotel?\nImplementation Details\nYour task is to implement the following procedures.\nvoid init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)\n$$$L$$$: the length of the road.\n$$$N$$$: the number of non-reserve buses.\n$$$T$$$: an array of length $$$N$$$ describing the times at which non-reserve buses are scheduled to leave from the airport.\n$$$W$$$: an array of length $$$N$$$ describing the maximum speeds of non-reserve buses.\n$$$X$$$: the time it takes for the reserve bus to travel $$$1$$$ kilometre.\n$$$M$$$: the number of sorting stations.\n$$$S$$$: an array of length $$$M$$$ describing the distances of the sorting stations from the airport.\nThis procedure is called exactly once for each test case, before any calls to\narrival_time\n.\nint64 arrival_time(int64 Y)\n$$$Y$$$: the time at which the reserve bus (bus $$$N$$$) is supposed to leave from the airport.\nThis procedure should return the time at which the reserve bus would arrive at the hotel.\nThis procedure is called exactly $$$Q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$L \\; N \\; X \\; M \\; Q$$$ ($$$1 \\le L \\le 10^9$$$, $$$1 \\le N \\le 1\\,000$$$, $$$1 \\le X \\le 10^9$$$, $$$2 \\le M \\le 1\\,000$$$, $$$1 \\le Q \\le 10^6$$$)\nline $$$2$$$: $$$T[0] \\; T[1] \\; \\ldots \\; T[N-1]$$$ ($$$0 \\le T[i] \\le 10^{18}$$$)\nline $$$3$$$: $$$W[0] \\; W[1] \\; \\ldots \\; W[N-1]$$$ ($$$1 \\le W[i] \\le 10^9$$$)\nline $$$4$$$: $$$S[0] \\; S[1] \\; \\ldots \\; S[M-1]$$$ ($$$0 = S[0] < S[1] < \\cdots < S[M-1] = L$$$)\nline $$$5 + k$$$ ($$$0 \\le k < Q$$$): $$$Y$$$ for question $$$k$$$ ($$$0 \\le Y \\le 10^{18}$$$)\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + k$$$ ($$$0 \\le k < Q$$$): the return value of\narrival_time\nfor question $$$k$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$N = 1, Q \\le 1\\,000$$$\n2\n10\n$$$M = 2, Q \\le 1\\,000$$$\n3\n20\n$$$N, M, Q \\le 100$$$\n4\n26\n$$$Q \\le 5\\,000$$$\n5\n35\nNo additional constraints.\nExample\nNote\nConsider the following sequence of calls:\ninit(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])\nIgnoring bus $$$4$$$ (that has not yet been scheduled), the following table shows the expected and actual times of arrivals for non-reserve buses at each sorting station:\n$$$i$$$\n$$$t_{i,0}$$$\n$$$e_{i,1}$$$\n$$$t_{i,1}$$$\n$$$e_{i,2}$$$\n$$$t_{i,2}$$$\n$$$e_{i,3}$$$\n$$$t_{i,3}$$$\n$$$0$$$\n$$$20$$$\n$$$25$$$\n$$$30$$$\n$$$40$$$\n$$$40$$$\n$$$55$$$\n$$$55$$$\n$$$1$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$70$$$\n$$$70$$$\n$$$130$$$\n$$$130$$$\n$$$2$$$\n$$$40$$$\n$$$60$$$\n$$$60$$$\n$$$100$$$\n$$$100$$$\n$$$160$$$\n$$$180$$$\n$$$3$$$\n$$$0$$$\n$$$30$$$\n$$$30$$$\n$$$90$$$\n$$$90$$$\n$$$180$$$\n$$$180$$$\nThe times of arrivals at station $$$0$$$ are the times at which buses are scheduled to leave the airport. That is, $$$t_{i,0} = T[i]$$$ for $$$0 \\le i \\le 3$$$.\nThe expected and actual times of arrivals at sorting station $$$1$$$ are computed as follows:\nThe expected times of arrivals at station $$$1$$$:\nBus $$$0$$$: $$$e_{0,1} = t_{0,0} + W[0] \\cdot (S[1]-S[0]) = 20 + 5 \\cdot 1 = 25$$$.\nBus $$$1$$$: $$$e_{1,1} = t_{1,0} + W[1] \\cdot (S[1]-S[0]) = 10 + 20 \\cdot 1 = 30$$$.\nBus $$$2$$$: $$$e_{2,1} = t_{2,0} + W[2] \\cdot (S[1]-S[0]) = 40 + 20 \\cdot 1 = 60$$$.\nBus $$$3$$$: $$$e_{3,1} = t_{3,0} + W[3] \\cdot (S[1]-S[0]) = 0 + 30 \\cdot 1 = 30$$$.\nThe times of arrivals at station $$$1$$$:\nBuses $$$1$$$ and $$$3$$$ arrive at station $$$0$$$ earlier than bus $$$0$$$, so $$$t_{0,1} = \\max([e_{0,1},e_{1,1},e_{3,1}]) = 30$$$.\nBus $$$3$$$ arrives at station $$$0$$$ earlier than bus $$$1$$$, so $$$t_{1,1} = \\max([e_{1,1},e_{3,1}]) = 30$$$.\nBus $$$0$$$, bus $$$1$$$ and bus $$$3$$$ arrive at sorting station $$$0$$$ earlier than bus $$$2$$$, so $$$t_{2,1} = \\max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$$$.\nNo bus arrives at station $$$0$$$ earlier than bus $$$3$$$, so $$$t_{3,1} = \\max([e_{3,1}]) = 30$$$.\narrival_time(0)\nBus $$$4$$$ takes $$$10$$$ seconds to travel $$$1$$$ kilometre and is now scheduled to leave the airport at the $$$0$$$-th second. In this case, the following table shows the times of arrivals for each bus. The only change regarding the expected and actual arrival times of the non-reserve buses is underlined.\n$$$i$$$\n$$$t_{i,0}$$$\n$$$e_{i,1}$$$\n$$$t_{i,1}$$$\n$$$e_{i,2}$$$\n$$$t_{i,2}$$$\n$$$e_{i,3}$$$\n$$$t_{i,3}$$$\n$$$0$$$\n$$$20$$$\n$$$25$$$\n$$$30$$$\n$$$40$$$\n$$$40$$$\n$$$55$$$\n$$$\\underline{60}$$$\n$$$1$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$70$$$\n$$$70$$$\n$$$130$$$\n$$$130$$$\n$$$2$$$\n$$$40$$$\n$$$60$$$\n$$$60$$$\n$$$100$$$\n$$$100$$$\n$$$160$$$\n$$$180$$$\n$$$3$$$\n$$$0$$$\n$$$30$$$\n$$$30$$$\n$$$90$$$\n$$$90$$$\n$$$180$$$\n$$$180$$$\n$$$4$$$\n$$$0$$$\n$$$10$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$60$$$\n$$$60$$$\nWe see that bus $$$4$$$ arrives at the hotel at the $$$60$$$-th second. Thus, the procedure should return $$$60$$$.\narrival_time(50)\nBus $$$4$$$ is now scheduled to leave the airport at the $$$50$$$-th second. In this case, there are no changes in the times of arrivals for the non-reserve buses compared to the initial table. The times of arrivals are shown in the following table.\n$$$i$$$\n$$$t_{i,0}$$$\n$$$e_{i,1}$$$\n$$$t_{i,1}$$$\n$$$e_{i,2}$$$\n$$$t_{i,2}$$$\n$$$e_{i,3}$$$\n$$$t_{i,3}$$$\n$$$0$$$\n$$$20$$$\n$$$25$$$\n$$$30$$$\n$$$40$$$\n$$$40$$$\n$$$55$$$\n$$$55$$$\n$$$1$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$70$$$\n$$$70$$$\n$$$130$$$\n$$$130$$$\n$$$2$$$\n$$$40$$$\n$$$60$$$\n$$$60$$$\n$$$100$$$\n$$$100$$$\n$$$160$$$\n$$$180$$$\n$$$3$$$\n$$$0$$$\n$$$30$$$\n$$$30$$$\n$$$90$$$\n$$$90$$$\n$$$180$$$\n$$$180$$$\n$$$4$$$\n$$$50$$$\n$$$60$$$\n$$$60$$$\n$$$80$$$\n$$$90$$$\n$$$120$$$\n$$$130$$$\nBus $$$4$$$ overtakes the slower bus $$$2$$$ at sorting station $$$1$$$ as they arrive at the same time. Next, bus $$$4$$$ gets bunched with bus $$$3$$$ between station $$$1$$$ and station $$$2$$$, making bus $$$4$$$ arrive at station $$$2$$$ at the $$$90$$$-th second instead of the $$$80$$$-th. After leaving station $$$2$$$, bus $$$4$$$ gets bunched with bus $$$1$$$ up until they arrive at the hotel. Bus $$$4$$$ arrives at the hotel at the $$$130$$$-th second. Thus, the procedure should return $$$130$$$.\nWe can plot the time it takes for each bus to arrive at each distance from the airport. The x-axis of the plot represents the distance from the airport (in kilometres) and the y-axis of the plot represents the time (in seconds). Vertical dashed lines mark the positions of the sorting stations. Different solid lines (accompanied by the bus indices) represent the four non-reserve buses. The dotted black line represents the reserve bus.\narrival_time(0)\narrival_time(50)"
    },
    "original": "There is a one-lane, one-way road from Budapest Airport to Hotel Forrás. The road is $$$L$$$ kilometres long.\nOver the IOI 2023 event, $$$N+1$$$ transfer buses traverse this road. Buses are numbered from $$$0$$$ to $$$N$$$. Bus $$$i$$$ ($$$0 \\le i < N$$$) is scheduled to leave the airport at the $$$T[i]$$$-th second of the event, and can travel $$$1$$$ kilometre in $$$W[i]$$$ seconds. Bus $$$N$$$ is a reserve bus that can travel $$$1$$$ kilometre in $$$X$$$ seconds. The time $$$Y$$$ when it will leave the airport has not yet been decided.\nOvertaking is not allowed on the road in general, but the buses are allowed to overtake each other at\nsorting stations\n. There are $$$M$$$ ($$$M > 1$$$) sorting stations, numbered from $$$0$$$ to $$$M - 1$$$, on different positions on the road. Sorting station $$$j$$$ ($$$0 \\le j < M$$$) is located $$$S[j]$$$ kilometres from the airport along the road. The sorting stations are sorted in increasing distance from the airport, that is, $$$S[j] < S[j+1]$$$ for each $$$0 \\le j \\le M - 2$$$. The first sorting station is the airport and the last one is the hotel, that is, $$$S[0] = 0$$$ and $$$S[M-1] = L$$$.\nEach bus travels at maximum speed unless it catches up to a slower bus travelling ahead of it on the road, in which case they get bunched and forced to travel at the speed of the slower bus, until they reach the next sorting station. There, the faster buses will overtake the slower buses.\nFormally, for each $$$i$$$ and $$$j$$$ such that $$$0 \\le i \\le N$$$ and $$$0 \\le j < M$$$, the time $$$t_{i,j}$$$ (in seconds) when bus $$$i$$$\narrives at\nsorting station $$$j$$$ is defined as follows. Let $$$t_{i,0} = T[i]$$$ for each $$$0 \\le i < N$$$, and let $$$t_{N,0} = Y$$$. For each $$$j$$$ such that $$$0 < j < M$$$:\nDefine the\nexpected time of arrival\n(in seconds) of bus $$$i$$$ at sorting station $$$j$$$, denoted by $$$e_{i,j}$$$, as the time when bus $$$i$$$ would arrive at sorting station $$$j$$$ if it was travelling at full speed from the time it arrived at sorting station $$$j-1$$$. That is, let\n$$$e_{i,j} = t_{i,j-1} + W[i] \\cdot (S[j]-S[j-1])$$$ for each $$$0 \\le i < N$$$, and\n$$$e_{N,j} = t_{N,j-1} + X \\cdot (S[j]-S[j-1])$$$.\nBus $$$i$$$ arrives at sorting station $$$j$$$ at the\nmaximum\nof the expected times of arrivals of bus $$$i$$$ and of every other bus that arrived at station $$$j-1$$$ earlier than bus $$$i$$$. Formally, let $$$t_{i,j}$$$ be the maximum of $$$e_{i,j}$$$ and every $$$e_{k,j}$$$ for which $$$0 \\le k \\le N$$$ and $$$t_{k,j-1} < t_{i,j-1}$$$.\nThe IOI organizers want to schedule the reserve bus (bus $$$N$$$). Your task is to answer $$$Q$$$ questions of the organizers, which are of the following form: given the time $$$Y$$$ (in seconds) when the reserve bus is supposed to leave the airport, at what time would it arrive at the hotel?\nImplementation Details\nYour task is to implement the following procedures.\nvoid init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)\n$$$L$$$: the length of the road.\n$$$N$$$: the number of non-reserve buses.\n$$$T$$$: an array of length $$$N$$$ describing the times at which non-reserve buses are scheduled to leave from the airport.\n$$$W$$$: an array of length $$$N$$$ describing the maximum speeds of non-reserve buses.\n$$$X$$$: the time it takes for the reserve bus to travel $$$1$$$ kilometre.\n$$$M$$$: the number of sorting stations.\n$$$S$$$: an array of length $$$M$$$ describing the distances of the sorting stations from the airport.\nThis procedure is called exactly once for each test case, before any calls to\narrival_time\n.\nint64 arrival_time(int64 Y)\n$$$Y$$$: the time at which the reserve bus (bus $$$N$$$) is supposed to leave from the airport.\nThis procedure should return the time at which the reserve bus would arrive at the hotel.\nThis procedure is called exactly $$$Q$$$ times.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$L \\; N \\; X \\; M \\; Q$$$ ($$$1 \\le L \\le 10^9$$$, $$$1 \\le N \\le 1\\,000$$$, $$$1 \\le X \\le 10^9$$$, $$$2 \\le M \\le 1\\,000$$$, $$$1 \\le Q \\le 10^6$$$)\nline $$$2$$$: $$$T[0] \\; T[1] \\; \\ldots \\; T[N-1]$$$ ($$$0 \\le T[i] \\le 10^{18}$$$)\nline $$$3$$$: $$$W[0] \\; W[1] \\; \\ldots \\; W[N-1]$$$ ($$$1 \\le W[i] \\le 10^9$$$)\nline $$$4$$$: $$$S[0] \\; S[1] \\; \\ldots \\; S[M-1]$$$ ($$$0 = S[0] < S[1] < \\cdots < S[M-1] = L$$$)\nline $$$5 + k$$$ ($$$0 \\le k < Q$$$): $$$Y$$$ for question $$$k$$$ ($$$0 \\le Y \\le 10^{18}$$$)\nOutput\nThe sample grader prints your answers in the following format:\nline $$$1 + k$$$ ($$$0 \\le k < Q$$$): the return value of\narrival_time\nfor question $$$k$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$N = 1, Q \\le 1\\,000$$$\n2\n10\n$$$M = 2, Q \\le 1\\,000$$$\n3\n20\n$$$N, M, Q \\le 100$$$\n4\n26\n$$$Q \\le 5\\,000$$$\n5\n35\nNo additional constraints.\nExample\nNote\nConsider the following sequence of calls:\ninit(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])\nIgnoring bus $$$4$$$ (that has not yet been scheduled), the following table shows the expected and actual times of arrivals for non-reserve buses at each sorting station:\n$$$i$$$\n$$$t_{i,0}$$$\n$$$e_{i,1}$$$\n$$$t_{i,1}$$$\n$$$e_{i,2}$$$\n$$$t_{i,2}$$$\n$$$e_{i,3}$$$\n$$$t_{i,3}$$$\n$$$0$$$\n$$$20$$$\n$$$25$$$\n$$$30$$$\n$$$40$$$\n$$$40$$$\n$$$55$$$\n$$$55$$$\n$$$1$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$70$$$\n$$$70$$$\n$$$130$$$\n$$$130$$$\n$$$2$$$\n$$$40$$$\n$$$60$$$\n$$$60$$$\n$$$100$$$\n$$$100$$$\n$$$160$$$\n$$$180$$$\n$$$3$$$\n$$$0$$$\n$$$30$$$\n$$$30$$$\n$$$90$$$\n$$$90$$$\n$$$180$$$\n$$$180$$$\nThe times of arrivals at station $$$0$$$ are the times at which buses are scheduled to leave the airport. That is, $$$t_{i,0} = T[i]$$$ for $$$0 \\le i \\le 3$$$.\nThe expected and actual times of arrivals at sorting station $$$1$$$ are computed as follows:\nThe expected times of arrivals at station $$$1$$$:\nBus $$$0$$$: $$$e_{0,1} = t_{0,0} + W[0] \\cdot (S[1]-S[0]) = 20 + 5 \\cdot 1 = 25$$$.\nBus $$$1$$$: $$$e_{1,1} = t_{1,0} + W[1] \\cdot (S[1]-S[0]) = 10 + 20 \\cdot 1 = 30$$$.\nBus $$$2$$$: $$$e_{2,1} = t_{2,0} + W[2] \\cdot (S[1]-S[0]) = 40 + 20 \\cdot 1 = 60$$$.\nBus $$$3$$$: $$$e_{3,1} = t_{3,0} + W[3] \\cdot (S[1]-S[0]) = 0 + 30 \\cdot 1 = 30$$$.\nThe times of arrivals at station $$$1$$$:\nBuses $$$1$$$ and $$$3$$$ arrive at station $$$0$$$ earlier than bus $$$0$$$, so $$$t_{0,1} = \\max([e_{0,1},e_{1,1},e_{3,1}]) = 30$$$.\nBus $$$3$$$ arrives at station $$$0$$$ earlier than bus $$$1$$$, so $$$t_{1,1} = \\max([e_{1,1},e_{3,1}]) = 30$$$.\nBus $$$0$$$, bus $$$1$$$ and bus $$$3$$$ arrive at sorting station $$$0$$$ earlier than bus $$$2$$$, so $$$t_{2,1} = \\max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$$$.\nNo bus arrives at station $$$0$$$ earlier than bus $$$3$$$, so $$$t_{3,1} = \\max([e_{3,1}]) = 30$$$.\narrival_time(0)\nBus $$$4$$$ takes $$$10$$$ seconds to travel $$$1$$$ kilometre and is now scheduled to leave the airport at the $$$0$$$-th second. In this case, the following table shows the times of arrivals for each bus. The only change regarding the expected and actual arrival times of the non-reserve buses is underlined.\n$$$i$$$\n$$$t_{i,0}$$$\n$$$e_{i,1}$$$\n$$$t_{i,1}$$$\n$$$e_{i,2}$$$\n$$$t_{i,2}$$$\n$$$e_{i,3}$$$\n$$$t_{i,3}$$$\n$$$0$$$\n$$$20$$$\n$$$25$$$\n$$$30$$$\n$$$40$$$\n$$$40$$$\n$$$55$$$\n$$$\\underline{60}$$$\n$$$1$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$70$$$\n$$$70$$$\n$$$130$$$\n$$$130$$$\n$$$2$$$\n$$$40$$$\n$$$60$$$\n$$$60$$$\n$$$100$$$\n$$$100$$$\n$$$160$$$\n$$$180$$$\n$$$3$$$\n$$$0$$$\n$$$30$$$\n$$$30$$$\n$$$90$$$\n$$$90$$$\n$$$180$$$\n$$$180$$$\n$$$4$$$\n$$$0$$$\n$$$10$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$60$$$\n$$$60$$$\nWe see that bus $$$4$$$ arrives at the hotel at the $$$60$$$-th second. Thus, the procedure should return $$$60$$$.\narrival_time(50)\nBus $$$4$$$ is now scheduled to leave the airport at the $$$50$$$-th second. In this case, there are no changes in the times of arrivals for the non-reserve buses compared to the initial table. The times of arrivals are shown in the following table.\n$$$i$$$\n$$$t_{i,0}$$$\n$$$e_{i,1}$$$\n$$$t_{i,1}$$$\n$$$e_{i,2}$$$\n$$$t_{i,2}$$$\n$$$e_{i,3}$$$\n$$$t_{i,3}$$$\n$$$0$$$\n$$$20$$$\n$$$25$$$\n$$$30$$$\n$$$40$$$\n$$$40$$$\n$$$55$$$\n$$$55$$$\n$$$1$$$\n$$$10$$$\n$$$30$$$\n$$$30$$$\n$$$70$$$\n$$$70$$$\n$$$130$$$\n$$$130$$$\n$$$2$$$\n$$$40$$$\n$$$60$$$\n$$$60$$$\n$$$100$$$\n$$$100$$$\n$$$160$$$\n$$$180$$$\n$$$3$$$\n$$$0$$$\n$$$30$$$\n$$$30$$$\n$$$90$$$\n$$$90$$$\n$$$180$$$\n$$$180$$$\n$$$4$$$\n$$$50$$$\n$$$60$$$\n$$$60$$$\n$$$80$$$\n$$$90$$$\n$$$120$$$\n$$$130$$$\nBus $$$4$$$ overtakes the slower bus $$$2$$$ at sorting station $$$1$$$ as they arrive at the same time. Next, bus $$$4$$$ gets bunched with bus $$$3$$$ between station $$$1$$$ and station $$$2$$$, making bus $$$4$$$ arrive at station $$$2$$$ at the $$$90$$$-th second instead of the $$$80$$$-th. After leaving station $$$2$$$, bus $$$4$$$ gets bunched with bus $$$1$$$ up until they arrive at the hotel. Bus $$$4$$$ arrives at the hotel at the $$$130$$$-th second. Thus, the procedure should return $$$130$$$.\nWe can plot the time it takes for each bus to arrive at each distance from the airport. The x-axis of the plot represents the distance from the airport (in kilometres) and the y-axis of the plot represents the time (in seconds). Vertical dashed lines mark the positions of the sorting stations. Different solid lines (accompanied by the bus indices) represent the four non-reserve buses. The dotted black line represents the reserve bus.\narrival_time(0)\narrival_time(50)",
    "_meta": {
      "index": 90,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/E",
      "uuid": "ps_7d4a4294f0c8b8759245b63eeb083832d6ccc240"
    }
  },
  {
    "planning_view": {
      "title": "D. Beech Tree",
      "task": "Determine which subtrees can be ordered with parent-child relationships matching color frequency patterns",
      "given": [
        "Tree with N nodes numbered 0 to N-1",
        "Node i (≥1) connects to parent P[i] where P[i] < i",
        "Edges have colors from 1 to M",
        "For node r, T(r) is subtree rooted at r"
      ],
      "goal": "For each node r, determine if T(r) has a beautiful permutation",
      "key_rules": [
        "Tree is rooted at node 0 with parent-child relationships",
        "Single-node subtrees are always beautiful",
        "Parent of vᵢ is determined by color frequency pattern in permutation"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "N ≤ 8, M ≤ 500"
        },
        "2": {
          "points": 5,
          "req": "Tree is a path: P[i] = i-1 for i≥1"
        },
        "3": {
          "points": 9,
          "req": "Tree depth ≤ 2: all nodes connect to 0 or to neighbors of 0"
        },
        "4": {
          "points": 8,
          "req": "At most 2 edges of each color"
        },
        "5": {
          "points": 14,
          "req": "N ≤ 200, M ≤ 500"
        },
        "6": {
          "points": 14,
          "req": "N ≤ 2000, M = 2"
        },
        "7": {
          "points": 12,
          "req": "N ≤ 2000"
        },
        "8": {
          "points": 17,
          "req": "M = 2"
        },
        "9": {
          "points": 12,
          "req": "No constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Beech Tree",
      "contest": "IOI 2023 day 2",
      "one_line": "Determine which subtrees can be ordered with parent-child relationships matching color frequency patterns",
      "given": [
        "Tree with N nodes numbered 0 to N-1",
        "Node i (≥1) connects to parent P[i] where P[i] < i",
        "Edges have colors from 1 to M",
        "For node r, T(r) is subtree rooted at r"
      ],
      "goal": "For each node r, determine if T(r) has a beautiful permutation",
      "mechanism": "A permutation v₀,v₁,... of T(r) is beautiful if v₀=r and parent(vᵢ) = v_{f(i)} where f(i) counts how many times color C[vᵢ] appears in v₁...v_{i-1}",
      "success_condition": "Subtree is beautiful if it has at least one beautiful permutation",
      "constraints": {
        "critical": [
          "Tree is rooted at node 0 with parent-child relationships",
          "Single-node subtrees are always beautiful",
          "Parent of vᵢ is determined by color frequency pattern in permutation"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N ≤ 8, M ≤ 500"
          },
          "2": {
            "points": 5,
            "req": "Tree is a path: P[i] = i-1 for i≥1"
          },
          "3": {
            "points": 9,
            "req": "Tree depth ≤ 2: all nodes connect to 0 or to neighbors of 0"
          },
          "4": {
            "points": 8,
            "req": "At most 2 edges of each color"
          },
          "5": {
            "points": 14,
            "req": "N ≤ 200, M ≤ 500"
          },
          "6": {
            "points": 14,
            "req": "N ≤ 2000, M = 2"
          },
          "7": {
            "points": 12,
            "req": "N ≤ 2000"
          },
          "8": {
            "points": 17,
            "req": "M = 2"
          },
          "9": {
            "points": 12,
            "req": "No constraints"
          }
        }
      },
      "limits": {
        "time": "1.5 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Beech Tree",
        "contest": "IOI 2023 day 2",
        "one_line": "Determine which subtrees can be ordered with parent-child relationships matching color frequency patterns"
      },
      "problem": {
        "given": [
          "Tree with N nodes numbered 0 to N-1",
          "Node i (≥1) connects to parent P[i] where P[i] < i",
          "Edges have colors from 1 to M",
          "For node r, T(r) is subtree rooted at r"
        ],
        "goal": "For each node r, determine if T(r) has a beautiful permutation",
        "mechanism": "A permutation v₀,v₁,... of T(r) is beautiful if v₀=r and parent(vᵢ) = v_{f(i)} where f(i) counts how many times color C[vᵢ] appears in v₁...v_{i-1}",
        "success_condition": "Subtree is beautiful if it has at least one beautiful permutation"
      },
      "constraints": {
        "critical": [
          "Tree is rooted at node 0 with parent-child relationships",
          "Single-node subtrees are always beautiful",
          "Parent of vᵢ is determined by color frequency pattern in permutation"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N ≤ 8, M ≤ 500"
          },
          "2": {
            "points": 5,
            "req": "Tree is a path: P[i] = i-1 for i≥1"
          },
          "3": {
            "points": 9,
            "req": "Tree depth ≤ 2: all nodes connect to 0 or to neighbors of 0"
          },
          "4": {
            "points": 8,
            "req": "At most 2 edges of each color"
          },
          "5": {
            "points": 14,
            "req": "N ≤ 200, M ≤ 500"
          },
          "6": {
            "points": 14,
            "req": "N ≤ 2000, M = 2"
          },
          "7": {
            "points": 12,
            "req": "N ≤ 2000"
          },
          "8": {
            "points": 17,
            "req": "M = 2"
          },
          "9": {
            "points": 12,
            "req": "No constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] beechtree(int N, int M, int[] P, int[] C)",
        "available_api": {},
        "requirements": [
          "Return array b of length N where b[r]=1 if T(r) is beautiful, else 0",
          "P[0] = -1, C[0] = 0",
          "Nodes are 0-indexed",
          "Must handle N up to 200,000"
        ]
      },
      "limits": {
        "time": "1.5 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "4 2\n-1 0 0 0\n0 1 1 2",
          "output": "0 1 1 1"
        }
      ],
      "original_statement": "Vétyem Woods is a famous woodland with lots of colorful trees. One of the oldest and tallest beech trees is called Ős Vezér.\nThe tree Ős Vezér can be modeled as a set of $$$N$$$\nnodes\nand $$$N-1$$$\nedges\n. Nodes are numbered from $$$0$$$ to $$$N-1$$$ and edges are numbered from $$$1$$$ to $$$N-1$$$. Each edge connects two distinct nodes of the tree. Specifically, edge $$$i$$$ ($$$1 \\le i < N$$$) connects node $$$i$$$ to node $$$P[i]$$$, where $$$0 \\le P[i] < i$$$. Node $$$P[i]$$$ is called the\nparent\nof node $$$i$$$, and node $$$i$$$ is called a\nchild\nof node $$$P[i]$$$.\nEach edge has a color. There are $$$M$$$ possible edge colors numbered from $$$1$$$ to $$$M$$$. The color of edge $$$i$$$ is $$$C[i]$$$. Different edges may have the same color.\nNote that in the definitions above, the case $$$i = 0$$$ does not correspond to an edge of the tree. For convenience, we let $$$P[0] = -1$$$ and $$$C[0] = 0$$$.\nFor example, suppose that Ős Vezér has $$$N = 18$$$ nodes and $$$M = 3$$$ possible edge colors, with $$$17$$$ edges described by connections $$$P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$$$ and colors $$$C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$$$. The tree is displayed in the following figure:\nÁrpád is a talented forester who likes to study specific parts of the tree called\nsubtrees\n. For each $$$r$$$ such that $$$0 \\le r < N$$$, the subtree of node $$$r$$$ is the set $$$T(r)$$$ of nodes with the following properties:\nNode $$$r$$$ belongs to $$$T(r)$$$.\nWhenever a node $$$x$$$ belongs to $$$T(r)$$$, all children of $$$x$$$ also belong to $$$T(r)$$$.\nNo other nodes belong to $$$T(r)$$$.\nThe size of the set $$$T(r)$$$ is denoted as $$$|T(r)|$$$.\nÁrpád recently discovered a complicated but interesting subtree property. Árpád's discovery involved a lot of playing with pen and paper, and he suspects you might need to do the same to understand it. He will also show you multiple examples you can then analyze in detail.\nSuppose we have a fixed $$$r$$$ and a permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ of the nodes in the subtree $$$T(r)$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, let $$$f(i)$$$ be the number of times the color $$$C[v_i]$$$ appears in the following sequence of $$$i-1$$$ colors: $$$C[v_1], C[v_2], \\ldots, C[v_{i-1}]$$$.\n(Note that $$$f(1)$$$ is always $$$0$$$ because the sequence of colors in its definition is empty.)\nThe permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ is a\nbeautiful permutation\nif and only if all the following properties hold:\n$$$v_0 = r$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, the parent of node $$$v_i$$$ is node $$$v_{f(i)}$$$.\nFor any $$$r$$$ such that $$$0 \\le r < N$$$, the subtree $$$T(r)$$$ is a\nbeautiful subtree\nif and only if there exists a beautiful permutation of the nodes in $$$T(r)$$$. Note that according to the definition every subtree which consists of a single node is beautiful.\nConsider the example tree above. It can be shown that the subtrees $$$T(0)$$$ and $$$T(3)$$$ of this tree are not beautiful. The subtree $$$T(14)$$$ is beautiful, as it consists of a single node. Below, we will show that the subtree $$$T(1)$$$ is also beautiful.\nConsider the sequence of distinct integers $$$[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$$$. This sequence is a permutation of the nodes in $$$T(1)$$$. The figure below depicts this permutation. The labels attached to the nodes are the indices at which those nodes appear in the permutation.\nWe will now verify that this is a\nbeautiful permutation\n.\n$$$v_0 = 1$$$.\n$$$f(1) = 0$$$ since $$$C[v_1] = C[4] = 1$$$ appears $$$0$$$ times in the sequence $$$[]$$$.\nCorrespondingly, the parent of $$$v_1$$$ is $$$v_0$$$. That is, the parent of node $$$4$$$ is node $$$1$$$. (Formally, $$$P[4] = 1$$$.)\n$$$f(2) = 0$$$ since $$$C[v_2] = C[5] = 2$$$ appears $$$0$$$ times in the sequence $$$[1]$$$.\nCorrespondingly, the parent of $$$v_2$$$ is $$$v_0$$$. That is, the parent of $$$5$$$ is $$$1$$$.\n$$$f(3) = 1$$$ since $$$C[v_3] = C[12] = 1$$$ appears $$$1$$$ time in the sequence $$$[1, 2]$$$.\nCorrespondingly, the parent of $$$v_3$$$ is $$$v_1$$$. That is, the parent of $$$12$$$ is $$$4$$$.\n$$$f(4) = 1$$$ since $$$C[v_4] = C[13] = 2$$$ appears $$$1$$$ time in the sequence $$$[1, 2, 1]$$$.\nCorrespondingly, the parent of $$$v_4$$$ is $$$v_1$$$. That is, the parent of $$$13$$$ is $$$4$$$.\n$$$f(5) = 0$$$ since $$$C[v_5] = C[6] = 3$$$ appears $$$0$$$ times in the sequence $$$[1, 2, 1, 2]$$$.\nCorrespondingly, the parent of $$$v_5$$$ is $$$v_0$$$. That is, the parent of $$$6$$$ is $$$1$$$.\n$$$f(6) = 2$$$ since $$$C[v_6] = C[14] = 2$$$ appears $$$2$$$ times in the sequence $$$[1, 2, 1, 2, 3]$$$.\nCorrespondingly, the parent of $$$v_6$$$ is $$$v_2$$$. That is, the parent of $$$14$$$ is $$$5$$$.\nAs we could find a\nbeautiful permutation\nof the nodes in $$$T(1)$$$, the subtree $$$T(1)$$$ is a\nbeautiful subtree\n.\nYour task is to help Árpád decide for every subtree of Ős Vezér whether it is beautiful.\nImplementation Details\nYou should implement the following procedure.\nint[] beechtree(int N, int M, int[] P, int[] C)\n$$$N$$$: the number of nodes in the tree.\n$$$M$$$: the number of possible edge colors.\n$$$P$$$, $$$C$$$: arrays of length $$$N$$$ describing the edges of the tree.\nThis procedure should return an array $$$b$$$ of length $$$N$$$. For each $$$r$$$ such that $$$0 \\le r < N$$$, $$$b[r]$$$ should be $$$1$$$ if $$$T(r)$$$ is beautiful, and $$$0$$$ otherwise.\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$3 \\le N \\le 200\\,000$$$, $$$2 \\le M \\le 200\\,000$$$)\nline $$$2$$$: $$$P[0] \\; P[1] \\; \\ldots \\; P[N-1]$$$ ($$$0 \\le P[i] < i$$$)\nline $$$3$$$: $$$C[0] \\; C[1] \\; \\ldots \\; C[N-1]$$$ ($$$1 \\le C[i] \\le M$$$)\n$$$P[0] = -1$$$ and $$$C[0] = 0$$$\nOutput\nLet $$$b[0], \\; b[1], \\; \\ldots$$$ denote the elements of the array returned by\nbeechtree\n. The sample grader prints your answer in a single line, in the following format:\nline $$$1$$$: $$$b[0] \\; b[1] \\; \\ldots$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$N \\le 8$$$ and $$$M \\le 500$$$\n2\n5\nEdge $$$i$$$ connects node $$$i$$$ to node $$$i-1$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, $$$P[i] = i-1$$$.\n3\n9\nEach node other than node $$$0$$$ is either connected to node $$$0$$$, or is connected to a node which is connected to node $$$0$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, either $$$P[i]=0$$$ or $$$P[P[i]]=0$$$.\n4\n8\nFor each $$$c$$$ such that $$$1 \\le c \\le M$$$, there are at most two edges of color $$$c$$$.\n5\n14\n$$$N \\le 200$$$ and $$$M \\le 500$$$\n6\n14\n$$$N \\le 2\\,000$$$ and $$$M = 2$$$\n7\n12\n$$$N \\le 2\\,000$$$\n8\n17\n$$$M = 2$$$\n9\n12\nNo additional constraints\nExamples\nNote\nExample 1\nConsider the following call:\nbeechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])\nThe tree is displayed in the following figure:\n$$$T(1)$$$, $$$T(2)$$$, and $$$T(3)$$$ each consist of a single node and are therefore beautiful. $$$T(0)$$$ is not beautiful. Therefore, the procedure should return $$$[0, 1, 1, 1]$$$.\nExample 2\nConsider the following call:\nbeechtree(18, 3, [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11], [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])\nThis example is illustrated in the task description above.\nThe procedure should return $$$[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$$$.\nExample 3\nConsider the following call:\nbeechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])\nThis example is illustrated in the following figure.\n$$$T(0)$$$ is the only subtree that is not beautiful. The procedure should return $$$[0, 1, 1, 1, 1, 1, 1]$$$."
    },
    "original": "Vétyem Woods is a famous woodland with lots of colorful trees. One of the oldest and tallest beech trees is called Ős Vezér.\nThe tree Ős Vezér can be modeled as a set of $$$N$$$\nnodes\nand $$$N-1$$$\nedges\n. Nodes are numbered from $$$0$$$ to $$$N-1$$$ and edges are numbered from $$$1$$$ to $$$N-1$$$. Each edge connects two distinct nodes of the tree. Specifically, edge $$$i$$$ ($$$1 \\le i < N$$$) connects node $$$i$$$ to node $$$P[i]$$$, where $$$0 \\le P[i] < i$$$. Node $$$P[i]$$$ is called the\nparent\nof node $$$i$$$, and node $$$i$$$ is called a\nchild\nof node $$$P[i]$$$.\nEach edge has a color. There are $$$M$$$ possible edge colors numbered from $$$1$$$ to $$$M$$$. The color of edge $$$i$$$ is $$$C[i]$$$. Different edges may have the same color.\nNote that in the definitions above, the case $$$i = 0$$$ does not correspond to an edge of the tree. For convenience, we let $$$P[0] = -1$$$ and $$$C[0] = 0$$$.\nFor example, suppose that Ős Vezér has $$$N = 18$$$ nodes and $$$M = 3$$$ possible edge colors, with $$$17$$$ edges described by connections $$$P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$$$ and colors $$$C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$$$. The tree is displayed in the following figure:\nÁrpád is a talented forester who likes to study specific parts of the tree called\nsubtrees\n. For each $$$r$$$ such that $$$0 \\le r < N$$$, the subtree of node $$$r$$$ is the set $$$T(r)$$$ of nodes with the following properties:\nNode $$$r$$$ belongs to $$$T(r)$$$.\nWhenever a node $$$x$$$ belongs to $$$T(r)$$$, all children of $$$x$$$ also belong to $$$T(r)$$$.\nNo other nodes belong to $$$T(r)$$$.\nThe size of the set $$$T(r)$$$ is denoted as $$$|T(r)|$$$.\nÁrpád recently discovered a complicated but interesting subtree property. Árpád's discovery involved a lot of playing with pen and paper, and he suspects you might need to do the same to understand it. He will also show you multiple examples you can then analyze in detail.\nSuppose we have a fixed $$$r$$$ and a permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ of the nodes in the subtree $$$T(r)$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, let $$$f(i)$$$ be the number of times the color $$$C[v_i]$$$ appears in the following sequence of $$$i-1$$$ colors: $$$C[v_1], C[v_2], \\ldots, C[v_{i-1}]$$$.\n(Note that $$$f(1)$$$ is always $$$0$$$ because the sequence of colors in its definition is empty.)\nThe permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ is a\nbeautiful permutation\nif and only if all the following properties hold:\n$$$v_0 = r$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, the parent of node $$$v_i$$$ is node $$$v_{f(i)}$$$.\nFor any $$$r$$$ such that $$$0 \\le r < N$$$, the subtree $$$T(r)$$$ is a\nbeautiful subtree\nif and only if there exists a beautiful permutation of the nodes in $$$T(r)$$$. Note that according to the definition every subtree which consists of a single node is beautiful.\nConsider the example tree above. It can be shown that the subtrees $$$T(0)$$$ and $$$T(3)$$$ of this tree are not beautiful. The subtree $$$T(14)$$$ is beautiful, as it consists of a single node. Below, we will show that the subtree $$$T(1)$$$ is also beautiful.\nConsider the sequence of distinct integers $$$[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$$$. This sequence is a permutation of the nodes in $$$T(1)$$$. The figure below depicts this permutation. The labels attached to the nodes are the indices at which those nodes appear in the permutation.\nWe will now verify that this is a\nbeautiful permutation\n.\n$$$v_0 = 1$$$.\n$$$f(1) = 0$$$ since $$$C[v_1] = C[4] = 1$$$ appears $$$0$$$ times in the sequence $$$[]$$$.\nCorrespondingly, the parent of $$$v_1$$$ is $$$v_0$$$. That is, the parent of node $$$4$$$ is node $$$1$$$. (Formally, $$$P[4] = 1$$$.)\n$$$f(2) = 0$$$ since $$$C[v_2] = C[5] = 2$$$ appears $$$0$$$ times in the sequence $$$[1]$$$.\nCorrespondingly, the parent of $$$v_2$$$ is $$$v_0$$$. That is, the parent of $$$5$$$ is $$$1$$$.\n$$$f(3) = 1$$$ since $$$C[v_3] = C[12] = 1$$$ appears $$$1$$$ time in the sequence $$$[1, 2]$$$.\nCorrespondingly, the parent of $$$v_3$$$ is $$$v_1$$$. That is, the parent of $$$12$$$ is $$$4$$$.\n$$$f(4) = 1$$$ since $$$C[v_4] = C[13] = 2$$$ appears $$$1$$$ time in the sequence $$$[1, 2, 1]$$$.\nCorrespondingly, the parent of $$$v_4$$$ is $$$v_1$$$. That is, the parent of $$$13$$$ is $$$4$$$.\n$$$f(5) = 0$$$ since $$$C[v_5] = C[6] = 3$$$ appears $$$0$$$ times in the sequence $$$[1, 2, 1, 2]$$$.\nCorrespondingly, the parent of $$$v_5$$$ is $$$v_0$$$. That is, the parent of $$$6$$$ is $$$1$$$.\n$$$f(6) = 2$$$ since $$$C[v_6] = C[14] = 2$$$ appears $$$2$$$ times in the sequence $$$[1, 2, 1, 2, 3]$$$.\nCorrespondingly, the parent of $$$v_6$$$ is $$$v_2$$$. That is, the parent of $$$14$$$ is $$$5$$$.\nAs we could find a\nbeautiful permutation\nof the nodes in $$$T(1)$$$, the subtree $$$T(1)$$$ is a\nbeautiful subtree\n.\nYour task is to help Árpád decide for every subtree of Ős Vezér whether it is beautiful.\nImplementation Details\nYou should implement the following procedure.\nint[] beechtree(int N, int M, int[] P, int[] C)\n$$$N$$$: the number of nodes in the tree.\n$$$M$$$: the number of possible edge colors.\n$$$P$$$, $$$C$$$: arrays of length $$$N$$$ describing the edges of the tree.\nThis procedure should return an array $$$b$$$ of length $$$N$$$. For each $$$r$$$ such that $$$0 \\le r < N$$$, $$$b[r]$$$ should be $$$1$$$ if $$$T(r)$$$ is beautiful, and $$$0$$$ otherwise.\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$3 \\le N \\le 200\\,000$$$, $$$2 \\le M \\le 200\\,000$$$)\nline $$$2$$$: $$$P[0] \\; P[1] \\; \\ldots \\; P[N-1]$$$ ($$$0 \\le P[i] < i$$$)\nline $$$3$$$: $$$C[0] \\; C[1] \\; \\ldots \\; C[N-1]$$$ ($$$1 \\le C[i] \\le M$$$)\n$$$P[0] = -1$$$ and $$$C[0] = 0$$$\nOutput\nLet $$$b[0], \\; b[1], \\; \\ldots$$$ denote the elements of the array returned by\nbeechtree\n. The sample grader prints your answer in a single line, in the following format:\nline $$$1$$$: $$$b[0] \\; b[1] \\; \\ldots$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$N \\le 8$$$ and $$$M \\le 500$$$\n2\n5\nEdge $$$i$$$ connects node $$$i$$$ to node $$$i-1$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, $$$P[i] = i-1$$$.\n3\n9\nEach node other than node $$$0$$$ is either connected to node $$$0$$$, or is connected to a node which is connected to node $$$0$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, either $$$P[i]=0$$$ or $$$P[P[i]]=0$$$.\n4\n8\nFor each $$$c$$$ such that $$$1 \\le c \\le M$$$, there are at most two edges of color $$$c$$$.\n5\n14\n$$$N \\le 200$$$ and $$$M \\le 500$$$\n6\n14\n$$$N \\le 2\\,000$$$ and $$$M = 2$$$\n7\n12\n$$$N \\le 2\\,000$$$\n8\n17\n$$$M = 2$$$\n9\n12\nNo additional constraints\nExamples\nNote\nExample 1\nConsider the following call:\nbeechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])\nThe tree is displayed in the following figure:\n$$$T(1)$$$, $$$T(2)$$$, and $$$T(3)$$$ each consist of a single node and are therefore beautiful. $$$T(0)$$$ is not beautiful. Therefore, the procedure should return $$$[0, 1, 1, 1]$$$.\nExample 2\nConsider the following call:\nbeechtree(18, 3, [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11], [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])\nThis example is illustrated in the task description above.\nThe procedure should return $$$[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$$$.\nExample 3\nConsider the following call:\nbeechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])\nThis example is illustrated in the following figure.\n$$$T(0)$$$ is the only subtree that is not beautiful. The procedure should return $$$[0, 1, 1, 1, 1, 1, 1]$$$.",
    "_meta": {
      "index": 91,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/D",
      "uuid": "ps_b15b9c7bf5bfd790e77fc89a2e2cea92b564ddea"
    }
  },
  {
    "planning_view": {
      "title": "D. Beech Tree",
      "task": "Determine which subtrees have beautiful permutations matching parent-child constraints",
      "given": [
        "Tree with N nodes numbered 0 to N-1",
        "Edge from node i to P[i] with color C[i] (P[0]=-1, C[0]=0)",
        "Each subtree T(r) rooted at r"
      ],
      "goal": "For each subtree T(r), determine if it has a beautiful permutation",
      "key_rules": [
        "v₀ must be the root r",
        "Parent of vᵢ must be exactly v₍ƒ₍ᵢ₎₎ where ƒ(i) counts previous occurrences of C[vᵢ]",
        "Single-node subtrees are always beautiful"
      ],
      "target": {
        "1": {
          "points": 9,
          "req": "N ≤ 8, M ≤ 500"
        },
        "2": {
          "points": 5,
          "req": "Linear tree (chain)"
        },
        "3": {
          "points": 9,
          "req": "Depth ≤ 2 from root"
        },
        "4": {
          "points": 8,
          "req": "At most 2 edges per color"
        },
        "5": {
          "points": 14,
          "req": "N ≤ 200, M ≤ 500"
        },
        "6": {
          "points": 14,
          "req": "N ≤ 2000, M = 2"
        },
        "7": {
          "points": 12,
          "req": "N ≤ 2000"
        },
        "8": {
          "points": 17,
          "req": "M = 2"
        },
        "9": {
          "points": 12,
          "req": "No constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "D. Beech Tree",
      "contest": "IOI 2023 day 2",
      "one_line": "Determine which subtrees have beautiful permutations matching parent-child constraints",
      "given": [
        "Tree with N nodes numbered 0 to N-1",
        "Edge from node i to P[i] with color C[i] (P[0]=-1, C[0]=0)",
        "Each subtree T(r) rooted at r"
      ],
      "goal": "For each subtree T(r), determine if it has a beautiful permutation",
      "mechanism": "A permutation is beautiful if v₀=r and parent of vᵢ = v₍ƒ₍ᵢ₎₎ where ƒ(i) counts how many times C[vᵢ] appeared earlier",
      "success_condition": "Subtree is beautiful if such permutation exists",
      "constraints": {
        "critical": [
          "v₀ must be the root r",
          "Parent of vᵢ must be exactly v₍ƒ₍ᵢ₎₎ where ƒ(i) counts previous occurrences of C[vᵢ]",
          "Single-node subtrees are always beautiful"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N ≤ 8, M ≤ 500"
          },
          "2": {
            "points": 5,
            "req": "Linear tree (chain)"
          },
          "3": {
            "points": 9,
            "req": "Depth ≤ 2 from root"
          },
          "4": {
            "points": 8,
            "req": "At most 2 edges per color"
          },
          "5": {
            "points": 14,
            "req": "N ≤ 200, M ≤ 500"
          },
          "6": {
            "points": 14,
            "req": "N ≤ 2000, M = 2"
          },
          "7": {
            "points": 12,
            "req": "N ≤ 2000"
          },
          "8": {
            "points": 17,
            "req": "M = 2"
          },
          "9": {
            "points": 12,
            "req": "No constraints"
          }
        }
      },
      "limits": {
        "time": "1.5 seconds",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "D. Beech Tree",
        "contest": "IOI 2023 day 2",
        "one_line": "Determine which subtrees have beautiful permutations matching parent-child constraints"
      },
      "problem": {
        "given": [
          "Tree with N nodes numbered 0 to N-1",
          "Edge from node i to P[i] with color C[i] (P[0]=-1, C[0]=0)",
          "Each subtree T(r) rooted at r"
        ],
        "goal": "For each subtree T(r), determine if it has a beautiful permutation",
        "mechanism": "A permutation is beautiful if v₀=r and parent of vᵢ = v₍ƒ₍ᵢ₎₎ where ƒ(i) counts how many times C[vᵢ] appeared earlier",
        "success_condition": "Subtree is beautiful if such permutation exists"
      },
      "constraints": {
        "critical": [
          "v₀ must be the root r",
          "Parent of vᵢ must be exactly v₍ƒ₍ᵢ₎₎ where ƒ(i) counts previous occurrences of C[vᵢ]",
          "Single-node subtrees are always beautiful"
        ],
        "subtasks": {
          "1": {
            "points": 9,
            "req": "N ≤ 8, M ≤ 500"
          },
          "2": {
            "points": 5,
            "req": "Linear tree (chain)"
          },
          "3": {
            "points": 9,
            "req": "Depth ≤ 2 from root"
          },
          "4": {
            "points": 8,
            "req": "At most 2 edges per color"
          },
          "5": {
            "points": 14,
            "req": "N ≤ 200, M ≤ 500"
          },
          "6": {
            "points": 14,
            "req": "N ≤ 2000, M = 2"
          },
          "7": {
            "points": 12,
            "req": "N ≤ 2000"
          },
          "8": {
            "points": 17,
            "req": "M = 2"
          },
          "9": {
            "points": 12,
            "req": "No constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "int[] beechtree(int N, int M, int[] P, int[] C)",
        "available_api": {},
        "requirements": [
          "Return array b of length N with b[r]=1 if T(r) beautiful, else 0",
          "P[0] = -1, C[0] = 0",
          "Edges: for 1 ≤ i < N, edge i connects i to P[i] with color C[i]"
        ]
      },
      "limits": {
        "time": "1.5 seconds",
        "memory": "1024 megabytes"
      },
      "samples": [
        {
          "input": "4 2\n-1 0 0 0\n0 1 1 2",
          "output": "0 1 1 1"
        }
      ],
      "original_statement": "Vétyem Woods is a famous woodland with lots of colorful trees. One of the oldest and tallest beech trees is called Ős Vezér.\nThe tree Ős Vezér can be modeled as a set of $$$N$$$\nnodes\nand $$$N-1$$$\nedges\n. Nodes are numbered from $$$0$$$ to $$$N-1$$$ and edges are numbered from $$$1$$$ to $$$N-1$$$. Each edge connects two distinct nodes of the tree. Specifically, edge $$$i$$$ ($$$1 \\le i < N$$$) connects node $$$i$$$ to node $$$P[i]$$$, where $$$0 \\le P[i] < i$$$. Node $$$P[i]$$$ is called the\nparent\nof node $$$i$$$, and node $$$i$$$ is called a\nchild\nof node $$$P[i]$$$.\nEach edge has a color. There are $$$M$$$ possible edge colors numbered from $$$1$$$ to $$$M$$$. The color of edge $$$i$$$ is $$$C[i]$$$. Different edges may have the same color.\nNote that in the definitions above, the case $$$i = 0$$$ does not correspond to an edge of the tree. For convenience, we let $$$P[0] = -1$$$ and $$$C[0] = 0$$$.\nFor example, suppose that Ős Vezér has $$$N = 18$$$ nodes and $$$M = 3$$$ possible edge colors, with $$$17$$$ edges described by connections $$$P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$$$ and colors $$$C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$$$. The tree is displayed in the following figure:\nÁrpád is a talented forester who likes to study specific parts of the tree called\nsubtrees\n. For each $$$r$$$ such that $$$0 \\le r < N$$$, the subtree of node $$$r$$$ is the set $$$T(r)$$$ of nodes with the following properties:\nNode $$$r$$$ belongs to $$$T(r)$$$.\nWhenever a node $$$x$$$ belongs to $$$T(r)$$$, all children of $$$x$$$ also belong to $$$T(r)$$$.\nNo other nodes belong to $$$T(r)$$$.\nThe size of the set $$$T(r)$$$ is denoted as $$$|T(r)|$$$.\nÁrpád recently discovered a complicated but interesting subtree property. Árpád's discovery involved a lot of playing with pen and paper, and he suspects you might need to do the same to understand it. He will also show you multiple examples you can then analyze in detail.\nSuppose we have a fixed $$$r$$$ and a permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ of the nodes in the subtree $$$T(r)$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, let $$$f(i)$$$ be the number of times the color $$$C[v_i]$$$ appears in the following sequence of $$$i-1$$$ colors: $$$C[v_1], C[v_2], \\ldots, C[v_{i-1}]$$$.\n(Note that $$$f(1)$$$ is always $$$0$$$ because the sequence of colors in its definition is empty.)\nThe permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ is a\nbeautiful permutation\nif and only if all the following properties hold:\n$$$v_0 = r$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, the parent of node $$$v_i$$$ is node $$$v_{f(i)}$$$.\nFor any $$$r$$$ such that $$$0 \\le r < N$$$, the subtree $$$T(r)$$$ is a\nbeautiful subtree\nif and only if there exists a beautiful permutation of the nodes in $$$T(r)$$$. Note that according to the definition every subtree which consists of a single node is beautiful.\nConsider the example tree above. It can be shown that the subtrees $$$T(0)$$$ and $$$T(3)$$$ of this tree are not beautiful. The subtree $$$T(14)$$$ is beautiful, as it consists of a single node. Below, we will show that the subtree $$$T(1)$$$ is also beautiful.\nConsider the sequence of distinct integers $$$[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$$$. This sequence is a permutation of the nodes in $$$T(1)$$$. The figure below depicts this permutation. The labels attached to the nodes are the indices at which those nodes appear in the permutation.\nWe will now verify that this is a\nbeautiful permutation\n.\n$$$v_0 = 1$$$.\n$$$f(1) = 0$$$ since $$$C[v_1] = C[4] = 1$$$ appears $$$0$$$ times in the sequence $$$[]$$$.\nCorrespondingly, the parent of $$$v_1$$$ is $$$v_0$$$. That is, the parent of node $$$4$$$ is node $$$1$$$. (Formally, $$$P[4] = 1$$$.)\n$$$f(2) = 0$$$ since $$$C[v_2] = C[5] = 2$$$ appears $$$0$$$ times in the sequence $$$[1]$$$.\nCorrespondingly, the parent of $$$v_2$$$ is $$$v_0$$$. That is, the parent of $$$5$$$ is $$$1$$$.\n$$$f(3) = 1$$$ since $$$C[v_3] = C[12] = 1$$$ appears $$$1$$$ time in the sequence $$$[1, 2]$$$.\nCorrespondingly, the parent of $$$v_3$$$ is $$$v_1$$$. That is, the parent of $$$12$$$ is $$$4$$$.\n$$$f(4) = 1$$$ since $$$C[v_4] = C[13] = 2$$$ appears $$$1$$$ time in the sequence $$$[1, 2, 1]$$$.\nCorrespondingly, the parent of $$$v_4$$$ is $$$v_1$$$. That is, the parent of $$$13$$$ is $$$4$$$.\n$$$f(5) = 0$$$ since $$$C[v_5] = C[6] = 3$$$ appears $$$0$$$ times in the sequence $$$[1, 2, 1, 2]$$$.\nCorrespondingly, the parent of $$$v_5$$$ is $$$v_0$$$. That is, the parent of $$$6$$$ is $$$1$$$.\n$$$f(6) = 2$$$ since $$$C[v_6] = C[14] = 2$$$ appears $$$2$$$ times in the sequence $$$[1, 2, 1, 2, 3]$$$.\nCorrespondingly, the parent of $$$v_6$$$ is $$$v_2$$$. That is, the parent of $$$14$$$ is $$$5$$$.\nAs we could find a\nbeautiful permutation\nof the nodes in $$$T(1)$$$, the subtree $$$T(1)$$$ is a\nbeautiful subtree\n.\nYour task is to help Árpád decide for every subtree of Ős Vezér whether it is beautiful.\nImplementation Details\nYou should implement the following procedure.\nint[] beechtree(int N, int M, int[] P, int[] C)\n$$$N$$$: the number of nodes in the tree.\n$$$M$$$: the number of possible edge colors.\n$$$P$$$, $$$C$$$: arrays of length $$$N$$$ describing the edges of the tree.\nThis procedure should return an array $$$b$$$ of length $$$N$$$. For each $$$r$$$ such that $$$0 \\le r < N$$$, $$$b[r]$$$ should be $$$1$$$ if $$$T(r)$$$ is beautiful, and $$$0$$$ otherwise.\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$3 \\le N \\le 200\\,000$$$, $$$2 \\le M \\le 200\\,000$$$)\nline $$$2$$$: $$$P[0] \\; P[1] \\; \\ldots \\; P[N-1]$$$ ($$$0 \\le P[i] < i$$$)\nline $$$3$$$: $$$C[0] \\; C[1] \\; \\ldots \\; C[N-1]$$$ ($$$1 \\le C[i] \\le M$$$)\n$$$P[0] = -1$$$ and $$$C[0] = 0$$$\nOutput\nLet $$$b[0], \\; b[1], \\; \\ldots$$$ denote the elements of the array returned by\nbeechtree\n. The sample grader prints your answer in a single line, in the following format:\nline $$$1$$$: $$$b[0] \\; b[1] \\; \\ldots$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$N \\le 8$$$ and $$$M \\le 500$$$\n2\n5\nEdge $$$i$$$ connects node $$$i$$$ to node $$$i-1$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, $$$P[i] = i-1$$$.\n3\n9\nEach node other than node $$$0$$$ is either connected to node $$$0$$$, or is connected to a node which is connected to node $$$0$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, either $$$P[i]=0$$$ or $$$P[P[i]]=0$$$.\n4\n8\nFor each $$$c$$$ such that $$$1 \\le c \\le M$$$, there are at most two edges of color $$$c$$$.\n5\n14\n$$$N \\le 200$$$ and $$$M \\le 500$$$\n6\n14\n$$$N \\le 2\\,000$$$ and $$$M = 2$$$\n7\n12\n$$$N \\le 2\\,000$$$\n8\n17\n$$$M = 2$$$\n9\n12\nNo additional constraints\nExamples\nNote\nExample 1\nConsider the following call:\nbeechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])\nThe tree is displayed in the following figure:\n$$$T(1)$$$, $$$T(2)$$$, and $$$T(3)$$$ each consist of a single node and are therefore beautiful. $$$T(0)$$$ is not beautiful. Therefore, the procedure should return $$$[0, 1, 1, 1]$$$.\nExample 2\nConsider the following call:\nbeechtree(18, 3, [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11], [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])\nThis example is illustrated in the task description above.\nThe procedure should return $$$[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$$$.\nExample 3\nConsider the following call:\nbeechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])\nThis example is illustrated in the following figure.\n$$$T(0)$$$ is the only subtree that is not beautiful. The procedure should return $$$[0, 1, 1, 1, 1, 1, 1]$$$."
    },
    "original": "Vétyem Woods is a famous woodland with lots of colorful trees. One of the oldest and tallest beech trees is called Ős Vezér.\nThe tree Ős Vezér can be modeled as a set of $$$N$$$\nnodes\nand $$$N-1$$$\nedges\n. Nodes are numbered from $$$0$$$ to $$$N-1$$$ and edges are numbered from $$$1$$$ to $$$N-1$$$. Each edge connects two distinct nodes of the tree. Specifically, edge $$$i$$$ ($$$1 \\le i < N$$$) connects node $$$i$$$ to node $$$P[i]$$$, where $$$0 \\le P[i] < i$$$. Node $$$P[i]$$$ is called the\nparent\nof node $$$i$$$, and node $$$i$$$ is called a\nchild\nof node $$$P[i]$$$.\nEach edge has a color. There are $$$M$$$ possible edge colors numbered from $$$1$$$ to $$$M$$$. The color of edge $$$i$$$ is $$$C[i]$$$. Different edges may have the same color.\nNote that in the definitions above, the case $$$i = 0$$$ does not correspond to an edge of the tree. For convenience, we let $$$P[0] = -1$$$ and $$$C[0] = 0$$$.\nFor example, suppose that Ős Vezér has $$$N = 18$$$ nodes and $$$M = 3$$$ possible edge colors, with $$$17$$$ edges described by connections $$$P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$$$ and colors $$$C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$$$. The tree is displayed in the following figure:\nÁrpád is a talented forester who likes to study specific parts of the tree called\nsubtrees\n. For each $$$r$$$ such that $$$0 \\le r < N$$$, the subtree of node $$$r$$$ is the set $$$T(r)$$$ of nodes with the following properties:\nNode $$$r$$$ belongs to $$$T(r)$$$.\nWhenever a node $$$x$$$ belongs to $$$T(r)$$$, all children of $$$x$$$ also belong to $$$T(r)$$$.\nNo other nodes belong to $$$T(r)$$$.\nThe size of the set $$$T(r)$$$ is denoted as $$$|T(r)|$$$.\nÁrpád recently discovered a complicated but interesting subtree property. Árpád's discovery involved a lot of playing with pen and paper, and he suspects you might need to do the same to understand it. He will also show you multiple examples you can then analyze in detail.\nSuppose we have a fixed $$$r$$$ and a permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ of the nodes in the subtree $$$T(r)$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, let $$$f(i)$$$ be the number of times the color $$$C[v_i]$$$ appears in the following sequence of $$$i-1$$$ colors: $$$C[v_1], C[v_2], \\ldots, C[v_{i-1}]$$$.\n(Note that $$$f(1)$$$ is always $$$0$$$ because the sequence of colors in its definition is empty.)\nThe permutation $$$v_0, v_1, \\ldots, v_{|T(r)|-1}$$$ is a\nbeautiful permutation\nif and only if all the following properties hold:\n$$$v_0 = r$$$.\nFor each $$$i$$$ such that $$$1 \\le i < |T(r)|$$$, the parent of node $$$v_i$$$ is node $$$v_{f(i)}$$$.\nFor any $$$r$$$ such that $$$0 \\le r < N$$$, the subtree $$$T(r)$$$ is a\nbeautiful subtree\nif and only if there exists a beautiful permutation of the nodes in $$$T(r)$$$. Note that according to the definition every subtree which consists of a single node is beautiful.\nConsider the example tree above. It can be shown that the subtrees $$$T(0)$$$ and $$$T(3)$$$ of this tree are not beautiful. The subtree $$$T(14)$$$ is beautiful, as it consists of a single node. Below, we will show that the subtree $$$T(1)$$$ is also beautiful.\nConsider the sequence of distinct integers $$$[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$$$. This sequence is a permutation of the nodes in $$$T(1)$$$. The figure below depicts this permutation. The labels attached to the nodes are the indices at which those nodes appear in the permutation.\nWe will now verify that this is a\nbeautiful permutation\n.\n$$$v_0 = 1$$$.\n$$$f(1) = 0$$$ since $$$C[v_1] = C[4] = 1$$$ appears $$$0$$$ times in the sequence $$$[]$$$.\nCorrespondingly, the parent of $$$v_1$$$ is $$$v_0$$$. That is, the parent of node $$$4$$$ is node $$$1$$$. (Formally, $$$P[4] = 1$$$.)\n$$$f(2) = 0$$$ since $$$C[v_2] = C[5] = 2$$$ appears $$$0$$$ times in the sequence $$$[1]$$$.\nCorrespondingly, the parent of $$$v_2$$$ is $$$v_0$$$. That is, the parent of $$$5$$$ is $$$1$$$.\n$$$f(3) = 1$$$ since $$$C[v_3] = C[12] = 1$$$ appears $$$1$$$ time in the sequence $$$[1, 2]$$$.\nCorrespondingly, the parent of $$$v_3$$$ is $$$v_1$$$. That is, the parent of $$$12$$$ is $$$4$$$.\n$$$f(4) = 1$$$ since $$$C[v_4] = C[13] = 2$$$ appears $$$1$$$ time in the sequence $$$[1, 2, 1]$$$.\nCorrespondingly, the parent of $$$v_4$$$ is $$$v_1$$$. That is, the parent of $$$13$$$ is $$$4$$$.\n$$$f(5) = 0$$$ since $$$C[v_5] = C[6] = 3$$$ appears $$$0$$$ times in the sequence $$$[1, 2, 1, 2]$$$.\nCorrespondingly, the parent of $$$v_5$$$ is $$$v_0$$$. That is, the parent of $$$6$$$ is $$$1$$$.\n$$$f(6) = 2$$$ since $$$C[v_6] = C[14] = 2$$$ appears $$$2$$$ times in the sequence $$$[1, 2, 1, 2, 3]$$$.\nCorrespondingly, the parent of $$$v_6$$$ is $$$v_2$$$. That is, the parent of $$$14$$$ is $$$5$$$.\nAs we could find a\nbeautiful permutation\nof the nodes in $$$T(1)$$$, the subtree $$$T(1)$$$ is a\nbeautiful subtree\n.\nYour task is to help Árpád decide for every subtree of Ős Vezér whether it is beautiful.\nImplementation Details\nYou should implement the following procedure.\nint[] beechtree(int N, int M, int[] P, int[] C)\n$$$N$$$: the number of nodes in the tree.\n$$$M$$$: the number of possible edge colors.\n$$$P$$$, $$$C$$$: arrays of length $$$N$$$ describing the edges of the tree.\nThis procedure should return an array $$$b$$$ of length $$$N$$$. For each $$$r$$$ such that $$$0 \\le r < N$$$, $$$b[r]$$$ should be $$$1$$$ if $$$T(r)$$$ is beautiful, and $$$0$$$ otherwise.\nThis procedure is called exactly once for each test case.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$N \\; M$$$ ($$$3 \\le N \\le 200\\,000$$$, $$$2 \\le M \\le 200\\,000$$$)\nline $$$2$$$: $$$P[0] \\; P[1] \\; \\ldots \\; P[N-1]$$$ ($$$0 \\le P[i] < i$$$)\nline $$$3$$$: $$$C[0] \\; C[1] \\; \\ldots \\; C[N-1]$$$ ($$$1 \\le C[i] \\le M$$$)\n$$$P[0] = -1$$$ and $$$C[0] = 0$$$\nOutput\nLet $$$b[0], \\; b[1], \\; \\ldots$$$ denote the elements of the array returned by\nbeechtree\n. The sample grader prints your answer in a single line, in the following format:\nline $$$1$$$: $$$b[0] \\; b[1] \\; \\ldots$$$\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n9\n$$$N \\le 8$$$ and $$$M \\le 500$$$\n2\n5\nEdge $$$i$$$ connects node $$$i$$$ to node $$$i-1$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, $$$P[i] = i-1$$$.\n3\n9\nEach node other than node $$$0$$$ is either connected to node $$$0$$$, or is connected to a node which is connected to node $$$0$$$. That is, for each $$$i$$$ such that $$$1 \\le i < N$$$, either $$$P[i]=0$$$ or $$$P[P[i]]=0$$$.\n4\n8\nFor each $$$c$$$ such that $$$1 \\le c \\le M$$$, there are at most two edges of color $$$c$$$.\n5\n14\n$$$N \\le 200$$$ and $$$M \\le 500$$$\n6\n14\n$$$N \\le 2\\,000$$$ and $$$M = 2$$$\n7\n12\n$$$N \\le 2\\,000$$$\n8\n17\n$$$M = 2$$$\n9\n12\nNo additional constraints\nExamples\nNote\nExample 1\nConsider the following call:\nbeechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])\nThe tree is displayed in the following figure:\n$$$T(1)$$$, $$$T(2)$$$, and $$$T(3)$$$ each consist of a single node and are therefore beautiful. $$$T(0)$$$ is not beautiful. Therefore, the procedure should return $$$[0, 1, 1, 1]$$$.\nExample 2\nConsider the following call:\nbeechtree(18, 3, [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11], [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])\nThis example is illustrated in the task description above.\nThe procedure should return $$$[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$$$.\nExample 3\nConsider the following call:\nbeechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])\nThis example is illustrated in the following figure.\n$$$T(0)$$$ is the only subtree that is not beautiful. The procedure should return $$$[0, 1, 1, 1, 1, 1, 1]$$$.",
    "_meta": {
      "index": 91,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/D",
      "uuid": "ps_b15b9c7bf5bfd790e77fc89a2e2cea92b564ddea"
    }
  },
  {
    "planning_view": {
      "title": "F. Robot Contest",
      "task": "Program Pulibot to mark shortest paths in unknown mazes using ≤19 colors in ≤500k steps",
      "given": [
        "(H+2)×(W+2) grid with boundary cells (r=-1/H, c=-1/W)",
        "Empty cells have colors (0-Z_MAX), obstacle cells block movement",
        "At least one path exists from (0,0) to (H-1,W-1)"
      ],
      "goal": "Color empty cells so one shortest path is marked with 1s, all others 0s",
      "key_rules": [
        "Z_MAX = 19 (colors 0-19)",
        "Maximum 500,000 steps per execution",
        "Cannot move to non-empty cells (obstacles/boundaries)",
        "Must set instruction for every encountered state array"
      ],
      "target": {
        "1": {
          "points": 6,
          "req": "No obstacles in maze"
        },
        "2": {
          "points": 10,
          "req": "H = 2"
        },
        "3": {
          "points": 18,
          "req": "Exactly one path between any two empty cells"
        },
        "4": {
          "points": 20,
          "req": "All shortest paths have length H+W-2"
        },
        "5": {
          "points": 46,
          "req": "No additional constraints"
        }
      }
    },
    "algorithm_view": {
      "title": "F. Robot Contest",
      "contest": "IOI 2023 day 2",
      "one_line": "Program Pulibot to mark shortest paths in unknown mazes using ≤19 colors in ≤500k steps",
      "given": [
        "(H+2)×(W+2) grid with boundary cells (r=-1/H, c=-1/W)",
        "Empty cells have colors (0-Z_MAX), obstacle cells block movement",
        "At least one path exists from (0,0) to (H-1,W-1)"
      ],
      "goal": "Color empty cells so one shortest path is marked with 1s, all others 0s",
      "mechanism": "Pulibot moves through maze, recognizes 5-cell state array (current + 4 directions), executes color-setting + movement instructions",
      "success_condition": "After termination, exactly one shortest path is marked with 1s, all other cells are 0",
      "constraints": {
        "critical": [
          "Z_MAX = 19 (colors 0-19)",
          "Maximum 500,000 steps per execution",
          "Cannot move to non-empty cells (obstacles/boundaries)",
          "Must set instruction for every encountered state array"
        ],
        "subtasks": {
          "1": {
            "points": 6,
            "req": "No obstacles in maze"
          },
          "2": {
            "points": 10,
            "req": "H = 2"
          },
          "3": {
            "points": 18,
            "req": "Exactly one path between any two empty cells"
          },
          "4": {
            "points": 20,
            "req": "All shortest paths have length H+W-2"
          },
          "5": {
            "points": 46,
            "req": "No additional constraints"
          }
        }
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      }
    },
    "implementation_view": {
      "core": {
        "title": "F. Robot Contest",
        "contest": "IOI 2023 day 2",
        "one_line": "Program Pulibot to mark shortest paths in unknown mazes using ≤19 colors in ≤500k steps"
      },
      "problem": {
        "given": [
          "(H+2)×(W+2) grid with boundary cells (r=-1/H, c=-1/W)",
          "Empty cells have colors (0-Z_MAX), obstacle cells block movement",
          "At least one path exists from (0,0) to (H-1,W-1)"
        ],
        "goal": "Color empty cells so one shortest path is marked with 1s, all others 0s",
        "mechanism": "Pulibot moves through maze, recognizes 5-cell state array (current + 4 directions), executes color-setting + movement instructions",
        "success_condition": "After termination, exactly one shortest path is marked with 1s, all other cells are 0"
      },
      "constraints": {
        "critical": [
          "Z_MAX = 19 (colors 0-19)",
          "Maximum 500,000 steps per execution",
          "Cannot move to non-empty cells (obstacles/boundaries)",
          "Must set instruction for every encountered state array"
        ],
        "subtasks": {
          "1": {
            "points": 6,
            "req": "No obstacles in maze"
          },
          "2": {
            "points": 10,
            "req": "H = 2"
          },
          "3": {
            "points": 18,
            "req": "Exactly one path between any two empty cells"
          },
          "4": {
            "points": 20,
            "req": "All shortest paths have length H+W-2"
          },
          "5": {
            "points": 46,
            "req": "No additional constraints"
          }
        }
      },
      "implementation": {
        "function_to_write": "void program_pulibot()",
        "available_api": {
          "set_instruction": {
            "signature": "void set_instruction(int[] S, int Z, char A)",
            "params": "S: length-5 array [current, west, south, east, north states], Z: color (0-19), A: action",
            "returns": "None",
            "side_effect": "Defines instruction for state array S"
          }
        },
        "requirements": [
          "Must call set_instruction for every state array Pulibot might encounter",
          "Actions: H(stay), W(west), S(south), E(east), N(north), T(terminate)",
          "States: -2(boundary), -1(obstacle), 0-19(color)",
          "Grid coordinates: (-1 to H) × (-1 to W)"
        ]
      },
      "limits": {
        "time": "1 second",
        "memory": "1024 megabytes"
      },
      "samples": [],
      "original_statement": "AI researchers at the University of Szeged are holding a robot programming contest. Your friend, Hanga, has decided to take part in the contest. The objective is to program the ultimate\nPulibot\n, admiring the great intelligence of the famous Hungarian herding dog breed, the Puli.\nPulibot will be tested on a maze consisting of a $$$(H+2) \\times (W+2)$$$ grid of cells. The rows of the grid are numbered from $$$-1$$$ to $$$H$$$ from north to south and the columns of the grid are numbered from $$$-1$$$ to $$$W$$$ from west to east. We refer to the cell located at row $$$r$$$ and column $$$c$$$ of the grid ($$$-1 \\le r \\le H$$$, $$$-1 \\le c \\le W$$$) as cell $$$(r, c)$$$.\nConsider a cell $$$(r,c)$$$ such that $$$0 \\le r < H$$$ and $$$0 \\le c < W$$$. There are $$$4$$$ cells\nadjacent\nto cell $$$(r,c)$$$:\ncell $$$(r,c-1)$$$ is referred to as the cell\nwest\nof cell $$$(r,c)$$$;\ncell $$$(r+1,c)$$$ is referred to as the cell\nsouth\nof cell $$$(r,c)$$$;\ncell $$$(r,c+1)$$$ is referred to as the cell\neast\nof cell $$$(r,c)$$$;\ncell $$$(r-1,c)$$$ is referred to as the cell\nnorth\nof cell $$$(r,c)$$$.\nCell $$$(r,c)$$$ is called a\nboundary\ncell of the maze if $$$r=-1$$$ or $$$r=H$$$ or $$$c=-1$$$ or $$$c=W$$$ holds. Each cell that is not a boundary cell of the maze is either an\nobstacle\ncell or an\nempty\ncell. Additionally, each empty cell has a\ncolor\n, represented by a nonnegative integer between $$$0$$$ and $$$Z_{MAX}$$$, inclusive. Initially, the color of each empty cell is $$$0$$$.\nFor example, consider a maze with $$$H=4$$$ and $$$W=5$$$, containing a single obstacle cell $$$(1,3)$$$:\nThe only obstacle cell is denoted by a cross. Boundary cells of the maze are shaded. The number in each empty cell represents its color.\nA\npath\nof length $$$\\ell$$$ ($$$\\ell > 0$$$) from cell $$$(r_0, c_0)$$$ to cell $$$(r_\\ell, c_\\ell)$$$ is a sequence of pairwise distinct\nempty\ncells $$$(r_0,c_0), (r_1, c_1), \\ldots, (r_\\ell, c_\\ell)$$$ in which for each $$$i$$$ ($$$0 \\le i < \\ell$$$) the cells $$$(r_i, c_i)$$$ and $$$(r_{i+1}, c_{i+1})$$$ are adjacent.\nNote that a path of length $$$\\ell$$$ contains exactly $$$\\ell+1$$$ cells.\nAt the contest, the researchers set up a maze in which there exists at least one path from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$. Note that this implies that cells $$$(0, 0)$$$ and $$$(H-1, W-1)$$$ are guaranteed to be empty.\nHanga does not know which cells of the maze are empty and which cells are obstacles.\nYour task is to help Hanga to program Pulibot so that it is capable of finding a\nshortest path\n(that is, a path of minimum length) from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$ in the unknown maze set up by the researchers. The specification of Pulibot and the rules of the contest are described below.\nNote that the last section of this problem statement describes a display tool you can use to visualize Pulibot.\nPulibot's Specification\nDefine the\nstate\nof a cell $$$(r,c)$$$ for each $$$-1 \\le r \\le H$$$ and $$$-1 \\le c \\le W$$$ as an integer so that:\nif cell $$$(r,c)$$$ is a boundary cell then its state is $$$-2$$$;\nif cell $$$(r,c)$$$ is an obstacle cell then its state is $$$-1$$$;\nif cell $$$(r,c)$$$ is an empty cell then its state is the color of the cell.\nPulibot's program is executed as a sequence of steps. In each step, Pulibot recognizes the states of nearby cells and then performs an instruction. The instruction it performs is determined by the recognized states. A more precise description follows.\nSuppose that at the beginning of the current step, Pulibot is at cell $$$(r,c)$$$, which is an empty cell. The step is performed as follows:\nFirst, Pulibot recognizes the current\nstate array\n, that is, the array $$$S = [S[0], S[1], S[2], S[3], S[4]]$$$, consisting of the state of cell $$$(r,c)$$$ and of all adjacent cells:\n$$$S[0]$$$ is the state of cell $$$(r,c)$$$.\n$$$S[1]$$$ is the state of the cell to the west.\n$$$S[2]$$$ is the state of the cell to the south.\n$$$S[3]$$$ is the state of the cell to the east.\n$$$S[4]$$$ is the state of the cell to the north.\nThen, Pulibot determines the\ninstruction\n$$$(Z, A)$$$ which corresponds to the recognized state array.\nFinally, Pulibot performs that instruction: it sets the color of cell $$$(r, c)$$$ to color $$$Z$$$ and then it performs action $$$A$$$, which is one of the following actions:\nstay\nat cell $$$(r,c)$$$;\nmove\nto one of the $$$4$$$ adjacent cells;\nterminate the program\n.\nFor example, consider the scenario displayed on the left of the following figure. Pulibot is currently at cell $$$(0, 0)$$$ with the color $$$0$$$. Pulibot recognizes the state array $$$S = [0, -2, 2, 2, -2]$$$. Pulibot may have a program which, upon recognizing this array, sets the color of the current cell to $$$Z = 1$$$ and then moves to the east, as displayed in the middle and on the right of the figure:\nRobot Contest Rules\nAt the start, Pulibot is placed at cell $$$(0,0)$$$ and begins to execute its program.\nPulibot is not allowed to move to a cell which is not empty.\nPulibot's program must terminate after at most $$$500\\,000$$$ steps.\nAfter the termination of Pulibot's program, empty cells in the maze should be colored such that:\nThere exists a shortest path from $$$(0,0)$$$ to $$$(H-1, W-1)$$$ for which the color of each cell included in the path is $$$1$$$.\nAll other empty cells have color $$$0$$$.\nPulibot may terminate its program at any empty cell.\nFor example, the following figure shows a possible maze with $$$H = W = 6$$$. The starting configuration is displayed on the left and one acceptable coloring of empty cells after termination is displayed on the right:\nImplementation Details\nYou should implement the following procedure.\nvoid program_pulibot()\nThis procedure should produce Pulibot's program. This program should work correctly for all values of $$$H$$$ and $$$W$$$ and any maze which meets the task constraints.\nThis procedure is called exactly once for each test case.\nThis procedure can make calls to the following procedure to produce Pulibot's program:\nvoid set_instruction(int[] S, int Z, char A)\n$$$S$$$: array of length $$$5$$$ describing a state array.\n$$$Z$$$: a nonnegative integer representing a color.\n$$$A$$$: a single character representing an action of Pulibot as follows:\nH\n: stay;\nW\n: move to the west;\nS\n: move to the south;\nE\n: move to the east;\nN\n: move to the north;\nT\n: terminate the program.\nCalling this procedure instructs Pulibot that upon recognizing the state array $$$S$$$ it should perform the instruction $$$(Z, A)$$$.\nCalling this procedure multiple times with the same state array $$$S$$$ will result in an\nOutput isn't correct\nverdict.\nIt is not required to call\nset_instruction\nwith each possible state array $$$S$$$. However, if Pulibot later recognizes a state array for which an instruction was not set, you will get an\nOutput isn't correct\nverdict.\nAfter\nprogram_pulibot\ncompletes, the grader invokes Pulibot's program over one or more mazes. These invocations do\nnot\ncount towards the time limit for your solution. The grader is\nnot\nadaptive, that is, the set of mazes is predefined in each test case.\nIf Pulibot violates any of the Robot Contest Rules before terminating its program, you will get an\nOutput isn't correct\nverdict.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$H \\; W$$$ ($$$2 \\le H, W \\le 15$$$)\nline $$$2 + r$$$ ($$$0 \\le r < H$$$): $$$m[r][0] \\; m[r][1] \\; \\ldots \\; m[r][W-1]$$$\nHere, $$$m$$$ is an array of $$$H$$$ arrays of $$$W$$$ integers, describing the non-boundary cells of the maze. $$$m[r][c] = 0$$$ if cell $$$(r, c)$$$ is an empty cell and $$$m[r][c] = 1$$$ if cell $$$(r, c)$$$ is an obstacle cell.\nThere is at least one path from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$.\n$$$Z_{MAX} = 19$$$. Hence, Pulibot can use colors from 0 to 19, inclusive.\nOutput\nThe sample grader first calls\nprogram_pulibot()\n. If the sample grader detects a protocol violation, the sample grader prints\nProtocol Violation: <MSG>\nand terminates, where\n<MSG>\nis one of the following error messages:\nInvalid array\n: $$$-2 \\le S[i] \\le Z_{MAX}$$$ is not met for some $$$i$$$ or the length of $$$S$$$ is not $$$5$$$.\nInvalid color\n: $$$0 \\le Z \\le Z_{MAX}$$$ is not met.\nInvalid action\n: character $$$A$$$ is not one of\nH\n,\nW\n,\nS\n,\nE\n,\nN\nor\nT\n.\nSame state array\n:\nset_instruction\nwas called with the same array $$$S$$$ at least twice.\nOtherwise, when\nprogram_pulibot\ncompletes, the sample grader executes Pulibot's program in the maze described by the input.\nThe sample grader produces two outputs.\nFirst, the sample grader writes a log of Pulibot's actions to the file\nrobot.bin\nin the working directory. This file serves as the input of the visualization tool described in the following section.\nSecond, if Pulibot's program does not terminate successfully, the sample grader prints one of the following error messages:\nUnexpected state\n: Pulibot recognized a state array which\nset_instruction\nwas not called with.\nInvalid move\n: performing an action resulted in Pulibot moving to a nonempty cell.\nToo many steps\n: Pulibot performed $$$500\\,000$$$ steps without terminating its program.\nOtherwise, let $$$e[r][c]$$$ be the state of cell $$$(r, c)$$$ after Pulibot's program terminates. The sample grader prints $$$H$$$ lines in the following format:\nLine $$$1 + r$$$ ($$$0 \\le r < H$$$): $$$e[r][0] \\; e[r][1] \\; \\ldots \\; e[r][W-1]$$$\nDisplay Tool\nThe attachment package for this task contains a file named\ndisplay.py\n. When invoked, this Python script displays Pulibot's actions in the maze described by the input of the sample grader. For this, the binary file\nrobot.bin\nmust be present in the working directory.\nTo invoke the script, execute the following command.\npython3 display.py\nA simple graphical interface shows up. The main features are as follows:\nYou can observe the status of the full maze. The current location of Pulibot is highlighted by a rectangle.\nYou can browse through the steps of Pulibot by clicking the arrow buttons or pressing their hotkeys. You can also jump to a specific step.\nThe upcoming step in Pulibot's program is shown at the bottom. It shows the current state array and the instruction it will perform. After the final step, it shows either one of the error messages of the grader, or\nTerminated\nif the program successfully terminates.\nTo each number that represents a color, you can assign a visual background color, as well as a display text. The display text is a short string that shall appear in each cell having that color. You can assign background colors and display texts in either of the following ways:\nSet them in a dialog window after clicking on the\nColors\nbutton.\nEdit the contents of the\ncolors.txt\nfile.\nTo reload\nrobot.bin\n, use the\nReload\nbutton. It is useful if the contents of\nrobot.bin\nhave changed.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n6\nThere is no obstacle cell in the maze.\n2\n10\n$$$H = 2$$$\n3\n18\nThere is exactly one path between each pair of empty cells.\n4\n20\nEach shortest path from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$ has length $$$H + W - 2$$$.\n5\n46\nNo additional constraints.\nIf, in any of the test cases, the calls to the procedure\nset_instruction\nor Pulibot's program over its execution do not conform to the constraints described in Implementation Details, the score of your solution for that subtask will be $$$0$$$.\nIn each subtask, you can obtain a partial score by producing a coloring that is almost correct.\nFormally:\nThe solution of a test case is\ncomplete\nif the final coloring of the empty cells satisfies Robot Contest Rules.\nThe solution of a test case is\npartial\nif the final coloring looks as follows:\nThere exists a shortest path from $$$(0,0)$$$ to $$$(H-1, W-1)$$$ for which the color of each cell included in the path is $$$1$$$.\nThere is no other empty cell in the grid with color $$$1$$$.\nSome empty cell in the grid has a color other than $$$0$$$ and $$$1$$$.\nIf your solution to a test case is neither complete nor partial, your score for the corresponding test case will be $$$0$$$.\nIn subtasks 1-4, the score for a complete solution is 100% and the score for a partial solution to a test case is 50% of the points for its subtask.\nIn subtask 5, your score depends on the number of colors used in Pulibot's program. More precisely, denote by $$$Z^\\star$$$ the maximum value of $$$Z$$$ over all calls made to\nset_instruction\n. The score of the test case is calculated according to the following table:\nCondition\nScore (complete)\nScore (partial)\n$$$11 \\le Z^\\star \\le 19$$$\n$$$20 + (19 - Z^\\star)$$$\n$$$12 + (19 - Z^\\star)$$$\n$$$Z^\\star = 10$$$\n$$$31$$$\n$$$23$$$\n$$$Z^\\star = 9$$$\n$$$34$$$\n$$$26$$$\n$$$Z^\\star = 8$$$\n$$$38$$$\n$$$29$$$\n$$$Z^\\star = 7$$$\n$$$42$$$\n$$$32$$$\n$$$Z^\\star \\le 6$$$\n$$$46$$$\n$$$36$$$\nThe score for each subtask is the minimum of the points for the test cases in the subtask.\nNote\nThe procedure\nprogram_pulibot\nmay make calls to\nset_instruction\nas follows:\nCall\nInstruction for state array $$$S$$$\nset_instruction([0, -2, -1, 0, -2], 1, E)\nSet color to $$$1$$$ and move east\nset_instruction([0, 1, -1, 0, -2], 1, E)\nSet color to $$$1$$$ and move east\nset_instruction([0, 1, 0, -2, -2], 1, S)\nSet color to $$$1$$$ and move south\nset_instruction([0, -1, -2, -2, 1], 1, T)\nSet color to $$$1$$$ and terminate program\nConsider a scenario where $$$H=2$$$ and $$$W=3$$$, and the maze is displayed in the following figure.\nFor this particular maze Pulibot's program runs in four steps. The state arrays Pulibot recognizes and the instructions it performs correspond exactly to the four calls to\nset_instruction\nmade above, in order. The last of these instructions terminates the program.\nThe following figure shows the maze before each of the four steps and the final colors after termination.\nHowever, do note that this program of $$$4$$$ instructions might not find a shortest path in other valid mazes. Therefore, if submitted, it will receive an\nOutput isn't correct\nverdict."
    },
    "original": "AI researchers at the University of Szeged are holding a robot programming contest. Your friend, Hanga, has decided to take part in the contest. The objective is to program the ultimate\nPulibot\n, admiring the great intelligence of the famous Hungarian herding dog breed, the Puli.\nPulibot will be tested on a maze consisting of a $$$(H+2) \\times (W+2)$$$ grid of cells. The rows of the grid are numbered from $$$-1$$$ to $$$H$$$ from north to south and the columns of the grid are numbered from $$$-1$$$ to $$$W$$$ from west to east. We refer to the cell located at row $$$r$$$ and column $$$c$$$ of the grid ($$$-1 \\le r \\le H$$$, $$$-1 \\le c \\le W$$$) as cell $$$(r, c)$$$.\nConsider a cell $$$(r,c)$$$ such that $$$0 \\le r < H$$$ and $$$0 \\le c < W$$$. There are $$$4$$$ cells\nadjacent\nto cell $$$(r,c)$$$:\ncell $$$(r,c-1)$$$ is referred to as the cell\nwest\nof cell $$$(r,c)$$$;\ncell $$$(r+1,c)$$$ is referred to as the cell\nsouth\nof cell $$$(r,c)$$$;\ncell $$$(r,c+1)$$$ is referred to as the cell\neast\nof cell $$$(r,c)$$$;\ncell $$$(r-1,c)$$$ is referred to as the cell\nnorth\nof cell $$$(r,c)$$$.\nCell $$$(r,c)$$$ is called a\nboundary\ncell of the maze if $$$r=-1$$$ or $$$r=H$$$ or $$$c=-1$$$ or $$$c=W$$$ holds. Each cell that is not a boundary cell of the maze is either an\nobstacle\ncell or an\nempty\ncell. Additionally, each empty cell has a\ncolor\n, represented by a nonnegative integer between $$$0$$$ and $$$Z_{MAX}$$$, inclusive. Initially, the color of each empty cell is $$$0$$$.\nFor example, consider a maze with $$$H=4$$$ and $$$W=5$$$, containing a single obstacle cell $$$(1,3)$$$:\nThe only obstacle cell is denoted by a cross. Boundary cells of the maze are shaded. The number in each empty cell represents its color.\nA\npath\nof length $$$\\ell$$$ ($$$\\ell > 0$$$) from cell $$$(r_0, c_0)$$$ to cell $$$(r_\\ell, c_\\ell)$$$ is a sequence of pairwise distinct\nempty\ncells $$$(r_0,c_0), (r_1, c_1), \\ldots, (r_\\ell, c_\\ell)$$$ in which for each $$$i$$$ ($$$0 \\le i < \\ell$$$) the cells $$$(r_i, c_i)$$$ and $$$(r_{i+1}, c_{i+1})$$$ are adjacent.\nNote that a path of length $$$\\ell$$$ contains exactly $$$\\ell+1$$$ cells.\nAt the contest, the researchers set up a maze in which there exists at least one path from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$. Note that this implies that cells $$$(0, 0)$$$ and $$$(H-1, W-1)$$$ are guaranteed to be empty.\nHanga does not know which cells of the maze are empty and which cells are obstacles.\nYour task is to help Hanga to program Pulibot so that it is capable of finding a\nshortest path\n(that is, a path of minimum length) from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$ in the unknown maze set up by the researchers. The specification of Pulibot and the rules of the contest are described below.\nNote that the last section of this problem statement describes a display tool you can use to visualize Pulibot.\nPulibot's Specification\nDefine the\nstate\nof a cell $$$(r,c)$$$ for each $$$-1 \\le r \\le H$$$ and $$$-1 \\le c \\le W$$$ as an integer so that:\nif cell $$$(r,c)$$$ is a boundary cell then its state is $$$-2$$$;\nif cell $$$(r,c)$$$ is an obstacle cell then its state is $$$-1$$$;\nif cell $$$(r,c)$$$ is an empty cell then its state is the color of the cell.\nPulibot's program is executed as a sequence of steps. In each step, Pulibot recognizes the states of nearby cells and then performs an instruction. The instruction it performs is determined by the recognized states. A more precise description follows.\nSuppose that at the beginning of the current step, Pulibot is at cell $$$(r,c)$$$, which is an empty cell. The step is performed as follows:\nFirst, Pulibot recognizes the current\nstate array\n, that is, the array $$$S = [S[0], S[1], S[2], S[3], S[4]]$$$, consisting of the state of cell $$$(r,c)$$$ and of all adjacent cells:\n$$$S[0]$$$ is the state of cell $$$(r,c)$$$.\n$$$S[1]$$$ is the state of the cell to the west.\n$$$S[2]$$$ is the state of the cell to the south.\n$$$S[3]$$$ is the state of the cell to the east.\n$$$S[4]$$$ is the state of the cell to the north.\nThen, Pulibot determines the\ninstruction\n$$$(Z, A)$$$ which corresponds to the recognized state array.\nFinally, Pulibot performs that instruction: it sets the color of cell $$$(r, c)$$$ to color $$$Z$$$ and then it performs action $$$A$$$, which is one of the following actions:\nstay\nat cell $$$(r,c)$$$;\nmove\nto one of the $$$4$$$ adjacent cells;\nterminate the program\n.\nFor example, consider the scenario displayed on the left of the following figure. Pulibot is currently at cell $$$(0, 0)$$$ with the color $$$0$$$. Pulibot recognizes the state array $$$S = [0, -2, 2, 2, -2]$$$. Pulibot may have a program which, upon recognizing this array, sets the color of the current cell to $$$Z = 1$$$ and then moves to the east, as displayed in the middle and on the right of the figure:\nRobot Contest Rules\nAt the start, Pulibot is placed at cell $$$(0,0)$$$ and begins to execute its program.\nPulibot is not allowed to move to a cell which is not empty.\nPulibot's program must terminate after at most $$$500\\,000$$$ steps.\nAfter the termination of Pulibot's program, empty cells in the maze should be colored such that:\nThere exists a shortest path from $$$(0,0)$$$ to $$$(H-1, W-1)$$$ for which the color of each cell included in the path is $$$1$$$.\nAll other empty cells have color $$$0$$$.\nPulibot may terminate its program at any empty cell.\nFor example, the following figure shows a possible maze with $$$H = W = 6$$$. The starting configuration is displayed on the left and one acceptable coloring of empty cells after termination is displayed on the right:\nImplementation Details\nYou should implement the following procedure.\nvoid program_pulibot()\nThis procedure should produce Pulibot's program. This program should work correctly for all values of $$$H$$$ and $$$W$$$ and any maze which meets the task constraints.\nThis procedure is called exactly once for each test case.\nThis procedure can make calls to the following procedure to produce Pulibot's program:\nvoid set_instruction(int[] S, int Z, char A)\n$$$S$$$: array of length $$$5$$$ describing a state array.\n$$$Z$$$: a nonnegative integer representing a color.\n$$$A$$$: a single character representing an action of Pulibot as follows:\nH\n: stay;\nW\n: move to the west;\nS\n: move to the south;\nE\n: move to the east;\nN\n: move to the north;\nT\n: terminate the program.\nCalling this procedure instructs Pulibot that upon recognizing the state array $$$S$$$ it should perform the instruction $$$(Z, A)$$$.\nCalling this procedure multiple times with the same state array $$$S$$$ will result in an\nOutput isn't correct\nverdict.\nIt is not required to call\nset_instruction\nwith each possible state array $$$S$$$. However, if Pulibot later recognizes a state array for which an instruction was not set, you will get an\nOutput isn't correct\nverdict.\nAfter\nprogram_pulibot\ncompletes, the grader invokes Pulibot's program over one or more mazes. These invocations do\nnot\ncount towards the time limit for your solution. The grader is\nnot\nadaptive, that is, the set of mazes is predefined in each test case.\nIf Pulibot violates any of the Robot Contest Rules before terminating its program, you will get an\nOutput isn't correct\nverdict.\nInput\nThe sample grader reads the input in the following format:\nline $$$1$$$: $$$H \\; W$$$ ($$$2 \\le H, W \\le 15$$$)\nline $$$2 + r$$$ ($$$0 \\le r < H$$$): $$$m[r][0] \\; m[r][1] \\; \\ldots \\; m[r][W-1]$$$\nHere, $$$m$$$ is an array of $$$H$$$ arrays of $$$W$$$ integers, describing the non-boundary cells of the maze. $$$m[r][c] = 0$$$ if cell $$$(r, c)$$$ is an empty cell and $$$m[r][c] = 1$$$ if cell $$$(r, c)$$$ is an obstacle cell.\nThere is at least one path from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$.\n$$$Z_{MAX} = 19$$$. Hence, Pulibot can use colors from 0 to 19, inclusive.\nOutput\nThe sample grader first calls\nprogram_pulibot()\n. If the sample grader detects a protocol violation, the sample grader prints\nProtocol Violation: <MSG>\nand terminates, where\n<MSG>\nis one of the following error messages:\nInvalid array\n: $$$-2 \\le S[i] \\le Z_{MAX}$$$ is not met for some $$$i$$$ or the length of $$$S$$$ is not $$$5$$$.\nInvalid color\n: $$$0 \\le Z \\le Z_{MAX}$$$ is not met.\nInvalid action\n: character $$$A$$$ is not one of\nH\n,\nW\n,\nS\n,\nE\n,\nN\nor\nT\n.\nSame state array\n:\nset_instruction\nwas called with the same array $$$S$$$ at least twice.\nOtherwise, when\nprogram_pulibot\ncompletes, the sample grader executes Pulibot's program in the maze described by the input.\nThe sample grader produces two outputs.\nFirst, the sample grader writes a log of Pulibot's actions to the file\nrobot.bin\nin the working directory. This file serves as the input of the visualization tool described in the following section.\nSecond, if Pulibot's program does not terminate successfully, the sample grader prints one of the following error messages:\nUnexpected state\n: Pulibot recognized a state array which\nset_instruction\nwas not called with.\nInvalid move\n: performing an action resulted in Pulibot moving to a nonempty cell.\nToo many steps\n: Pulibot performed $$$500\\,000$$$ steps without terminating its program.\nOtherwise, let $$$e[r][c]$$$ be the state of cell $$$(r, c)$$$ after Pulibot's program terminates. The sample grader prints $$$H$$$ lines in the following format:\nLine $$$1 + r$$$ ($$$0 \\le r < H$$$): $$$e[r][0] \\; e[r][1] \\; \\ldots \\; e[r][W-1]$$$\nDisplay Tool\nThe attachment package for this task contains a file named\ndisplay.py\n. When invoked, this Python script displays Pulibot's actions in the maze described by the input of the sample grader. For this, the binary file\nrobot.bin\nmust be present in the working directory.\nTo invoke the script, execute the following command.\npython3 display.py\nA simple graphical interface shows up. The main features are as follows:\nYou can observe the status of the full maze. The current location of Pulibot is highlighted by a rectangle.\nYou can browse through the steps of Pulibot by clicking the arrow buttons or pressing their hotkeys. You can also jump to a specific step.\nThe upcoming step in Pulibot's program is shown at the bottom. It shows the current state array and the instruction it will perform. After the final step, it shows either one of the error messages of the grader, or\nTerminated\nif the program successfully terminates.\nTo each number that represents a color, you can assign a visual background color, as well as a display text. The display text is a short string that shall appear in each cell having that color. You can assign background colors and display texts in either of the following ways:\nSet them in a dialog window after clicking on the\nColors\nbutton.\nEdit the contents of the\ncolors.txt\nfile.\nTo reload\nrobot.bin\n, use the\nReload\nbutton. It is useful if the contents of\nrobot.bin\nhave changed.\nScoring\nSubtask\nPoints\nAdditional Input Constraints\n1\n6\nThere is no obstacle cell in the maze.\n2\n10\n$$$H = 2$$$\n3\n18\nThere is exactly one path between each pair of empty cells.\n4\n20\nEach shortest path from cell $$$(0,0)$$$ to cell $$$(H-1, W-1)$$$ has length $$$H + W - 2$$$.\n5\n46\nNo additional constraints.\nIf, in any of the test cases, the calls to the procedure\nset_instruction\nor Pulibot's program over its execution do not conform to the constraints described in Implementation Details, the score of your solution for that subtask will be $$$0$$$.\nIn each subtask, you can obtain a partial score by producing a coloring that is almost correct.\nFormally:\nThe solution of a test case is\ncomplete\nif the final coloring of the empty cells satisfies Robot Contest Rules.\nThe solution of a test case is\npartial\nif the final coloring looks as follows:\nThere exists a shortest path from $$$(0,0)$$$ to $$$(H-1, W-1)$$$ for which the color of each cell included in the path is $$$1$$$.\nThere is no other empty cell in the grid with color $$$1$$$.\nSome empty cell in the grid has a color other than $$$0$$$ and $$$1$$$.\nIf your solution to a test case is neither complete nor partial, your score for the corresponding test case will be $$$0$$$.\nIn subtasks 1-4, the score for a complete solution is 100% and the score for a partial solution to a test case is 50% of the points for its subtask.\nIn subtask 5, your score depends on the number of colors used in Pulibot's program. More precisely, denote by $$$Z^\\star$$$ the maximum value of $$$Z$$$ over all calls made to\nset_instruction\n. The score of the test case is calculated according to the following table:\nCondition\nScore (complete)\nScore (partial)\n$$$11 \\le Z^\\star \\le 19$$$\n$$$20 + (19 - Z^\\star)$$$\n$$$12 + (19 - Z^\\star)$$$\n$$$Z^\\star = 10$$$\n$$$31$$$\n$$$23$$$\n$$$Z^\\star = 9$$$\n$$$34$$$\n$$$26$$$\n$$$Z^\\star = 8$$$\n$$$38$$$\n$$$29$$$\n$$$Z^\\star = 7$$$\n$$$42$$$\n$$$32$$$\n$$$Z^\\star \\le 6$$$\n$$$46$$$\n$$$36$$$\nThe score for each subtask is the minimum of the points for the test cases in the subtask.\nNote\nThe procedure\nprogram_pulibot\nmay make calls to\nset_instruction\nas follows:\nCall\nInstruction for state array $$$S$$$\nset_instruction([0, -2, -1, 0, -2], 1, E)\nSet color to $$$1$$$ and move east\nset_instruction([0, 1, -1, 0, -2], 1, E)\nSet color to $$$1$$$ and move east\nset_instruction([0, 1, 0, -2, -2], 1, S)\nSet color to $$$1$$$ and move south\nset_instruction([0, -1, -2, -2, 1], 1, T)\nSet color to $$$1$$$ and terminate program\nConsider a scenario where $$$H=2$$$ and $$$W=3$$$, and the maze is displayed in the following figure.\nFor this particular maze Pulibot's program runs in four steps. The state arrays Pulibot recognizes and the instructions it performs correspond exactly to the four calls to\nset_instruction\nmade above, in order. The last of these instructions terminates the program.\nThe following figure shows the maze before each of the four steps and the final colors after termination.\nHowever, do note that this program of $$$4$$$ instructions might not find a shortest path in other valid mazes. Therefore, if submitted, it will receive an\nOutput isn't correct\nverdict.",
    "_meta": {
      "index": 92,
      "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/F",
      "uuid": "ps_19727f753e9123dc3bacdbc8a840ed6bce6935bb"
    }
  }
]